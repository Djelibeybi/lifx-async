{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lifx-async","text":"<p>A modern, type-safe, async Python library for controlling LIFX lights over the local network.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udce6 No Runtime Dependencies: only Python standard libraries required</li> <li>\ud83c\udfaf Type-Safe: Full type hints with strict Pyright validation</li> <li>\u26a1 Async Context Managers: Provides <code>async with</code> and <code>await</code> usage patterns</li> <li>\ud83d\udd0c Connection Pooling: Efficient reuse with LRU cache</li> <li>\ud83c\udfd7\ufe0f Layered Architecture: Protocol \u2192 Network \u2192 Device \u2192 API</li> <li>\ud83d\udd04 Protocol Generator: generates LIFX protocol <code>Packets</code>, <code>Fields</code> and <code>Enum</code> classes from LIFX public protocol definition</li> <li>\ud83c\udf08 Comprehensive Support: supports all LIFX smart lighting products including Color, White, Warm to White, Filament, Clean, Night Vision, Z, Beam, String, Neon, Permanent Outdoor, Tile, Candle, Ceiling, Path, Spot, and Luna.</li> </ul>"},{"location":"#examples","title":"Examples","text":"DiscoveryDirect ConnectionColor Control <pre><code>import asyncio\nfrom lifx import discover, Colors\n\nasync def main():\n    # Discover all devices with automatic connection management\n    async with discover(timeout=3.0) as group:\n        if not group:\n            print(\"No LIFX devices found!\")\n            return\n\n        # Control all devices at once\n        await group.set_power(True)\n        await group.set_color(Colors.BLUE, duration=1.0)\n        await group.set_brightness(0.5)\n\n        # Or control individual devices\n        for device in group:\n            label = await device.get_label()\n            print(f\"Controlling: {label}\")\n\nasyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom lifx import Light, Colors\n\nasync def main():\n    # Connect directly without discovery\n    async with await Light.from_ip(ip=\"192.168.1.100\") as light:\n        await light.set_color(Colors.RED)\n        await light.set_brightness(0.8, duration=2.0)\n\nasyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom lifx import Light, HSBK, Colors\n\nasync def main():\n    async with await Light.from_ip(ip=\"192.168.1.100\") as light:\n        # Use RGB\n        red = HSBK.from_rgb(255, 0, 0)\n        await light.set_color(red)\n\n        # Use presets\n        await light.set_color(Colors.WARM_WHITE)\n\n        # Custom HSBK\n        custom = HSBK(\n            hue=180,         # 0-360 degrees\n            saturation=0.7,  # 0.0-1.0\n            brightness=0.8,  # 0.0-1.0\n            kelvin=3500,     # 1500-9000\n        )\n        await light.set_color(custom)\n\nasyncio.run(main())\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Using uv (recommended)\nuv pip install lifx-async\n\n# Or using pip\npip install lifx-async\n</code></pre> <p>For development:</p> <pre><code>git clone https://github.com/Djelibeybi/lifx-async.git\ncd lifx\nuv sync\n</code></pre>"},{"location":"#why-lifx-async","title":"Why lifx-async?","text":""},{"location":"#modern-python","title":"Modern Python","text":"<ul> <li>Async With: extensive use of async context managers</li> <li>Async/Await: Native asyncio support for concurrent operations</li> <li>Type Hints: Full type annotations for better IDE support</li> <li>Python 3.11+: Modern language features and performance</li> </ul>"},{"location":"#reliable","title":"Reliable","text":"<ul> <li>Comprehensive Tests: over 500 tests covering over 80% of the source code</li> <li>Connection Pooling: Efficient connection reuse</li> <li>State Caching: Reduces network traffic</li> </ul>"},{"location":"#developer-friendly","title":"Developer Friendly","text":"<ul> <li>Clear API: Intuitive, Pythonic interface</li> <li>Rich Documentation: Extensive guides and examples</li> <li>Code Generation: Protocol updates are automatic</li> <li>No External Dependencies: Only Python standard libraries required</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>Documentation: https://lifx.readthedocs.io</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>Universal Permissive License 1.0 - see LICENSE for details.</p>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v100-2025-11-04","title":"v1.0.0 (2025-11-04)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#what-is-lifx-async","title":"What is lifx-async?","text":"<p>lifx-async is a modern, async Python library for controlling LIFX smart lighting devices over your local network. It provides a type-safe, high-performance interface for device discovery, color control, effects, and more.</p>"},{"location":"faq/#which-devices-are-supported","title":"Which devices are supported?","text":"<p>lifx-async supports all LIFX lighting products:</p> <ul> <li>Light: A19, BR30, Downlight, etc.</li> <li>HEV: Clean</li> <li>Infrared: Nightvision</li> <li>Multizone: LIFX Z, Beam, Neon, String</li> <li>Matrix: LIFX Tile, Candle, Ceiling, Path, Spot</li> </ul> <p>Button and Relay devices are not currently supported (they are out of scope for this lighting-focused library).</p>"},{"location":"faq/#do-i-need-cloud-access","title":"Do I need cloud access?","text":"<p>No! lifx-async communicates directly with devices over your local network. No cloud connection or LIFX account required.</p>"},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>Python 3.11 or higher is required.</p>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#how-do-i-install-lifx-async","title":"How do I install lifx-async?","text":"<pre><code># Using uv (recommended)\nuv pip install lifx-async\n\n# Or using pip\npip install lifx-async\n</code></pre> <p>See the Installation Guide for more options.</p>"},{"location":"faq/#why-cant-discovery-find-my-devices","title":"Why can't discovery find my devices?","text":"<p>Common issues:</p> <ol> <li>Same Network: Ensure your computer and LIFX devices are on the same network</li> <li>Firewall: Check firewall settings allow UDP broadcasts</li> <li>Timeout: Try increasing timeout: <code>discover(timeout=10.0)</code></li> <li>Router: Some routers block broadcast packets - try direct connection</li> </ol> <p>Workaround - Connect directly by IP:</p> <pre><code>async with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n</code></pre>"},{"location":"faq/#do-i-need-to-know-my-devices-ip-address","title":"Do I need to know my device's IP address?","text":"<p>No! Discovery finds devices automatically:</p> <pre><code>async with discover() as group:\n    # All devices found automatically\n    await group.set_color(Colors.BLUE)\n</code></pre> <p>If you do know the IP, you can connect directly for faster connection.</p>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#how-do-i-control-multiple-lights-at-once","title":"How do I control multiple lights at once?","text":"<p>Use the <code>DeviceGroup</code> returned by <code>discover()</code> for batch operations:</p> <pre><code>from lifx import discover, Colors\n\nasync with discover() as group:\n    # All lights at once\n    await group.set_power(True)\n    await group.set_color(Colors.BLUE)\n    await group.set_brightness(0.5)\n</code></pre>"},{"location":"faq/#how-do-i-set-a-specific-rgb-color","title":"How do I set a specific RGB color?","text":"<p>Use <code>HSBK.from_rgb()</code>:</p> <pre><code>from lifx import HSBK\n\n# Create color from RGB (0-255)\npurple = HSBK.from_rgb(128, 0, 128)\nawait light.set_color(purple)\n\n# Or use hex\ncolor = HSBK.from_rgb(0xFF, 0x00, 0xFF)\n</code></pre>"},{"location":"faq/#can-i-control-lights-concurrently","title":"Can I control lights concurrently?","text":"<p>Yes! Use <code>asyncio.gather()</code>:</p> <pre><code>import asyncio\n\n# Control multiple lights in parallel\nawait asyncio.gather(\n    light1.set_color(Colors.RED),\n    light2.set_color(Colors.GREEN),\n    light3.set_color(Colors.BLUE),\n)\n</code></pre>"},{"location":"faq/#how-do-i-find-a-specific-device","title":"How do I find a specific device?","text":"<p>By label:</p> <pre><code>lights = await find_lights(label_contains=\"Bedroom\")\n</code></pre> <p>By serial number:</p> <pre><code>device = await find_by_serial(\"d073d5123456\")\n</code></pre>"},{"location":"faq/#what-are-the-available-color-presets","title":"What are the available color presets?","text":"<p>See <code>Colors</code> for the complete list:</p> <pre><code>from lifx import Colors\n\n# Primary colors\nColors.RED, Colors.GREEN, Colors.BLUE\n\n# White variants\nColors.WARM_WHITE, Colors.COOL_WHITE, Colors.DAYLIGHT\n\n# Pastels\nColors.PASTEL_BLUE, Colors.PASTEL_PINK\n</code></pre>"},{"location":"faq/#how-do-i-create-smooth-transitions","title":"How do I create smooth transitions?","text":"<p>Use the <code>duration</code> parameter (in seconds):</p> <pre><code># Fade to blue over 2 seconds\nawait light.set_color(Colors.BLUE, duration=2.0)\n\n# Fade brightness over 3 seconds\nawait light.set_brightness(0.5, duration=3.0)\n</code></pre>"},{"location":"faq/#can-i-create-pulsing-effects","title":"Can I create pulsing effects?","text":"<p>Yes! Use the <code>pulse()</code> or <code>breathe()</code> methods:</p> <pre><code># Pulse red 5 times\nawait light.pulse(Colors.RED, period=1.0, cycles=5)\n\n# Breathe blue infinitely\nawait light.breathe(Colors.BLUE, period=2.0, cycles=0)\n</code></pre>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#is-lifx-async-fast","title":"Is lifx-async fast?","text":"<p>Yes! Key performance features:</p> <ul> <li>Async I/O: Non-blocking operations</li> <li>Connection Pooling: Reuses connections (LRU cache)</li> <li>Rate Limiting: Prevents overwhelming devices (20 msg/sec)</li> <li>State Caching: Reduces redundant network requests</li> <li>Concurrent Requests: Multiple requests per connection</li> </ul>"},{"location":"faq/#does-lifx-async-cache-device-state","title":"Does lifx-async cache device state?","text":"<p>Yes! Device state (label, power, color, etc.) is cached with a 5-second TTL by default. This reduces network traffic and improves performance.</p> <p>To force a fresh read:</p> <pre><code>light.invalidate_cache()\nlabel = await light.get_label()  # Fresh from device\n</code></pre>"},{"location":"faq/#can-i-control-devices-from-multiple-computers","title":"Can I control devices from multiple computers?","text":"<p>Yes! lifx-async doesn't require exclusive access. Multiple instances (even on different computers) can control the same devices.</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#i-get-lifxtimeouterror","title":"I get <code>LifxTimeoutError</code>","text":"<p>Common causes:</p> <ol> <li>Device offline: Check device is powered and connected</li> <li>Network issues: Verify network connectivity</li> <li>Firewall: Ensure UDP port 56700 is open</li> <li>Timeout too short: Increase timeout value</li> </ol>"},{"location":"faq/#connection-fails-with-lifxconnectionerror","title":"Connection fails with <code>LifxConnectionError</code>","text":"<p>Try:</p> <ol> <li>Restart device: Power cycle the LIFX device</li> <li>Check IP: Verify IP address is correct</li> <li>Firewall: Check firewall allows UDP 56700</li> <li>Network: Ensure same subnet</li> </ol>"},{"location":"faq/#effects-dont-work-as-expected","title":"Effects don't work as expected","text":"<p>Make sure you're using the correct duration/period values:</p> <pre><code># Period is in seconds\nawait light.pulse(Colors.RED, period=1.0, cycles=5)\n\n# Duration is in seconds (milliseconds * 1000)\nawait light.set_color(Colors.BLUE, duration=2.0)\n</code></pre>"},{"location":"faq/#type-checker-errors","title":"Type checker errors","text":"<p>lifx-async is fully type-hinted. If you get type errors:</p> <ol> <li>Ensure you're using Python 3.11+</li> <li>Update your type checker (Pyright, mypy)</li> <li>Check you're using correct types</li> </ol>"},{"location":"faq/#development","title":"Development","text":""},{"location":"faq/#how-do-i-contribute","title":"How do I contribute?","text":"<p>Quick start:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes with tests</li> <li>Submit a pull request</li> </ol>"},{"location":"faq/#how-do-i-run-tests","title":"How do I run tests?","text":"<pre><code>uv run --frozen pytest\n</code></pre>"},{"location":"faq/#how-do-i-generate-protocol-code","title":"How do I generate protocol code?","text":"<pre><code>uv run python -m lifx.protocol.generator\n</code></pre> <p>This downloads the latest <code>protocol.yml</code> from LIFX and regenerates Python code.</p>"},{"location":"faq/#where-is-the-protocol-specification","title":"Where is the protocol specification?","text":"<p>The official LIFX protocol specification is at: https://github.com/LIFX/public-protocol/blob/main/protocol.yml</p> <p>lifx-async automatically downloads and generates Python code from this specification.</p>"},{"location":"faq/#advanced","title":"Advanced","text":""},{"location":"faq/#can-i-use-lifx-async-without-async","title":"Can I use lifx-async without async?","text":"<p>No.</p>"},{"location":"faq/#how-do-i-access-low-level-protocol","title":"How do I access low-level protocol?","text":"<pre><code>from lifx.protocol.packets import Light\nfrom lifx.protocol.protocol_types import HSBK\n\n# Create a packet directly\npacket = Light.SetColor(\n    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0\n)\n\n# Send via connection\nasync with DeviceConnection(serial, ip) as conn:\n    reply = await conn.request(packet)\n</code></pre>"},{"location":"faq/#how-does-connection-pooling-work","title":"How does connection pooling work?","text":"<p>lifx-async maintains an LRU cache of connections. When you open a connection to a device, it's automatically pooled and reused for subsequent operations. Connections are evicted when the cache is full (default maximum: 100 connections).</p>"},{"location":"faq/#still-have-questions","title":"Still have questions?","text":"<ul> <li>Documentation: Browse the API Reference</li> <li>Issues: Report bugs on GitHub Issues</li> <li>Discussions: Ask questions in   GitHub Discussions</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference documentation for lifx-async.</p>"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>lifx/\n\u251c\u2500\u2500 __init__.py               # High-level API exports\n\u251c\u2500\u2500 api.py                    # Simplified discovery and device group functions\n\u251c\u2500\u2500 color.py                  # Color utilities (HSBK, Colors)\n\u251c\u2500\u2500 const.py                  # Network constants and URLs\n\u251c\u2500\u2500 exceptions.py             # Exception hierarchy\n\u251c\u2500\u2500 devices/                  # Device classes\n\u2502   \u251c\u2500\u2500 base.py              # Base Device class\n\u2502   \u251c\u2500\u2500 light.py             # Light device (color control)\n\u2502   \u251c\u2500\u2500 hev.py               # HevLight device (anti-bacterial cleaning)\n\u2502   \u251c\u2500\u2500 infrared.py          # InfraredLight device (night vision)\n\u2502   \u251c\u2500\u2500 multizone.py         # MultiZoneLight (strips/beams)\n\u2502   \u2514\u2500\u2500 tile.py              # TileDevice (2D pixel grids)\n\u251c\u2500\u2500 network/                  # Network layer\n\u2502   \u251c\u2500\u2500 connection.py        # Device connections with pooling\n\u2502   \u251c\u2500\u2500 discovery.py         # Network device discovery\n\u2502   \u251c\u2500\u2500 message.py           # Message building and parsing\n\u2502   \u2514\u2500\u2500 transport.py         # UDP transport\n\u251c\u2500\u2500 products/                 # Product registry\n\u2502   \u251c\u2500\u2500 registry.py          # Auto-generated product database\n\u2502   \u251c\u2500\u2500 generator.py         # Generator to download/parse products.json\n\u2502   \u2514\u2500\u2500 __init__.py          # Public API exports\n\u2514\u2500\u2500 protocol/                 # Protocol layer (auto-generated)\n    \u251c\u2500\u2500 base.py              # Base packet class\n    \u251c\u2500\u2500 generator.py         # Code generator from protocol.yml\n    \u251c\u2500\u2500 header.py            # Protocol header (36 bytes)\n    \u251c\u2500\u2500 models.py            # Protocol models (Serial, HEV types)\n    \u251c\u2500\u2500 packets.py           # Packet definitions\n    \u251c\u2500\u2500 protocol_types.py    # Type definitions and enums\n    \u2514\u2500\u2500 serializer.py        # Binary serialization/deserialization\n</code></pre>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#high-level-api","title":"High-Level API","text":"<p>Main entry points for most users:</p> <ul> <li><code>discover()</code> - Simple device discovery</li> <li><code>find_lights()</code> - Find Light devices</li> <li><code>find_by_serial()</code> - Find specific device</li> <li><code>DeviceGroup</code> - Batch operations</li> </ul>"},{"location":"api/#device-classes","title":"Device Classes","text":"<p>Control your LIFX devices:</p> <ul> <li><code>Device</code> - Base device operations</li> <li><code>Light</code> - Color control</li> <li><code>HevLight</code> - Anti-bacterial cleaning cycles</li> <li><code>InfraredLight</code> - Night vision infrared LED</li> <li><code>MultiZoneLight</code> - Strips/beams</li> <li><code>TileDevice</code> - 2D tile grids</li> </ul>"},{"location":"api/#color-utilities","title":"Color Utilities","text":"<p>Work with colors:</p> <ul> <li><code>HSBK</code> - Color representation</li> <li><code>Colors</code> - Built-in presets</li> </ul>"},{"location":"api/#network-layer","title":"Network Layer","text":"<p>Low-level network operations:</p> <ul> <li><code>discover_devices()</code> - Low-level discovery</li> <li><code>DeviceConnection</code> - Device connections</li> </ul>"},{"location":"api/#products-registry","title":"Products Registry","text":"<p>Device capabilities and automatic type detection:</p> <ul> <li><code>ProductInfo</code> - Product information</li> <li><code>ProductCapability</code> - Device capabilities</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":"<p>Error handling:</p> <ul> <li><code>LifxError</code> - Base exception</li> <li><code>LifxTimeoutError</code> - Timeout errors</li> <li><code>LifxConnectionError</code> - Connection errors</li> </ul>"},{"location":"api/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/#async-context-managers","title":"Async Context Managers","text":"<p>All device classes support async context managers for automatic resource cleanup:</p> <pre><code>async with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n# Connection automatically closed\n</code></pre>"},{"location":"api/#batch-operations","title":"Batch Operations","text":"<p>Use <code>DeviceGroup</code> for efficient batch operations:</p> <pre><code>async with discover() as group:\n    await group.set_power(True)\n    await group.set_color(Colors.BLUE)\n</code></pre>"},{"location":"api/#connection-pooling","title":"Connection Pooling","text":"<p>Connections are automatically pooled and reused:</p> <pre><code># Multiple operations reuse the same connection\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.RED)\n    await light.set_brightness(0.5)\n    await light.get_label()\n</code></pre>"},{"location":"api/#concurrent-requests","title":"Concurrent Requests","text":"<p>Devices support concurrent requests via asyncio.gather:</p> <pre><code># Execute multiple operations concurrently\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    color, brightness = await asyncio.gather(\n        light.get_color(),\n        light.get_brightness()\n    )\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>lifx-async is fully type-hinted. Use a type checker like Pyright or mypy:</p> <pre><code>from lifx import Light, HSBK\n\n\nasync def set_custom_color(light: Light, hue: float) -&gt; None:\n    color: HSBK = HSBK(hue=hue, saturation=1.0, brightness=0.8, kelvin=3500)\n    await light.set_color(color)\n</code></pre>"},{"location":"api/#api-sections","title":"API Sections","text":"<ul> <li> High-Level API</li> </ul> <p>Simple, batteries-included API for common tasks</p> <p> High-Level API</p> <ul> <li> Device Classes</li> </ul> <p>Control LIFX lights, strips, and tiles</p> <p> Devices</p> <ul> <li> Color Utilities</li> </ul> <p>Work with colors, RGB, and HSBK</p> <p> Colors</p> <ul> <li> Network Layer</li> </ul> <p>Low-level network operations</p> <p> Network</p> <ul> <li> Protocol Layer</li> </ul> <p>Auto-generated protocol structures</p> <p> Protocol</p> <ul> <li> Exceptions</li> </ul> <p>Error handling and exception hierarchy</p> <p> Exceptions</p>"},{"location":"api/#best-practices","title":"Best Practices","text":""},{"location":"api/#always-use-context-managers","title":"Always Use Context Managers","text":"<pre><code># \u2705 Good - automatic cleanup\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n\n# \u274c Bad - manual cleanup required\nlight = Light(\"d073d5123456\", \"192.168.1.100\")\nawait light.connect()\nawait light.set_color(Colors.BLUE)\nawait light.disconnect()\n</code></pre>"},{"location":"api/#handle-exceptions","title":"Handle Exceptions","text":"<pre><code>from lifx import discover, LifxError\n\ntry:\n    async with discover() as group:\n        await group.set_color(Colors.GREEN)\nexcept LifxError as e:\n    print(f\"LIFX error: {e}\")\n</code></pre>"},{"location":"api/#use-type-hints","title":"Use Type Hints","text":"<pre><code>from lifx import Light, HSBK\n\n\nasync def control_light(light: Light) -&gt; str:\n    label: str = await light.get_label()\n    return label\n</code></pre>"},{"location":"api/#further-reading","title":"Further Reading","text":"<ul> <li>Architecture - How lifx-async works</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"api/colors/","title":"Color Utilities","text":"<p>lifx-async provides comprehensive color utilities for working with LIFX's HSBK color model and converting to/from RGB.</p>"},{"location":"api/colors/#hsbk-class","title":"HSBK Class","text":"<p>The <code>HSBK</code> class represents colors in the Hue, Saturation, Brightness, Kelvin color model used by LIFX devices.</p>"},{"location":"api/colors/#lifx.color.HSBK","title":"HSBK  <code>dataclass</code>","text":"<pre><code>HSBK(hue: float, saturation: float, brightness: float, kelvin: int)\n</code></pre> <p>User-friendly HSBK color representation.</p> <p>LIFX devices use HSBK (Hue, Saturation, Brightness, Kelvin) color space. This class provides a convenient interface with normalized values and conversion to/from RGB.</p> ATTRIBUTE DESCRIPTION <code>hue</code> <p>Hue value in degrees (0-360)</p> <p> TYPE: <code>float</code> </p> <code>saturation</code> <p>Saturation (0.0-1.0, where 0 is white and 1 is fully saturated)</p> <p> TYPE: <code>float</code> </p> <code>brightness</code> <p>Brightness (0.0-1.0, where 0 is off and 1 is full brightness)</p> <p> TYPE: <code>float</code> </p> <code>kelvin</code> <p>Color temperature in Kelvin (1500-9000, typically 2500-9000 for LIFX)</p> <p> TYPE: <code>int</code> </p> Example <pre><code># Create a red color\nred = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)\n\n# Create from RGB\npurple = HSBK.from_rgb(128, 0, 128)\n\n# Convert to RGB\nr, g, b = purple.to_rgb()\n</code></pre> METHOD DESCRIPTION <code>__post_init__</code> <p>Validate all fields after initialization.</p> <code>from_rgb</code> <p>Create HSBK from RGB values.</p> <code>to_rgb</code> <p>Convert HSBK to RGB values.</p> <code>to_protocol</code> <p>Convert to protocol HSBK for packet serialization.</p> <code>from_protocol</code> <p>Create HSBK from protocol HSBK.</p> <code>with_hue</code> <p>Create a new HSBK with modified hue.</p> <code>with_saturation</code> <p>Create a new HSBK with modified saturation.</p> <code>with_brightness</code> <p>Create a new HSBK with modified brightness.</p> <code>with_kelvin</code> <p>Create a new HSBK with modified color temperature.</p>"},{"location":"api/colors/#lifx.color.HSBK-functions","title":"Functions","text":""},{"location":"api/colors/#lifx.color.HSBK.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate all fields after initialization.</p> Source code in <code>src/lifx/color.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate all fields after initialization.\"\"\"\n    self._validate_hue(self.hue)\n    self._validate_saturation(self.saturation)\n    self._validate_brightness(self.brightness)\n    self._validate_kelvin(self.kelvin)\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.from_rgb","title":"from_rgb  <code>classmethod</code>","text":"<pre><code>from_rgb(r: int, g: int, b: int, kelvin: int = KELVIN_NEUTRAL) -&gt; HSBK\n</code></pre> <p>Create HSBK from RGB values.</p> PARAMETER DESCRIPTION <code>r</code> <p>Red component (0-255)</p> <p> TYPE: <code>int</code> </p> <code>g</code> <p>Green component (0-255)</p> <p> TYPE: <code>int</code> </p> <code>b</code> <p>Blue component (0-255)</p> <p> TYPE: <code>int</code> </p> <code>kelvin</code> <p>Color temperature in Kelvin (default: 3500)</p> <p> TYPE: <code>int</code> DEFAULT: <code>KELVIN_NEUTRAL</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>HSBK instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If RGB values are out of range (0-255)</p> Example <pre><code># Pure red\nred = HSBK.from_rgb(255, 0, 0)\n\n# Purple with warm white\npurple = HSBK.from_rgb(128, 0, 128, kelvin=2500)\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>@classmethod\ndef from_rgb(\n    cls,\n    r: int,\n    g: int,\n    b: int,\n    kelvin: int = KELVIN_NEUTRAL,\n) -&gt; HSBK:\n    \"\"\"Create HSBK from RGB values.\n\n    Args:\n        r: Red component (0-255)\n        g: Green component (0-255)\n        b: Blue component (0-255)\n        kelvin: Color temperature in Kelvin (default: 3500)\n\n    Returns:\n        HSBK instance\n\n    Raises:\n        ValueError: If RGB values are out of range (0-255)\n\n    Example:\n        ```python\n        # Pure red\n        red = HSBK.from_rgb(255, 0, 0)\n\n        # Purple with warm white\n        purple = HSBK.from_rgb(128, 0, 128, kelvin=2500)\n        ```\n    \"\"\"\n    cls._validate_rgb_component(r, \"Red\")\n    cls._validate_rgb_component(g, \"Green\")\n    cls._validate_rgb_component(b, \"Blue\")\n\n    # Normalize to 0-1\n    r_norm = r / 255.0\n    g_norm = g / 255.0\n    b_norm = b / 255.0\n\n    # Convert to HSV using colorsys\n    h, s, v = colorsys.rgb_to_hsv(r_norm, g_norm, b_norm)\n\n    # Convert to LIFX ranges\n    hue = h * 360.0  # 0-1 -&gt; 0-360\n    saturation = s  # Already 0-1\n    brightness = v  # Already 0-1\n\n    return cls(hue=hue, saturation=saturation, brightness=brightness, kelvin=kelvin)\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.to_rgb","title":"to_rgb","text":"<pre><code>to_rgb() -&gt; tuple[int, int, int]\n</code></pre> <p>Convert HSBK to RGB values.</p> <p>Color temperature (kelvin) is not considered in this conversion, as it only affects the white point of the device.</p> RETURNS DESCRIPTION <code>tuple[int, int, int]</code> <p>Tuple of (red, green, blue) with values 0-255</p> Example <pre><code>color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)\nr, g, b = color.to_rgb()  # Returns (0, 255, 0) - green\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def to_rgb(self) -&gt; tuple[int, int, int]:\n    \"\"\"Convert HSBK to RGB values.\n\n    Color temperature (kelvin) is not considered in this conversion,\n    as it only affects the white point of the device.\n\n    Returns:\n        Tuple of (red, green, blue) with values 0-255\n\n    Example:\n        ```python\n        color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)\n        r, g, b = color.to_rgb()  # Returns (0, 255, 0) - green\n        ```\n    \"\"\"\n    # Convert to colorsys ranges\n    h = self.hue / 360.0  # 0-360 -&gt; 0-1\n    s = self.saturation  # Already 0-1\n    v = self.brightness  # Already 0-1\n\n    # Convert using colorsys\n    r_norm, g_norm, b_norm = colorsys.hsv_to_rgb(h, s, v)\n\n    # Scale to 0-255 and round\n    r = int(round(r_norm * 255))\n    g = int(round(g_norm * 255))\n    b = int(round(b_norm * 255))\n\n    return (r, g, b)\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.to_protocol","title":"to_protocol","text":"<pre><code>to_protocol() -&gt; LightHsbk\n</code></pre> <p>Convert to protocol HSBK for packet serialization.</p> <p>LIFX protocol uses uint16 values for all HSBK components: - Hue: 0-65535 (represents 0-360 degrees) - Saturation: 0-65535 (represents 0-100%) - Brightness: 0-65535 (represents 0-100%) - Kelvin: Direct value in Kelvin</p> RETURNS DESCRIPTION <code>LightHsbk</code> <p>LightHsbk instance for packet serialization</p> Example <pre><code>color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\nprotocol_color = color.to_protocol()\n# Use in packet: LightSetColor(color=protocol_color, ...)\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def to_protocol(self) -&gt; LightHsbk:\n    \"\"\"Convert to protocol HSBK for packet serialization.\n\n    LIFX protocol uses uint16 values for all HSBK components:\n    - Hue: 0-65535 (represents 0-360 degrees)\n    - Saturation: 0-65535 (represents 0-100%)\n    - Brightness: 0-65535 (represents 0-100%)\n    - Kelvin: Direct value in Kelvin\n\n    Returns:\n        LightHsbk instance for packet serialization\n\n    Example:\n        ```python\n        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\n        protocol_color = color.to_protocol()\n        # Use in packet: LightSetColor(color=protocol_color, ...)\n        ```\n    \"\"\"\n    # Convert to uint16 ranges with overflow protection\n    # Clamp values to prevent overflow\n    hue_u16 = max(0, min(65535, int(round((self.hue / 360.0) * 65535))))\n    saturation_u16 = max(0, min(65535, int(round(self.saturation * 65535))))\n    brightness_u16 = max(0, min(65535, int(round(self.brightness * 65535))))\n\n    return LightHsbk(\n        hue=hue_u16,\n        saturation=saturation_u16,\n        brightness=brightness_u16,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.from_protocol","title":"from_protocol  <code>classmethod</code>","text":"<pre><code>from_protocol(protocol: LightHsbk) -&gt; HSBK\n</code></pre> <p>Create HSBK from protocol HSBK.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>LightHsbk instance from packet deserialization</p> <p> TYPE: <code>LightHsbk</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>User-friendly HSBK instance</p> Example <pre><code># After receiving LightState packet\nstate = await device.get_state()\ncolor = HSBK.from_protocol(state.color)\nprint(f\"Hue: {color.hue}\u00b0, Brightness: {color.brightness * 100}%\")\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>@classmethod\ndef from_protocol(cls, protocol: LightHsbk) -&gt; HSBK:\n    \"\"\"Create HSBK from protocol HSBK.\n\n    Args:\n        protocol: LightHsbk instance from packet deserialization\n\n    Returns:\n        User-friendly HSBK instance\n\n    Example:\n        ```python\n        # After receiving LightState packet\n        state = await device.get_state()\n        color = HSBK.from_protocol(state.color)\n        print(f\"Hue: {color.hue}\u00b0, Brightness: {color.brightness * 100}%\")\n        ```\n    \"\"\"\n    # Convert from uint16 ranges to user-friendly ranges\n    hue = (protocol.hue / 65535.0) * 360.0\n    saturation = protocol.saturation / 65535.0\n    brightness = protocol.brightness / 65535.0\n\n    return cls(\n        hue=hue,\n        saturation=saturation,\n        brightness=brightness,\n        kelvin=protocol.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_hue","title":"with_hue","text":"<pre><code>with_hue(hue: float) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified hue.</p> PARAMETER DESCRIPTION <code>hue</code> <p>New hue value (0-360)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_hue(self, hue: float) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified hue.\n\n    Args:\n        hue: New hue value (0-360)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=hue,\n        saturation=self.saturation,\n        brightness=self.brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_saturation","title":"with_saturation","text":"<pre><code>with_saturation(saturation: float) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified saturation.</p> PARAMETER DESCRIPTION <code>saturation</code> <p>New saturation value (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_saturation(self, saturation: float) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified saturation.\n\n    Args:\n        saturation: New saturation value (0.0-1.0)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=saturation,\n        brightness=self.brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_brightness","title":"with_brightness","text":"<pre><code>with_brightness(brightness: float) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified brightness.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>New brightness value (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_brightness(self, brightness: float) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified brightness.\n\n    Args:\n        brightness: New brightness value (0.0-1.0)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=self.saturation,\n        brightness=brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_kelvin","title":"with_kelvin","text":"<pre><code>with_kelvin(kelvin: int) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified color temperature.</p> PARAMETER DESCRIPTION <code>kelvin</code> <p>New kelvin value (1500-9000)</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_kelvin(self, kelvin: int) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified color temperature.\n\n    Args:\n        kelvin: New kelvin value (1500-9000)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=self.saturation,\n        brightness=self.brightness,\n        kelvin=kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#colors-class","title":"Colors Class","text":"<p>The <code>Colors</code> class provides convenient color presets for common colors.</p>"},{"location":"api/colors/#lifx.color.Colors","title":"Colors","text":"<p>Common color presets for convenience.</p>"},{"location":"api/colors/#examples","title":"Examples","text":""},{"location":"api/colors/#creating-colors","title":"Creating Colors","text":"<pre><code>from lifx import HSBK, Colors\n\n# Use built-in color presets\ncolor = Colors.BLUE\n\n# Create custom colors\ncustom = HSBK(hue=180.0, saturation=1.0, brightness=0.8, kelvin=3500)\n\n# Create from RGB\nred = HSBK.from_rgb(255, 0, 0, kelvin=3500)\n\n# Convert to RGB\nr, g, b = Colors.BLUE.to_rgb()\nprint(f\"RGB: ({r}, {g}, {b})\")\n</code></pre>"},{"location":"api/colors/#color-components","title":"Color Components","text":"<pre><code>from lifx import HSBK\n\ncolor = HSBK(hue=240.0, saturation=1.0, brightness=0.5, kelvin=3500)\n\n# Hue: 0-360 degrees (0=red, 120=green, 240=blue)\nprint(f\"Hue: {color.hue}\u00b0\")\n\n# Saturation: 0.0-1.0 (0=white, 1=full color)\nprint(f\"Saturation: {color.saturation * 100}%\")\n\n# Brightness: 0.0-1.0 (0=off, 1=full brightness)\nprint(f\"Brightness: {color.brightness * 100}%\")\n\n# Kelvin: 1500-9000 (warm white to cool white)\nprint(f\"Temperature: {color.kelvin}K\")\n</code></pre>"},{"location":"api/colors/#color-manipulation","title":"Color Manipulation","text":"<pre><code>from lifx import HSBK, Light\n\n\nasync def cycle_hue(light: Light):\n    \"\"\"Cycle through the color spectrum\"\"\"\n    for hue in range(0, 360, 10):\n        color = HSBK(hue=float(hue), saturation=1.0, brightness=0.8, kelvin=3500)\n        await light.set_color(color, duration=0.1)\n</code></pre>"},{"location":"api/colors/#white-balance","title":"White Balance","text":"<pre><code>from lifx import HSBK\n\n# Warm white (sunset, candlelight)\nwarm = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=2500)\n\n# Neutral white (daylight)\nneutral = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=4000)\n\n# Cool white (overcast, shade)\ncool = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=6500)\n</code></pre>"},{"location":"api/colors/#available-color-presets","title":"Available Color Presets","text":"<p>The <code>Colors</code> class provides these preset colors:</p> <ul> <li><code>Colors.WHITE</code> - Pure white (3500K)</li> <li><code>Colors.RED</code> - Red</li> <li><code>Colors.ORANGE</code> - Orange</li> <li><code>Colors.YELLOW</code> - Yellow</li> <li><code>Colors.GREEN</code> - Green</li> <li><code>Colors.CYAN</code> - Cyan</li> <li><code>Colors.BLUE</code> - Blue</li> <li><code>Colors.PURPLE</code> - Purple</li> <li><code>Colors.PINK</code> - Pink</li> <li><code>Colors.WARM_WHITE</code> - Warm white (2500K)</li> <li><code>Colors.COOL_WHITE</code> - Cool white (6500K)</li> </ul>"},{"location":"api/colors/#color-conversion-notes","title":"Color Conversion Notes","text":""},{"location":"api/colors/#rgb-to-hsbk","title":"RGB to HSBK","text":"<p>When converting from RGB to HSBK, note that:</p> <ul> <li>RGB values are 0-255</li> <li>The Kelvin value must be specified (default: 3500K)</li> <li>Some RGB colors may not have exact HSBK equivalents</li> <li>Conversion uses standard HSV formulas with brightness mapping</li> </ul>"},{"location":"api/colors/#hsbk-to-rgb","title":"HSBK to RGB","text":"<p>When converting from HSBK to RGB:</p> <ul> <li>Returns tuple of (r, g, b) with values 0-255</li> <li>Kelvin temperature is not represented in RGB</li> <li>White colors (saturation=0) will be pure gray values</li> <li>Conversion is lossy - converting back may not yield the same HSBK</li> </ul>"},{"location":"api/devices/","title":"Device Classes","text":"<p>Device classes provide direct control over LIFX devices. All device classes support async context managers for automatic resource cleanup.</p>"},{"location":"api/devices/#base-device","title":"Base Device","text":"<p>The <code>Device</code> class provides common operations available on all LIFX devices.</p>"},{"location":"api/devices/#lifx.devices.base.Device","title":"Device","text":"<pre><code>Device(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n)\n</code></pre> <p>Base class for LIFX devices.</p> <p>This class provides common functionality for all LIFX devices: - Connection management - Basic device queries (label, power, version, info) - State caching with TTL</p> Example <pre><code>device = Device(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with device:\n    # Get device label\n    label = await device.get_label()\n    print(f\"Device: {label}\")\n\n    # Turn on device\n    await device.set_power(True)\n\n    # Get power state\n    is_on = await device.get_power()\n    print(f\"Power: {'ON' if is_on else 'OFF'}\")\n</code></pre> PARAMETER DESCRIPTION <code>serial</code> <p>Device serial number as 12-digit hex string (e.g., \"d073d5123456\")</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>cache_ttl</code> <p>Cache time-to-live in seconds (default 5.0, min 0.1, max 300)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Overall timeout for network requests in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>max_retries</code> <p>Maximum number of retry attempts for network requests</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any parameter is invalid</p> METHOD DESCRIPTION <code>from_ip</code> <p>Create and return an instance for the given IP address.</p> <code>get_label</code> <p>Get device label/name.</p> <code>set_label</code> <p>Set device label/name.</p> <code>get_power</code> <p>Get device power state.</p> <code>set_power</code> <p>Set device power state.</p> <code>get_version</code> <p>Get device version information.</p> <code>get_info</code> <p>Get device runtime information.</p> <code>get_wifi_info</code> <p>Get device WiFi module information.</p> <code>get_host_firmware</code> <p>Get device host (WiFi module) firmware information.</p> <code>get_wifi_firmware</code> <p>Get device WiFi module firmware information.</p> <code>get_location</code> <p>Get device location information.</p> <code>set_location</code> <p>Set device location information.</p> <code>get_group</code> <p>Get device group information.</p> <code>set_group</code> <p>Set device group information.</p> <code>set_reboot</code> <p>Reboot the device.</p> ATTRIBUTE DESCRIPTION <code>capabilities</code> <p>Get device product capabilities.</p> <p> TYPE: <code>ProductInfo | None</code> </p> <code>location</code> <p>Get cached location info if available.</p> <p> TYPE: <code>LocationInfo | None</code> </p> <code>group</code> <p>Get cached group info if available.</p> <p> TYPE: <code>GroupInfo | None</code> </p> <code>model</code> <p>Get LIFX friendly model name if available.</p> <p> TYPE: <code>str | None</code> </p> <code>min_kelvin</code> <p>Get the minimum supported kelvin value if available.</p> <p> TYPE: <code>int | None</code> </p> <code>max_kelvin</code> <p>Get the maximum supported kelvin value if available.</p> <p> TYPE: <code>int | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        cache_ttl: Cache time-to-live in seconds (default 5.0, min 0.1, max 300)\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Check multicast bit (first byte, LSB should be 0 for unicast)\n    if serial_bytes[0] &amp; 0x01:\n        raise ValueError(\"Multicast serial number not allowed\")\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        raise ValueError(\"Localhost IP address not allowed\")\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\"Unspecified IP address (0.0.0.0) not allowed\")\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")\n\n    # Validate port\n    if not (1 &lt;= port &lt;= 65535):\n        raise ValueError(f\"Port must be between 1 and 65535, got {port}\")\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Validate cache TTL\n    if cache_ttl is None:\n        cache_ttl = self.DEFAULT_CACHE_TTL\n\n    if not (self.MIN_CACHE_TTL &lt;= cache_ttl &lt;= self.MAX_CACHE_TTL):\n        raise ValueError(\n            f\"cache_ttl must be between {self.MIN_CACHE_TTL} \"\n            f\"and {self.MAX_CACHE_TTL}, got {cache_ttl}\"\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self.cache_ttl = cache_ttl\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State cache: key -&gt; (value, timestamp, ttl)\n    self._cache: dict[str, tuple[Any, float, float]] = {}\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.base.Device.capabilities","title":"capabilities  <code>property</code>","text":"<pre><code>capabilities: ProductInfo | None\n</code></pre> <p>Get device product capabilities.</p> <p>Returns product information including supported features like: - color, infrared, multizone, extended_multizone - matrix (for tiles), chain, relays, buttons, hev - temperature_range</p> <p>Capabilities are automatically loaded when using device as context manager.</p> RETURNS DESCRIPTION <code>ProductInfo | None</code> <p>ProductInfo if capabilities have been loaded, None otherwise.</p> Example <pre><code>async with device:\n    if device.capabilities and device.capabilities.has_multizone:\n        print(\"Device supports multizone\")\n    if device.capabilities and device.capabilities.has_extended_multizone:\n        print(\"Device supports extended multizone\")\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.location","title":"location  <code>property</code>","text":"<pre><code>location: LocationInfo | None\n</code></pre> <p>Get cached location info if available.</p> <p>Use get_location() to fetch from device.</p> RETURNS DESCRIPTION <code>LocationInfo | None</code> <p>Cached location info or None if not cached.</p>"},{"location":"api/devices/#lifx.devices.base.Device.group","title":"group  <code>property</code>","text":"<pre><code>group: GroupInfo | None\n</code></pre> <p>Get cached group info if available.</p> <p>Use get_group() to fetch from device.</p> RETURNS DESCRIPTION <code>GroupInfo | None</code> <p>Cached group info or None if not cached.</p>"},{"location":"api/devices/#lifx.devices.base.Device.model","title":"model  <code>property</code>","text":"<pre><code>model: str | None\n</code></pre> <p>Get LIFX friendly model name if available.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Model string from product registry.</p>"},{"location":"api/devices/#lifx.devices.base.Device.min_kelvin","title":"min_kelvin  <code>property</code>","text":"<pre><code>min_kelvin: int | None\n</code></pre> <p>Get the minimum supported kelvin value if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Minimum kelvin value from product registry.</p>"},{"location":"api/devices/#lifx.devices.base.Device.max_kelvin","title":"max_kelvin  <code>property</code>","text":"<pre><code>max_kelvin: int | None\n</code></pre> <p>Get the maximum supported kelvin value if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Maximum kelvin value from product registry.</p>"},{"location":"api/devices/#lifx.devices.base.Device-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.base.Device.from_ip","title":"from_ip  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_ip(\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    serial: str | None = None,\n    timeout: float = 1.0,\n) -&gt; Self\n</code></pre> <p>Create and return an instance for the given IP address.</p> <p>This is a convenience class method for connecting to a known device by IP address. The returned instance can be used as a context manager.</p> PARAMETER DESCRIPTION <code>ip</code> <p>IP address of the device</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Port number (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>serial</code> <p>Serial number as 12-digit hex string</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Request timeout for this light instance</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Device instance ready to use with async context manager</p> Example <pre><code>async with Device.from_ip(ip=\"192.168.1.100\") as device:\n    label = await device.get_label()\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>@classmethod\nasync def from_ip(\n    cls,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    serial: str | None = None,\n    timeout: float = 1.0,\n) -&gt; Self:\n    \"\"\"Create and return an instance for the given IP address.\n\n    This is a convenience class method for connecting to a known device\n    by IP address. The returned instance can be used as a context manager.\n\n    Args:\n        ip: IP address of the device\n        port: Port number (default LIFX_UDP_PORT)\n        serial: Serial number as 12-digit hex string\n        timeout: Request timeout for this light instance\n\n    Returns:\n        Device instance ready to use with async context manager\n\n    Example:\n        ```python\n        async with Device.from_ip(ip=\"192.168.1.100\") as device:\n            label = await device.get_label()\n        ```\n    \"\"\"\n    if serial is None:\n        temp_conn = DeviceConnection(serial=\"000000000000\", ip=ip, port=port)\n        response = await temp_conn.request(packets.Device.GetService(), timeout=2.0)\n        if response and isinstance(response, packets.Device.StateService):\n            if temp_conn.serial and temp_conn.serial != \"000000000000\":\n                return cls(\n                    serial=temp_conn.serial, ip=ip, port=port, timeout=timeout\n                )\n    else:\n        return cls(serial=serial, ip=ip, port=port, timeout=timeout)\n\n    raise LifxDeviceNotFoundError()\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_label","title":"get_label  <code>async</code>","text":"<pre><code>get_label(use_cache: bool = True) -&gt; str\n</code></pre> <p>Get device label/name.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Device label as string (max 32 bytes UTF-8)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>label = await device.get_label()\nprint(f\"Device name: {label}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_label(self, use_cache: bool = True) -&gt; str:\n    \"\"\"Get device label/name.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        Device label as string (max 32 bytes UTF-8)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        label = await device.get_label()\n        print(f\"Device name: {label}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"label\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks and decodes label\n    state = await self.connection.request(packets.Device.GetLabel())\n\n    # Label is already decoded to string by connection layer\n    self._set_cached(\"label\", state.label)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_label\",\n            \"action\": \"query\",\n            \"reply\": {\"label\": state.label},\n        }\n    )\n    return state.label\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_label","title":"set_label  <code>async</code>","text":"<pre><code>set_label(label: str) -&gt; None\n</code></pre> <p>Set device label/name.</p> PARAMETER DESCRIPTION <code>label</code> <p>New device label (max 32 bytes UTF-8)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If label is too long</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code>await device.set_label(\"Living Room Light\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_label(self, label: str) -&gt; None:\n    \"\"\"Set device label/name.\n\n    Args:\n        label: New device label (max 32 bytes UTF-8)\n\n    Raises:\n        ValueError: If label is too long\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        await device.set_label(\"Living Room Light\")\n        ```\n    \"\"\"\n    # Encode and pad to 32 bytes\n    label_bytes = label.encode(\"utf-8\")\n    if len(label_bytes) &gt; 32:\n        raise ValueError(f\"Label too long: {len(label_bytes)} bytes (max 32)\")\n\n    # Pad with zeros\n    label_bytes = label_bytes.ljust(32, b\"\\x00\")\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Device.SetLabel(label=label_bytes),\n    )\n\n    # Update cache\n    self._set_cached(\"label\", label)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_label\",\n            \"action\": \"change\",\n            \"values\": {\"label\": label},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_power","title":"get_power  <code>async</code>","text":"<pre><code>get_power(use_cache: bool = True) -&gt; bool\n</code></pre> <p>Get device power state.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if device is powered on, False otherwise</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>is_on = await device.get_power()\nprint(f\"Power: {'ON' if is_on else 'OFF'}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_power(self, use_cache: bool = True) -&gt; bool:\n    \"\"\"Get device power state.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        True if device is powered on, False otherwise\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        is_on = await device.get_power()\n        print(f\"Power: {'ON' if is_on else 'OFF'}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"power\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetPower())\n\n    # Power level is uint16 (0 or 65535)\n    is_on = state.level &gt; 0\n\n    self._set_cached(\"power\", is_on)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_power\",\n            \"action\": \"query\",\n            \"reply\": {\"level\": state.level},\n        }\n    )\n    return is_on\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(on: bool) -&gt; None\n</code></pre> <p>Set device power state.</p> PARAMETER DESCRIPTION <code>on</code> <p>True to turn on, False to turn off</p> <p> TYPE: <code>bool</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Turn on\nawait device.set_power(True)\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_power(self, on: bool) -&gt; None:\n    \"\"\"Set device power state.\n\n    Args:\n        on: True to turn on, False to turn off\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Turn on\n        await device.set_power(True)\n        ```\n    \"\"\"\n    # Power level: 0 for off, 65535 for on\n    level = 65535 if on else 0\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Device.SetPower(level=level),\n    )\n\n    # Update cache\n    self._set_cached(\"power\", on)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_power\",\n            \"action\": \"change\",\n            \"values\": {\"level\": level},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_version","title":"get_version  <code>async</code>","text":"<pre><code>get_version(use_cache: bool = True) -&gt; DeviceVersion\n</code></pre> <p>Get device version information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>DeviceVersion</code> <p>DeviceVersion with vendor and product fields</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>version = await device.get_version()\nprint(f\"Vendor: {version.vendor}, Product: {version.product}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_version(self, use_cache: bool = True) -&gt; DeviceVersion:\n    \"\"\"Get device version information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        DeviceVersion with vendor and product fields\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        version = await device.get_version()\n        print(f\"Vendor: {version.vendor}, Product: {version.product}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"version\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetVersion())\n\n    version = DeviceVersion(\n        vendor=state.vendor,\n        product=state.product,\n    )\n\n    # Version is immutable - cache permanently\n    self._set_cached(\"version\", version, ttl=self.PERMANENT_CACHE_TTL)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_version\",\n            \"action\": \"query\",\n            \"reply\": {\"vendor\": state.vendor, \"product\": state.product},\n        }\n    )\n    return version\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_info","title":"get_info  <code>async</code>","text":"<pre><code>get_info(use_cache: bool = True) -&gt; DeviceInfo\n</code></pre> <p>Get device runtime information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>DeviceInfo</code> <p>DeviceInfo with time, uptime, and downtime</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>info = await device.get_info()\nuptime_hours = info.uptime / 1e9 / 3600\nprint(f\"Uptime: {uptime_hours:.1f} hours\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_info(self, use_cache: bool = True) -&gt; DeviceInfo:\n    \"\"\"Get device runtime information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        DeviceInfo with time, uptime, and downtime\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        info = await device.get_info()\n        uptime_hours = info.uptime / 1e9 / 3600\n        print(f\"Uptime: {uptime_hours:.1f} hours\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"info\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetInfo())  # type: ignore\n\n    info = DeviceInfo(time=state.time, uptime=state.uptime, downtime=state.downtime)\n\n    self._set_cached(\"info\", info)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_info\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"time\": state.time,\n                \"uptime\": state.uptime,\n                \"downtime\": state.downtime,\n            },\n        }\n    )\n    return info\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_wifi_info","title":"get_wifi_info  <code>async</code>","text":"<pre><code>get_wifi_info(use_cache: bool = True) -&gt; WifiInfo\n</code></pre> <p>Get device WiFi module information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>WifiInfo</code> <p>WifiInfo with signal strength and network stats</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>wifi_info = await device.get_wifi_info()\nprint(f\"WiFi signal: {wifi_info.signal} mW\")\nprint(f\"TX: {wifi_info.tx} bytes, RX: {wifi_info.rx} bytes\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_wifi_info(self, use_cache: bool = True) -&gt; WifiInfo:\n    \"\"\"Get device WiFi module information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        WifiInfo with signal strength and network stats\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        wifi_info = await device.get_wifi_info()\n        print(f\"WiFi signal: {wifi_info.signal} mW\")\n        print(f\"TX: {wifi_info.tx} bytes, RX: {wifi_info.rx} bytes\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"wifi_info\")\n        if cached is not None:\n            return cached\n\n    # Request WiFi info from device\n    state = await self.connection.request(packets.Device.GetWifiInfo())\n\n    # Extract WiFi info from response\n    wifi_info = WifiInfo(signal=state.signal, tx=state.tx, rx=state.rx)\n\n    self._set_cached(\"wifi_info\", wifi_info)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_wifi_info\",\n            \"action\": \"query\",\n            \"reply\": {\"signal\": state.signal, \"tx\": state.tx, \"rx\": state.rx},\n        }\n    )\n    return wifi_info\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_host_firmware","title":"get_host_firmware  <code>async</code>","text":"<pre><code>get_host_firmware(use_cache: bool = True) -&gt; FirmwareInfo\n</code></pre> <p>Get device host (WiFi module) firmware information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>FirmwareInfo</code> <p>FirmwareInfo with build timestamp and version</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>firmware = await device.get_host_firmware()\nprint(f\"Firmware: v{firmware.version_major}.{firmware.version_minor}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_host_firmware(self, use_cache: bool = True) -&gt; FirmwareInfo:\n    \"\"\"Get device host (WiFi module) firmware information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        FirmwareInfo with build timestamp and version\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        firmware = await device.get_host_firmware()\n        print(f\"Firmware: v{firmware.version_major}.{firmware.version_minor}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"host_firmware\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetHostFirmware())  # type: ignore\n\n    firmware = FirmwareInfo(\n        build=state.build,\n        version_major=state.version_major,\n        version_minor=state.version_minor,\n    )\n\n    # Host firmware is immutable - cache permanently\n    self._set_cached(\"host_firmware\", firmware, ttl=self.PERMANENT_CACHE_TTL)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_host_firmware\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"build\": state.build,\n                \"version_major\": state.version_major,\n                \"version_minor\": state.version_minor,\n            },\n        }\n    )\n    return firmware\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_wifi_firmware","title":"get_wifi_firmware  <code>async</code>","text":"<pre><code>get_wifi_firmware(use_cache: bool = True) -&gt; FirmwareInfo\n</code></pre> <p>Get device WiFi module firmware information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>FirmwareInfo</code> <p>FirmwareInfo with build timestamp and version</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>wifi_fw = await device.get_wifi_firmware()\nprint(f\"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_wifi_firmware(self, use_cache: bool = True) -&gt; FirmwareInfo:\n    \"\"\"Get device WiFi module firmware information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        FirmwareInfo with build timestamp and version\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        wifi_fw = await device.get_wifi_firmware()\n        print(f\"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"wifi_firmware\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetWifiFirmware())  # type: ignore\n\n    firmware = FirmwareInfo(\n        build=state.build,\n        version_major=state.version_major,\n        version_minor=state.version_minor,\n    )\n\n    # WiFi firmware is immutable - cache permanently\n    self._set_cached(\"wifi_firmware\", firmware, ttl=self.PERMANENT_CACHE_TTL)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_wifi_firmware\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"build\": state.build,\n                \"version_major\": state.version_major,\n                \"version_minor\": state.version_minor,\n            },\n        }\n    )\n    return firmware\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_location","title":"get_location  <code>async</code>","text":"<pre><code>get_location(use_cache: bool = True) -&gt; LocationInfo\n</code></pre> <p>Get device location information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>LocationInfo</code> <p>LocationInfo with location UUID, label, and updated timestamp</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>location = await device.get_location()\nprint(f\"Location: {location.label}\")\nprint(f\"Location ID: {location.location.hex()}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_location(self, use_cache: bool = True) -&gt; LocationInfo:\n    \"\"\"Get device location information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        LocationInfo with location UUID, label, and updated timestamp\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        location = await device.get_location()\n        print(f\"Location: {location.label}\")\n        print(f\"Location ID: {location.location.hex()}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"location\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetLocation())  # type: ignore\n\n    location = LocationInfo(\n        location=state.location,\n        label=state.label,\n        updated_at=state.updated_at,\n    )\n\n    self._set_cached(\"location\", location, ttl=self.METADATA_CACHE_TTL)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_location\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"location\": state.location.hex(),\n                \"label\": state.label,\n                \"updated_at\": state.updated_at,\n            },\n        }\n    )\n    return location\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_location","title":"set_location  <code>async</code>","text":"<pre><code>set_location(label: str, *, discover_timeout: float = 3.0) -&gt; None\n</code></pre> <p>Set device location information.</p> <p>Automatically discovers devices on the network to check if any device already has the target location label. If found, reuses that existing UUID to ensure devices with the same label share the same location UUID. If not found, generates a new UUID for this label.</p> PARAMETER DESCRIPTION <code>label</code> <p>Location label (max 32 characters)</p> <p> TYPE: <code>str</code> </p> <code>discover_timeout</code> <p>Timeout for device discovery in seconds (default 3.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>ValueError</code> <p>If label is invalid</p> Example <pre><code># Set device location - checks network for existing \"Living Room\" location\nawait device.set_location(\"Living Room\")\n\n# If another device already has \"Kitchen\" location, this device will\n# join that existing location UUID\nawait device.set_location(\"Kitchen\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_location(self, label: str, *, discover_timeout: float = 3.0) -&gt; None:\n    \"\"\"Set device location information.\n\n    Automatically discovers devices on the network to check if any device already\n    has the target location label. If found, reuses that existing UUID to ensure\n    devices with the same label share the same location UUID. If not found,\n    generates a new UUID for this label.\n\n    Args:\n        label: Location label (max 32 characters)\n        discover_timeout: Timeout for device discovery in seconds (default 3.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        ValueError: If label is invalid\n\n    Example:\n        ```python\n        # Set device location - checks network for existing \"Living Room\" location\n        await device.set_location(\"Living Room\")\n\n        # If another device already has \"Kitchen\" location, this device will\n        # join that existing location UUID\n        await device.set_location(\"Kitchen\")\n        ```\n    \"\"\"\n    # Validate label\n    if not label:\n        raise ValueError(\"Label cannot be empty\")\n    if len(label) &gt; 32:\n        raise ValueError(f\"Label must be max 32 characters, got {len(label)}\")\n\n    # Import here to avoid circular dependency\n    from lifx.network.discovery import discover_devices\n\n    # Discover all devices to check for existing label\n    location_uuid_to_use: bytes | None = None\n\n    try:\n        discovered = await discover_devices(timeout=discover_timeout)\n\n        # Check each device for the target label\n        for disc in discovered:\n            try:\n                # Create connection handle - no explicit open/close needed\n                temp_conn = DeviceConnection(\n                    serial=disc.serial, ip=disc.ip, port=disc.port\n                )\n\n                # Get location info using new request() API\n                state_packet = await temp_conn.request(packets.Device.GetLocation())  # type: ignore\n\n                # Check if this device has the target label\n                if (\n                    state_packet.label == label\n                    and state_packet.location is not None\n                    and isinstance(state_packet.location, bytes)\n                ):\n                    location_uuid_to_use = state_packet.location\n                    # Type narrowing: we know location_uuid_to_use is not None here\n                    _LOGGER.debug(\n                        {\n                            \"action\": \"device.set_location\",\n                            \"location_found\": True,\n                            \"label\": label,\n                            \"uuid\": location_uuid_to_use.hex(),\n                        }\n                    )\n                    break\n\n            except Exception as e:\n                _LOGGER.debug(\n                    {\n                        \"action\": \"device.set_location\",\n                        \"discovery_query_failed\": True,\n                        \"reason\": str(e),\n                    }\n                )\n                continue\n\n    except Exception as e:\n        _LOGGER.warning(\n            {\n                \"warning\": \"Discovery failed, will generate new UUID\",\n                \"reason\": str(e),\n            }\n        )\n\n    # If no existing location with target label found, generate new UUID\n    if location_uuid_to_use is None:\n        location_uuid = uuid.uuid5(LIFX_LOCATION_NAMESPACE, label)\n        location_uuid_to_use = location_uuid.bytes\n\n    # Encode label for protocol\n    label_bytes = label.encode(\"utf-8\")[:32].ljust(32, b\"\\x00\")\n\n    # Always use current time as updated_at timestamp\n    updated_at = int(time.time() * 1e9)\n\n    # Update this device\n    await self.connection.request(\n        packets.Device.SetLocation(\n            location=location_uuid_to_use, label=label_bytes, updated_at=updated_at\n        ),\n    )\n\n    # Update cache\n    location_info = LocationInfo(\n        location=location_uuid_to_use, label=label, updated_at=updated_at\n    )\n    self._set_cached(\"location\", location_info, ttl=self.METADATA_CACHE_TTL)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_location\",\n            \"action\": \"change\",\n            \"values\": {\n                \"location\": location_uuid_to_use.hex(),\n                \"label\": label,\n                \"updated_at\": updated_at,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_group","title":"get_group  <code>async</code>","text":"<pre><code>get_group(use_cache: bool = True) -&gt; GroupInfo\n</code></pre> <p>Get device group information.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>GroupInfo</code> <p>GroupInfo with group UUID, label, and updated timestamp</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>group = await device.get_group()\nprint(f\"Group: {group.label}\")\nprint(f\"Group ID: {group.group.hex()}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_group(self, use_cache: bool = True) -&gt; GroupInfo:\n    \"\"\"Get device group information.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        GroupInfo with group UUID, label, and updated timestamp\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        group = await device.get_group()\n        print(f\"Group: {group.label}\")\n        print(f\"Group ID: {group.group.hex()}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"group\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetGroup())  # type: ignore\n\n    group = GroupInfo(\n        group=state.group,\n        label=state.label,\n        updated_at=state.updated_at,\n    )\n\n    self._set_cached(\"group\", group, ttl=self.METADATA_CACHE_TTL)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_group\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"group\": state.group.hex(),\n                \"label\": state.label,\n                \"updated_at\": state.updated_at,\n            },\n        }\n    )\n    return group\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_group","title":"set_group  <code>async</code>","text":"<pre><code>set_group(label: str, *, discover_timeout: float = 3.0) -&gt; None\n</code></pre> <p>Set device group information.</p> <p>Automatically discovers devices on the network to check if any device already has the target group label. If found, reuses that existing UUID to ensure devices with the same label share the same group UUID. If not found, generates a new UUID for this label.</p> PARAMETER DESCRIPTION <code>label</code> <p>Group label (max 32 characters)</p> <p> TYPE: <code>str</code> </p> <code>discover_timeout</code> <p>Timeout for device discovery in seconds (default 3.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>ValueError</code> <p>If label is invalid</p> Example <pre><code># Set device group - checks network for existing \"Bedroom Lights\" group\nawait device.set_group(\"Bedroom Lights\")\n\n# If another device already has \"Upstairs\" group, this device will\n# join that existing group UUID\nawait device.set_group(\"Upstairs\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_group(self, label: str, *, discover_timeout: float = 3.0) -&gt; None:\n    \"\"\"Set device group information.\n\n    Automatically discovers devices on the network to check if any device already\n    has the target group label. If found, reuses that existing UUID to ensure\n    devices with the same label share the same group UUID. If not found,\n    generates a new UUID for this label.\n\n    Args:\n        label: Group label (max 32 characters)\n        discover_timeout: Timeout for device discovery in seconds (default 3.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        ValueError: If label is invalid\n\n    Example:\n        ```python\n        # Set device group - checks network for existing \"Bedroom Lights\" group\n        await device.set_group(\"Bedroom Lights\")\n\n        # If another device already has \"Upstairs\" group, this device will\n        # join that existing group UUID\n        await device.set_group(\"Upstairs\")\n        ```\n    \"\"\"\n    # Validate label\n    if not label:\n        raise ValueError(\"Label cannot be empty\")\n    if len(label) &gt; 32:\n        raise ValueError(f\"Label must be max 32 characters, got {len(label)}\")\n\n    # Import here to avoid circular dependency\n    from lifx.network.discovery import discover_devices\n\n    # Discover all devices to check for existing label\n    group_uuid_to_use: bytes | None = None\n\n    try:\n        discovered = await discover_devices(timeout=discover_timeout)\n\n        # Check each device for the target label\n        for disc in discovered:\n            try:\n                # Create connection handle - no explicit open/close needed\n                temp_conn = DeviceConnection(\n                    serial=disc.serial, ip=disc.ip, port=disc.port\n                )\n\n                # Get group info using new request() API\n                state_packet = await temp_conn.request(packets.Device.GetGroup())  # type: ignore\n\n                # Check if this device has the target label\n                if (\n                    state_packet.label == label\n                    and state_packet.group is not None\n                    and isinstance(state_packet.group, bytes)\n                ):\n                    group_uuid_to_use = state_packet.group\n                    # Type narrowing: we know group_uuid_to_use is not None here\n                    _LOGGER.debug(\n                        {\n                            \"action\": \"device.set_group\",\n                            \"group_found\": True,\n                            \"label\": label,\n                            \"uuid\": group_uuid_to_use.hex(),\n                        }\n                    )\n                    break\n\n            except Exception as e:\n                _LOGGER.debug(\n                    {\n                        \"action\": \"device.set_group\",\n                        \"discovery_query_failed\": True,\n                        \"reason\": str(e),\n                    }\n                )\n                continue\n\n    except Exception as e:\n        _LOGGER.warning(\n            {\n                \"warning\": \"Discovery failed, will generate new UUID\",\n                \"reason\": str(e),\n            }\n        )\n\n    # If no existing group with target label found, generate new UUID\n    if group_uuid_to_use is None:\n        group_uuid = uuid.uuid5(LIFX_GROUP_NAMESPACE, label)\n        group_uuid_to_use = group_uuid.bytes\n\n    # Encode label for protocol\n    label_bytes = label.encode(\"utf-8\")[:32].ljust(32, b\"\\x00\")\n\n    # Always use current time as updated_at timestamp\n    updated_at = int(time.time() * 1e9)\n\n    # Update this device\n    await self.connection.request(\n        packets.Device.SetGroup(\n            group=group_uuid_to_use, label=label_bytes, updated_at=updated_at\n        ),\n    )\n\n    # Update cache\n    group_info = GroupInfo(\n        group=group_uuid_to_use, label=label, updated_at=updated_at\n    )\n    self._set_cached(\"group\", group_info, ttl=self.METADATA_CACHE_TTL)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_group\",\n            \"action\": \"change\",\n            \"values\": {\n                \"group\": group_uuid_to_use.hex(),\n                \"label\": label,\n                \"updated_at\": updated_at,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_reboot","title":"set_reboot  <code>async</code>","text":"<pre><code>set_reboot() -&gt; None\n</code></pre> <p>Reboot the device.</p> <p>This sends a reboot command to the device. The device will disconnect and restart. You should disconnect from the device after calling this method.</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code>async with device:\n    await device.set_reboot()\n    # Device will reboot, connection will be lost\n</code></pre> Note <p>After rebooting, you may need to wait 10-30 seconds before the device comes back online and is discoverable again.</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_reboot(self) -&gt; None:\n    \"\"\"Reboot the device.\n\n    This sends a reboot command to the device. The device will disconnect\n    and restart. You should disconnect from the device after calling this method.\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        async with device:\n            await device.set_reboot()\n            # Device will reboot, connection will be lost\n        ```\n\n    Note:\n        After rebooting, you may need to wait 10-30 seconds before the device\n        comes back online and is discoverable again.\n    \"\"\"\n    # Send reboot request\n    await self.connection.request(\n        packets.Device.SetReboot(),\n    )\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_reboot\",\n            \"action\": \"change\",\n            \"values\": {},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#light","title":"Light","text":"<p>The <code>Light</code> class provides color control and effects for standard LIFX lights.</p>"},{"location":"api/devices/#lifx.devices.light.Light","title":"Light","text":"<pre><code>Light(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n)\n</code></pre> <p>               Bases: <code>Device</code></p> <p>LIFX light device with color control.</p> <p>Extends the base Device class with light-specific functionality: - Color control (HSBK) - Brightness control - Color temperature control - Waveform effects</p> Example <pre><code>light = Light(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Set color\n    await light.set_color(HSBK.from_rgb(255, 0, 0))\n\n    # Set brightness\n    await light.set_brightness(0.5)\n\n    # Set temperature\n    await light.set_temperature(3500)\n</code></pre> <p>Using the simplified connect method (without knowing the serial): <pre><code>async with await Light.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_color(HSBK.from_rgb(255, 0, 0))\n</code></pre></p> METHOD DESCRIPTION <code>get_color</code> <p>Get current light color.</p> <code>set_color</code> <p>Set light color.</p> <code>set_brightness</code> <p>Set light brightness only, preserving hue, saturation, and temperature.</p> <code>set_kelvin</code> <p>Set light color temperature, preserving brightness. Saturation is</p> <code>set_hue</code> <p>Set light hue only, preserving saturation, brightness, and temperature.</p> <code>set_saturation</code> <p>Set light saturation only, preserving hue, brightness, and temperature.</p> <code>get_power</code> <p>Get light power state (specific to light, not device).</p> <code>set_power</code> <p>Set light power state (specific to light, not device).</p> <code>set_waveform</code> <p>Apply a waveform effect to the light.</p> <code>set_waveform_optional</code> <p>Apply a waveform effect with selective color component control.</p> <code>pulse</code> <p>Pulse the light to a specific color.</p> <code>breathe</code> <p>Make the light breathe to a specific color.</p> ATTRIBUTE DESCRIPTION <code>color</code> <p>Get cached light color if available.</p> <p> TYPE: <code>HSBK | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        cache_ttl: Cache time-to-live in seconds (default 5.0, min 0.1, max 300)\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Check multicast bit (first byte, LSB should be 0 for unicast)\n    if serial_bytes[0] &amp; 0x01:\n        raise ValueError(\"Multicast serial number not allowed\")\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        raise ValueError(\"Localhost IP address not allowed\")\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\"Unspecified IP address (0.0.0.0) not allowed\")\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")\n\n    # Validate port\n    if not (1 &lt;= port &lt;= 65535):\n        raise ValueError(f\"Port must be between 1 and 65535, got {port}\")\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Validate cache TTL\n    if cache_ttl is None:\n        cache_ttl = self.DEFAULT_CACHE_TTL\n\n    if not (self.MIN_CACHE_TTL &lt;= cache_ttl &lt;= self.MAX_CACHE_TTL):\n        raise ValueError(\n            f\"cache_ttl must be between {self.MIN_CACHE_TTL} \"\n            f\"and {self.MAX_CACHE_TTL}, got {cache_ttl}\"\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self.cache_ttl = cache_ttl\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State cache: key -&gt; (value, timestamp, ttl)\n    self._cache: dict[str, tuple[Any, float, float]] = {}\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.light.Light.color","title":"color  <code>property</code>","text":"<pre><code>color: HSBK | None\n</code></pre> <p>Get cached light color if available.</p> RETURNS DESCRIPTION <code>HSBK | None</code> <p>Cached color or None if not cached. Use get_color() to fetch from device.</p>"},{"location":"api/devices/#lifx.devices.light.Light-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.light.Light.get_color","title":"get_color  <code>async</code>","text":"<pre><code>get_color(use_cache: bool = True) -&gt; HSBK\n</code></pre> <p>Get current light color.</p> <p>Note: This method also caches label and power state from the StateColor response, reducing the need for separate get_label() and get_power() calls.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>HSBK color</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>color = await light.get_color()\nprint(f\"Hue: {color.hue}\u00b0, Brightness: {color.brightness * 100}%\")\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def get_color(self, use_cache: bool = True) -&gt; HSBK:\n    \"\"\"Get current light color.\n\n    Note: This method also caches label and power state from the StateColor\n    response, reducing the need for separate get_label() and get_power() calls.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        HSBK color\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        color = await light.get_color()\n        print(f\"Hue: {color.hue}\u00b0, Brightness: {color.brightness * 100}%\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"color\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response and decodes labels\n    state = await self.connection.request(packets.Light.GetColor())\n\n    # Convert from protocol HSBK to user-friendly HSBK\n    color = HSBK.from_protocol(state.color)\n\n    # Cache color and other fields from StateColor response\n    self._set_cached(\"color\", color)\n    self._set_cached(\"label\", state.label)  # Already decoded to string\n    self._set_cached(\"power\", state.power &gt; 0)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_color\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"hue\": state.color.hue,\n                \"saturation\": state.color.saturation,\n                \"brightness\": state.color.brightness,\n                \"kelvin\": state.color.kelvin,\n                \"power\": state.power,\n                \"label\": state.label,\n            },\n        }\n    )\n\n    return color\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_color","title":"set_color  <code>async</code>","text":"<pre><code>set_color(color: HSBK, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light color.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to red instantly\nawait light.set_color(HSBK.from_rgb(255, 0, 0))\n\n# Fade to blue over 2 seconds\nawait light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_color(\n    self,\n    color: HSBK,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Set light color.\n\n    Args:\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to red instantly\n        await light.set_color(HSBK.from_rgb(255, 0, 0))\n\n        # Fade to blue over 2 seconds\n        await light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)\n        ```\n    \"\"\"\n    # Convert to protocol HSBK\n    protocol_color = color.to_protocol()\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Light.SetColor(\n            color=protocol_color,\n            duration=duration_ms,\n        ),\n    )\n\n    # Update cache\n    self._set_cached(\"color\", color)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_color\",\n            \"action\": \"change\",\n            \"values\": {\n                \"hue\": protocol_color.hue,\n                \"saturation\": protocol_color.saturation,\n                \"brightness\": protocol_color.brightness,\n                \"kelvin\": protocol_color.kelvin,\n                \"duration\": duration_ms,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_brightness","title":"set_brightness  <code>async</code>","text":"<pre><code>set_brightness(brightness: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light brightness only, preserving hue, saturation, and temperature.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>Brightness level (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If brightness is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to 50% brightness\nawait light.set_brightness(0.5)\n\n# Fade to full brightness over 1 second\nawait light.set_brightness(1.0, duration=1.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_brightness(self, brightness: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light brightness only, preserving hue, saturation, and temperature.\n\n    Args:\n        brightness: Brightness level (0.0-1.0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If brightness is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to 50% brightness\n        await light.set_brightness(0.5)\n\n        # Fade to full brightness over 1 second\n        await light.set_brightness(1.0, duration=1.0)\n        ```\n    \"\"\"\n    if not (0.0 &lt;= brightness &lt;= 1.0):\n        raise ValueError(\n            f\"Brightness must be between 0.0 and 1.0, got {brightness}\"\n        )\n\n    # Get current color\n    current_color = await self.get_color(use_cache=True)\n\n    # Create new color with modified brightness\n    new_color = current_color.with_brightness(brightness)\n\n    # Set the new color\n    await self.set_color(new_color, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_kelvin","title":"set_kelvin  <code>async</code>","text":"<pre><code>set_kelvin(kelvin: int, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light color temperature, preserving brightness. Saturation is    automatically set to 0 to switch the light to color temperature mode.</p> PARAMETER DESCRIPTION <code>kelvin</code> <p>Color temperature in Kelvin (1500-9000)</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If kelvin is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to warm white\nawait light.set_kelvin(2500)\n\n# Fade to cool white over 2 seconds\nawait light.set_kelvin(6500, duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_kelvin(self, kelvin: int, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light color temperature, preserving brightness. Saturation is\n       automatically set to 0 to switch the light to color temperature mode.\n\n    Args:\n        kelvin: Color temperature in Kelvin (1500-9000)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If kelvin is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to warm white\n        await light.set_kelvin(2500)\n\n        # Fade to cool white over 2 seconds\n        await light.set_kelvin(6500, duration=2.0)\n        ```\n    \"\"\"\n    if not (HSBK.MIN_KELVIN &lt;= kelvin &lt;= HSBK.MAX_KELVIN):\n        raise ValueError(f\"Kelvin must be 1500-9000, got {kelvin}\")\n\n    # Get current color\n    current_color = await self.get_color(use_cache=True)\n\n    # Create new color with modified temperature and no saturation\n    new_color = current_color.with_kelvin(kelvin).with_saturation(0)\n\n    # Set the new color\n    await self.set_color(new_color, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_hue","title":"set_hue  <code>async</code>","text":"<pre><code>set_hue(hue: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light hue only, preserving saturation, brightness, and temperature.</p> PARAMETER DESCRIPTION <code>hue</code> <p>Hue in degrees (0-360)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If hue is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to red (0 degrees)\nawait light.set_hue(0)\n\n# Cycle through rainbow\nfor hue in range(0, 360, 10):\n    await light.set_hue(hue, duration=0.5)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_hue(self, hue: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light hue only, preserving saturation, brightness, and temperature.\n\n    Args:\n        hue: Hue in degrees (0-360)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If hue is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to red (0 degrees)\n        await light.set_hue(0)\n\n        # Cycle through rainbow\n        for hue in range(0, 360, 10):\n            await light.set_hue(hue, duration=0.5)\n        ```\n    \"\"\"\n    if not (HSBK.MIN_HUE &lt;= hue &lt;= HSBK.MAX_HUE):\n        raise ValueError(\n            f\"Hue must be between {HSBK.MIN_HUE} and {HSBK.MAX_HUE}, got {hue}\"\n        )\n\n    # Get current color\n    current_color = await self.get_color(use_cache=True)\n\n    # Create new color with modified hue\n    new_color = current_color.with_hue(hue)\n\n    # Set the new color\n    await self.set_color(new_color, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_saturation","title":"set_saturation  <code>async</code>","text":"<pre><code>set_saturation(saturation: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light saturation only, preserving hue, brightness, and temperature.</p> PARAMETER DESCRIPTION <code>saturation</code> <p>Saturation level (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If saturation is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to fully saturated\nawait light.set_saturation(1.0)\n\n# Fade to white (no saturation) over 2 seconds\nawait light.set_saturation(0.0, duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_saturation(self, saturation: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light saturation only, preserving hue, brightness, and temperature.\n\n    Args:\n        saturation: Saturation level (0.0-1.0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If saturation is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to fully saturated\n        await light.set_saturation(1.0)\n\n        # Fade to white (no saturation) over 2 seconds\n        await light.set_saturation(0.0, duration=2.0)\n        ```\n    \"\"\"\n    if not (HSBK.MIN_SATURATION &lt;= saturation &lt;= HSBK.MAX_SATURATION):\n        raise ValueError(f\"Saturation must be 0.0-1.0, got {saturation}\")\n\n    # Get current color\n    current_color = await self.get_color(use_cache=True)\n\n    # Create new color with modified saturation\n    new_color = current_color.with_saturation(saturation)\n\n    # Set the new color\n    await self.set_color(new_color, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.get_power","title":"get_power  <code>async</code>","text":"<pre><code>get_power(use_cache: bool = True) -&gt; bool\n</code></pre> <p>Get light power state (specific to light, not device).</p> <p>This overrides Device.get_power() as it queries the light-specific power state (packet type 116/118) instead of device power (packet type 20/22).</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if light is powered on, False otherwise</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>is_on = await light.get_power()\nprint(f\"Light power: {'ON' if is_on else 'OFF'}\")\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def get_power(self, use_cache: bool = True) -&gt; bool:\n    \"\"\"Get light power state (specific to light, not device).\n\n    This overrides Device.get_power() as it queries the light-specific\n    power state (packet type 116/118) instead of device power (packet type 20/22).\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        True if light is powered on, False otherwise\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        is_on = await light.get_power()\n        print(f\"Light power: {'ON' if is_on else 'OFF'}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"power\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Light.GetPower())\n\n    # Power level is uint16 (0 or 65535)\n    is_on = state.level &gt; 0\n\n    self._set_cached(\"power\", is_on)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_power\",\n            \"action\": \"query\",\n            \"reply\": {\"level\": state.level},\n        }\n    )\n\n    return is_on\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(on: bool, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light power state (specific to light, not device).</p> <p>This overrides Device.set_power() as it uses the light-specific power packet (type 117) which supports transition duration.</p> PARAMETER DESCRIPTION <code>on</code> <p>True to turn on, False to turn off</p> <p> TYPE: <code>bool</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Turn on instantly\nawait light.set_power(True)\n\n# Fade off over 3 seconds\nawait light.set_power(False, duration=3.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_power(self, on: bool, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light power state (specific to light, not device).\n\n    This overrides Device.set_power() as it uses the light-specific\n    power packet (type 117) which supports transition duration.\n\n    Args:\n        on: True to turn on, False to turn off\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Turn on instantly\n        await light.set_power(True)\n\n        # Fade off over 3 seconds\n        await light.set_power(False, duration=3.0)\n        ```\n    \"\"\"\n    # Power level: 0 for off, 65535 for on\n    level = 65535 if on else 0\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Light.SetPower(level=level, duration=duration_ms),\n    )\n\n    # Update cache\n    self._set_cached(\"power\", on)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_power\",\n            \"action\": \"change\",\n            \"values\": {\"level\": level, \"duration\": duration_ms},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_waveform","title":"set_waveform  <code>async</code>","text":"<pre><code>set_waveform(\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n) -&gt; None\n</code></pre> <p>Apply a waveform effect to the light.</p> <p>Waveforms create repeating color transitions. Useful for effects like pulsing, breathing, or blinking.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color for the waveform</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one cycle in seconds</p> <p> TYPE: <code>float</code> </p> <code>cycles</code> <p>Number of cycles</p> <p> TYPE: <code>float</code> </p> <code>waveform</code> <p>Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)</p> <p> TYPE: <code>LightWaveform</code> </p> <code>transient</code> <p>If True, return to original color after effect (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>skew_ratio</code> <p>Waveform skew (0.0-1.0, default 0.5 for symmetric)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If parameters are out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code>from lifx.protocol.protocol_types import LightWaveform\n\n# Pulse red 5 times\nawait light.set_waveform(\n    color=HSBK.from_rgb(255, 0, 0),\n    period=1.0,\n    cycles=5,\n    waveform=LightWaveform.SINE,\n)\n\n# Breathe white once\nawait light.set_waveform(\n    color=HSBK(0, 0, 1.0, 3500),\n    period=2.0,\n    cycles=1,\n    waveform=LightWaveform.SINE,\n    transient=False,\n)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_waveform(\n    self,\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n) -&gt; None:\n    \"\"\"Apply a waveform effect to the light.\n\n    Waveforms create repeating color transitions. Useful for effects like\n    pulsing, breathing, or blinking.\n\n    Args:\n        color: Target color for the waveform\n        period: Period of one cycle in seconds\n        cycles: Number of cycles\n        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)\n        transient: If True, return to original color after effect (default True)\n        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)\n\n    Raises:\n        ValueError: If parameters are out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        from lifx.protocol.protocol_types import LightWaveform\n\n        # Pulse red 5 times\n        await light.set_waveform(\n            color=HSBK.from_rgb(255, 0, 0),\n            period=1.0,\n            cycles=5,\n            waveform=LightWaveform.SINE,\n        )\n\n        # Breathe white once\n        await light.set_waveform(\n            color=HSBK(0, 0, 1.0, 3500),\n            period=2.0,\n            cycles=1,\n            waveform=LightWaveform.SINE,\n            transient=False,\n        )\n        ```\n    \"\"\"\n    if period &lt;= 0:\n        raise ValueError(f\"Period must be positive, got {period}\")\n    if cycles &lt; 1:\n        raise ValueError(f\"Cycles must be 1 or higher, got {cycles}\")\n    if not (0.0 &lt;= skew_ratio &lt;= 1.0):\n        raise ValueError(\n            f\"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}\"\n        )\n\n    # Convert to protocol values\n    protocol_color = color.to_protocol()\n    period_ms = int(period * 1000)\n    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range\n\n    # Send request\n    await self.connection.request(\n        packets.Light.SetWaveform(\n            transient=bool(transient),\n            color=protocol_color,\n            period=period_ms,\n            cycles=cycles,\n            skew_ratio=skew_ratio_i16,\n            waveform=waveform,\n        ),\n    )\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_waveform\",\n            \"action\": \"change\",\n            \"values\": {\n                \"transient\": transient,\n                \"hue\": protocol_color.hue,\n                \"saturation\": protocol_color.saturation,\n                \"brightness\": protocol_color.brightness,\n                \"kelvin\": protocol_color.kelvin,\n                \"period\": period_ms,\n                \"cycles\": cycles,\n                \"skew_ratio\": skew_ratio_i16,\n                \"waveform\": waveform.value,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_waveform_optional","title":"set_waveform_optional  <code>async</code>","text":"<pre><code>set_waveform_optional(\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n    set_hue: bool = True,\n    set_saturation: bool = True,\n    set_brightness: bool = True,\n    set_kelvin: bool = True,\n) -&gt; None\n</code></pre> <p>Apply a waveform effect with selective color component control.</p> <p>Similar to set_waveform() but allows fine-grained control over which color components (hue, saturation, brightness, kelvin) are affected by the waveform. This enables effects like pulsing brightness while keeping hue constant, or cycling hue while maintaining brightness.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color for the waveform</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one cycle in seconds</p> <p> TYPE: <code>float</code> </p> <code>cycles</code> <p>Number of cycles</p> <p> TYPE: <code>float</code> </p> <code>waveform</code> <p>Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)</p> <p> TYPE: <code>LightWaveform</code> </p> <code>transient</code> <p>If True, return to original color after effect (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>skew_ratio</code> <p>Waveform skew (0.0-1.0, default 0.5 for symmetric)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>set_hue</code> <p>Apply waveform to hue component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>set_saturation</code> <p>Apply waveform to saturation component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>set_brightness</code> <p>Apply waveform to brightness component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>set_kelvin</code> <p>Apply waveform to kelvin component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If parameters are out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code>from lifx.protocol.protocol_types import LightWaveform\n\n# Pulse brightness only, keeping hue/saturation constant\nawait light.set_waveform_optional(\n    color=HSBK(0, 1.0, 1.0, 3500),\n    period=1.0,\n    cycles=5,\n    waveform=LightWaveform.SINE,\n    set_hue=False,\n    set_saturation=False,\n    set_brightness=True,\n    set_kelvin=False,\n)\n\n# Cycle hue while maintaining brightness\nawait light.set_waveform_optional(\n    color=HSBK(180, 1.0, 1.0, 3500),\n    period=5.0,\n    cycles=0,  # Infinite\n    waveform=LightWaveform.SAW,\n    set_hue=True,\n    set_saturation=False,\n    set_brightness=False,\n    set_kelvin=False,\n)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_waveform_optional(\n    self,\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n    set_hue: bool = True,\n    set_saturation: bool = True,\n    set_brightness: bool = True,\n    set_kelvin: bool = True,\n) -&gt; None:\n    \"\"\"Apply a waveform effect with selective color component control.\n\n    Similar to set_waveform() but allows fine-grained control over which\n    color components (hue, saturation, brightness, kelvin) are affected\n    by the waveform. This enables effects like pulsing brightness while\n    keeping hue constant, or cycling hue while maintaining brightness.\n\n    Args:\n        color: Target color for the waveform\n        period: Period of one cycle in seconds\n        cycles: Number of cycles\n        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)\n        transient: If True, return to original color after effect (default True)\n        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)\n        set_hue: Apply waveform to hue component (default True)\n        set_saturation: Apply waveform to saturation component (default True)\n        set_brightness: Apply waveform to brightness component (default True)\n        set_kelvin: Apply waveform to kelvin component (default True)\n\n    Raises:\n        ValueError: If parameters are out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        from lifx.protocol.protocol_types import LightWaveform\n\n        # Pulse brightness only, keeping hue/saturation constant\n        await light.set_waveform_optional(\n            color=HSBK(0, 1.0, 1.0, 3500),\n            period=1.0,\n            cycles=5,\n            waveform=LightWaveform.SINE,\n            set_hue=False,\n            set_saturation=False,\n            set_brightness=True,\n            set_kelvin=False,\n        )\n\n        # Cycle hue while maintaining brightness\n        await light.set_waveform_optional(\n            color=HSBK(180, 1.0, 1.0, 3500),\n            period=5.0,\n            cycles=0,  # Infinite\n            waveform=LightWaveform.SAW,\n            set_hue=True,\n            set_saturation=False,\n            set_brightness=False,\n            set_kelvin=False,\n        )\n        ```\n    \"\"\"\n    if period &lt;= 0:\n        raise ValueError(f\"Period must be positive, got {period}\")\n    if cycles &lt; 0:\n        raise ValueError(f\"Cycles must be non-negative, got {cycles}\")\n    if not (0.0 &lt;= skew_ratio &lt;= 1.0):\n        raise ValueError(\n            f\"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}\"\n        )\n\n    # Convert to protocol values\n    protocol_color = color.to_protocol()\n    period_ms = int(period * 1000)\n    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range\n\n    # Send request\n    await self.connection.request(\n        packets.Light.SetWaveformOptional(\n            transient=bool(transient),\n            color=protocol_color,\n            period=period_ms,\n            cycles=cycles,\n            skew_ratio=skew_ratio_i16,\n            waveform=waveform,\n            set_hue=set_hue,\n            set_saturation=set_saturation,\n            set_brightness=set_brightness,\n            set_kelvin=set_kelvin,\n        ),\n    )\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_waveform_optional\",\n            \"action\": \"change\",\n            \"values\": {\n                \"transient\": transient,\n                \"hue\": protocol_color.hue,\n                \"saturation\": protocol_color.saturation,\n                \"brightness\": protocol_color.brightness,\n                \"kelvin\": protocol_color.kelvin,\n                \"period\": period_ms,\n                \"cycles\": cycles,\n                \"skew_ratio\": skew_ratio_i16,\n                \"waveform\": waveform.value,\n                \"set_hue\": set_hue,\n                \"set_saturation\": set_saturation,\n                \"set_brightness\": set_brightness,\n                \"set_kelvin\": set_kelvin,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.pulse","title":"pulse  <code>async</code>","text":"<pre><code>pulse(\n    color: HSBK, period: float = 1.0, cycles: float = 1, transient: bool = True\n) -&gt; None\n</code></pre> <p>Pulse the light to a specific color.</p> <p>Convenience method for creating a pulse effect using SINE waveform.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color to pulse to</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one pulse in seconds (default 1.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>cycles</code> <p>Number of pulses (default 1)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>transient</code> <p>If True, return to original color after effect (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <pre><code># Pulse red once\nawait light.pulse(HSBK.from_rgb(255, 0, 0))\n\n# Pulse blue 3 times, 2 seconds per pulse\nawait light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def pulse(\n    self,\n    color: HSBK,\n    period: float = 1.0,\n    cycles: float = 1,\n    transient: bool = True,\n) -&gt; None:\n    \"\"\"Pulse the light to a specific color.\n\n    Convenience method for creating a pulse effect using SINE waveform.\n\n    Args:\n        color: Target color to pulse to\n        period: Period of one pulse in seconds (default 1.0)\n        cycles: Number of pulses (default 1)\n        transient: If True, return to original color after effect (default True)\n\n    Example:\n        ```python\n        # Pulse red once\n        await light.pulse(HSBK.from_rgb(255, 0, 0))\n\n        # Pulse blue 3 times, 2 seconds per pulse\n        await light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)\n        ```\n    \"\"\"\n    await self.set_waveform(\n        color=color,\n        period=period,\n        cycles=cycles,\n        waveform=LightWaveform.PULSE,\n        transient=transient,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.breathe","title":"breathe  <code>async</code>","text":"<pre><code>breathe(color: HSBK, period: float = 2.0, cycles: float = 1) -&gt; None\n</code></pre> <p>Make the light breathe to a specific color.</p> <p>Convenience method for creating a breathing effect using SINE waveform.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color to breathe to</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one breath in seconds (default 2.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>cycles</code> <p>Number of breaths (default 1)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> Example <pre><code># Breathe white once\nawait light.breathe(HSBK(0, 0, 1.0, 3500))\n\n# Breathe purple 10 times\nawait light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def breathe(\n    self,\n    color: HSBK,\n    period: float = 2.0,\n    cycles: float = 1,\n) -&gt; None:\n    \"\"\"Make the light breathe to a specific color.\n\n    Convenience method for creating a breathing effect using SINE waveform.\n\n    Args:\n        color: Target color to breathe to\n        period: Period of one breath in seconds (default 2.0)\n        cycles: Number of breaths (default 1)\n\n    Example:\n        ```python\n        # Breathe white once\n        await light.breathe(HSBK(0, 0, 1.0, 3500))\n\n        # Breathe purple 10 times\n        await light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)\n        ```\n    \"\"\"\n    await self.set_waveform(\n        color=color,\n        period=period,\n        cycles=cycles,\n        waveform=LightWaveform.SINE,\n        transient=True,\n    )\n</code></pre>"},{"location":"api/devices/#hev-light","title":"HEV Light","text":"<p>The <code>HevLight</code> class extends <code>Light</code> with anti-bacterial cleaning cycle control for LIFX HEV devices.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight","title":"HevLight","text":"<pre><code>HevLight(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX HEV light with anti-bacterial cleaning capabilities.</p> <p>Extends the Light class with HEV (High Energy Visible) cycle control. HEV uses UV-C light to sanitize surfaces and air with anti-bacterial properties.</p> Example <pre><code>light = HevLight(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Start a 2-hour cleaning cycle\n    await light.set_hev_cycle(enable=True, duration_seconds=7200)\n\n    # Check cycle status\n    state = await light.get_hev_cycle()\n    if state.is_running:\n        print(f\"Cleaning: {state.remaining_s}s remaining\")\n\n    # Configure defaults\n    await light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await HevLight.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_hev_cycle(enable=True, duration_seconds=3600)\n</code></pre></p> METHOD DESCRIPTION <code>get_hev_cycle</code> <p>Get current HEV cycle state.</p> <code>set_hev_cycle</code> <p>Start or stop a HEV cleaning cycle.</p> <code>get_hev_config</code> <p>Get HEV cycle configuration.</p> <code>set_hev_config</code> <p>Configure HEV cycle defaults.</p> <code>get_last_hev_result</code> <p>Get result of the last HEV cleaning cycle.</p> ATTRIBUTE DESCRIPTION <code>hev_cycle</code> <p>Get cached HEV cycle state if available.</p> <p> TYPE: <code>HevCycleState | None</code> </p> <code>hev_config</code> <p>Get cached HEV configuration if available.</p> <p> TYPE: <code>HevConfig | None</code> </p> <code>hev_result</code> <p>Get cached last HEV cycle result if available.</p> <p> TYPE: <code>LightLastHevCycleResult | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        cache_ttl: Cache time-to-live in seconds (default 5.0, min 0.1, max 300)\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Check multicast bit (first byte, LSB should be 0 for unicast)\n    if serial_bytes[0] &amp; 0x01:\n        raise ValueError(\"Multicast serial number not allowed\")\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        raise ValueError(\"Localhost IP address not allowed\")\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\"Unspecified IP address (0.0.0.0) not allowed\")\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")\n\n    # Validate port\n    if not (1 &lt;= port &lt;= 65535):\n        raise ValueError(f\"Port must be between 1 and 65535, got {port}\")\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Validate cache TTL\n    if cache_ttl is None:\n        cache_ttl = self.DEFAULT_CACHE_TTL\n\n    if not (self.MIN_CACHE_TTL &lt;= cache_ttl &lt;= self.MAX_CACHE_TTL):\n        raise ValueError(\n            f\"cache_ttl must be between {self.MIN_CACHE_TTL} \"\n            f\"and {self.MAX_CACHE_TTL}, got {cache_ttl}\"\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self.cache_ttl = cache_ttl\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State cache: key -&gt; (value, timestamp, ttl)\n    self._cache: dict[str, tuple[Any, float, float]] = {}\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.hev.HevLight.hev_cycle","title":"hev_cycle  <code>property</code>","text":"<pre><code>hev_cycle: HevCycleState | None\n</code></pre> <p>Get cached HEV cycle state if available.</p> RETURNS DESCRIPTION <code>HevCycleState | None</code> <p>Cached cycle state (use get_hev_cycle() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight.hev_config","title":"hev_config  <code>property</code>","text":"<pre><code>hev_config: HevConfig | None\n</code></pre> <p>Get cached HEV configuration if available.</p> RETURNS DESCRIPTION <code>HevConfig | None</code> <p>Cached config (use get_hev_config() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight.hev_result","title":"hev_result  <code>property</code>","text":"<pre><code>hev_result: LightLastHevCycleResult | None\n</code></pre> <p>Get cached last HEV cycle result if available.</p> RETURNS DESCRIPTION <code>LightLastHevCycleResult | None</code> <p>Cached result (use get_last_hev_result() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.hev.HevLight.get_hev_cycle","title":"get_hev_cycle  <code>async</code>","text":"<pre><code>get_hev_cycle(use_cache: bool = True) -&gt; HevCycleState\n</code></pre> <p>Get current HEV cycle state.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>HevCycleState</code> <p>HevCycleState with duration, remaining time, and last power state</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>state = await light.get_hev_cycle()\nif state.is_running:\n    print(f\"HEV cleaning in progress: {state.remaining_s}s left\")\nelse:\n    print(\"No active cleaning cycle\")\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def get_hev_cycle(self, use_cache: bool = True) -&gt; HevCycleState:\n    \"\"\"Get current HEV cycle state.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        HevCycleState with duration, remaining time, and last power state\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        state = await light.get_hev_cycle()\n        if state.is_running:\n            print(f\"HEV cleaning in progress: {state.remaining_s}s left\")\n        else:\n            print(\"No active cleaning cycle\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"hev_cycle\")\n        if cached is not None:\n            return cached\n\n    # Request HEV cycle state\n    state = await self.connection.request(packets.Light.GetHevCycle())\n\n    # Create state object\n    cycle_state = HevCycleState(\n        duration_s=state.duration_s,\n        remaining_s=state.remaining_s,\n        last_power=state.last_power,\n    )\n\n    # Cache the result\n    self._set_cached(\"hev_cycle\", cycle_state)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_hev_cycle\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"duration_s\": state.duration_s,\n                \"remaining_s\": state.remaining_s,\n                \"last_power\": state.last_power,\n            },\n        }\n    )\n\n    return cycle_state\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.set_hev_cycle","title":"set_hev_cycle  <code>async</code>","text":"<pre><code>set_hev_cycle(enable: bool, duration_seconds: int) -&gt; None\n</code></pre> <p>Start or stop a HEV cleaning cycle.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to start cycle, False to stop</p> <p> TYPE: <code>bool</code> </p> <code>duration_seconds</code> <p>Duration of the cleaning cycle in seconds</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If duration is negative</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Start a 1-hour cleaning cycle\nawait light.set_hev_cycle(enable=True, duration_seconds=3600)\n\n# Stop the current cycle\nawait light.set_hev_cycle(enable=False, duration_seconds=0)\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def set_hev_cycle(self, enable: bool, duration_seconds: int) -&gt; None:\n    \"\"\"Start or stop a HEV cleaning cycle.\n\n    Args:\n        enable: True to start cycle, False to stop\n        duration_seconds: Duration of the cleaning cycle in seconds\n\n    Raises:\n        ValueError: If duration is negative\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Start a 1-hour cleaning cycle\n        await light.set_hev_cycle(enable=True, duration_seconds=3600)\n\n        # Stop the current cycle\n        await light.set_hev_cycle(enable=False, duration_seconds=0)\n        ```\n    \"\"\"\n    if duration_seconds &lt; 0:\n        raise ValueError(f\"Duration must be non-negative, got {duration_seconds}\")\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Light.SetHevCycle(\n            enable=enable,\n            duration_s=duration_seconds,\n        ),\n    )\n\n    # Invalidate cache since state changed\n    self._invalidate_cache(\"hev_cycle\")\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_hev_cycle\",\n            \"action\": \"change\",\n            \"values\": {\"enable\": enable, \"duration_s\": duration_seconds},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.get_hev_config","title":"get_hev_config  <code>async</code>","text":"<pre><code>get_hev_config(use_cache: bool = True) -&gt; HevConfig\n</code></pre> <p>Get HEV cycle configuration.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>HevConfig</code> <p>HevConfig with indication and default duration settings</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>config = await light.get_hev_config()\nprint(f\"Default duration: {config.duration_s}s\")\nprint(f\"Visual indication: {config.indication}\")\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def get_hev_config(self, use_cache: bool = True) -&gt; HevConfig:\n    \"\"\"Get HEV cycle configuration.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        HevConfig with indication and default duration settings\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        config = await light.get_hev_config()\n        print(f\"Default duration: {config.duration_s}s\")\n        print(f\"Visual indication: {config.indication}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"hev_config\")\n        if cached is not None:\n            return cached\n\n    # Request HEV configuration\n    state = await self.connection.request(packets.Light.GetHevCycleConfiguration())\n\n    # Create config object\n    config = HevConfig(\n        indication=state.indication,\n        duration_s=state.duration_s,\n    )\n\n    # Cache the result\n    self._set_cached(\"hev_config\", config)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_hev_config\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"indication\": state.indication,\n                \"duration_s\": state.duration_s,\n            },\n        }\n    )\n\n    return config\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.set_hev_config","title":"set_hev_config  <code>async</code>","text":"<pre><code>set_hev_config(indication: bool, duration_seconds: int) -&gt; None\n</code></pre> <p>Configure HEV cycle defaults.</p> PARAMETER DESCRIPTION <code>indication</code> <p>Whether to show visual indication during cleaning</p> <p> TYPE: <code>bool</code> </p> <code>duration_seconds</code> <p>Default duration for cleaning cycles in seconds</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If duration is negative</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Configure 2-hour default with visual indication\nawait light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def set_hev_config(self, indication: bool, duration_seconds: int) -&gt; None:\n    \"\"\"Configure HEV cycle defaults.\n\n    Args:\n        indication: Whether to show visual indication during cleaning\n        duration_seconds: Default duration for cleaning cycles in seconds\n\n    Raises:\n        ValueError: If duration is negative\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Configure 2-hour default with visual indication\n        await light.set_hev_config(indication=True, duration_seconds=7200)\n        ```\n    \"\"\"\n    if duration_seconds &lt; 0:\n        raise ValueError(f\"Duration must be non-negative, got {duration_seconds}\")\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Light.SetHevCycleConfiguration(\n            indication=indication,\n            duration_s=duration_seconds,\n        ),\n    )\n\n    # Update cache\n    self._set_cached(\n        \"hev_config\", HevConfig(indication=indication, duration_s=duration_seconds)\n    )\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_hev_config\",\n            \"action\": \"change\",\n            \"values\": {\"indication\": indication, \"duration_s\": duration_seconds},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.get_last_hev_result","title":"get_last_hev_result  <code>async</code>","text":"<pre><code>get_last_hev_result(use_cache: bool = True) -&gt; LightLastHevCycleResult\n</code></pre> <p>Get result of the last HEV cleaning cycle.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>LightLastHevCycleResult</code> <p>LightLastHevCycleResult enum value indicating success or interruption reason</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>result = await light.get_last_hev_result()\nif result == LightLastHevCycleResult.SUCCESS:\n    print(\"Last cleaning cycle completed successfully\")\nelif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:\n    print(\"Cycle was interrupted by network command\")\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def get_last_hev_result(\n    self, use_cache: bool = True\n) -&gt; LightLastHevCycleResult:\n    \"\"\"Get result of the last HEV cleaning cycle.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        LightLastHevCycleResult enum value indicating success or interruption reason\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        result = await light.get_last_hev_result()\n        if result == LightLastHevCycleResult.SUCCESS:\n            print(\"Last cleaning cycle completed successfully\")\n        elif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:\n            print(\"Cycle was interrupted by network command\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"hev_result\")\n        if cached is not None:\n            return cached\n\n    # Request last HEV result\n    state = await self.connection.request(packets.Light.GetLastHevCycleResult())\n\n    # Cache the result\n    self._set_cached(\"hev_result\", state.result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_last_hev_result\",\n            \"action\": \"query\",\n            \"reply\": {\"result\": state.result.value},\n        }\n    )\n\n    return state.result\n</code></pre>"},{"location":"api/devices/#infrared-light","title":"Infrared Light","text":"<p>The <code>InfraredLight</code> class extends <code>Light</code> with infrared LED control for night vision on LIFX A19 + Night Vision devices.</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight","title":"InfraredLight","text":"<pre><code>InfraredLight(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX infrared light with IR LED control.</p> <p>Extends the Light class with infrared brightness control. Infrared LEDs automatically activate in low-light conditions to provide illumination for night vision cameras.</p> Example <pre><code>light = InfraredLight(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Set infrared brightness to 50%\n    await light.set_infrared(0.5)\n\n    # Get current infrared brightness\n    brightness = await light.get_infrared()\n    print(f\"IR brightness: {brightness * 100}%\")\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await InfraredLight.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_infrared(0.8)\n</code></pre></p> METHOD DESCRIPTION <code>get_infrared</code> <p>Get current infrared brightness.</p> <code>set_infrared</code> <p>Set infrared brightness.</p> ATTRIBUTE DESCRIPTION <code>infrared</code> <p>Get cached infrared brightness if available.</p> <p> TYPE: <code>float | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        cache_ttl: Cache time-to-live in seconds (default 5.0, min 0.1, max 300)\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Check multicast bit (first byte, LSB should be 0 for unicast)\n    if serial_bytes[0] &amp; 0x01:\n        raise ValueError(\"Multicast serial number not allowed\")\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        raise ValueError(\"Localhost IP address not allowed\")\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\"Unspecified IP address (0.0.0.0) not allowed\")\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")\n\n    # Validate port\n    if not (1 &lt;= port &lt;= 65535):\n        raise ValueError(f\"Port must be between 1 and 65535, got {port}\")\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Validate cache TTL\n    if cache_ttl is None:\n        cache_ttl = self.DEFAULT_CACHE_TTL\n\n    if not (self.MIN_CACHE_TTL &lt;= cache_ttl &lt;= self.MAX_CACHE_TTL):\n        raise ValueError(\n            f\"cache_ttl must be between {self.MIN_CACHE_TTL} \"\n            f\"and {self.MAX_CACHE_TTL}, got {cache_ttl}\"\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self.cache_ttl = cache_ttl\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State cache: key -&gt; (value, timestamp, ttl)\n    self._cache: dict[str, tuple[Any, float, float]] = {}\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.infrared","title":"infrared  <code>property</code>","text":"<pre><code>infrared: float | None\n</code></pre> <p>Get cached infrared brightness if available.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Cached brightness (use get_infrared() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.get_infrared","title":"get_infrared  <code>async</code>","text":"<pre><code>get_infrared(use_cache: bool = True) -&gt; float\n</code></pre> <p>Get current infrared brightness.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Infrared brightness (0.0-1.0)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>brightness = await light.get_infrared()\nif brightness &gt; 0:\n    print(f\"IR LEDs active at {brightness * 100}%\")\n</code></pre> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>async def get_infrared(self, use_cache: bool = True) -&gt; float:\n    \"\"\"Get current infrared brightness.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        Infrared brightness (0.0-1.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        brightness = await light.get_infrared()\n        if brightness &gt; 0:\n            print(f\"IR LEDs active at {brightness * 100}%\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"infrared\")\n        if cached is not None:\n            return cached\n\n    # Request infrared state\n    state = await self.connection.request(packets.Light.GetInfrared())\n\n    # Convert from uint16 (0-65535) to float (0.0-1.0)\n    brightness = state.brightness / 65535.0\n\n    # Cache the result\n    self._set_cached(\"infrared\", brightness)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_infrared\",\n            \"action\": \"query\",\n            \"reply\": {\"brightness\": state.brightness},\n        }\n    )\n\n    return brightness\n</code></pre>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.set_infrared","title":"set_infrared  <code>async</code>","text":"<pre><code>set_infrared(brightness: float) -&gt; None\n</code></pre> <p>Set infrared brightness.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>Infrared brightness (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If brightness is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to 75% infrared brightness\nawait light.set_infrared(0.75)\n\n# Turn off infrared\nawait light.set_infrared(0.0)\n</code></pre> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>async def set_infrared(self, brightness: float) -&gt; None:\n    \"\"\"Set infrared brightness.\n\n    Args:\n        brightness: Infrared brightness (0.0-1.0)\n\n    Raises:\n        ValueError: If brightness is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to 75% infrared brightness\n        await light.set_infrared(0.75)\n\n        # Turn off infrared\n        await light.set_infrared(0.0)\n        ```\n    \"\"\"\n    if not (0.0 &lt;= brightness &lt;= 1.0):\n        raise ValueError(\n            f\"Brightness must be between 0.0 and 1.0, got {brightness}\"\n        )\n\n    # Convert from float (0.0-1.0) to uint16 (0-65535)\n    brightness_u16 = max(0, min(65535, int(round(brightness * 65535))))\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Light.SetInfrared(brightness=brightness_u16),\n    )\n\n    # Update cache\n    self._set_cached(\"infrared\", brightness)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_infrared\",\n            \"action\": \"change\",\n            \"values\": {\"brightness\": brightness_u16},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#multizone-light","title":"MultiZone Light","text":"<p>The <code>MultiZoneLight</code> class controls LIFX strips and beams with multiple color zones.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight","title":"MultiZoneLight","text":"<pre><code>MultiZoneLight(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX MultiZone light device (strips, beams).</p> <p>Extends the Light class with zone-specific functionality: - Individual zone color control - Multi-zone effects (move, etc.) - Extended color zone support for efficient bulk updates</p> Example <pre><code>light = MultiZoneLight(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Get number of zones\n    zone_count = await light.get_zone_count()\n    print(f\"Device has {zone_count} zones\")\n\n    # Set all zones to red\n    await light.set_color_zones(\n        start=0, end=zone_count - 1, color=HSBK.from_rgb(255, 0, 0)\n    )\n\n    # Get colors for first 5 zones\n    colors = await light.get_color_zones(0, 4)\n\n    # Apply a moving effect\n    await light.set_move_effect(speed=5.0, direction=\"forward\")\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await MultiZoneLight.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_move_effect(speed=5.0, direction=\"forward\")\n</code></pre></p> METHOD DESCRIPTION <code>get_zone_count</code> <p>Get the number of zones in the device.</p> <code>get_color_zones</code> <p>Get colors for a range of zones using GetColorZones.</p> <code>get_extended_color_zones</code> <p>Get colors for a range of zones using GetExtendedColorZones.</p> <code>set_color_zones</code> <p>Set color for a range of zones.</p> <code>set_extended_color_zones</code> <p>Set colors for multiple zones efficiently (up to 82 zones per call).</p> <code>get_multizone_effect</code> <p>Get current multizone effect.</p> <code>set_multizone_effect</code> <p>Set multizone effect.</p> <code>stop_effect</code> <p>Stop any running multizone effect.</p> <code>set_move_effect</code> <p>Apply a moving effect that shifts colors along the strip.</p> ATTRIBUTE DESCRIPTION <code>zone_count</code> <p>Get cached zone count if available.</p> <p> TYPE: <code>int | None</code> </p> <code>multizone_effect</code> <p>Get cached multizone effect if available.</p> <p> TYPE: <code>MultiZoneEffect | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        cache_ttl: Cache time-to-live in seconds (default 5.0, min 0.1, max 300)\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Check multicast bit (first byte, LSB should be 0 for unicast)\n    if serial_bytes[0] &amp; 0x01:\n        raise ValueError(\"Multicast serial number not allowed\")\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        raise ValueError(\"Localhost IP address not allowed\")\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\"Unspecified IP address (0.0.0.0) not allowed\")\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")\n\n    # Validate port\n    if not (1 &lt;= port &lt;= 65535):\n        raise ValueError(f\"Port must be between 1 and 65535, got {port}\")\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Validate cache TTL\n    if cache_ttl is None:\n        cache_ttl = self.DEFAULT_CACHE_TTL\n\n    if not (self.MIN_CACHE_TTL &lt;= cache_ttl &lt;= self.MAX_CACHE_TTL):\n        raise ValueError(\n            f\"cache_ttl must be between {self.MIN_CACHE_TTL} \"\n            f\"and {self.MAX_CACHE_TTL}, got {cache_ttl}\"\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self.cache_ttl = cache_ttl\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State cache: key -&gt; (value, timestamp, ttl)\n    self._cache: dict[str, tuple[Any, float, float]] = {}\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.zone_count","title":"zone_count  <code>property</code>","text":"<pre><code>zone_count: int | None\n</code></pre> <p>Get cached zone count if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Cached zone count (use get_zone_count() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.multizone_effect","title":"multizone_effect  <code>property</code>","text":"<pre><code>multizone_effect: MultiZoneEffect | None\n</code></pre> <p>Get cached multizone effect if available.</p> RETURNS DESCRIPTION <code>MultiZoneEffect | None</code> <p>Cached multizone effect (use get_multizone_effect() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_zone_count","title":"get_zone_count  <code>async</code>","text":"<pre><code>get_zone_count(use_cache: bool = True) -&gt; int\n</code></pre> <p>Get the number of zones in the device.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of zones</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>zone_count = await light.get_zone_count()\nprint(f\"Device has {zone_count} zones\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_zone_count(self, use_cache: bool = True) -&gt; int:\n    \"\"\"Get the number of zones in the device.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        Number of zones\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        zone_count = await light.get_zone_count()\n        print(f\"Device has {zone_count} zones\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"zone_count\")\n        if cached is not None:\n            return cached  # Query zone 0 to get count\n    # Request automatically unpacks response\n    if self.capabilities and self.capabilities.has_extended_multizone:\n        state = await self.connection.request(\n            packets.MultiZone.GetExtendedColorZones()\n        )\n    else:\n        state = await self.connection.request(\n            packets.MultiZone.GetColorZones(start_index=0, end_index=0)\n        )\n\n    count = state.count\n\n    self._set_cached(\"zone_count\", count)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_zone_count\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"count\": state.count,\n            },\n        }\n    )\n\n    return count\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_color_zones","title":"get_color_zones  <code>async</code>","text":"<pre><code>get_color_zones(start: int, end: int, use_cache: bool = False) -&gt; list[HSBK]\n</code></pre> <p>Get colors for a range of zones using GetColorZones.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>end</code> <p>End zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>use_cache</code> <p>Use cached value if available (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors, one per zone</p> RAISES DESCRIPTION <code>ValueError</code> <p>If zone indices are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code># Get colors for first 10 zones\ncolors = await light.get_color_zones(0, 9)\nfor i, color in enumerate(colors):\n    print(f\"Zone {i}: {color}\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_color_zones(\n    self,\n    start: int,\n    end: int,\n    use_cache: bool = False,\n) -&gt; list[HSBK]:\n    \"\"\"Get colors for a range of zones using GetColorZones.\n\n    Args:\n        start: Start zone index (inclusive)\n        end: End zone index (inclusive)\n        use_cache: Use cached value if available (default False)\n\n    Returns:\n        List of HSBK colors, one per zone\n\n    Raises:\n        ValueError: If zone indices are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        # Get colors for first 10 zones\n        colors = await light.get_color_zones(0, 9)\n        for i, color in enumerate(colors):\n            print(f\"Zone {i}: {color}\")\n        ```\n    \"\"\"\n    if start &lt; 0 or end &lt; start:\n        raise ValueError(f\"Invalid zone range: {start}-{end}\")\n\n    # Ensure capabilities are loaded\n    if self.capabilities is None:\n        await self._ensure_capabilities()\n\n    zone_count = await self.get_zone_count()\n    end = min(zone_count - 1, end)\n\n    cache_key = f\"zones_{start}_{end}\"\n    if use_cache:\n        cached = self._get_cached(cache_key)\n        if cached is not None:\n            return cached\n\n    colors = []\n    current_start = start\n\n    while current_start &lt;= end:\n        current_end = min(current_start + 7, end)  # Max 8 zones per request\n        state = await self.connection.request(\n            packets.MultiZone.GetColorZones(\n                start_index=current_start, end_index=current_end\n            )\n        )\n\n        # Extract colors from response (up to 8 colors)\n        zones_in_response = min(8, current_end - current_start + 1)\n        for i in range(zones_in_response):\n            if i &gt;= len(state.colors):\n                break\n            protocol_hsbk = state.colors[i]\n            colors.append(HSBK.from_protocol(protocol_hsbk))\n\n        current_start += 8\n\n    result = colors\n\n    self._set_cached(cache_key, result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_color_zones\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"start\": start,\n                \"end\": end,\n                \"zone_count\": len(result),\n                \"colors\": [\n                    {\n                        \"hue\": c.hue,\n                        \"saturation\": c.saturation,\n                        \"brightness\": c.brightness,\n                        \"kelvin\": c.kelvin,\n                    }\n                    for c in result\n                ],\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_extended_color_zones","title":"get_extended_color_zones  <code>async</code>","text":"<pre><code>get_extended_color_zones(\n    start: int, end: int, use_cache: bool = False\n) -&gt; list[HSBK]\n</code></pre> <p>Get colors for a range of zones using GetExtendedColorZones.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>end</code> <p>End zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>use_cache</code> <p>Use cached value if available (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors, one per zone</p> RAISES DESCRIPTION <code>ValueError</code> <p>If zone indices are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code># Get colors for first 10 zones\ncolors = await light.get_color_zones(0, 9)\nfor i, color in enumerate(colors):\n    print(f\"Zone {i}: {color}\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_extended_color_zones(\n    self, start: int, end: int, use_cache: bool = False\n) -&gt; list[HSBK]:\n    \"\"\"Get colors for a range of zones using GetExtendedColorZones.\n\n    Args:\n        start: Start zone index (inclusive)\n        end: End zone index (inclusive)\n        use_cache: Use cached value if available (default False)\n\n    Returns:\n        List of HSBK colors, one per zone\n\n    Raises:\n        ValueError: If zone indices are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        # Get colors for first 10 zones\n        colors = await light.get_color_zones(0, 9)\n        for i, color in enumerate(colors):\n            print(f\"Zone {i}: {color}\")\n        ```\n    \"\"\"\n    if start &lt; 0 or end &lt; start:\n        raise ValueError(f\"Invalid zone range: {start}-{end}\")\n\n    # Ensure capabilities are loaded\n    if self.capabilities is None:\n        await self._ensure_capabilities()\n\n    zone_count = await self.get_zone_count()\n    end = min(zone_count - 1, end)\n\n    cache_key = f\"zones_{start}_{end}\"\n    if use_cache:\n        cached = self._get_cached(cache_key)\n        if cached is not None:\n            return cached\n\n    if self.capabilities and not self.capabilities.has_extended_multizone:\n        return await self.get_color_zones(start=start, end=end, use_cache=use_cache)\n\n    colors = []\n\n    state = await self.connection.request(\n        packets.MultiZone.GetExtendedColorZones(),\n        collect_multiple=bool(zone_count &gt; 82),\n    )\n\n    # Handle both single packet and list of packets (when collect_multiple=True)\n    packets_list = state if isinstance(state, list) else [state]\n\n    for packet in packets_list:\n        # Only process valid colors based on colors_count\n        for i in range(packet.colors_count):\n            if i &gt;= len(packet.colors):\n                break\n            protocol_hsbk = packet.colors[i]\n            colors.append(HSBK.from_protocol(protocol_hsbk))\n\n    result = colors\n    self._set_cached(cache_key, result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_extended_color_zones\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"start\": start,\n                \"end\": end,\n                \"zone_count\": len(result),\n                \"colors\": [\n                    {\n                        \"hue\": c.hue,\n                        \"saturation\": c.saturation,\n                        \"brightness\": c.brightness,\n                        \"kelvin\": c.kelvin,\n                    }\n                    for c in result\n                ],\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_color_zones","title":"set_color_zones  <code>async</code>","text":"<pre><code>set_color_zones(\n    start: int,\n    end: int,\n    color: HSBK,\n    duration: float = 0.0,\n    apply: MultiZoneApplicationRequest = APPLY,\n) -&gt; None\n</code></pre> <p>Set color for a range of zones.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>end</code> <p>End zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>apply</code> <p>Application mode (default APPLY)    - NO_APPLY: Don't apply immediately (use for batching)    - APPLY: Apply this change and any pending changes    - APPLY_ONLY: Apply only this change</p> <p> TYPE: <code>MultiZoneApplicationRequest</code> DEFAULT: <code>APPLY</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If zone indices are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set zones 0-9 to red\nawait light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))\n\n# Set with transition\nawait light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)\n\n# Batch updates\nawait light.set_color_zones(\n    0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY\n)\nawait light.set_color_zones(\n    5, 9, color2, apply=MultiZoneApplicationRequest.APPLY\n)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_color_zones(\n    self,\n    start: int,\n    end: int,\n    color: HSBK,\n    duration: float = 0.0,\n    apply: MultiZoneApplicationRequest = MultiZoneApplicationRequest.APPLY,\n) -&gt; None:\n    \"\"\"Set color for a range of zones.\n\n    Args:\n        start: Start zone index (inclusive)\n        end: End zone index (inclusive)\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n        apply: Application mode (default APPLY)\n               - NO_APPLY: Don't apply immediately (use for batching)\n               - APPLY: Apply this change and any pending changes\n               - APPLY_ONLY: Apply only this change\n\n    Raises:\n        ValueError: If zone indices are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set zones 0-9 to red\n        await light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))\n\n        # Set with transition\n        await light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)\n\n        # Batch updates\n        await light.set_color_zones(\n            0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY\n        )\n        await light.set_color_zones(\n            5, 9, color2, apply=MultiZoneApplicationRequest.APPLY\n        )\n        ```\n    \"\"\"\n    if start &lt; 0 or end &lt; start:\n        raise ValueError(\n            f\"Invalid zone range: {start}-{end}\"\n        )  # Convert to protocol HSBK\n    protocol_color = color.to_protocol()\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Send request\n    await self.connection.request(\n        packets.MultiZone.SetColorZones(\n            start_index=start,\n            end_index=end,\n            color=protocol_color,\n            duration=duration_ms,\n            apply=apply,\n        ),\n    )\n\n    # Invalidate cache for affected zones\n    self._invalidate_cache(f\"zones_{start}_{end}\")\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_color_zones\",\n            \"action\": \"change\",\n            \"values\": {\n                \"start\": start,\n                \"end\": end,\n                \"color\": {\n                    \"hue\": color.hue,\n                    \"saturation\": color.saturation,\n                    \"brightness\": color.brightness,\n                    \"kelvin\": color.kelvin,\n                },\n                \"duration\": duration_ms,\n                \"apply\": apply.name,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_extended_color_zones","title":"set_extended_color_zones  <code>async</code>","text":"<pre><code>set_extended_color_zones(\n    zone_index: int,\n    colors: list[HSBK],\n    duration: float = 0.0,\n    apply: MultiZoneExtendedApplicationRequest = APPLY,\n) -&gt; None\n</code></pre> <p>Set colors for multiple zones efficiently (up to 82 zones per call).</p> <p>This is more efficient than set_color_zones when setting different colors for many zones at once.</p> PARAMETER DESCRIPTION <code>zone_index</code> <p>Starting zone index</p> <p> TYPE: <code>int</code> </p> <code>colors</code> <p>List of HSBK colors to set (max 82)</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>apply</code> <p>Application mode (default APPLY)</p> <p> TYPE: <code>MultiZoneExtendedApplicationRequest</code> DEFAULT: <code>APPLY</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If colors list is too long or zone index is invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Create a rainbow effect across zones\ncolors = [\n    HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)\n    for i in range(10)\n]\nawait light.set_extended_color_zones(0, colors)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_extended_color_zones(\n    self,\n    zone_index: int,\n    colors: list[HSBK],\n    duration: float = 0.0,\n    apply: ExtendedAppReq = ExtendedAppReq.APPLY,\n) -&gt; None:\n    \"\"\"Set colors for multiple zones efficiently (up to 82 zones per call).\n\n    This is more efficient than set_color_zones when setting different colors\n    for many zones at once.\n\n    Args:\n        zone_index: Starting zone index\n        colors: List of HSBK colors to set (max 82)\n        duration: Transition duration in seconds (default 0.0)\n        apply: Application mode (default APPLY)\n\n    Raises:\n        ValueError: If colors list is too long or zone index is invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Create a rainbow effect across zones\n        colors = [\n            HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)\n            for i in range(10)\n        ]\n        await light.set_extended_color_zones(0, colors)\n        ```\n    \"\"\"\n    if zone_index &lt; 0:\n        raise ValueError(f\"Invalid zone index: {zone_index}\")\n    if len(colors) &gt; 82:\n        raise ValueError(f\"Too many colors: {len(colors)} (max 82 per request)\")\n    if len(colors) == 0:\n        raise ValueError(\"Colors list cannot be empty\")  # Convert to protocol HSBK\n    protocol_colors = [color.to_protocol() for color in colors]\n\n    # Pad to 82 colors if needed\n    while len(protocol_colors) &lt; 82:\n        protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Send request\n    await self.connection.request(\n        packets.MultiZone.SetExtendedColorZones(\n            duration=duration_ms,\n            apply=apply,\n            index=zone_index,\n            colors_count=len(colors),\n            colors=protocol_colors,\n        ),\n    )\n\n    # Invalidate cache\n    end_index = zone_index + len(colors) - 1\n    self._invalidate_cache(f\"zones_{zone_index}_{end_index}\")\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_extended_color_zones\",\n            \"action\": \"change\",\n            \"values\": {\n                \"zone_index\": zone_index,\n                \"colors_count\": len(colors),\n                \"colors\": [\n                    {\n                        \"hue\": c.hue,\n                        \"saturation\": c.saturation,\n                        \"brightness\": c.brightness,\n                        \"kelvin\": c.kelvin,\n                    }\n                    for c in colors\n                ],\n                \"duration\": duration_ms,\n                \"apply\": apply.name,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_multizone_effect","title":"get_multizone_effect  <code>async</code>","text":"<pre><code>get_multizone_effect(use_cache: bool = True) -&gt; MultiZoneEffect | None\n</code></pre> <p>Get current multizone effect.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>MultiZoneEffect | None</code> <p>MultiZoneEffect if an effect is active, None if no effect</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>effect = await light.get_multizone_effect()\nif effect:\n    print(f\"Effect: {effect.effect_type}, Speed: {effect.speed}ms\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_multizone_effect(\n    self, use_cache: bool = True\n) -&gt; MultiZoneEffect | None:\n    \"\"\"Get current multizone effect.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        MultiZoneEffect if an effect is active, None if no effect\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        effect = await light.get_multizone_effect()\n        if effect:\n            print(f\"Effect: {effect.effect_type}, Speed: {effect.speed}ms\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"multizone_effect\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.MultiZone.GetEffect())\n\n    settings = state.settings\n    effect_type = settings.effect_type\n\n    # Extract parameters from the settings parameter field\n    parameters = [\n        settings.parameter.parameter0,\n        settings.parameter.parameter1,\n        settings.parameter.parameter2,\n        settings.parameter.parameter3,\n        settings.parameter.parameter4,\n        settings.parameter.parameter5,\n        settings.parameter.parameter6,\n        settings.parameter.parameter7,\n    ]\n\n    if effect_type == MultiZoneEffectType.OFF:\n        result = None\n    else:\n        result = MultiZoneEffect(\n            effect_type=effect_type,\n            speed=settings.speed,\n            duration=settings.duration,\n            parameters=parameters,\n        )\n\n    self._set_cached(\"multizone_effect\", result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_multizone_effect\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"effect_type\": effect_type.name,\n                \"speed\": settings.speed,\n                \"duration\": settings.duration,\n                \"parameters\": parameters,\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_multizone_effect","title":"set_multizone_effect  <code>async</code>","text":"<pre><code>set_multizone_effect(effect: MultiZoneEffect) -&gt; None\n</code></pre> <p>Set multizone effect.</p> PARAMETER DESCRIPTION <code>effect</code> <p>MultiZone effect configuration</p> <p> TYPE: <code>MultiZoneEffect</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Apply a move effect\neffect = MultiZoneEffect(\n    effect_type=MultiZoneEffectType.MOVE,\n    speed=5000,  # 5 seconds per cycle\n    duration=0,  # Infinite\n)\nawait light.set_multizone_effect(effect)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_multizone_effect(\n    self,\n    effect: MultiZoneEffect,\n) -&gt; None:\n    \"\"\"Set multizone effect.\n\n    Args:\n        effect: MultiZone effect configuration\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Apply a move effect\n        effect = MultiZoneEffect(\n            effect_type=MultiZoneEffectType.MOVE,\n            speed=5000,  # 5 seconds per cycle\n            duration=0,  # Infinite\n        )\n        await light.set_multizone_effect(effect)\n        ```\n    \"\"\"  # Ensure parameters list is 8 elements\n    parameters = effect.parameters or [0] * 8\n    if len(parameters) &lt; 8:\n        parameters.extend([0] * (8 - len(parameters)))\n    parameters = parameters[:8]\n\n    # Send request\n    await self.connection.request(\n        packets.MultiZone.SetEffect(\n            settings=MultiZoneEffectSettings(\n                instanceid=0,  # 0 for new effect\n                effect_type=effect.effect_type,\n                speed=effect.speed,\n                duration=effect.duration,\n                parameter=MultiZoneEffectParameter(\n                    parameter0=parameters[0],\n                    parameter1=parameters[1],\n                    parameter2=parameters[2],\n                    parameter3=parameters[3],\n                    parameter4=parameters[4],\n                    parameter5=parameters[5],\n                    parameter6=parameters[6],\n                    parameter7=parameters[7],\n                ),\n            ),\n        ),\n    )\n\n    # Update cache\n    self._set_cached(\n        \"multizone_effect\",\n        effect if effect.effect_type != MultiZoneEffectType.OFF else None,\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_multizone_effect\",\n            \"action\": \"change\",\n            \"values\": {\n                \"effect_type\": effect.effect_type.name,\n                \"speed\": effect.speed,\n                \"duration\": effect.duration,\n                \"parameters\": parameters,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.stop_effect","title":"stop_effect  <code>async</code>","text":"<pre><code>stop_effect() -&gt; None\n</code></pre> <p>Stop any running multizone effect.</p> Example <pre><code>await light.stop_effect()\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def stop_effect(self) -&gt; None:\n    \"\"\"Stop any running multizone effect.\n\n    Example:\n        ```python\n        await light.stop_effect()\n        ```\n    \"\"\"\n    await self.set_multizone_effect(\n        MultiZoneEffect(\n            effect_type=MultiZoneEffectType.OFF,\n            speed=0,\n            duration=0,\n        )\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"stop_effect\",\n            \"action\": \"change\",\n            \"values\": {},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_move_effect","title":"set_move_effect  <code>async</code>","text":"<pre><code>set_move_effect(\n    speed: float = 5.0, direction: str = \"forward\", duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Apply a moving effect that shifts colors along the strip.</p> PARAMETER DESCRIPTION <code>speed</code> <p>Speed in seconds per complete cycle (default 5.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>5.0</code> </p> <code>direction</code> <p>\"forward\" or \"backward\" (default \"forward\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'forward'</code> </p> <code>duration</code> <p>Total duration in seconds (0 for infinite, default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If direction is invalid or speed is non-positive</p> Example <pre><code># Move forward at moderate speed\nawait light.set_move_effect(speed=5.0, direction=\"forward\")\n\n# Move backward slowly for 60 seconds\nawait light.set_move_effect(speed=10.0, direction=\"backward\", duration=60.0)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_move_effect(\n    self,\n    speed: float = 5.0,\n    direction: str = \"forward\",\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Apply a moving effect that shifts colors along the strip.\n\n    Args:\n        speed: Speed in seconds per complete cycle (default 5.0)\n        direction: \"forward\" or \"backward\" (default \"forward\")\n        duration: Total duration in seconds (0 for infinite, default 0.0)\n\n    Raises:\n        ValueError: If direction is invalid or speed is non-positive\n\n    Example:\n        ```python\n        # Move forward at moderate speed\n        await light.set_move_effect(speed=5.0, direction=\"forward\")\n\n        # Move backward slowly for 60 seconds\n        await light.set_move_effect(speed=10.0, direction=\"backward\", duration=60.0)\n        ```\n    \"\"\"\n    if speed &lt;= 0:\n        raise ValueError(f\"Speed must be positive, got {speed}\")\n    if direction not in (\"forward\", \"backward\"):\n        raise ValueError(\n            f\"Direction must be 'forward' or 'backward', got {direction}\"\n        )\n\n    # Convert speed to milliseconds\n    speed_ms = int(speed * 1000)\n\n    # Convert duration to nanoseconds\n    duration_ns = int(duration * 1_000_000_000)\n\n    # Set parameter[0] to 1 for backward, 0 for forward\n    parameters = [1 if direction == \"backward\" else 0] + [0] * 7\n\n    await self.set_multizone_effect(\n        MultiZoneEffect(\n            effect_type=MultiZoneEffectType.MOVE,\n            speed=speed_ms,\n            duration=duration_ns,\n            parameters=parameters,\n        )\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_move_effect\",\n            \"action\": \"change\",\n            \"values\": {\n                \"speed\": speed,\n                \"direction\": direction,\n                \"duration\": duration,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#tile-device","title":"Tile Device","text":"<p>The <code>TileDevice</code> class controls LIFX tile grids with 2D zone control.</p>"},{"location":"api/devices/#lifx.devices.tile.TileDevice","title":"TileDevice","text":"<pre><code>TileDevice(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX Tile device with grid control.</p> <p>Extends the Light class with tile-specific functionality: - Tile chain discovery and information - Individual tile grid color control - Tile effects (morph, flame, sky)</p> Example <pre><code>tile = TileDevice(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with tile:\n    # Get tile chain information\n    chain = await tile.get_tile_chain()\n    print(f\"Device has {len(chain)} tiles\")\n\n    # Get colors from first tile\n    colors = await tile.get_tile_colors(tile_index=0)\n\n    # Set entire first tile to red\n    red = HSBK.from_rgb(255, 0, 0)\n    await tile.set_tile_colors(\n        tile_index=0, colors=[[red] * 8 for _ in range(8)]\n    )\n\n    # Apply a flame effect\n    await tile.set_flame_effect(speed=5.0)\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await TileDevice.from_ip(ip=\"192.168.1.100\") as light:\n    await tile.set_flame_effect(speed=5.0)\n</code></pre></p> METHOD DESCRIPTION <code>get_tile_chain</code> <p>Get information about all tiles in the chain.</p> <code>get_tile_count</code> <p>Get the number of tiles in the chain.</p> <code>get_tile_colors</code> <p>Get colors from a tile.</p> <code>set_tile_colors</code> <p>Set colors on a tile.</p> <code>get_tile_effect</code> <p>Get current tile effect.</p> <code>set_tile_effect</code> <p>Set tile effect.</p> <code>stop_effect</code> <p>Stop any running tile effect.</p> <code>copy_frame_buffer</code> <p>Copy a rectangular region from one frame buffer to another.</p> <code>set_morph_effect</code> <p>Apply a morph effect that transitions through a color palette.</p> <code>set_flame_effect</code> <p>Apply a flame effect.</p> ATTRIBUTE DESCRIPTION <code>tile_chain</code> <p>Get cached tile chain if available.</p> <p> TYPE: <code>list[TileInfo] | None</code> </p> <code>tile_count</code> <p>Get cached tile count if available.</p> <p> TYPE: <code>int | None</code> </p> <code>tile_effect</code> <p>Get cached tile effect if available.</p> <p> TYPE: <code>TileEffect | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    cache_ttl: float | None = None,\n    timeout: float = 1.0,\n    max_retries: int = 3,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        cache_ttl: Cache time-to-live in seconds (default 5.0, min 0.1, max 300)\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Check multicast bit (first byte, LSB should be 0 for unicast)\n    if serial_bytes[0] &amp; 0x01:\n        raise ValueError(\"Multicast serial number not allowed\")\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        raise ValueError(\"Localhost IP address not allowed\")\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\"Unspecified IP address (0.0.0.0) not allowed\")\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")\n\n    # Validate port\n    if not (1 &lt;= port &lt;= 65535):\n        raise ValueError(f\"Port must be between 1 and 65535, got {port}\")\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Validate cache TTL\n    if cache_ttl is None:\n        cache_ttl = self.DEFAULT_CACHE_TTL\n\n    if not (self.MIN_CACHE_TTL &lt;= cache_ttl &lt;= self.MAX_CACHE_TTL):\n        raise ValueError(\n            f\"cache_ttl must be between {self.MIN_CACHE_TTL} \"\n            f\"and {self.MAX_CACHE_TTL}, got {cache_ttl}\"\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self.cache_ttl = cache_ttl\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State cache: key -&gt; (value, timestamp, ttl)\n    self._cache: dict[str, tuple[Any, float, float]] = {}\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.tile.TileDevice.tile_chain","title":"tile_chain  <code>property</code>","text":"<pre><code>tile_chain: list[TileInfo] | None\n</code></pre> <p>Get cached tile chain if available.</p> RETURNS DESCRIPTION <code>list[TileInfo] | None</code> <p>Cached tile chain (use get_tile_chain() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.tile_count","title":"tile_count  <code>property</code>","text":"<pre><code>tile_count: int | None\n</code></pre> <p>Get cached tile count if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Cached tile count (use get_tile_count() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.tile_effect","title":"tile_effect  <code>property</code>","text":"<pre><code>tile_effect: TileEffect | None\n</code></pre> <p>Get cached tile effect if available.</p> RETURNS DESCRIPTION <code>TileEffect | None</code> <p>Cached tile effect (use get_tile_effect() for fresh data)</p>"},{"location":"api/devices/#lifx.devices.tile.TileDevice-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.tile.TileDevice.get_tile_chain","title":"get_tile_chain  <code>async</code>","text":"<pre><code>get_tile_chain(use_cache: bool = True) -&gt; list[TileInfo]\n</code></pre> <p>Get information about all tiles in the chain.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[TileInfo]</code> <p>List of TileInfo objects, one per tile</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>chain = await tile.get_tile_chain()\nfor i, tile_info in enumerate(chain):\n    print(f\"Tile {i}: {tile_info.width}x{tile_info.height}\")\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def get_tile_chain(self, use_cache: bool = True) -&gt; list[TileInfo]:\n    \"\"\"Get information about all tiles in the chain.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        List of TileInfo objects, one per tile\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        chain = await tile.get_tile_chain()\n        for i, tile_info in enumerate(chain):\n            print(f\"Tile {i}: {tile_info.width}x{tile_info.height}\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"tile_chain\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Tile.GetDeviceChain())\n\n    # Convert protocol TileDevice objects to TileInfo\n    tiles = [\n        TileInfo.from_protocol(tile_device)\n        for tile_device in state.tile_devices[: state.tile_devices_count]\n    ]\n\n    # Tile chain is immutable (hardware configuration) - cache permanently\n    self._set_cached(\"tile_chain\", tiles, ttl=self.PERMANENT_CACHE_TTL)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_tile_chain\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"tile_devices_count\": state.tile_devices_count,\n                \"tiles\": [\n                    {\n                        \"width\": tile.width,\n                        \"height\": tile.height,\n                        \"device_version_vendor\": tile.device_version_vendor,\n                        \"device_version_product\": tile.device_version_product,\n                        \"firmware_version_major\": tile.firmware_version_major,\n                        \"firmware_version_minor\": tile.firmware_version_minor,\n                    }\n                    for tile in tiles\n                ],\n            },\n        }\n    )\n\n    return tiles\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.get_tile_count","title":"get_tile_count  <code>async</code>","text":"<pre><code>get_tile_count(use_cache: bool = True) -&gt; int\n</code></pre> <p>Get the number of tiles in the chain.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of tiles</p> Example <pre><code>count = await tile.get_tile_count()\nprint(f\"Device has {count} tiles\")\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def get_tile_count(self, use_cache: bool = True) -&gt; int:\n    \"\"\"Get the number of tiles in the chain.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        Number of tiles\n\n    Example:\n        ```python\n        count = await tile.get_tile_count()\n        print(f\"Device has {count} tiles\")\n        ```\n    \"\"\"\n    chain = await self.get_tile_chain(use_cache=use_cache)\n    count = len(chain)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_tile_count\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"count\": count,\n            },\n        }\n    )\n\n    return count\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.get_tile_colors","title":"get_tile_colors  <code>async</code>","text":"<pre><code>get_tile_colors(\n    tile_index: int,\n    x: int = 0,\n    y: int = 0,\n    width: int | None = None,\n    height: int | None = None,\n    use_cache: bool = False,\n) -&gt; list[list[HSBK]]\n</code></pre> <p>Get colors from a tile.</p> <p>Returns a 2D array of colors representing the zones. For tiles with &gt;64 zones, multiple Get64 requests are sent sequentially.</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of tile in chain (0-based)</p> <p> TYPE: <code>int</code> </p> <code>x</code> <p>Starting X coordinate (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>y</code> <p>Starting Y coordinate (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>width</code> <p>Rectangle width in zones (default: tile width)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>height</code> <p>Rectangle height in zones (default: tile height)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>use_cache</code> <p>Use cached value if available (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[list[HSBK]]</code> <p>2D list of HSBK colors</p> RAISES DESCRIPTION <code>ValueError</code> <p>If tile_index or dimensions are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code># Get all colors from first tile\ncolors = await tile.get_tile_colors(0)\nprint(f\"Top-left zone: {colors[0][0]}\")\n\n# Get colors from specific rectangle\ncolors = await tile.get_tile_colors(0, x=2, y=2, width=4, height=4)\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def get_tile_colors(\n    self,\n    tile_index: int,\n    x: int = 0,\n    y: int = 0,\n    width: int | None = None,\n    height: int | None = None,\n    use_cache: bool = False,\n) -&gt; list[list[HSBK]]:\n    \"\"\"Get colors from a tile.\n\n    Returns a 2D array of colors representing the zones.\n    For tiles with &gt;64 zones, multiple Get64 requests are sent sequentially.\n\n    Args:\n        tile_index: Index of tile in chain (0-based)\n        x: Starting X coordinate (default 0)\n        y: Starting Y coordinate (default 0)\n        width: Rectangle width in zones (default: tile width)\n        height: Rectangle height in zones (default: tile height)\n        use_cache: Use cached value if available (default False)\n\n    Returns:\n        2D list of HSBK colors\n\n    Raises:\n        ValueError: If tile_index or dimensions are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        # Get all colors from first tile\n        colors = await tile.get_tile_colors(0)\n        print(f\"Top-left zone: {colors[0][0]}\")\n\n        # Get colors from specific rectangle\n        colors = await tile.get_tile_colors(0, x=2, y=2, width=4, height=4)\n        ```\n    \"\"\"\n    if tile_index &lt; 0:\n        raise ValueError(f\"Invalid tile index: {tile_index}\")\n    if x &lt; 0 or y &lt; 0:\n        raise ValueError(f\"Invalid coordinates: x={x}, y={y}\")\n\n    # Get tile info to determine dimensions\n    chain = await self.get_tile_chain(use_cache=True)\n    if tile_index &gt;= len(chain):\n        raise ValueError(\n            f\"Tile index {tile_index} out of range (chain has {len(chain)} tiles)\"\n        )\n\n    tile_info = chain[tile_index]\n\n    # Default to full tile if dimensions not specified\n    if width is None:\n        width = tile_info.width - x\n    if height is None:\n        height = tile_info.height - y\n\n    # Validate dimensions\n    if width &lt;= 0 or height &lt;= 0:\n        raise ValueError(f\"Invalid dimensions: width={width}, height={height}\")\n    if x + width &gt; tile_info.width or y + height &gt; tile_info.height:\n        raise ValueError(\n            f\"Rectangle exceeds tile dimensions ({x},{y},{width},{height}) \"\n            f\"vs ({tile_info.width}x{tile_info.height})\"\n        )\n\n    cache_key = f\"tile_{tile_index}_colors_{x}_{y}_{width}_{height}\"\n    if use_cache:\n        cached = self._get_cached(cache_key)\n        if cached is not None:\n            return cached\n\n    total_zones = width * height\n\n    if total_zones &lt;= 64:\n        # Single Get64 request sufficient\n        state = await self.connection.request(\n            packets.Tile.Get64(\n                tile_index=tile_index,\n                length=1,\n                rect=TileBufferRect(fb_index=0, x=x, y=y, width=width),\n            ),\n        )\n\n        # Convert colors from protocol HSBK to HSBK\n        colors_flat = [\n            HSBK.from_protocol(color) for color in state.colors[:total_zones]\n        ]\n    else:\n        # Multiple Get64 requests needed\n        # Split into chunks by rows, taking as many rows as fit in 64 zones\n        colors_flat: list[HSBK] = []\n        current_y = y\n\n        while current_y &lt; y + height:\n            # Calculate how many rows we can fetch in this chunk (max 64 zones)\n            rows_in_chunk = min((64 // width), (y + height - current_y))\n            if rows_in_chunk == 0:\n                rows_in_chunk = 1  # Always fetch at least 1 row\n\n            # Send Get64 request for this chunk\n            state = await self.connection.request(\n                packets.Tile.Get64(\n                    tile_index=tile_index,\n                    length=1,\n                    rect=TileBufferRect(fb_index=0, x=x, y=current_y, width=width),\n                ),\n            )\n\n            # Extract colors for this chunk\n            zones_in_chunk = width * rows_in_chunk\n            chunk_colors = [\n                HSBK.from_protocol(color) for color in state.colors[:zones_in_chunk]\n            ]\n            colors_flat.extend(chunk_colors)\n\n            current_y += rows_in_chunk\n\n    # Convert flat list to 2D array [y][x]\n    colors_2d: list[list[HSBK]] = []\n    for row_idx in range(height):\n        row: list[HSBK] = []\n        for col_idx in range(width):\n            index = row_idx * width + col_idx\n            if index &lt; len(colors_flat):\n                row.append(colors_flat[index])\n            else:\n                # Pad with black if we don't have enough colors\n                row.append(HSBK(0, 0, 0, 3500))\n        colors_2d.append(row)\n\n    self._set_cached(cache_key, colors_2d)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_tile_colors\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"tile_index\": tile_index,\n                \"x\": x,\n                \"y\": y,\n                \"width\": width,\n                \"height\": height,\n                \"total_zones\": total_zones,\n            },\n        }\n    )\n\n    return colors_2d\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.set_tile_colors","title":"set_tile_colors  <code>async</code>","text":"<pre><code>set_tile_colors(\n    tile_index: int,\n    colors: list[list[HSBK]],\n    x: int = 0,\n    y: int = 0,\n    duration: float = 0.0,\n) -&gt; None\n</code></pre> <p>Set colors on a tile.</p> <p>For tiles with &gt;64 zones, multiple Set64 requests are sent to frame buffer 1, then CopyFrameBuffer is used to atomically copy to frame buffer 0 with the specified duration. This eliminates flicker during multi-packet updates.</p> <p>If the device is powered off, colors are set instantly (duration=0) and then the device is powered on with the specified duration for a smooth visual effect.</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of tile in chain (0-based)</p> <p> TYPE: <code>int</code> </p> <code>colors</code> <p>2D list of HSBK colors</p> <p> TYPE: <code>list[list[HSBK]]</code> </p> <code>x</code> <p>Starting X coordinate on tile (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>y</code> <p>Starting Y coordinate on tile (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If parameters are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set entire 8x8 tile to red\nred = HSBK.from_rgb(255, 0, 0)\ncolors = [[red] * 8 for _ in range(8)]\nawait tile.set_tile_colors(0, colors)\n\n# Set a 4x4 area starting at (2, 2) with transition\nblue = HSBK.from_rgb(0, 0, 255)\ncolors = [[blue] * 4 for _ in range(4)]\nawait tile.set_tile_colors(0, colors, x=2, y=2, duration=1.0)\n\n# Set entire 16x8 wide tile with smooth transition\ncolors = [[HSBK.from_rgb(255, 0, 0)] * 16 for _ in range(8)]\nawait tile.set_tile_colors(0, colors, duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def set_tile_colors(\n    self,\n    tile_index: int,\n    colors: list[list[HSBK]],\n    x: int = 0,\n    y: int = 0,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Set colors on a tile.\n\n    For tiles with &gt;64 zones, multiple Set64 requests are sent to frame buffer 1,\n    then CopyFrameBuffer is used to atomically copy to frame buffer 0 with the\n    specified duration. This eliminates flicker during multi-packet updates.\n\n    If the device is powered off, colors are set instantly (duration=0) and then\n    the device is powered on with the specified duration for a smooth visual effect.\n\n    Args:\n        tile_index: Index of tile in chain (0-based)\n        colors: 2D list of HSBK colors\n        x: Starting X coordinate on tile (default 0)\n        y: Starting Y coordinate on tile (default 0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If parameters are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set entire 8x8 tile to red\n        red = HSBK.from_rgb(255, 0, 0)\n        colors = [[red] * 8 for _ in range(8)]\n        await tile.set_tile_colors(0, colors)\n\n        # Set a 4x4 area starting at (2, 2) with transition\n        blue = HSBK.from_rgb(0, 0, 255)\n        colors = [[blue] * 4 for _ in range(4)]\n        await tile.set_tile_colors(0, colors, x=2, y=2, duration=1.0)\n\n        # Set entire 16x8 wide tile with smooth transition\n        colors = [[HSBK.from_rgb(255, 0, 0)] * 16 for _ in range(8)]\n        await tile.set_tile_colors(0, colors, duration=2.0)\n        ```\n    \"\"\"\n    if tile_index &lt; 0:\n        raise ValueError(f\"Invalid tile index: {tile_index}\")\n    if x &lt; 0 or y &lt; 0:\n        raise ValueError(f\"Invalid coordinates: x={x}, y={y}\")\n    if not colors or not colors[0]:\n        raise ValueError(\"Colors array cannot be empty\")\n\n    height = len(colors)\n    width = len(colors[0])\n\n    # Validate that all rows have the same width\n    for row in colors:\n        if len(row) != width:\n            raise ValueError(\"All rows in colors array must have the same width\")\n\n    # Flatten colors to 1D array\n    colors_flat: list[HSBK] = []\n    for row in colors:\n        colors_flat.extend(row)\n\n    total_zones = width * height\n\n    # Check power state to optimize duration handling\n    # If device is off, set colors instantly then power on with duration\n    is_powered_on = await self.get_power(use_cache=True)\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Apply duration to colors only if device is already on\n    color_duration_ms = duration_ms if is_powered_on else 0\n\n    if total_zones &lt;= 64:\n        # Single Set64 request sufficient - write directly to visible frame buffer 0\n        # Pad to 64 colors\n        protocol_colors = [color.to_protocol() for color in colors_flat]\n        while len(protocol_colors) &lt; 64:\n            protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())\n\n        await self.connection.request(\n            packets.Tile.Set64(\n                tile_index=tile_index,\n                length=1,\n                rect=TileBufferRect(fb_index=0, x=x, y=y, width=width),\n                duration=color_duration_ms,\n                colors=protocol_colors,\n            ),\n        )\n    else:\n        # Multiple Set64 requests needed for &gt;64 zones\n        # Write to buffer 1, then copy to buffer 0 atomically\n        current_y = y\n        flat_index = 0\n\n        while flat_index &lt; len(colors_flat):\n            # Calculate how many rows we can write in this chunk (max 64 zones)\n            rows_in_chunk = min((64 // width), (y + height - current_y))\n            if rows_in_chunk == 0:\n                rows_in_chunk = 1  # Always write at least 1 row\n\n            # Extract colors for this chunk\n            zones_in_chunk = width * rows_in_chunk\n            chunk_colors = colors_flat[flat_index : flat_index + zones_in_chunk]\n\n            # Pad to 64 colors\n            protocol_colors = [color.to_protocol() for color in chunk_colors]\n            while len(protocol_colors) &lt; 64:\n                protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())\n\n            # Write to frame buffer 1 (invisible) with no duration\n            await self.connection.request(\n                packets.Tile.Set64(\n                    tile_index=tile_index,\n                    length=1,\n                    rect=TileBufferRect(fb_index=1, x=x, y=current_y, width=width),\n                    duration=0,\n                    colors=protocol_colors,\n                ),\n            )\n\n            flat_index += zones_in_chunk\n            current_y += rows_in_chunk\n\n        # Copy from buffer 1 to buffer 0 with transition duration\n        copy_duration = duration if is_powered_on else 0.0\n        await self.copy_frame_buffer(\n            tile_index=tile_index,\n            src_fb_index=1,\n            dst_fb_index=0,\n            src_x=x,\n            src_y=y,\n            dst_x=x,\n            dst_y=y,\n            width=width,\n            height=height,\n            duration=copy_duration,\n        )\n\n    # Invalidate cache\n    self._invalidate_cache(f\"tile_{tile_index}_colors_{x}_{y}_{width}_{height}\")\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_tile_colors\",\n            \"action\": \"change\",\n            \"values\": {\n                \"tile_index\": tile_index,\n                \"x\": x,\n                \"y\": y,\n                \"width\": width,\n                \"height\": height,\n                \"total_zones\": total_zones,\n                \"duration\": duration,\n            },\n        }\n    )\n\n    # If device was off, power it on with the specified duration\n    if not is_powered_on and duration &gt; 0:\n        await self.set_power(True, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.get_tile_effect","title":"get_tile_effect  <code>async</code>","text":"<pre><code>get_tile_effect(use_cache: bool = True) -&gt; TileEffect | None\n</code></pre> <p>Get current tile effect.</p> PARAMETER DESCRIPTION <code>use_cache</code> <p>Use cached value if available (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>TileEffect | None</code> <p>TileEffect if an effect is active, None if no effect</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code>effect = await tile.get_tile_effect()\nif effect:\n    print(f\"Effect: {effect.effect_type}, Speed: {effect.speed}ms\")\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def get_tile_effect(self, use_cache: bool = True) -&gt; TileEffect | None:\n    \"\"\"Get current tile effect.\n\n    Args:\n        use_cache: Use cached value if available (default True)\n\n    Returns:\n        TileEffect if an effect is active, None if no effect\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        effect = await tile.get_tile_effect()\n        if effect:\n            print(f\"Effect: {effect.effect_type}, Speed: {effect.speed}ms\")\n        ```\n    \"\"\"\n    if use_cache:\n        cached = self._get_cached(\"tile_effect\")\n        if cached is not None:\n            return cached\n\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Tile.GetEffect())\n\n    settings = state.settings\n    effect_type = settings.effect_type\n\n    # Extract parameters from the settings parameter field\n    parameters = [\n        settings.parameter.parameter0,\n        settings.parameter.parameter1,\n        settings.parameter.parameter2,\n        settings.parameter.parameter3,\n        settings.parameter.parameter4,\n        settings.parameter.parameter5,\n        settings.parameter.parameter6,\n        settings.parameter.parameter7,\n    ]\n\n    # Convert palette from protocol HSBK to HSBK\n    palette = [\n        HSBK.from_protocol(color)\n        for color in settings.palette[: settings.palette_count]\n    ]\n\n    if effect_type == TileEffectType.OFF:\n        result = None\n    else:\n        result = TileEffect(\n            effect_type=effect_type,\n            speed=settings.speed,\n            duration=settings.duration,\n            palette=palette,\n            parameters=parameters,\n        )\n\n    self._set_cached(\"tile_effect\", result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_tile_effect\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"effect_type\": effect_type.name,\n                \"speed\": settings.speed,\n                \"duration\": settings.duration,\n                \"palette_count\": settings.palette_count,\n                \"parameters\": parameters,\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.set_tile_effect","title":"set_tile_effect  <code>async</code>","text":"<pre><code>set_tile_effect(effect: TileEffect) -&gt; None\n</code></pre> <p>Set tile effect.</p> PARAMETER DESCRIPTION <code>effect</code> <p>Tile effect configuration</p> <p> TYPE: <code>TileEffect</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If palette has too many colors</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Apply a morph effect with rainbow palette\npalette = [\n    HSBK(0, 1.0, 1.0, 3500),  # Red\n    HSBK(60, 1.0, 1.0, 3500),  # Yellow\n    HSBK(120, 1.0, 1.0, 3500),  # Green\n    HSBK(240, 1.0, 1.0, 3500),  # Blue\n]\neffect = TileEffect(\n    effect_type=TileEffectType.MORPH,\n    speed=5000,\n    palette=palette,\n)\nawait tile.set_tile_effect(effect)\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def set_tile_effect(self, effect: TileEffect) -&gt; None:\n    \"\"\"Set tile effect.\n\n    Args:\n        effect: Tile effect configuration\n\n    Raises:\n        ValueError: If palette has too many colors\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Apply a morph effect with rainbow palette\n        palette = [\n            HSBK(0, 1.0, 1.0, 3500),  # Red\n            HSBK(60, 1.0, 1.0, 3500),  # Yellow\n            HSBK(120, 1.0, 1.0, 3500),  # Green\n            HSBK(240, 1.0, 1.0, 3500),  # Blue\n        ]\n        effect = TileEffect(\n            effect_type=TileEffectType.MORPH,\n            speed=5000,\n            palette=palette,\n        )\n        await tile.set_tile_effect(effect)\n        ```\n    \"\"\"\n    palette = effect.palette or [HSBK(0, 0, 1.0, 3500)]\n    if len(palette) &gt; 16:\n        raise ValueError(f\"Palette too large: {len(palette)} colors (max 16)\")\n\n    # Convert palette to protocol HSBK and pad to 16\n    protocol_palette = [color.to_protocol() for color in palette]\n    while len(protocol_palette) &lt; 16:\n        protocol_palette.append(HSBK(0, 0, 0, 3500).to_protocol())\n\n    # Ensure parameters list is 8 elements\n    parameters = effect.parameters or [0] * 8\n    if len(parameters) &lt; 8:\n        parameters.extend([0] * (8 - len(parameters)))\n    parameters = parameters[:8]\n\n    # Request automatically handles acknowledgement\n    await self.connection.request(\n        packets.Tile.SetEffect(\n            settings=TileEffectSettings(\n                instanceid=0,  # 0 for new effect\n                effect_type=effect.effect_type,\n                speed=effect.speed,\n                duration=effect.duration,\n                parameter=TileEffectParameter(\n                    parameter0=parameters[0],\n                    parameter1=parameters[1],\n                    parameter2=parameters[2],\n                    parameter3=parameters[3],\n                    parameter4=parameters[4],\n                    parameter5=parameters[5],\n                    parameter6=parameters[6],\n                    parameter7=parameters[7],\n                ),\n                palette_count=len(palette),\n                palette=protocol_palette,\n            ),\n        ),\n    )\n\n    # Update cache\n    self._set_cached(\n        \"tile_effect\", effect if effect.effect_type != TileEffectType.OFF else None\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_tile_effect\",\n            \"action\": \"change\",\n            \"values\": {\n                \"effect_type\": effect.effect_type.name,\n                \"speed\": effect.speed,\n                \"duration\": effect.duration,\n                \"palette_count\": len(palette),\n                \"parameters\": parameters,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.stop_effect","title":"stop_effect  <code>async</code>","text":"<pre><code>stop_effect() -&gt; None\n</code></pre> <p>Stop any running tile effect.</p> Example <pre><code>await tile.stop_effect()\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def stop_effect(self) -&gt; None:\n    \"\"\"Stop any running tile effect.\n\n    Example:\n        ```python\n        await tile.stop_effect()\n        ```\n    \"\"\"\n    await self.set_tile_effect(\n        TileEffect(\n            effect_type=TileEffectType.OFF,\n            speed=0,\n            duration=0,\n        )\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"stop_effect\",\n            \"action\": \"change\",\n            \"values\": {},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.copy_frame_buffer","title":"copy_frame_buffer  <code>async</code>","text":"<pre><code>copy_frame_buffer(\n    tile_index: int,\n    src_fb_index: int = 0,\n    dst_fb_index: int = 0,\n    src_x: int = 0,\n    src_y: int = 0,\n    dst_x: int = 0,\n    dst_y: int = 0,\n    width: int = 8,\n    height: int = 8,\n    duration: float = 0.0,\n) -&gt; None\n</code></pre> <p>Copy a rectangular region from one frame buffer to another.</p> <p>This allows copying pixel data between frame buffers or within the same frame buffer on a tile. Useful for double-buffering effects or moving pixel regions.</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of tile in chain (0-based)</p> <p> TYPE: <code>int</code> </p> <code>src_fb_index</code> <p>Source frame buffer index (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>dst_fb_index</code> <p>Destination frame buffer index (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>src_x</code> <p>Source rectangle X coordinate (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>src_y</code> <p>Source rectangle Y coordinate (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>dst_x</code> <p>Destination rectangle X coordinate (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>dst_y</code> <p>Destination rectangle Y coordinate (default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>width</code> <p>Rectangle width in zones (default 8)</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>height</code> <p>Rectangle height in zones (default 8)</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If parameters are invalid or out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Copy entire tile from frame buffer 0 to frame buffer 1\nawait tile.copy_frame_buffer(tile_index=0, src_fb_index=0, dst_fb_index=1)\n\n# Copy a 4x4 region from (0,0) to (2,2) within same buffer with transition\nawait tile.copy_frame_buffer(\n    tile_index=0,\n    src_x=0,\n    src_y=0,\n    dst_x=2,\n    dst_y=2,\n    width=4,\n    height=4,\n    duration=1.0,\n)\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def copy_frame_buffer(\n    self,\n    tile_index: int,\n    src_fb_index: int = 0,\n    dst_fb_index: int = 0,\n    src_x: int = 0,\n    src_y: int = 0,\n    dst_x: int = 0,\n    dst_y: int = 0,\n    width: int = 8,\n    height: int = 8,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Copy a rectangular region from one frame buffer to another.\n\n    This allows copying pixel data between frame buffers or within the same\n    frame buffer on a tile. Useful for double-buffering effects or moving\n    pixel regions.\n\n    Args:\n        tile_index: Index of tile in chain (0-based)\n        src_fb_index: Source frame buffer index (default 0)\n        dst_fb_index: Destination frame buffer index (default 0)\n        src_x: Source rectangle X coordinate (default 0)\n        src_y: Source rectangle Y coordinate (default 0)\n        dst_x: Destination rectangle X coordinate (default 0)\n        dst_y: Destination rectangle Y coordinate (default 0)\n        width: Rectangle width in zones (default 8)\n        height: Rectangle height in zones (default 8)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If parameters are invalid or out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Copy entire tile from frame buffer 0 to frame buffer 1\n        await tile.copy_frame_buffer(tile_index=0, src_fb_index=0, dst_fb_index=1)\n\n        # Copy a 4x4 region from (0,0) to (2,2) within same buffer with transition\n        await tile.copy_frame_buffer(\n            tile_index=0,\n            src_x=0,\n            src_y=0,\n            dst_x=2,\n            dst_y=2,\n            width=4,\n            height=4,\n            duration=1.0,\n        )\n        ```\n    \"\"\"\n    if tile_index &lt; 0:\n        raise ValueError(f\"Invalid tile index: {tile_index}\")\n    if src_fb_index &lt; 0 or dst_fb_index &lt; 0:\n        raise ValueError(\n            f\"Invalid frame buffer indices: src={src_fb_index}, dst={dst_fb_index}\"\n        )\n    if src_x &lt; 0 or src_y &lt; 0 or dst_x &lt; 0 or dst_y &lt; 0:\n        raise ValueError(\n            f\"Invalid coordinates: src=({src_x},{src_y}), dst=({dst_x},{dst_y})\"\n        )\n    if width &lt;= 0 or height &lt;= 0:\n        raise ValueError(f\"Invalid dimensions: {width}x{height}\")\n\n    # Get tile info to validate dimensions\n    chain = await self.get_tile_chain(use_cache=True)\n    if tile_index &gt;= len(chain):\n        raise ValueError(\n            f\"Tile index {tile_index} out of range (chain has {len(chain)} tiles)\"\n        )\n\n    tile_info = chain[tile_index]\n\n    # Validate source rectangle\n    if src_x + width &gt; tile_info.width or src_y + height &gt; tile_info.height:\n        raise ValueError(\n            f\"Source rectangle ({src_x},{src_y},{width},{height}) \"\n            f\"exceeds tile dimensions ({tile_info.width}x{tile_info.height})\"\n        )\n\n    # Validate destination rectangle\n    if dst_x + width &gt; tile_info.width or dst_y + height &gt; tile_info.height:\n        raise ValueError(\n            f\"Destination rectangle ({dst_x},{dst_y},{width},{height}) \"\n            f\"exceeds tile dimensions ({tile_info.width}x{tile_info.height})\"\n        )\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Send copy command\n    await self.connection.request(\n        packets.Tile.CopyFrameBuffer(\n            tile_index=tile_index,\n            length=1,\n            src_fb_index=src_fb_index,\n            dst_fb_index=dst_fb_index,\n            src_x=src_x,\n            src_y=src_y,\n            dst_x=dst_x,\n            dst_y=dst_y,\n            width=width,\n            height=height,\n            duration=duration_ms,\n        ),\n    )\n\n    # Invalidate cache for destination area if copying to visible buffer\n    if dst_fb_index == 0:\n        self._invalidate_cache(\n            f\"tile_{tile_index}_colors_{dst_x}_{dst_y}_{width}_{height}\"\n        )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"copy_frame_buffer\",\n            \"action\": \"change\",\n            \"values\": {\n                \"tile_index\": tile_index,\n                \"src_fb_index\": src_fb_index,\n                \"dst_fb_index\": dst_fb_index,\n                \"src_x\": src_x,\n                \"src_y\": src_y,\n                \"dst_x\": dst_x,\n                \"dst_y\": dst_y,\n                \"width\": width,\n                \"height\": height,\n                \"duration\": duration_ms,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.set_morph_effect","title":"set_morph_effect  <code>async</code>","text":"<pre><code>set_morph_effect(\n    palette: list[HSBK], speed: float = 5.0, duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Apply a morph effect that transitions through a color palette.</p> PARAMETER DESCRIPTION <code>palette</code> <p>List of colors to morph between (2-16 colors)</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>speed</code> <p>Speed in seconds per cycle (default 5.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>5.0</code> </p> <code>duration</code> <p>Total duration in seconds (0 for infinite, default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If palette is invalid</p> Example <pre><code># Morph between red, green, and blue\npalette = [\n    HSBK.from_rgb(255, 0, 0),\n    HSBK.from_rgb(0, 255, 0),\n    HSBK.from_rgb(0, 0, 255),\n]\nawait tile.set_morph_effect(palette, speed=5.0)\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def set_morph_effect(\n    self,\n    palette: list[HSBK],\n    speed: float = 5.0,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Apply a morph effect that transitions through a color palette.\n\n    Args:\n        palette: List of colors to morph between (2-16 colors)\n        speed: Speed in seconds per cycle (default 5.0)\n        duration: Total duration in seconds (0 for infinite, default 0.0)\n\n    Raises:\n        ValueError: If palette is invalid\n\n    Example:\n        ```python\n        # Morph between red, green, and blue\n        palette = [\n            HSBK.from_rgb(255, 0, 0),\n            HSBK.from_rgb(0, 255, 0),\n            HSBK.from_rgb(0, 0, 255),\n        ]\n        await tile.set_morph_effect(palette, speed=5.0)\n        ```\n    \"\"\"\n    if len(palette) &lt; 2:\n        raise ValueError(\"Palette must have at least 2 colors\")\n    if len(palette) &gt; 16:\n        raise ValueError(f\"Palette too large: {len(palette)} colors (max 16)\")\n\n    # Convert speed to milliseconds\n    speed_ms = int(speed * 1000)\n\n    # Convert duration to nanoseconds\n    duration_ns = int(duration * 1_000_000_000)\n\n    await self.set_tile_effect(\n        TileEffect(\n            effect_type=TileEffectType.MORPH,\n            speed=speed_ms,\n            duration=duration_ns,\n            palette=palette,\n        )\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_morph_effect\",\n            \"action\": \"change\",\n            \"values\": {\n                \"palette_count\": len(palette),\n                \"speed\": speed,\n                \"duration\": duration,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.tile.TileDevice.set_flame_effect","title":"set_flame_effect  <code>async</code>","text":"<pre><code>set_flame_effect(\n    speed: float = 5.0, duration: float = 0.0, palette: list[HSBK] | None = None\n) -&gt; None\n</code></pre> <p>Apply a flame effect.</p> PARAMETER DESCRIPTION <code>speed</code> <p>Effect speed in seconds per cycle (default 5.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>5.0</code> </p> <code>duration</code> <p>Total duration in seconds (0 for infinite, default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>palette</code> <p>Optional color palette (default: fire colors)</p> <p> TYPE: <code>list[HSBK] | None</code> DEFAULT: <code>None</code> </p> Example <pre><code># Apply default flame effect\nawait tile.set_flame_effect()\n\n# Custom flame colors\npalette = [\n    HSBK.from_rgb(255, 0, 0),  # Red\n    HSBK.from_rgb(255, 100, 0),  # Orange\n    HSBK.from_rgb(255, 200, 0),  # Yellow\n]\nawait tile.set_flame_effect(speed=3.0, palette=palette)\n</code></pre> Source code in <code>src/lifx/devices/tile.py</code> <pre><code>async def set_flame_effect(\n    self,\n    speed: float = 5.0,\n    duration: float = 0.0,\n    palette: list[HSBK] | None = None,\n) -&gt; None:\n    \"\"\"Apply a flame effect.\n\n    Args:\n        speed: Effect speed in seconds per cycle (default 5.0)\n        duration: Total duration in seconds (0 for infinite, default 0.0)\n        palette: Optional color palette (default: fire colors)\n\n    Example:\n        ```python\n        # Apply default flame effect\n        await tile.set_flame_effect()\n\n        # Custom flame colors\n        palette = [\n            HSBK.from_rgb(255, 0, 0),  # Red\n            HSBK.from_rgb(255, 100, 0),  # Orange\n            HSBK.from_rgb(255, 200, 0),  # Yellow\n        ]\n        await tile.set_flame_effect(speed=3.0, palette=palette)\n        ```\n    \"\"\"\n    if palette is None:\n        # Default fire palette\n        palette = [\n            HSBK(0, 1.0, 1.0, 3500),  # Red\n            HSBK(30, 1.0, 1.0, 3500),  # Orange\n            HSBK(45, 1.0, 0.8, 3500),  # Yellow-orange\n        ]\n\n    # Convert speed to milliseconds\n    speed_ms = int(speed * 1000)\n\n    # Convert duration to nanoseconds\n    duration_ns = int(duration * 1_000_000_000)\n\n    await self.set_tile_effect(\n        TileEffect(\n            effect_type=TileEffectType.FLAME,\n            speed=speed_ms,\n            duration=duration_ns,\n            palette=palette,\n        )\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_flame_effect\",\n            \"action\": \"change\",\n            \"values\": {\n                \"palette_count\": len(palette),\n                \"speed\": speed,\n                \"duration\": duration,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#examples","title":"Examples","text":""},{"location":"api/devices/#basic-light-control","title":"Basic Light Control","text":"<pre><code>from lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Turn on and set color\n        await light.set_power(True)\n        await light.set_color(Colors.BLUE, duration=1.0)\n\n        # Get device info\n        label = await light.get_label()\n        print(f\"Controlling: {label}\")\n</code></pre>"},{"location":"api/devices/#light-effects","title":"Light Effects","text":"<pre><code>from lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Pulse effect\n        await light.pulse(Colors.RED, period=1.0, cycles=5)\n\n        # Breathe effect\n        await light.breathe(Colors.BLUE, period=2.0, cycles=3)\n</code></pre>"},{"location":"api/devices/#hev-light-control-anti-bacterial-cleaning","title":"HEV Light Control (Anti-Bacterial Cleaning)","text":"<pre><code>from lifx import HevLight\n\n\nasync def main():\n    async with await HevLight.from_ip(\"192.168.1.100\") as light:\n        # Start a 2-hour cleaning cycle\n        await light.set_hev_cycle(enable=True, duration_seconds=7200)\n\n        # Check cycle status\n        state = await light.get_hev_cycle()\n        if state.is_running:\n            print(f\"Cleaning: {state.remaining_s}s remaining\")\n\n        # Configure default settings\n        await light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre>"},{"location":"api/devices/#infrared-light-control-night-vision","title":"Infrared Light Control (Night Vision)","text":"<pre><code>from lifx import InfraredLight\n\n\nasync def main():\n    async with await InfraredLight.from_ip(\"192.168.1.100\") as light:\n        # Set infrared brightness to 50%\n        await light.set_infrared(0.5)\n\n        # Get current infrared brightness\n        brightness = await light.get_infrared()\n        print(f\"IR brightness: {brightness * 100}%\")\n</code></pre>"},{"location":"api/devices/#multizone-control","title":"MultiZone Control","text":"<pre><code>from lifx import find_lights, Colors\n\n\nasync def main():\n    async with find_lights() as lights:\n        for light in lights:\n            if light.has_extended_multizone:\n                await light.get_extended_color_zones()\n            elif light.has_multizone:\n                await light.get_color_zones()\n</code></pre>"},{"location":"api/devices/#tile-control","title":"Tile Control","text":"<pre><code>from lifx import find_lights, HSBK\n\n\nasync def main():\n    async with find_lights() as lights:\n        for light in lights:\n            if light.has_matrix:\n                # Set a gradient across the tile\n                colors = [\n                    HSBK(hue=h, saturation=1.0, brightness=0.5, kelvin=3500)\n                    for h in range(0, 360, 10)\n                ]\n                await light.set_tile_colors(colors)\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>lifx-async defines a hierarchy of exceptions for different error conditions. All exceptions inherit from <code>LifxError</code>.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>LifxError (base exception)\n\u251c\u2500\u2500 LifxConnectionError\n\u251c\u2500\u2500 LifxTimeoutError\n\u251c\u2500\u2500 LifxDeviceNotFoundError\n\u251c\u2500\u2500 LifxProtocolError\n\u251c\u2500\u2500 LifxNetworkError\n\u2514\u2500\u2500 LifxUnsupportedCommandError\n</code></pre>"},{"location":"api/exceptions/#base-exception","title":"Base Exception","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxError","title":"LifxError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all lifx-async errors.</p>"},{"location":"api/exceptions/#connection-exceptions","title":"Connection Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxConnectionError","title":"LifxConnectionError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when there's a connection error.</p>"},{"location":"api/exceptions/#lifx.exceptions.LifxTimeoutError","title":"LifxTimeoutError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when an operation times out.</p>"},{"location":"api/exceptions/#lifx.exceptions.LifxDeviceNotFoundError","title":"LifxDeviceNotFoundError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when a device cannot be found or reached.</p>"},{"location":"api/exceptions/#protocol-exceptions","title":"Protocol Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxProtocolError","title":"LifxProtocolError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when there's an error with protocol parsing or validation.</p>"},{"location":"api/exceptions/#network-exceptions","title":"Network Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxNetworkError","title":"LifxNetworkError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when there's a network-level error.</p>"},{"location":"api/exceptions/#command-exceptions","title":"Command Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxUnsupportedCommandError","title":"LifxUnsupportedCommandError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when a device doesn't support the requested command.</p>"},{"location":"api/exceptions/#examples","title":"Examples","text":""},{"location":"api/exceptions/#basic-exception-handling","title":"Basic Exception Handling","text":"<pre><code>from lifx import discover, LifxError, LifxTimeoutError\n\n\nasync def main():\n    try:\n        async with discover(timeout=5.0) as group:\n            await group.set_color(Colors.BLUE)\n    except LifxTimeoutError:\n        print(\"Discovery timed out - no devices found\")\n    except LifxError as e:\n        print(f\"LIFX error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#specific-exception-handling","title":"Specific Exception Handling","text":"<pre><code>from lifx import Light, LifxConnectionError, LifxUnsupportedCommandError\n\n\nasync def main():\n    try:\n        async with await Light.from_ip(\"192.168.1.100\") as light:\n            await light.set_color(Colors.BLUE)\n    except LifxConnectionError:\n        print(\"Failed to connect to device\")\n    except LifxUnsupportedCommandError as e:\n        print(f\"Device doesn't support this operation: {e}\")\n</code></pre>"},{"location":"api/exceptions/#catching-all-lifx-exceptions","title":"Catching All LIFX Exceptions","text":"<pre><code>from lifx import find_lights, LifxError\n\n\nasync def safe_control():\n    try:\n        async with find_lights() as lights:\n            for light in lights:\n                await light.set_brightness(0.8)\n    except LifxError as e:\n        # Catches all LIFX-specific exceptions\n        print(f\"LIFX operation failed: {e}\")\n        # Log, retry, or handle gracefully\n</code></pre>"},{"location":"api/exceptions/#timeout-handling","title":"Timeout Handling","text":"<pre><code>from lifx import DeviceConnection, LifxTimeoutError\nfrom lifx.protocol.packets import LightGet, LightState\n\n\nasync def main():\n    try:\n        async with DeviceConnection(serial, ip, timeout=2.0) as conn:\n            response = await conn.request_response(LightGet(), LightState)\n    except LifxTimeoutError:\n        print(\"Device did not respond in time\")\n        # Device may be offline or unreachable\n</code></pre>"},{"location":"api/exceptions/#protocol-error-handling","title":"Protocol Error Handling","text":"<pre><code>from lifx import Light, LifxProtocolError\n\n\nasync def main():\n    try:\n        async with await Light.from_ip(\"192.168.1.100\") as light:\n            await light.set_color(Colors.BLUE)\n    except LifxProtocolError:\n        print(\"Protocol-level error occurred\")\n</code></pre>"},{"location":"api/exceptions/#unsupported-command-handling","title":"Unsupported Command Handling","text":"<pre><code>from lifx import find_lights, LifxUnsupportedCommandError\n\n\nasync def main():\n    async with find_lights() as lights:\n        for light in lights:\n            try:\n                # Some devices may not support all features\n                await light.set_infrared(0.5)\n            except LifxUnsupportedCommandError:\n                print(f\"{light.label} doesn't support this command\")\n                continue\n</code></pre>"},{"location":"api/exceptions/#device-not-found-handling","title":"Device Not Found Handling","text":"<pre><code>from lifx import find_by_serial, LifxDeviceNotFoundError\n\n\nasync def main():\n    try:\n        device = await find_by_serial(\"d073d5123456\", timeout=3.0)\n        if device:\n            async with device:\n                await device.set_power(True)\n    except LifxDeviceNotFoundError:\n        print(\"Device not found on the network\")\n</code></pre>"},{"location":"api/exceptions/#best-practices","title":"Best Practices","text":""},{"location":"api/exceptions/#always-catch-specific-exceptions-first","title":"Always Catch Specific Exceptions First","text":"<pre><code># \u2705 Good - specific to general\ntry:\n    await light.set_color(Colors.BLUE)\nexcept LifxTimeoutError:\n    print(\"Timeout\")\nexcept LifxConnectionError:\n    print(\"Connection failed\")\nexcept LifxError:\n    print(\"Other LIFX error\")\n\n# \u274c Bad - general exception catches everything\ntry:\n    await light.set_color(Colors.BLUE)\nexcept LifxError:\n    print(\"Error\")  # Can't distinguish timeout from other errors\n</code></pre>"},{"location":"api/exceptions/#use-context-managers-for-cleanup","title":"Use Context Managers for Cleanup","text":"<pre><code># \u2705 Good - resources cleaned up even on exception\ntry:\n    async with await Light.from_ip(ip) as light:\n        await light.set_color(Colors.BLUE)\nexcept LifxError:\n    print(\"Error occurred but connection was closed properly\")\n\n# \u274c Bad - connection may leak on exception\nlight = Light(serial, ip)\nawait light.connect()\ntry:\n    await light.set_color(Colors.BLUE)\nexcept LifxError:\n    pass  # Connection not closed!\nfinally:\n    await light.disconnect()\n</code></pre>"},{"location":"api/exceptions/#log-exceptions-for-debugging","title":"Log Exceptions for Debugging","text":"<pre><code>import logging\nfrom lifx import discover, LifxError\n\nlogger = logging.getLogger(__name__)\n\n\nasync def main():\n    try:\n        async with discover() as group:\n            await group.set_color(Colors.BLUE)\n    except LifxError as e:\n        logger.exception(\"Failed to control lights\")\n        # Logs full traceback for debugging\n</code></pre>"},{"location":"api/exceptions/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>from lifx import find_lights, LifxError\n\n\nasync def main():\n    async with find_lights() as lights:\n        for light in lights:\n            try:\n                await light.set_color(Colors.BLUE)\n            except LifxError as e:\n                # Continue with other lights even if one fails\n                print(f\"Failed to control {light.label}: {e}\")\n                continue\n</code></pre>"},{"location":"api/exceptions/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"api/exceptions/#device-not-responding","title":"Device Not Responding","text":"<pre><code># Usually raises: LifxTimeoutError\nasync with await Light.from_ip(\"192.168.1.100\", timeout=5.0) as light:\n    await light.set_color(Colors.BLUE)\n</code></pre> <p>Causes:</p> <ul> <li>Device is offline or unpowered</li> <li>Wrong IP address</li> <li>Network connectivity issues</li> <li>Firewall blocking UDP port 56700</li> </ul>"},{"location":"api/exceptions/#device-not-found-during-discovery","title":"Device Not Found During Discovery","text":"<pre><code># May raise: LifxTimeoutError or LifxDeviceNotFoundError\nasync with discover(timeout=3.0) as group:\n    if not group.devices:\n        print(\"No devices found\")\n</code></pre> <p>Causes:</p> <ul> <li>No LIFX devices on the network</li> <li>Devices on different subnet</li> <li>Discovery timeout too short</li> <li>Network doesn't allow broadcast packets</li> </ul>"},{"location":"api/exceptions/#connection-failed","title":"Connection Failed","text":"<pre><code># Raises: LifxConnectionError\nasync with DeviceConnection(serial, ip) as conn:\n    await conn.send_packet(packet)\n</code></pre> <p>Causes:</p> <ul> <li>Network unreachable</li> <li>Device offline</li> <li>Port blocked by firewall</li> <li>Invalid IP address</li> </ul>"},{"location":"api/exceptions/#unsupported-command","title":"Unsupported Command","text":"<pre><code># Raises: LifxUnsupportedCommandError\nasync with await Light.from_ip(ip) as light:\n    await light.set_zone_color(0, 5, Colors.RED)  # Not a multizone device\n</code></pre> <p>Causes:</p> <ul> <li>Attempting zone control on non-multizone device</li> <li>Using tile operations on non-tile device</li> <li>Feature not supported by firmware version</li> <li>Sending Light commands to non-light devices (e.g., switches)</li> </ul>"},{"location":"api/exceptions/#protocol-error","title":"Protocol Error","text":"<pre><code># Raises: LifxProtocolError\n</code></pre> <p>Causes:</p> <ul> <li>Invalid packet format received</li> <li>Protocol parsing failure</li> <li>Corrupted message data</li> <li>Unexpected packet type</li> </ul>"},{"location":"api/high-level/","title":"High-Level API","text":"<p>The high-level API provides simplified functions for common LIFX operations. These are the recommended entry points for most users.</p>"},{"location":"api/high-level/#discovery-functions","title":"Discovery Functions","text":""},{"location":"api/high-level/#lifx.api.discover","title":"discover","text":"<pre><code>discover(\n    timeout: float = 3.0,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; DiscoveryContext\n</code></pre> <p>Discover LIFX devices and return a discovery context manager.</p> <p>This function returns an async context manager that performs device discovery and automatically handles connection/disconnection.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Discovery timeout in seconds (default 3.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> <code>broadcast_address</code> <p>Broadcast address to use (default \"255.255.255.255\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>DiscoveryContext</code> <p>DiscoveryContext async context manager</p> Example <pre><code># Discover and control all devices using context manager\nasync with discover() as group:\n    await group.set_power(True)\n    await group.set_color(Colors.BLUE)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>def discover(\n    timeout: float = 3.0,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; DiscoveryContext:\n    \"\"\"Discover LIFX devices and return a discovery context manager.\n\n    This function returns an async context manager that performs device\n    discovery and automatically handles connection/disconnection.\n\n    Args:\n        timeout: Discovery timeout in seconds (default 3.0)\n        broadcast_address: Broadcast address to use (default \"255.255.255.255\")\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n\n    Returns:\n        DiscoveryContext async context manager\n\n    Example:\n        ```python\n        # Discover and control all devices using context manager\n        async with discover() as group:\n            await group.set_power(True)\n            await group.set_color(Colors.BLUE)\n        ```\n    \"\"\"\n    return DiscoveryContext(\n        timeout=timeout,\n        broadcast_address=broadcast_address,\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n    )\n</code></pre>"},{"location":"api/high-level/#lifx.api.find_lights","title":"find_lights  <code>async</code>","text":"<pre><code>find_lights(\n    label_contains: str | None = None,\n    timeout: float = 3.0,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; list[Light]\n</code></pre> <p>Find Light devices with optional label filtering.</p> PARAMETER DESCRIPTION <code>label_contains</code> <p>Filter by label substring (case-insensitive)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Discovery timeout in seconds (default 3.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> <code>broadcast_address</code> <p>Broadcast address to use (default \"255.255.255.255\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>list[Light]</code> <p>List of Light instances matching the criteria</p> Example <pre><code># Find all lights with \"bedroom\" in the label\nlights = await find_lights(label_contains=\"bedroom\")\nfor light in lights:\n    async with light:\n        await light.set_color(Colors.WARM_WHITE)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def find_lights(\n    label_contains: str | None = None,\n    timeout: float = 3.0,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; list[Light]:\n    \"\"\"Find Light devices with optional label filtering.\n\n    Args:\n        label_contains: Filter by label substring (case-insensitive)\n        timeout: Discovery timeout in seconds (default 3.0)\n        broadcast_address: Broadcast address to use (default \"255.255.255.255\")\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n\n    Returns:\n        List of Light instances matching the criteria\n\n    Example:\n        ```python\n        # Find all lights with \"bedroom\" in the label\n        lights = await find_lights(label_contains=\"bedroom\")\n        for light in lights:\n            async with light:\n                await light.set_color(Colors.WARM_WHITE)\n        ```\n    \"\"\"\n    discovered = await discover_devices(\n        timeout=timeout,\n        broadcast_address=broadcast_address,\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n    )\n\n    # Detect device types in parallel\n    results: list[Device | None] = [None] * len(discovered)\n\n    async def detect_and_store(index: int, disc: DiscoveredDevice) -&gt; None:\n        results[index] = await _detect_device_type(disc)\n\n    async with asyncio.TaskGroup() as tg:\n        for i, disc in enumerate(discovered):\n            tg.create_task(detect_and_store(i, disc))\n\n    devices = [d for d in results if d is not None]\n\n    # Filter to only Light devices (and subclasses like MultiZoneLight, TileDevice)\n    lights: list[Light] = [d for d in devices if isinstance(d, Light)]\n\n    # If label filtering is requested, connect and check label\n    if label_contains is not None:\n        filtered_lights: list[Light] = []\n        for light in lights:\n            async with light:\n                try:\n                    label = await light.get_label()\n                    if label_contains.lower() in label.lower():\n                        filtered_lights.append(light)\n                except LifxTimeoutError:\n                    # Skip devices that fail to respond\n                    _LOGGER.warning(\n                        {\n                            \"class\": \"find_lights\",\n                            \"method\": \"filter_devices\",\n                            \"action\": \"no_response\",\n                            \"serial\": light.serial,\n                            \"ip\": light.ip,\n                        }\n                    )\n        return filtered_lights\n\n    return lights\n</code></pre>"},{"location":"api/high-level/#lifx.api.find_by_serial","title":"find_by_serial  <code>async</code>","text":"<pre><code>find_by_serial(\n    serial: bytes | str,\n    timeout: float = 3.0,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; Device | None\n</code></pre> <p>Find a specific device by serial number.</p> PARAMETER DESCRIPTION <code>serial</code> <p>Serial number as bytes or hex string (with or without separators)</p> <p> TYPE: <code>bytes | str</code> </p> <code>timeout</code> <p>Discovery timeout in seconds (default 3.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> <code>broadcast_address</code> <p>Broadcast address to use (default \"255.255.255.255\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> RETURNS DESCRIPTION <code>Device | None</code> <p>Device instance if found, None otherwise</p> Example <pre><code># Find by serial number\ndevice = await find_by_serial(\"d073d5123456\")\nif device:\n    async with device:\n        await device.set_power(True)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def find_by_serial(\n    serial: bytes | str,\n    timeout: float = 3.0,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; Device | None:\n    \"\"\"Find a specific device by serial number.\n\n    Args:\n        serial: Serial number as bytes or hex string (with or without separators)\n        timeout: Discovery timeout in seconds (default 3.0)\n        broadcast_address: Broadcast address to use (default \"255.255.255.255\")\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n\n    Returns:\n        Device instance if found, None otherwise\n\n    Example:\n        ```python\n        # Find by serial number\n        device = await find_by_serial(\"d073d5123456\")\n        if device:\n            async with device:\n                await device.set_power(True)\n        ```\n    \"\"\"\n    # Normalize serial to string format (12-digit hex, no separators)\n    if isinstance(serial, bytes):\n        serial_str = serial.hex()\n    else:\n        serial_str = serial.replace(\":\", \"\").replace(\"-\", \"\").lower()\n\n    discovered = await discover_devices(\n        timeout=timeout,\n        broadcast_address=broadcast_address,\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n    )\n\n    for d in discovered:\n        if d.serial.lower() == serial_str:\n            # Detect device type and return appropriate class\n            return await _detect_device_type(d)\n\n    return None\n</code></pre>"},{"location":"api/high-level/#discovery-context","title":"Discovery Context","text":""},{"location":"api/high-level/#lifx.api.DiscoveryContext","title":"DiscoveryContext","text":"<pre><code>DiscoveryContext(\n    timeout: float,\n    broadcast_address: str,\n    port: int,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n)\n</code></pre> <p>Async context manager for device discovery.</p> <p>Handles device discovery and automatic connection/disconnection. Use with the <code>discover()</code> function for convenient device discovery.</p> Example <pre><code>async with discover(timeout=5.0) as group:\n    await group.set_power(True)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p>Discovery timeout in seconds</p> <p> TYPE: <code>float</code> </p> <code>broadcast_address</code> <p>Broadcast address to use</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Port to use</p> <p> TYPE: <code>int</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Discover devices and connect to them.</p> <code>__aexit__</code> <p>Disconnect from all devices.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def __init__(\n    self,\n    timeout: float,\n    broadcast_address: str,\n    port: int,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; None:\n    \"\"\"Initialize discovery context.\n\n    Args:\n        timeout: Discovery timeout in seconds\n        broadcast_address: Broadcast address to use\n        port: Port to use\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n    \"\"\"\n    self.timeout = timeout\n    self.broadcast_address = broadcast_address\n    self.port = port\n    self._group: DeviceGroup | None = None\n    self._max_response_time = max_response_time\n    self._idle_timeout_multiplier = idle_timeout_multiplier\n</code></pre>"},{"location":"api/high-level/#lifx.api.DiscoveryContext-functions","title":"Functions","text":""},{"location":"api/high-level/#lifx.api.DiscoveryContext.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; DeviceGroup\n</code></pre> <p>Discover devices and connect to them.</p> RETURNS DESCRIPTION <code>DeviceGroup</code> <p>DeviceGroup containing all discovered devices</p> Source code in <code>src/lifx/api.py</code> <pre><code>async def __aenter__(self) -&gt; DeviceGroup:\n    \"\"\"Discover devices and connect to them.\n\n    Returns:\n        DeviceGroup containing all discovered devices\n    \"\"\"\n    # Perform discovery\n    discovered = await discover_devices(\n        timeout=self.timeout,\n        broadcast_address=self.broadcast_address,\n        port=self.port,\n        max_response_time=self._max_response_time,\n        idle_timeout_multiplier=self._idle_timeout_multiplier,\n    )\n\n    # Detect device types and instantiate appropriate classes\n    results: list[Device | None] = [None] * len(discovered)\n\n    async def detect_and_store(index: int, disc: DiscoveredDevice) -&gt; None:\n        results[index] = await _detect_device_type(disc)\n\n    async with asyncio.TaskGroup() as tg:\n        for i, disc in enumerate(discovered):\n            tg.create_task(detect_and_store(i, disc))\n\n    # Filter out None values (unresponsive devices)\n    devices = [d for d in results if d is not None]\n\n    # Create group and connect all devices\n    self._group = DeviceGroup(devices)\n    await self._group.__aenter__()\n\n    return self._group\n</code></pre>"},{"location":"api/high-level/#lifx.api.DiscoveryContext.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Disconnect from all devices.</p> Source code in <code>src/lifx/api.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Disconnect from all devices.\"\"\"\n    if self._group:\n        await self._group.__aexit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/high-level/#device-group","title":"Device Group","text":""},{"location":"api/high-level/#lifx.api.DeviceGroup","title":"DeviceGroup","text":"<pre><code>DeviceGroup(\n    devices: list[\n        Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice\n    ],\n)\n</code></pre> <p>A group of devices for batch operations.</p> <p>Provides convenient methods to control multiple devices simultaneously.</p> Example <pre><code>async with discover() as group:\n    await group.set_power(True)\n    await group.set_color(Colors.BLUE)\n</code></pre> PARAMETER DESCRIPTION <code>devices</code> <p>List of Device instances</p> <p> TYPE: <code>list[Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice]</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter async context manager.</p> <code>__aexit__</code> <p>Exit async context manager.</p> <code>__iter__</code> <p>Iterate over devices in the group.</p> <code>__len__</code> <p>Get number of devices in the group.</p> <code>set_power</code> <p>Set power state for all devices in the group.</p> <code>set_color</code> <p>Set color for all Light devices in the group.</p> <code>set_brightness</code> <p>Set brightness for all Light devices in the group.</p> <code>pulse</code> <p>Pulse effect for all Light devices.</p> <code>organize_by_location</code> <p>Organize devices by location label.</p> <code>organize_by_group</code> <p>Organize devices by group label.</p> <code>filter_by_location</code> <p>Filter devices to a specific location.</p> <code>filter_by_group</code> <p>Filter devices to a specific group.</p> <code>get_unassigned_devices</code> <p>Get devices without location or group assigned.</p> <code>invalidate_metadata_cache</code> <p>Clear all cached location and group metadata.</p> ATTRIBUTE DESCRIPTION <code>devices</code> <p>Get all the devices in the group.</p> <p> TYPE: <code>list[Device]</code> </p> <code>lights</code> <p>Get all Light devices in the group.</p> <p> TYPE: <code>list[Light]</code> </p> <code>hev_lights</code> <p>Get the HEV lights in the group.</p> <p> TYPE: <code>list[HevLight]</code> </p> <code>infrared_lights</code> <p>Get the Infrared lights in the group.</p> <p> TYPE: <code>list[InfraredLight]</code> </p> <code>multizone_lights</code> <p>Get all MultiZone light devices in the group.</p> <p> TYPE: <code>list[MultiZoneLight]</code> </p> <code>tiles</code> <p>Get all Tile devices in the group.</p> <p> TYPE: <code>list[TileDevice]</code> </p> Source code in <code>src/lifx/api.py</code> <pre><code>def __init__(\n    self,\n    devices: list[\n        Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice\n    ],\n) -&gt; None:\n    \"\"\"Initialize device group.\n\n    Args:\n        devices: List of Device instances\n    \"\"\"\n    self._devices = devices\n    self._locations_cache: dict[str, DeviceGroup] | None = None\n    self._groups_cache: dict[str, DeviceGroup] | None = None\n    self._location_metadata: dict[bytes, LocationGrouping] | None = None\n    self._group_metadata: dict[bytes, GroupGrouping] | None = None\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup-attributes","title":"Attributes","text":""},{"location":"api/high-level/#lifx.api.DeviceGroup.devices","title":"devices  <code>property</code>","text":"<pre><code>devices: list[Device]\n</code></pre> <p>Get all the devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.lights","title":"lights  <code>property</code>","text":"<pre><code>lights: list[Light]\n</code></pre> <p>Get all Light devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.hev_lights","title":"hev_lights  <code>property</code>","text":"<pre><code>hev_lights: list[HevLight]\n</code></pre> <p>Get the HEV lights in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.infrared_lights","title":"infrared_lights  <code>property</code>","text":"<pre><code>infrared_lights: list[InfraredLight]\n</code></pre> <p>Get the Infrared lights in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.multizone_lights","title":"multizone_lights  <code>property</code>","text":"<pre><code>multizone_lights: list[MultiZoneLight]\n</code></pre> <p>Get all MultiZone light devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.tiles","title":"tiles  <code>property</code>","text":"<pre><code>tiles: list[TileDevice]\n</code></pre> <p>Get all Tile devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup-functions","title":"Functions","text":""},{"location":"api/high-level/#lifx.api.DeviceGroup.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; DeviceGroup\n</code></pre> <p>Enter async context manager.</p> <p>Note: With the new connection architecture, explicit connect/disconnect is not needed. Connections are managed automatically by the connection pool when requests are made.</p> Source code in <code>src/lifx/api.py</code> <pre><code>async def __aenter__(self) -&gt; DeviceGroup:\n    \"\"\"Enter async context manager.\n\n    Note: With the new connection architecture, explicit connect/disconnect\n    is not needed. Connections are managed automatically by the connection\n    pool when requests are made.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit async context manager.</p> <p>Note: Cleanup is handled automatically by the connection pool.</p> Source code in <code>src/lifx/api.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit async context manager.\n\n    Note: Cleanup is handled automatically by the connection pool.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[\n    Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice\n]\n</code></pre> <p>Iterate over devices in the group.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def __iter__(\n    self,\n) -&gt; Iterator[\n    Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice\n]:\n    \"\"\"Iterate over devices in the group.\"\"\"\n    return iter(self._devices)\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get number of devices in the group.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get number of devices in the group.\"\"\"\n    return len(self._devices)\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(on: bool, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set power state for all devices in the group.</p> PARAMETER DESCRIPTION <code>on</code> <p>True to turn on, False to turn off</p> <p> TYPE: <code>bool</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>async with discover() as group:\n    await group.set_power(True, duration=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def set_power(self, on: bool, duration: float = 0.0) -&gt; None:\n    \"\"\"Set power state for all devices in the group.\n\n    Args:\n        on: True to turn on, False to turn off\n        duration: Transition duration in seconds (default 0.0)\n\n    Example:\n        ```python\n        async with discover() as group:\n            await group.set_power(True, duration=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.set_power(on, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.set_color","title":"set_color  <code>async</code>","text":"<pre><code>set_color(color: HSBK, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set color for all Light devices in the group.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>async with discover() as group:\n    await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def set_color(self, color: HSBK, duration: float = 0.0) -&gt; None:\n    \"\"\"Set color for all Light devices in the group.\n\n    Args:\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n\n    Example:\n        ```python\n        async with discover() as group:\n            await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.set_color(color, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.set_brightness","title":"set_brightness  <code>async</code>","text":"<pre><code>set_brightness(brightness: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set brightness for all Light devices in the group.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>Brightness level (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>async with discover() as group:\n    await group.set_brightness(0.5, duration=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def set_brightness(self, brightness: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set brightness for all Light devices in the group.\n\n    Args:\n        brightness: Brightness level (0.0-1.0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Example:\n        ```python\n        async with discover() as group:\n            await group.set_brightness(0.5, duration=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.set_brightness(brightness, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.pulse","title":"pulse  <code>async</code>","text":"<pre><code>pulse(color: HSBK, period: float = 1.0, cycles: float = 1.0) -&gt; None\n</code></pre> <p>Pulse effect for all Light devices.</p> PARAMETER DESCRIPTION <code>color</code> <p>Color to pulse to</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one cycle in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>cycles</code> <p>Number of cycles</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> Example <pre><code>async with discover() as group:\n    await group.pulse(Colors.RED, period=1.0, cycles=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def pulse(\n    self, color: HSBK, period: float = 1.0, cycles: float = 1.0\n) -&gt; None:\n    \"\"\"Pulse effect for all Light devices.\n\n    Args:\n        color: Color to pulse to\n        period: Period of one cycle in seconds\n        cycles: Number of cycles\n\n    Example:\n        ```python\n        async with discover() as group:\n            await group.pulse(Colors.RED, period=1.0, cycles=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.pulse(color, period, cycles))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.organize_by_location","title":"organize_by_location  <code>async</code>","text":"<pre><code>organize_by_location(\n    include_unassigned: bool = False,\n) -&gt; dict[str, DeviceGroup]\n</code></pre> <p>Organize devices by location label.</p> <p>Fetches location metadata if not cached and groups devices by location label.</p> PARAMETER DESCRIPTION <code>include_unassigned</code> <p>Include \"Unassigned\" group</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, DeviceGroup]</code> <p>Dictionary mapping location labels to DeviceGroup instances</p> Example <pre><code>async with discover() as group:\n    by_location = await group.organize_by_location()\n    kitchen = by_location[\"Kitchen\"]\n    await kitchen.set_color(Colors.BLUE)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def organize_by_location(\n    self, include_unassigned: bool = False\n) -&gt; dict[str, DeviceGroup]:\n    \"\"\"Organize devices by location label.\n\n    Fetches location metadata if not cached and groups devices by location label.\n\n    Args:\n        include_unassigned: Include \"Unassigned\" group\n\n    Returns:\n        Dictionary mapping location labels to DeviceGroup instances\n\n    Example:\n        ```python\n        async with discover() as group:\n            by_location = await group.organize_by_location()\n            kitchen = by_location[\"Kitchen\"]\n            await kitchen.set_color(Colors.BLUE)\n        ```\n    \"\"\"\n    # Fetch metadata if not cached\n    if self._location_metadata is None:\n        await self._fetch_location_metadata()\n\n    # Build and cache groups\n    if self._locations_cache is None:\n        self._locations_cache = self._build_location_groups(include_unassigned)\n\n    return self._locations_cache\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.organize_by_group","title":"organize_by_group  <code>async</code>","text":"<pre><code>organize_by_group(include_unassigned: bool = False) -&gt; dict[str, DeviceGroup]\n</code></pre> <p>Organize devices by group label.</p> <p>Fetches group metadata if not cached and groups devices by group label.</p> PARAMETER DESCRIPTION <code>include_unassigned</code> <p>Include \"Unassigned\" group</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, DeviceGroup]</code> <p>Dictionary mapping group labels to DeviceGroup instances</p> Example <pre><code>async with discover() as group:\n    by_group = await group.organize_by_group()\n    bedroom = by_group[\"Bedroom Lights\"]\n    await bedroom.set_power(False)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def organize_by_group(\n    self, include_unassigned: bool = False\n) -&gt; dict[str, DeviceGroup]:\n    \"\"\"Organize devices by group label.\n\n    Fetches group metadata if not cached and groups devices by group label.\n\n    Args:\n        include_unassigned: Include \"Unassigned\" group\n\n    Returns:\n        Dictionary mapping group labels to DeviceGroup instances\n\n    Example:\n        ```python\n        async with discover() as group:\n            by_group = await group.organize_by_group()\n            bedroom = by_group[\"Bedroom Lights\"]\n            await bedroom.set_power(False)\n        ```\n    \"\"\"\n    # Fetch metadata if not cached\n    if self._group_metadata is None:\n        await self._fetch_group_metadata()\n\n    # Build and cache groups\n    if self._groups_cache is None:\n        self._groups_cache = self._build_group_groups(include_unassigned)\n\n    return self._groups_cache\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.filter_by_location","title":"filter_by_location  <code>async</code>","text":"<pre><code>filter_by_location(label: str, case_sensitive: bool = False) -&gt; DeviceGroup\n</code></pre> <p>Filter devices to a specific location.</p> PARAMETER DESCRIPTION <code>label</code> <p>Location label to filter by</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>If True, performs case-sensitive matching (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DeviceGroup</code> <p>DeviceGroup containing devices in the specified location</p> RAISES DESCRIPTION <code>KeyError</code> <p>If location label not found</p> Example <pre><code>async with discover() as group:\n    living_room = await group.filter_by_location(\"Living Room\")\n    await living_room.set_brightness(0.7)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def filter_by_location(\n    self, label: str, case_sensitive: bool = False\n) -&gt; DeviceGroup:\n    \"\"\"Filter devices to a specific location.\n\n    Args:\n        label: Location label to filter by\n        case_sensitive: If True, performs case-sensitive matching (default False)\n\n    Returns:\n        DeviceGroup containing devices in the specified location\n\n    Raises:\n        KeyError: If location label not found\n\n    Example:\n        ```python\n        async with discover() as group:\n            living_room = await group.filter_by_location(\"Living Room\")\n            await living_room.set_brightness(0.7)\n        ```\n    \"\"\"\n    locations = await self.organize_by_location(include_unassigned=False)\n\n    # Find matching label\n    if case_sensitive:\n        if label not in locations:\n            raise KeyError(f\"Location '{label}' not found\")\n        return locations[label]\n    else:\n        label_lower = label.lower()\n        for loc_label, device_group in locations.items():\n            if loc_label.lower() == label_lower:\n                return device_group\n        raise KeyError(f\"Location '{label}' not found\")\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.filter_by_group","title":"filter_by_group  <code>async</code>","text":"<pre><code>filter_by_group(label: str, case_sensitive: bool = False) -&gt; DeviceGroup\n</code></pre> <p>Filter devices to a specific group.</p> PARAMETER DESCRIPTION <code>label</code> <p>Group label to filter by</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>If True, performs case-sensitive matching (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DeviceGroup</code> <p>DeviceGroup containing devices in the specified group</p> RAISES DESCRIPTION <code>KeyError</code> <p>If group label not found</p> Example <pre><code>async with discover() as group:\n    bedroom = await group.filter_by_group(\"Bedroom Lights\")\n    await bedroom.set_color(Colors.WARM_WHITE)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def filter_by_group(\n    self, label: str, case_sensitive: bool = False\n) -&gt; DeviceGroup:\n    \"\"\"Filter devices to a specific group.\n\n    Args:\n        label: Group label to filter by\n        case_sensitive: If True, performs case-sensitive matching (default False)\n\n    Returns:\n        DeviceGroup containing devices in the specified group\n\n    Raises:\n        KeyError: If group label not found\n\n    Example:\n        ```python\n        async with discover() as group:\n            bedroom = await group.filter_by_group(\"Bedroom Lights\")\n            await bedroom.set_color(Colors.WARM_WHITE)\n        ```\n    \"\"\"\n    groups = await self.organize_by_group(include_unassigned=False)\n\n    # Find matching label\n    if case_sensitive:\n        if label not in groups:\n            raise KeyError(f\"Group '{label}' not found\")\n        return groups[label]\n    else:\n        label_lower = label.lower()\n        for grp_label, device_group in groups.items():\n            if grp_label.lower() == label_lower:\n                return device_group\n        raise KeyError(f\"Group '{label}' not found\")\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.get_unassigned_devices","title":"get_unassigned_devices","text":"<pre><code>get_unassigned_devices(\n    metadata_type: Literal[\"location\", \"group\"] = \"location\",\n) -&gt; list[Device]\n</code></pre> <p>Get devices without location or group assigned.</p> PARAMETER DESCRIPTION <code>metadata_type</code> <p>Type of metadata to check (\"location\" or \"group\")</p> <p> TYPE: <code>Literal['location', 'group']</code> DEFAULT: <code>'location'</code> </p> RETURNS DESCRIPTION <code>list[Device]</code> <p>List of devices without the specified metadata type</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If metadata hasn't been fetched yet</p> Example <pre><code>async with discover() as group:\n    await group.organize_by_location()\n    unassigned = group.get_unassigned_devices(metadata_type=\"location\")\n    print(f\"Found {len(unassigned)} devices without location\")\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>def get_unassigned_devices(\n    self, metadata_type: Literal[\"location\", \"group\"] = \"location\"\n) -&gt; list[Device]:\n    \"\"\"Get devices without location or group assigned.\n\n    Args:\n        metadata_type: Type of metadata to check (\"location\" or \"group\")\n\n    Returns:\n        List of devices without the specified metadata type\n\n    Raises:\n        RuntimeError: If metadata hasn't been fetched yet\n\n    Example:\n        ```python\n        async with discover() as group:\n            await group.organize_by_location()\n            unassigned = group.get_unassigned_devices(metadata_type=\"location\")\n            print(f\"Found {len(unassigned)} devices without location\")\n        ```\n    \"\"\"\n    if metadata_type == \"location\":\n        if self._location_metadata is None:\n            raise RuntimeError(\n                \"Location metadata not fetched. Call organize_by_location() first.\"\n            )\n        return [d for d in self._devices if not self._has_location(d)]\n    else:\n        if self._group_metadata is None:\n            raise RuntimeError(\n                \"Group metadata not fetched. Call organize_by_group() first.\"\n            )\n        return [d for d in self._devices if not self._has_group(d)]\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.invalidate_metadata_cache","title":"invalidate_metadata_cache","text":"<pre><code>invalidate_metadata_cache() -&gt; None\n</code></pre> <p>Clear all cached location and group metadata.</p> <p>Use this if you've changed device locations/groups and want to re-fetch.</p> Example <pre><code>async with discover() as group:\n    # First organization\n    by_location = await group.organize_by_location()\n\n    # ... change device locations ...\n\n    # Clear cache and re-organize\n    group.invalidate_metadata_cache()\n    by_location = await group.organize_by_location()\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>def invalidate_metadata_cache(self) -&gt; None:\n    \"\"\"Clear all cached location and group metadata.\n\n    Use this if you've changed device locations/groups and want to re-fetch.\n\n    Example:\n        ```python\n        async with discover() as group:\n            # First organization\n            by_location = await group.organize_by_location()\n\n            # ... change device locations ...\n\n            # Clear cache and re-organize\n            group.invalidate_metadata_cache()\n            by_location = await group.organize_by_location()\n        ```\n    \"\"\"\n    self._locations_cache = None\n    self._groups_cache = None\n    self._location_metadata = None\n    self._group_metadata = None\n</code></pre>"},{"location":"api/high-level/#examples","title":"Examples","text":""},{"location":"api/high-level/#simple-discovery","title":"Simple Discovery","text":"<pre><code>from lifx import discover, Colors\n\n\nasync def main():\n    async with discover() as group:\n        print(f\"Found {len(group.devices)} devices\")\n        await group.set_power(True)\n        await group.set_color(Colors.BLUE)\n</code></pre>"},{"location":"api/high-level/#find-specific-lights","title":"Find Specific Lights","text":"<pre><code>from lifx import find_lights\n\n\nasync def main():\n    # Find all lights with \"Kitchen\" in the label\n    async with find_lights(label_filter=\"Kitchen\") as lights:\n        for light in lights:\n            await light.set_brightness(0.8)\n</code></pre>"},{"location":"api/high-level/#find-by-serial-number","title":"Find by Serial Number","text":"<pre><code>from lifx import find_by_serial\n\n\nasync def main():\n    # Find specific device by serial number\n    device = await find_by_serial(\"d073d5123456\")\n    if device:\n        async with device:\n            await device.set_power(True)\n</code></pre>"},{"location":"api/network/","title":"Network Layer","text":"<p>The network layer provides low-level operations for communicating with LIFX devices over UDP.</p>"},{"location":"api/network/#discovery","title":"Discovery","text":"<p>Functions for discovering LIFX devices on the local network.</p>"},{"location":"api/network/#lifx.network.discovery.discover_devices","title":"discover_devices  <code>async</code>","text":"<pre><code>discover_devices(\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; list[DiscoveredDevice]\n</code></pre> <p>Discover LIFX devices on the local network.</p> <p>Sends a broadcast DeviceGetService packet and collects responses. Implements DoS protection via timeout, source validation, and serial validation.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Discovery timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> <code>broadcast_address</code> <p>Broadcast address to use</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>UDP port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> RETURNS DESCRIPTION <code>list[DiscoveredDevice]</code> <p>List of discovered devices (deduplicated by serial number)</p> Example <pre><code>devices = await discover_devices(timeout=5.0)\nfor device in devices:\n    print(f\"Found device: {device.serial} at {device.ip}:{device.port}\")\n</code></pre> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>async def discover_devices(\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n) -&gt; list[DiscoveredDevice]:\n    \"\"\"Discover LIFX devices on the local network.\n\n    Sends a broadcast DeviceGetService packet and collects responses.\n    Implements DoS protection via timeout, source validation, and serial validation.\n\n    Args:\n        timeout: Discovery timeout in seconds\n        broadcast_address: Broadcast address to use\n        port: UDP port to use (default LIFX_UDP_PORT)\n\n    Returns:\n        List of discovered devices (deduplicated by serial number)\n\n    Example:\n        ```python\n        devices = await discover_devices(timeout=5.0)\n        for device in devices:\n            print(f\"Found device: {device.serial} at {device.ip}:{device.port}\")\n        ```\n    \"\"\"\n    devices: dict[str, DiscoveredDevice] = {}\n    packet_count = 0\n    start_time = time.time()\n\n    # Create transport with broadcast enabled\n    async with UdpTransport(port=0, broadcast=True) as transport:\n        # Create discovery message\n        builder = MessageBuilder()\n        discovery_packet = DevicePackets.GetService()\n        message = builder.create_message(\n            packet=discovery_packet,\n            target=b\"\\x00\" * 8,  # Broadcast\n            res_required=True,\n            ack_required=False,\n        )\n\n        # Send broadcast\n        request_time = time.time()\n        _LOGGER.debug(\n            {\n                \"class\": \"discover_devices\",\n                \"method\": \"discover\",\n                \"action\": \"broadcast_sent\",\n                \"broadcast_address\": broadcast_address,\n                \"port\": port,\n                \"max_timeout\": timeout,\n                \"request_time\": request_time,\n            }\n        )\n        await transport.send(message, (broadcast_address, port))\n\n        # Calculate idle timeout\n        idle_timeout = max_response_time * idle_timeout_multiplier\n        last_response_time = request_time\n\n        # Collect responses with dynamic timeout\n        while True:\n            # Calculate elapsed time since last response\n            elapsed_since_last = time.time() - last_response_time\n\n            # Stop if we've been idle too long\n            if elapsed_since_last &gt;= idle_timeout:\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"idle_timeout\",\n                        \"idle_time\": elapsed_since_last,\n                        \"idle_timeout\": idle_timeout,\n                    }\n                )\n                break\n\n            # Stop if we've exceeded the overall timeout\n            if time.time() - request_time &gt;= timeout:\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"overall_timeout\",\n                        \"elapsed\": time.time() - request_time,\n                        \"timeout\": timeout,\n                    }\n                )\n                break\n\n            # Calculate remaining timeout (use the shorter of idle or overall timeout)\n            remaining_idle = idle_timeout - elapsed_since_last\n            remaining_overall = timeout - (time.time() - request_time)\n            remaining = min(remaining_idle, remaining_overall)\n\n            # Try to receive a packet\n            try:\n                data, addr = await transport.receive(timeout=remaining)\n                response_timestamp = time.time()\n\n            except LifxTimeoutError:\n                # Timeout means no more responses within the idle period\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"no_responses\",\n                    }\n                )\n                break\n\n            # Increment packet counter for logging\n            packet_count += 1\n\n            try:\n                # Parse message\n                header, payload = parse_message(data)\n\n                # Validate source matches expected source\n                if header.source != builder.source:\n                    _LOGGER.debug(\n                        {\n                            \"class\": \"discover_devices\",\n                            \"method\": \"discover\",\n                            \"action\": \"source_mismatch\",\n                            \"expected_source\": builder.source,\n                            \"received_source\": header.source,\n                            \"source_ip\": addr[0],\n                        }\n                    )\n                    continue\n\n                # Check if this is a DeviceStateService response\n                if header.pkt_type != DevicePackets.StateService.PKT_TYPE:\n                    _LOGGER.debug(\n                        {\n                            \"class\": \"discover_devices\",\n                            \"method\": \"discover\",\n                            \"action\": \"unexpected_packet_type\",\n                            \"pkt_type\": header.pkt_type,\n                            \"expected_type\": DevicePackets.StateService.PKT_TYPE,\n                            \"source_ip\": addr[0],\n                        }\n                    )\n                    continue\n\n                # Validate serial is not multicast/broadcast\n                if header.target[0] &amp; 0x01 or header.target == b\"\\xff\" * 8:\n                    _LOGGER.warning(\n                        {\n                            \"warning\": \"Invalid serial number in discovery response\",\n                            \"serial\": header.target.hex(),\n                            \"source_ip\": addr[0],\n                        }\n                    )\n                    continue\n\n                # Parse service info\n                service, device_port = _parse_device_state_service(payload)\n\n                # Calculate accurate response time from this specific response\n                response_time = response_timestamp - request_time\n\n                # Convert 8-byte protocol serial to string\n                device_serial = Serial.from_protocol(header.target).to_string()\n\n                # Create device info\n                device = DiscoveredDevice(\n                    serial=device_serial,\n                    ip=addr[0],\n                    port=device_port,\n                    service=service,\n                    response_time=response_time,\n                )\n\n                # Deduplicate by serial number\n                devices[device.serial] = device\n\n                # Update last response time for idle timeout calculation\n                last_response_time = response_timestamp\n\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"device_found\",\n                        \"serial\": device.serial,\n                        \"ip\": device.ip,\n                        \"port\": device.port,\n                        \"response_time\": response_time,\n                    }\n                )\n\n            except LifxProtocolError as e:\n                # Log malformed responses\n                _LOGGER.warning(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"malformed_response\",\n                        \"reason\": str(e),\n                        \"source_ip\": addr[0],\n                        \"packet_size\": len(data),\n                    },\n                    exc_info=True,\n                )\n                continue\n            except Exception as e:\n                # Log unexpected errors\n                _LOGGER.error(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"unexpected_error\",\n                        \"error_details\": str(e),\n                        \"source_ip\": addr[0],\n                    },\n                    exc_info=True,\n                )\n                continue\n\n        _LOGGER.debug(\n            {\n                \"class\": \"discover_devices\",\n                \"method\": \"discover\",\n                \"action\": \"complete\",\n                \"devices_found\": len(devices),\n                \"packets_processed\": packet_count,\n                \"elapsed\": time.time() - start_time,\n            }\n        )\n\n    return list(devices.values())\n</code></pre>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice","title":"DiscoveredDevice  <code>dataclass</code>","text":"<pre><code>DiscoveredDevice(\n    serial: str,\n    ip: str,\n    port: int,\n    service: int,\n    first_seen: float = time(),\n    response_time: float = 0.0,\n)\n</code></pre> <p>Information about a discovered LIFX device.</p> ATTRIBUTE DESCRIPTION <code>serial</code> <p>Device serial number as 12-digit hex string (e.g., \"d073d5123456\")</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port</p> <p> TYPE: <code>int</code> </p> <code>service</code> <p>Service type (typically UDP=1)</p> <p> TYPE: <code>int</code> </p> <code>first_seen</code> <p>Timestamp when device was first discovered</p> <p> TYPE: <code>float</code> </p> <code>response_time</code> <p>Response time in seconds</p> <p> TYPE: <code>float</code> </p> METHOD DESCRIPTION <code>create_device</code> <p>Create appropriate device instance based on product capabilities.</p> <code>__hash__</code> <p>Hash based on serial number for deduplication.</p> <code>__eq__</code> <p>Equality based on serial number.</p>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice.create_device","title":"create_device  <code>async</code>","text":"<pre><code>create_device() -&gt; Device\n</code></pre> <p>Create appropriate device instance based on product capabilities.</p> <p>Queries the device for its product ID and firmware version, then instantiates the appropriate device class (Device, Light, MultiZoneLight, or TileDevice) based on the product capabilities.</p> RETURNS DESCRIPTION <code>Device</code> <p>Device instance of the appropriate type</p> RAISES DESCRIPTION <code>DeviceNotFoundError</code> <p>If device doesn't respond</p> <code>TimeoutError</code> <p>If device query times out</p> Example <pre><code>devices = await discover_devices()\nfor discovered in devices:\n    device = await discovered.create_device()\n    print(f\"Created {type(device).__name__}: {await device.get_label()}\")\n</code></pre> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>async def create_device(self) -&gt; Device:\n    \"\"\"Create appropriate device instance based on product capabilities.\n\n    Queries the device for its product ID and firmware version, then\n    instantiates the appropriate device class (Device, Light, MultiZoneLight,\n    or TileDevice) based on the product capabilities.\n\n    Returns:\n        Device instance of the appropriate type\n\n    Raises:\n        DeviceNotFoundError: If device doesn't respond\n        TimeoutError: If device query times out\n\n    Example:\n        ```python\n        devices = await discover_devices()\n        for discovered in devices:\n            device = await discovered.create_device()\n            print(f\"Created {type(device).__name__}: {await device.get_label()}\")\n        ```\n    \"\"\"\n    from lifx.devices.base import Device\n    from lifx.devices.hev import HevLight\n    from lifx.devices.infrared import InfraredLight\n    from lifx.devices.light import Light\n    from lifx.devices.multizone import MultiZoneLight\n    from lifx.devices.tile import TileDevice\n    from lifx.products import get_device_class_name\n\n    # Create temporary device to query version (registry is always pre-loaded)\n    temp_device = Device(serial=self.serial, ip=self.ip, port=self.port)\n\n    try:\n        version = await temp_device.get_version()\n        pid = version.product\n\n        # Get appropriate class name\n        class_name = get_device_class_name(pid)\n\n        # Instantiate the correct class\n        if class_name == \"TileDevice\":\n            device = TileDevice(serial=self.serial, ip=self.ip, port=self.port)\n        elif class_name == \"MultiZoneLight\":\n            device = MultiZoneLight(serial=self.serial, ip=self.ip, port=self.port)\n        elif class_name == \"HevLight\":\n            device = HevLight(serial=self.serial, ip=self.ip, port=self.port)\n        elif class_name == \"InfraredLight\":\n            device = InfraredLight(serial=self.serial, ip=self.ip, port=self.port)\n        elif class_name == \"Light\":\n            device = Light(serial=self.serial, ip=self.ip, port=self.port)\n        else:\n            device = temp_device\n\n        return device\n\n    except Exception:\n        # If version query fails, default to Light\n        device = Light(serial=self.serial, ip=self.ip, port=self.port)\n        return device\n</code></pre>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash based on serial number for deduplication.</p> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash based on serial number for deduplication.\"\"\"\n    return hash(self.serial)\n</code></pre>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Equality based on serial number.</p> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Equality based on serial number.\"\"\"\n    if not isinstance(other, DiscoveredDevice):\n        return False\n    return self.serial == other.serial\n</code></pre>"},{"location":"api/network/#udp-transport","title":"UDP Transport","text":"<p>Low-level UDP transport for sending and receiving LIFX protocol messages.</p>"},{"location":"api/network/#lifx.network.transport.UdpTransport","title":"UdpTransport","text":"<pre><code>UdpTransport(\n    ip_address: str = DEFAULT_IP_ADDRESS, port: int = 0, broadcast: bool = False\n)\n</code></pre> <p>UDP transport for sending and receiving LIFX packets.</p> <p>This class provides a simple interface for UDP communication with LIFX devices. It uses asyncio for async I/O operations.</p> PARAMETER DESCRIPTION <code>port</code> <p>Local port to bind to (0 for automatic assignment)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>broadcast</code> <p>Enable broadcast mode for device discovery</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> METHOD DESCRIPTION <code>open</code> <p>Open the UDP socket.</p> <code>send</code> <p>Send data to a specific address.</p> <code>receive</code> <p>Receive data from socket with size validation.</p> <code>receive_many</code> <p>Receive multiple packets within timeout period.</p> <code>close</code> <p>Close the UDP socket.</p> ATTRIBUTE DESCRIPTION <code>is_open</code> <p>Check if socket is open.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>def __init__(\n    self,\n    ip_address: str = DEFAULT_IP_ADDRESS,\n    port: int = 0,\n    broadcast: bool = False,\n) -&gt; None:\n    \"\"\"Initialize UDP transport.\n\n    Args:\n        port: Local port to bind to (0 for automatic assignment)\n        broadcast: Enable broadcast mode for device discovery\n    \"\"\"\n    self._ip_address = ip_address\n    self._port = port\n    self._broadcast = broadcast\n    self._protocol: _UdpProtocol | None = None\n    self._transport: DatagramTransport | None = None\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport-attributes","title":"Attributes","text":""},{"location":"api/network/#lifx.network.transport.UdpTransport.is_open","title":"is_open  <code>property</code>","text":"<pre><code>is_open: bool\n</code></pre> <p>Check if socket is open.</p>"},{"location":"api/network/#lifx.network.transport.UdpTransport-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.transport.UdpTransport.open","title":"open  <code>async</code>","text":"<pre><code>open() -&gt; None\n</code></pre> <p>Open the UDP socket.</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def open(self) -&gt; None:\n    \"\"\"Open the UDP socket.\"\"\"\n    if self._protocol is not None:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"already_open\",\n                \"ip_address\": self._ip_address,\n                \"port\": self._port,\n            }\n        )\n        return\n\n    try:\n        import socket as stdlib_socket\n\n        loop = asyncio.get_running_loop()\n\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"opening_socket\",\n                \"ip_address\": self._ip_address,\n                \"port\": self._port,\n                \"broadcast\": self._broadcast,\n            }\n        )\n\n        # Create protocol\n        protocol = _UdpProtocol()\n        self._protocol = protocol\n\n        # Create datagram endpoint\n        self._transport, _ = await loop.create_datagram_endpoint(\n            lambda: protocol,\n            local_addr=(self._ip_address, self._port),\n            reuse_port=bool(hasattr(stdlib_socket, \"SO_REUSEPORT\")),\n            family=stdlib_socket.AF_INET,\n        )\n\n        # Get actual port assigned\n        actual_port = self._transport.get_extra_info(\"sockname\")[1]\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"socket_opened\",\n                \"assigned_port\": actual_port,\n                \"broadcast\": self._broadcast,\n            }\n        )\n\n        # Enable broadcast if requested\n        if self._broadcast:\n            sock = self._transport.get_extra_info(\"socket\")\n            if sock:\n                sock.setsockopt(\n                    stdlib_socket.SOL_SOCKET,\n                    stdlib_socket.SO_BROADCAST,\n                    1,\n                )\n                _LOGGER.debug(\n                    {\n                        \"class\": \"UdpTransport\",\n                        \"method\": \"open\",\n                        \"action\": \"broadcast_enabled\",\n                    }\n                )\n\n    except OSError as e:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"failed\",\n                \"ip_address\": self._ip_address,\n                \"port\": self._port,\n                \"reason\": str(e),\n            }\n        )\n        raise LifxNetworkError(f\"Failed to open UDP socket: {e}\") from e\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.send","title":"send  <code>async</code>","text":"<pre><code>send(data: bytes, address: tuple[str, int]) -&gt; None\n</code></pre> <p>Send data to a specific address.</p> PARAMETER DESCRIPTION <code>data</code> <p>Bytes to send</p> <p> TYPE: <code>bytes</code> </p> <code>address</code> <p>Tuple of (host, port)</p> <p> TYPE: <code>tuple[str, int]</code> </p> RAISES DESCRIPTION <code>NetworkError</code> <p>If socket is not open or send fails</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def send(self, data: bytes, address: tuple[str, int]) -&gt; None:\n    \"\"\"Send data to a specific address.\n\n    Args:\n        data: Bytes to send\n        address: Tuple of (host, port)\n\n    Raises:\n        NetworkError: If socket is not open or send fails\n    \"\"\"\n    if self._transport is None or self._protocol is None:\n        raise LifxNetworkError(\"Socket not open\")\n\n    try:\n        self._transport.sendto(data, address)\n    except OSError as e:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"send\",\n                \"action\": \"failed\",\n                \"destination\": address,\n                \"packet_size\": len(data),\n                \"reason\": str(e),\n            }\n        )\n        raise LifxNetworkError(f\"Failed to send data: {e}\") from e\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(timeout: float = 2.0) -&gt; tuple[bytes, tuple[str, int]]\n</code></pre> <p>Receive data from socket with size validation.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> RETURNS DESCRIPTION <code>tuple[bytes, tuple[str, int]]</code> <p>Tuple of (data, address) where address is (host, port)</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>If no data received within timeout</p> <code>NetworkError</code> <p>If socket is not open or receive fails</p> <code>ProtocolError</code> <p>If packet size is invalid</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def receive(self, timeout: float = 2.0) -&gt; tuple[bytes, tuple[str, int]]:\n    \"\"\"Receive data from socket with size validation.\n\n    Args:\n        timeout: Timeout in seconds\n\n    Returns:\n        Tuple of (data, address) where address is (host, port)\n\n    Raises:\n        LifxTimeoutError: If no data received within timeout\n        NetworkError: If socket is not open or receive fails\n        ProtocolError: If packet size is invalid\n    \"\"\"\n    if self._protocol is None:\n        raise LifxNetworkError(\"Socket not open\")\n\n    try:\n        async with asyncio.timeout(timeout):\n            data, addr = await self._protocol.queue.get()\n\n            # Validate packet size\n            if len(data) &gt; MAX_PACKET_SIZE:\n                from lifx.exceptions import LifxProtocolError\n\n                _LOGGER.error(\n                    {\n                        \"class\": \"UdpTransport\",\n                        \"method\": \"receive\",\n                        \"action\": \"packet_too_large\",\n                        \"packet_size\": len(data),\n                        \"max_size\": MAX_PACKET_SIZE,\n                    }\n                )\n                raise LifxProtocolError(\n                    f\"Packet too big: {len(data)} bytes &gt; {MAX_PACKET_SIZE} bytes\"\n                )\n\n            if len(data) &lt; MIN_PACKET_SIZE:\n                from lifx.exceptions import LifxProtocolError\n\n                _LOGGER.error(\n                    {\n                        \"class\": \"UdpTransport\",\n                        \"method\": \"receive\",\n                        \"action\": \"packet_too_small\",\n                        \"packet_size\": len(data),\n                        \"min_size\": MIN_PACKET_SIZE,\n                    }\n                )\n                raise LifxProtocolError(\n                    f\"Packet too small: {len(data)} bytes &lt; {MIN_PACKET_SIZE} bytes\"\n                )\n\n            return data, addr\n    except TimeoutError as e:\n        raise LifxTimeoutError(f\"No data received within {timeout}s\") from e\n    except OSError as e:\n        _LOGGER.error(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"receive\",\n                \"action\": \"failed\",\n                \"reason\": str(e),\n            }\n        )\n        raise LifxNetworkError(f\"Failed to receive data: {e}\") from e\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.receive_many","title":"receive_many  <code>async</code>","text":"<pre><code>receive_many(\n    timeout: float = 5.0, max_packets: int | None = None\n) -&gt; list[tuple[bytes, tuple[str, int]]]\n</code></pre> <p>Receive multiple packets within timeout period.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Total timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>5.0</code> </p> <code>max_packets</code> <p>Maximum number of packets to receive (None for unlimited)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[tuple[bytes, tuple[str, int]]]</code> <p>List of (data, address) tuples</p> RAISES DESCRIPTION <code>NetworkError</code> <p>If socket is not open</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def receive_many(\n    self, timeout: float = 5.0, max_packets: int | None = None\n) -&gt; list[tuple[bytes, tuple[str, int]]]:\n    \"\"\"Receive multiple packets within timeout period.\n\n    Args:\n        timeout: Total timeout in seconds\n        max_packets: Maximum number of packets to receive (None for unlimited)\n\n    Returns:\n        List of (data, address) tuples\n\n    Raises:\n        NetworkError: If socket is not open\n    \"\"\"\n    if self._protocol is None:\n        raise LifxNetworkError(\"Socket not open\")\n\n    packets: list[tuple[bytes, tuple[str, int]]] = []\n\n    try:\n        async with asyncio.timeout(timeout):\n            while True:\n                if max_packets is not None and len(packets) &gt;= max_packets:\n                    break\n\n                try:\n                    data, addr = await self._protocol.queue.get()\n\n                    # Validate packet size\n                    if len(data) &gt; MAX_PACKET_SIZE:\n                        # Drop oversized packet to prevent memory exhaustion DoS\n                        continue\n\n                    if len(data) &lt; MIN_PACKET_SIZE:\n                        # Drop undersized packet (header is 36 bytes)\n                        continue\n\n                    packets.append((data, addr))\n                except OSError:\n                    # Ignore individual receive errors\n                    break\n\n    except TimeoutError:\n        # Timeout is expected - return what we collected\n        pass\n\n    return packets\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the UDP socket.</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the UDP socket.\"\"\"\n    if self._transport is not None:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"close\",\n                \"action\": \"closing\",\n            }\n        )\n        self._transport.close()\n        self._transport = None\n        self._protocol = None\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"close\",\n                \"action\": \"closed\",\n            }\n        )\n</code></pre>"},{"location":"api/network/#message-building","title":"Message Building","text":"<p>Utilities for building and parsing LIFX protocol messages.</p>"},{"location":"api/network/#lifx.network.message.MessageBuilder","title":"MessageBuilder","text":"<pre><code>MessageBuilder(source: int | None = None)\n</code></pre> <p>Builder for creating LIFX messages with consistent source and sequence.</p> <p>This class maintains state for source ID and sequence numbers, making it easier to create multiple messages from the same client.</p> PARAMETER DESCRIPTION <code>source</code> <p>Client identifier (random if None)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>create_message</code> <p>Create a message with auto-incrementing sequence.</p> <code>next_sequence</code> <p>Get the next sequence number without incrementing.</p> Source code in <code>src/lifx/network/message.py</code> <pre><code>def __init__(self, source: int | None = None) -&gt; None:\n    \"\"\"Initialize message builder.\n\n    Args:\n        source: Client identifier (random if None)\n    \"\"\"\n    self.source = (\n        source if source is not None else secrets.randbelow(0xFFFFFFFF) + 1\n    )\n    self._sequence = 0\n</code></pre>"},{"location":"api/network/#lifx.network.message.MessageBuilder-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.message.MessageBuilder.create_message","title":"create_message","text":"<pre><code>create_message(\n    packet: Any,\n    target: bytes = b\"\\x00\" * 8,\n    ack_required: bool = False,\n    res_required: bool = True,\n) -&gt; bytes\n</code></pre> <p>Create a message with auto-incrementing sequence.</p> PARAMETER DESCRIPTION <code>packet</code> <p>Packet dataclass instance</p> <p> TYPE: <code>Any</code> </p> <code>target</code> <p>Device serial number in bytes</p> <p> TYPE: <code>bytes</code> DEFAULT: <code>b'\\x00' * 8</code> </p> <code>ack_required</code> <p>Request acknowledgement</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>res_required</code> <p>Request response</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>Complete message bytes</p> Source code in <code>src/lifx/network/message.py</code> <pre><code>def create_message(\n    self,\n    packet: Any,\n    target: bytes = b\"\\x00\" * 8,\n    ack_required: bool = False,\n    res_required: bool = True,\n) -&gt; bytes:\n    \"\"\"Create a message with auto-incrementing sequence.\n\n    Args:\n        packet: Packet dataclass instance\n        target: Device serial number in bytes\n        ack_required: Request acknowledgement\n        res_required: Request response\n\n    Returns:\n        Complete message bytes\n    \"\"\"\n    msg = create_message(\n        packet=packet,\n        source=self.source,\n        target=target,\n        sequence=self._sequence,\n        ack_required=ack_required,\n        res_required=res_required,\n    )\n    self._sequence = (self._sequence + 1) % 256\n    return msg\n</code></pre>"},{"location":"api/network/#lifx.network.message.MessageBuilder.next_sequence","title":"next_sequence","text":"<pre><code>next_sequence() -&gt; int\n</code></pre> <p>Get the next sequence number without incrementing.</p> RETURNS DESCRIPTION <code>int</code> <p>Next sequence number</p> Source code in <code>src/lifx/network/message.py</code> <pre><code>def next_sequence(self) -&gt; int:\n    \"\"\"Get the next sequence number without incrementing.\n\n    Returns:\n        Next sequence number\n    \"\"\"\n    return self._sequence\n</code></pre>"},{"location":"api/network/#examples","title":"Examples","text":""},{"location":"api/network/#device-discovery","title":"Device Discovery","text":"<pre><code>from lifx.network.discovery import discover_devices\n\n\nasync def main():\n    # Discover all devices on the network\n    devices = await discover_devices(timeout=3.0)\n\n    for device in devices:\n        print(f\"Found: {device.label} at {device.ip}\")\n        print(f\"  Serial: {device.serial}\")\n        print(f\"  Service: {device.service}\")\n</code></pre>"},{"location":"api/network/#concurrency","title":"Concurrency","text":""},{"location":"api/network/#concurrent-requests-on-single-connection","title":"Concurrent Requests on Single Connection","text":"<p>Each <code>DeviceConnection</code> supports true concurrent requests using a background response dispatcher:</p> <pre><code>import asyncio\nfrom lifx.network.connection import DeviceConnection\nfrom lifx.protocol.packets import LightGet, LightGetPower, DeviceGetLabel\n\n\nasync def main():\n    async with DeviceConnection(serial, ip) as conn:\n        # Multiple requests execute concurrently\n        state, power, label = await asyncio.gather(\n            conn.request_response(LightGet(), LightState),\n            conn.request_response(LightGetPower(), LightStatePower),\n            conn.request_response(DeviceGetLabel(), DeviceStateLabel),\n        )\n</code></pre>"},{"location":"api/network/#concurrent-requests-on-different-devices","title":"Concurrent Requests on Different Devices","text":"<pre><code>import asyncio\nfrom lifx.network.connection import DeviceConnection\n\n\nasync def main():\n    async with DeviceConnection(serial1, ip1) as conn1, DeviceConnection(\n        serial2, ip2\n    ) as conn2:\n        # Fully parallel - different UDP sockets\n        result1, result2 = await asyncio.gather(\n            conn1.request_response(...), conn2.request_response(...)\n        )\n</code></pre>"},{"location":"api/network/#connection-management","title":"Connection Management","text":""},{"location":"api/network/#lifx.network.connection.DeviceConnection","title":"DeviceConnection","text":"<pre><code>DeviceConnection(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    source: int | None = None,\n    max_retries: int = 3,\n    timeout: float = 1.0,\n)\n</code></pre> <p>Handle to a device connection (lightweight, user-facing).</p> <p>This is a lightweight handle that internally uses a class-level connection pool. Multiple DeviceConnection instances with the same serial/ip/port will share the same underlying connection.</p> <p>All connection management (pooling, opening, closing) is internal and completely hidden from Device classes.</p> Device classes just call <p>await self.connection.request(packet)</p> Example <pre><code>conn = DeviceConnection(serial=\"d073d5123456\", ip=\"192.168.1.100\")\nstate = await conn.request(packets.Light.GetColor())\n# state.label is already decoded to string\n# state.color is LightHsbk instance\n</code></pre> <p>This is lightweight - doesn't actually create a connection. Connection is created/retrieved from pool on first request().</p> PARAMETER DESCRIPTION <code>serial</code> <p>Device serial number as 12-digit hex string</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>source</code> <p>Client source identifier (random if None)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>max_retries</code> <p>Maximum retry attempts</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>timeout</code> <p>Overall timeout for requests in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> METHOD DESCRIPTION <code>close_all_connections</code> <p>Close all connections in the shared pool.</p> <code>get_pool_metrics</code> <p>Get connection pool metrics.</p> <code>request</code> <p>Send request and return unpacked response(s).</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    source: int | None = None,\n    max_retries: int = 3,\n    timeout: float = 1.0,\n) -&gt; None:\n    \"\"\"Initialize connection handle.\n\n    This is lightweight - doesn't actually create a connection.\n    Connection is created/retrieved from pool on first request().\n\n    Args:\n        serial: Device serial number as 12-digit hex string\n        ip: Device IP address\n        port: Device UDP port (default LIFX_UDP_PORT)\n        source: Client source identifier (random if None)\n        max_retries: Maximum retry attempts\n        timeout: Overall timeout for requests in seconds\n    \"\"\"\n    self.serial = serial\n    self.ip = ip\n    self.port = port\n    self.source = source\n    self.max_retries = max_retries\n    self.timeout = timeout\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.connection.DeviceConnection.close_all_connections","title":"close_all_connections  <code>async</code> <code>classmethod</code>","text":"<pre><code>close_all_connections() -&gt; None\n</code></pre> <p>Close all connections in the shared pool.</p> <p>Call this at application shutdown for clean teardown.</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>@classmethod\nasync def close_all_connections(cls) -&gt; None:\n    \"\"\"Close all connections in the shared pool.\n\n    Call this at application shutdown for clean teardown.\n    \"\"\"\n    async with cls._pool_lock:\n        if cls._pool is not None:\n            await cls._pool.close_all()\n            cls._pool = None\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.get_pool_metrics","title":"get_pool_metrics  <code>classmethod</code>","text":"<pre><code>get_pool_metrics() -&gt; ConnectionPoolMetrics | None\n</code></pre> <p>Get connection pool metrics.</p> RETURNS DESCRIPTION <code>ConnectionPoolMetrics | None</code> <p>ConnectionPoolMetrics if pool exists, None otherwise</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>@classmethod\ndef get_pool_metrics(cls) -&gt; ConnectionPoolMetrics | None:\n    \"\"\"Get connection pool metrics.\n\n    Returns:\n        ConnectionPoolMetrics if pool exists, None otherwise\n    \"\"\"\n    return cls._pool.metrics if cls._pool is not None else None\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.request","title":"request  <code>async</code>","text":"<pre><code>request(\n    packet: Any, timeout: float = 2.0, collect_multiple: bool = False\n) -&gt; Any\n</code></pre> <p>Send request and return unpacked response(s).</p> <p>This method handles everything internally: - Getting connection from pool (creates if needed) - Opening connection if needed - Sending request with proper ack/response flags - Optionally collecting multiple responses if requested - Unpacking response(s) - Decoding label fields</p> <p>Device classes just call this and get back the result.</p> <p>By default, GET requests return immediately after the first response. Set collect_multiple=True for multi-response commands to wait 200ms.</p> PARAMETER DESCRIPTION <code>packet</code> <p>Packet instance to send</p> <p> TYPE: <code>Any</code> </p> <code>timeout</code> <p>Request timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>collect_multiple</code> <p>Whether to wait for multiple responses (default: False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Single or multiple response packets (list if collect_multiple=True)</p> <code>Any</code> <p>True for SET acknowledgement</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>If request times out</p> <code>LifxProtocolError</code> <p>If response invalid</p> <code>LifxConnectionError</code> <p>If connection fails</p> <code>LifxUnsupportedCommandError</code> <p>If packet kind is unsupported</p> Example <pre><code># GET request returns unpacked packet\nstate = await conn.request(packets.Light.GetColor())\ncolor = HSBK.from_protocol(state.color)\nlabel = state.label  # Already decoded to string\n\n# SET request returns True\nsuccess = await conn.request(\n    packets.Light.SetColor(color=hsbk, duration=1000)\n)\n\n# Multi-response GET - collect multiple responses\nstates = await conn.request(\n    packets.MultiZone.GetColorZones(...), collect_multiple=True\n)\nif isinstance(states, list):\n    for state in states:\n        # process each zone state\n        pass\nelse:\n    # single response\n    pass\n</code></pre> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def request(\n    self, packet: Any, timeout: float = 2.0, collect_multiple: bool = False\n) -&gt; Any:\n    \"\"\"Send request and return unpacked response(s).\n\n    This method handles everything internally:\n    - Getting connection from pool (creates if needed)\n    - Opening connection if needed\n    - Sending request with proper ack/response flags\n    - Optionally collecting multiple responses if requested\n    - Unpacking response(s)\n    - Decoding label fields\n\n    Device classes just call this and get back the result.\n\n    By default, GET requests return immediately after the first response.\n    Set collect_multiple=True for multi-response commands to wait 200ms.\n\n    Args:\n        packet: Packet instance to send\n        timeout: Request timeout in seconds\n        collect_multiple: Whether to wait for multiple responses (default: False)\n\n    Returns:\n        Single or multiple response packets (list if collect_multiple=True)\n        True for SET acknowledgement\n\n    Raises:\n        LifxTimeoutError: If request times out\n        LifxProtocolError: If response invalid\n        LifxConnectionError: If connection fails\n        LifxUnsupportedCommandError: If packet kind is unsupported\n\n    Example:\n        ```python\n        # GET request returns unpacked packet\n        state = await conn.request(packets.Light.GetColor())\n        color = HSBK.from_protocol(state.color)\n        label = state.label  # Already decoded to string\n\n        # SET request returns True\n        success = await conn.request(\n            packets.Light.SetColor(color=hsbk, duration=1000)\n        )\n\n        # Multi-response GET - collect multiple responses\n        states = await conn.request(\n            packets.MultiZone.GetColorZones(...), collect_multiple=True\n        )\n        if isinstance(states, list):\n            for state in states:\n                # process each zone state\n                pass\n        else:\n            # single response\n            pass\n        ```\n    \"\"\"\n\n    # Get pool and retrieve actual connection\n    pool = await self._get_pool()\n    actual_conn = await pool.get_connection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        source=self.source,\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n    )\n\n    # Get packet metadata\n    packet_kind = getattr(packet, \"_packet_kind\", \"OTHER\")\n\n    if packet_kind == \"GET\":\n        # Request response(s) - with optional multi-response collection\n        response = await actual_conn.request_response(\n            packet, timeout=timeout, collect_multiple=collect_multiple\n        )\n\n        # Use PACKET_REGISTRY to find the appropriate packet class\n        from lifx.protocol.packets import get_packet_class\n\n        # Check if we got multiple responses or a single response\n        if isinstance(response, list):\n            # Multiple responses - unpack each one\n            unpacked_responses = []\n            for header, payload in response:\n                packet_class = get_packet_class(header.pkt_type)\n                if packet_class is None:\n                    raise LifxProtocolError(\n                        f\"Unknown packet type {header.pkt_type} in response\"\n                    )\n\n                # Unpack (labels are automatically decoded by Packet.unpack())\n                response_packet = packet_class.unpack(payload)\n                unpacked_responses.append(response_packet)\n\n            # Log the full request/reply cycle (multiple responses)\n            request_values = packet.as_dict\n            reply_values_by_seq: dict[int, dict[str, Any]] = {}\n            for i, (header, _) in enumerate(response, 1):\n                resp_pkt = unpacked_responses[i - 1]\n                reply_values_by_seq[header.sequence] = resp_pkt.as_dict\n\n            _LOGGER.debug(\n                {\n                    \"class\": \"DeviceConnection\",\n                    \"method\": \"request\",\n                    \"request\": {\n                        \"packet\": type(packet).__name__,\n                        \"values\": request_values,\n                    },\n                    \"reply\": {\n                        \"packet\": type(unpacked_responses[0]).__name__\n                        if unpacked_responses\n                        else \"Unknown\",\n                        \"expected\": len(response),\n                        \"received\": len(unpacked_responses),\n                        \"values\": reply_values_by_seq,\n                    },\n                    \"serial\": self.serial,\n                    \"ip\": self.ip,\n                }\n            )\n\n            return unpacked_responses\n        else:\n            # Single response - response is tuple[LifxHeader, bytes]\n            header, payload = response\n            packet_class = get_packet_class(header.pkt_type)\n            if packet_class is None:\n                raise LifxProtocolError(\n                    f\"Unknown packet type {header.pkt_type} in response\"\n                )\n\n            # Update unknown serial with value from response header\n            serial = Serial(value=header.target_serial).to_string()\n            if self.serial == \"000000000000\" and serial != self.serial:\n                self.serial = serial\n\n            # Unpack (labels are automatically decoded by Packet.unpack())\n            response_packet = packet_class.unpack(payload)\n\n            # Log the full request/reply cycle (single response)\n            request_values = packet.as_dict\n            reply_values = response_packet.as_dict\n            _LOGGER.debug(\n                {\n                    \"class\": \"DeviceConnection\",\n                    \"method\": \"request\",\n                    \"request\": {\n                        \"packet\": type(packet).__name__,\n                        \"values\": request_values,\n                    },\n                    \"reply\": {\n                        \"packet\": type(response_packet).__name__,\n                        \"values\": reply_values,\n                    },\n                    \"serial\": self.serial,\n                    \"ip\": self.ip,\n                }\n            )\n\n            return response_packet\n\n    elif packet_kind == \"SET\":\n        # Request acknowledgement\n        await actual_conn.request_ack(packet, timeout=timeout)\n\n        # Log the full request/ack cycle\n        request_values = packet.as_dict\n        _LOGGER.debug(\n            {\n                \"class\": \"DeviceConnection\",\n                \"method\": \"request\",\n                \"request\": {\n                    \"packet\": type(packet).__name__,\n                    \"values\": request_values,\n                },\n                \"reply\": {\n                    \"packet\": \"Acknowledgement\",\n                    \"values\": {},\n                },\n                \"serial\": self.serial,\n                \"ip\": self.ip,\n            }\n        )\n\n        return True\n\n    else:\n        # Handle special cases\n        if hasattr(packet, \"PKT_TYPE\"):\n            pkt_type = packet.PKT_TYPE\n            # EchoRequest/EchoResponse (58/59)\n            if pkt_type == 58:  # EchoRequest\n                from lifx.protocol.packets import Device\n\n                response = await actual_conn.request_response(\n                    packet, timeout=timeout, collect_multiple=False\n                )\n                if not isinstance(response, tuple):\n                    raise LifxProtocolError(\n                        \"Expected single response tuple for EchoRequest\"\n                    )\n\n                header, payload = response\n                response_packet = Device.EchoResponse.unpack(payload)\n\n                # Log the full request/reply cycle\n                request_values = packet.as_dict\n                reply_values = response_packet.as_dict\n                _LOGGER.debug(\n                    {\n                        \"class\": \"DeviceConnection\",\n                        \"method\": \"request\",\n                        \"request\": {\n                            \"packet\": type(packet).__name__,\n                            \"values\": request_values,\n                        },\n                        \"reply\": {\n                            \"packet\": type(response_packet).__name__,\n                            \"values\": reply_values,\n                        },\n                        \"serial\": self.serial,\n                        \"ip\": self.ip,\n                    }\n                )\n\n                return response_packet\n            else:\n                raise LifxUnsupportedCommandError(\n                    f\"Cannot auto-handle packet kind: {packet_kind}\"\n                )\n        else:\n            raise LifxProtocolError(\n                f\"Packet missing PKT_TYPE: {type(packet).__name__}\"\n            )\n</code></pre>"},{"location":"api/network/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/network/#connection-pooling","title":"Connection Pooling","text":"<ul> <li>Connections are cached with LRU eviction</li> <li>Default pool size: 100 connections</li> <li>Idle connections are automatically closed after timeout</li> <li>Pool metrics available via <code>get_pool_metrics()</code></li> </ul>"},{"location":"api/network/#response-handling","title":"Response Handling","text":"<ul> <li>Background receiver task runs continuously</li> <li>Responses matched by sequence number</li> <li>Minimal overhead per concurrent request (~100 bytes)</li> <li>Clean shutdown on connection close</li> </ul>"},{"location":"api/network/#rate-limiting","title":"Rate Limiting","text":"<p>The library intentionally does not implement rate limiting to keep the core library simple. Applications should implement their own rate limiting if needed. According to the LIFX protocol specification, devices can handle approximately 20 messages per second.</p>"},{"location":"api/protocol/","title":"Protocol Layer","text":"<p>The protocol layer contains auto-generated structures from the official LIFX protocol specification. These classes handle binary serialization and deserialization of LIFX messages.</p> <p>!!! warning \"Auto-Generated Code\" Files in the protocol layer are automatically generated from <code>protocol.yml</code>. Never edit these files directly. To update the protocol, download the latest <code>protocol.yml</code> from the LIFX public-protocol repository and run <code>uv run python -m lifx.protocol.generator</code>.</p>"},{"location":"api/protocol/#base-packet","title":"Base Packet","text":"<p>The base class for all protocol packets.</p>"},{"location":"api/protocol/#lifx.protocol.base.Packet","title":"Packet  <code>dataclass</code>","text":"<pre><code>Packet()\n</code></pre> <p>Base class for all LIFX protocol packets.</p> <p>Each packet subclass defines: - PKT_TYPE: ClassVar[int] - The packet type number - _fields: ClassVar[list[dict]] - Field metadata from protocol.yml - Actual field attributes as dataclass fields</p> METHOD DESCRIPTION <code>pack</code> <p>Pack packet to bytes using field metadata.</p> <code>unpack</code> <p>Unpack packet from bytes using field metadata.</p> ATTRIBUTE DESCRIPTION <code>as_dict</code> <p>Return packet as dictionary.</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/protocol/#lifx.protocol.base.Packet-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.protocol.base.Packet.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: dict[str, Any]\n</code></pre> <p>Return packet as dictionary.</p>"},{"location":"api/protocol/#lifx.protocol.base.Packet-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.base.Packet.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack packet to bytes using field metadata.</p> RETURNS DESCRIPTION <code>bytes</code> <p>Packed bytes ready to send in a LIFX message payload</p> Source code in <code>src/lifx/protocol/base.py</code> <pre><code>def pack(self) -&gt; bytes:\n    \"\"\"Pack packet to bytes using field metadata.\n\n    Returns:\n        Packed bytes ready to send in a LIFX message payload\n    \"\"\"\n    from lifx.protocol import serializer\n\n    result = b\"\"\n\n    for field_item in self._fields:\n        # Handle reserved fields (no name)\n        if \"name\" not in field_item:\n            size_bytes = field_item.get(\"size_bytes\", 0)\n            result += serializer.pack_reserved(size_bytes)\n            continue\n\n        # Get field value from instance\n        field_name = self._protocol_to_python_name(field_item[\"name\"])\n        value = getattr(self, field_name)\n\n        # Pack based on type\n        field_type = field_item[\"type\"]\n        size_bytes = field_item.get(\"size_bytes\", 0)\n        result += self._pack_field_value(value, field_type, size_bytes)\n\n    return result\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.base.Packet.unpack","title":"unpack  <code>classmethod</code>","text":"<pre><code>unpack(data: bytes, offset: int = 0) -&gt; Packet\n</code></pre> <p>Unpack packet from bytes using field metadata.</p> PARAMETER DESCRIPTION <code>data</code> <p>Bytes to unpack from</p> <p> TYPE: <code>bytes</code> </p> <code>offset</code> <p>Offset in bytes to start unpacking</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>Packet</code> <p>Packet instance with label fields decoded to strings</p> Source code in <code>src/lifx/protocol/base.py</code> <pre><code>@classmethod\ndef unpack(cls, data: bytes, offset: int = 0) -&gt; Packet:\n    \"\"\"Unpack packet from bytes using field metadata.\n\n    Args:\n        data: Bytes to unpack from\n        offset: Offset in bytes to start unpacking\n\n    Returns:\n        Packet instance with label fields decoded to strings\n    \"\"\"\n    packet, _ = cls._unpack_internal(data, offset)\n\n    # Decode label fields from bytes to string in-place\n    # This ensures all State packets have human-readable labels\n    cls._decode_labels_inplace(packet)\n\n    # Log packet values after unpacking and decoding labels\n    packet_values = asdict(packet)\n    _LOGGER.debug(\n        {\n            \"class\": \"Packet\",\n            \"method\": \"unpack\",\n            \"packet_type\": type(packet).__name__,\n            \"values\": packet_values,\n        }\n    )\n\n    return packet\n</code></pre>"},{"location":"api/protocol/#protocol-header","title":"Protocol Header","text":"<p>The LIFX protocol header structure (36 bytes).</p>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader","title":"LifxHeader  <code>dataclass</code>","text":"<pre><code>LifxHeader(\n    size: int,\n    protocol: int,\n    source: int,\n    target: bytes,\n    tagged: bool,\n    ack_required: bool,\n    res_required: bool,\n    sequence: int,\n    pkt_type: int,\n)\n</code></pre> <p>LIFX protocol header (36 bytes).</p> ATTRIBUTE DESCRIPTION <code>size</code> <p>Total packet size in bytes (header + payload)</p> <p> TYPE: <code>int</code> </p> <code>protocol</code> <p>Protocol number (must be 1024)</p> <p> TYPE: <code>int</code> </p> <code>source</code> <p>Unique client identifier</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Device serial number (6 or 8 bytes, automatically padded to 8 bytes)     Note: This is the LIFX serial number, which is often but not always     the same as the device's MAC address.</p> <p> TYPE: <code>bytes</code> </p> <code>tagged</code> <p>True for broadcast discovery, False for targeted messages</p> <p> TYPE: <code>bool</code> </p> <code>ack_required</code> <p>Request acknowledgement from device</p> <p> TYPE: <code>bool</code> </p> <code>res_required</code> <p>Request response from device</p> <p> TYPE: <code>bool</code> </p> <code>sequence</code> <p>Sequence number for matching requests/responses</p> <p> TYPE: <code>int</code> </p> <code>pkt_type</code> <p>Packet type identifier</p> <p> TYPE: <code>int</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validate header fields and auto-pad serial number if needed.</p> <code>create</code> <p>Create a new LIFX header.</p> <code>pack</code> <p>Pack header into 36 bytes.</p> <code>unpack</code> <p>Unpack header from bytes.</p> <code>__repr__</code> <p>String representation of header.</p>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.target_serial","title":"target_serial  <code>property</code>","text":"<pre><code>target_serial: bytes\n</code></pre> <p>Get the 6-byte serial number without padding.</p> RETURNS DESCRIPTION <code>bytes</code> <p>6-byte serial number</p>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate header fields and auto-pad serial number if needed.</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate header fields and auto-pad serial number if needed.\"\"\"\n    # Auto-pad serial number if 6 bytes\n    if len(self.target) == 6:\n        self.target = self.target + b\"\\x00\\x00\"\n    elif len(self.target) != 8:\n        raise ValueError(f\"Target must be 6 or 8 bytes, got {len(self.target)}\")\n\n    if self.protocol != self.PROTOCOL_NUMBER:\n        raise ValueError(\n            f\"Protocol must be {self.PROTOCOL_NUMBER}, got {self.protocol}\"\n        )\n    if self.sequence &gt; 255:\n        raise ValueError(f\"Sequence must be 0-255, got {self.sequence}\")\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    pkt_type: int,\n    source: int,\n    target: bytes = b\"\\x00\" * 6,\n    tagged: bool = False,\n    ack_required: bool = False,\n    res_required: bool = True,\n    sequence: int = 0,\n    payload_size: int = 0,\n) -&gt; LifxHeader\n</code></pre> <p>Create a new LIFX header.</p> PARAMETER DESCRIPTION <code>pkt_type</code> <p>Packet type identifier</p> <p> TYPE: <code>int</code> </p> <code>source</code> <p>Unique client identifier</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Device serial number (6 or 8 bytes, defaults to broadcast)</p> <p> TYPE: <code>bytes</code> DEFAULT: <code>b'\\x00' * 6</code> </p> <code>tagged</code> <p>True for broadcast, False for targeted</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ack_required</code> <p>Request acknowledgement</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>res_required</code> <p>Request response</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sequence</code> <p>Sequence number for matching requests/responses</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>payload_size</code> <p>Size of packet payload in bytes</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>LifxHeader</code> <p>LifxHeader instance</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    pkt_type: int,\n    source: int,\n    target: bytes = b\"\\x00\" * 6,\n    tagged: bool = False,\n    ack_required: bool = False,\n    res_required: bool = True,\n    sequence: int = 0,\n    payload_size: int = 0,\n) -&gt; LifxHeader:\n    \"\"\"Create a new LIFX header.\n\n    Args:\n        pkt_type: Packet type identifier\n        source: Unique client identifier\n        target: Device serial number (6 or 8 bytes, defaults to broadcast)\n        tagged: True for broadcast, False for targeted\n        ack_required: Request acknowledgement\n        res_required: Request response\n        sequence: Sequence number for matching requests/responses\n        payload_size: Size of packet payload in bytes\n\n    Returns:\n        LifxHeader instance\n    \"\"\"\n    return cls(\n        size=cls.HEADER_SIZE + payload_size,\n        protocol=cls.PROTOCOL_NUMBER,\n        source=source,\n        target=target,  # __post_init__ will auto-pad if needed\n        tagged=tagged,\n        ack_required=ack_required,\n        res_required=res_required,\n        sequence=sequence,\n        pkt_type=pkt_type,\n    )\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack header into 36 bytes.</p> RETURNS DESCRIPTION <code>bytes</code> <p>Packed header bytes</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>def pack(self) -&gt; bytes:\n    \"\"\"Pack header into 36 bytes.\n\n    Returns:\n        Packed header bytes\n    \"\"\"\n    # Frame (8 bytes)\n    # Byte 0-1: size (uint16)\n    # Byte 2-3: origin + tagged + addressable + protocol bits\n    # Byte 4-7: source (uint32)\n\n    # Pack protocol field with flags\n    protocol_field = (\n        (self.ORIGIN &amp; 0b11) &lt;&lt; 14\n        | (int(self.tagged) &amp; 0b1) &lt;&lt; 13\n        | (self.ADDRESSABLE &amp; 0b1) &lt;&lt; 12\n        | (self.protocol &amp; 0xFFF)\n    )\n\n    frame = struct.pack(\"&lt;HHI\", self.size, protocol_field, self.source)\n\n    # Frame Address (16 bytes)\n    # Byte 0-7: target (uint64)\n    # Byte 8-13: reserved (6 bytes)\n    # Byte 14: res_required (bit 0) + ack_required (bit 1) + reserved (6 bits)\n    # Byte 15: sequence (uint8)\n\n    flags = (int(self.res_required) &amp; 0b1) | ((int(self.ack_required) &amp; 0b1) &lt;&lt; 1)\n\n    frame_addr = struct.pack(\n        \"&lt;Q6sBB\",\n        int.from_bytes(self.target, byteorder=\"little\"),\n        b\"\\x00\" * 6,  # reserved\n        flags,\n        self.sequence,\n    )\n\n    # Protocol Header (12 bytes)\n    # Byte 0-7: reserved (uint64)\n    # Byte 8-9: type (uint16)\n    # Byte 10-11: reserved (uint16)\n\n    protocol_header = struct.pack(\"&lt;QHH\", 0, self.pkt_type, 0)\n\n    return frame + frame_addr + protocol_header\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.unpack","title":"unpack  <code>classmethod</code>","text":"<pre><code>unpack(data: bytes) -&gt; LifxHeader\n</code></pre> <p>Unpack header from bytes.</p> PARAMETER DESCRIPTION <code>data</code> <p>Header bytes (at least 36 bytes)</p> <p> TYPE: <code>bytes</code> </p> RETURNS DESCRIPTION <code>LifxHeader</code> <p>LifxHeader instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If data is too short or invalid</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>@classmethod\ndef unpack(cls, data: bytes) -&gt; LifxHeader:\n    \"\"\"Unpack header from bytes.\n\n    Args:\n        data: Header bytes (at least 36 bytes)\n\n    Returns:\n        LifxHeader instance\n\n    Raises:\n        ValueError: If data is too short or invalid\n    \"\"\"\n    if len(data) &lt; cls.HEADER_SIZE:\n        raise ValueError(f\"Header data must be at least {cls.HEADER_SIZE} bytes\")\n\n    # Unpack Frame (8 bytes)\n    size, protocol_field, source = struct.unpack(\"&lt;HHI\", data[0:8])\n\n    # Extract protocol field components\n    origin = (protocol_field &gt;&gt; 14) &amp; 0b11\n    tagged = bool((protocol_field &gt;&gt; 13) &amp; 0b1)\n    addressable = bool((protocol_field &gt;&gt; 12) &amp; 0b1)\n    protocol = protocol_field &amp; 0xFFF\n\n    # Validate origin and addressable\n    if origin != cls.ORIGIN:\n        raise ValueError(f\"Invalid origin: {origin}\")\n    if not addressable:\n        raise ValueError(\"Addressable bit must be set\")\n\n    # Unpack Frame Address (16 bytes)\n    target_int, _reserved, flags, sequence = struct.unpack(\"&lt;Q6sBB\", data[8:24])\n    target = target_int.to_bytes(8, byteorder=\"little\")\n\n    res_required = bool(flags &amp; 0b1)\n    ack_required = bool((flags &gt;&gt; 1) &amp; 0b1)\n\n    # Unpack Protocol Header (12 bytes)\n    _reserved1, pkt_type, _reserved2 = struct.unpack(\"&lt;QHH\", data[24:36])\n\n    return cls(\n        size=size,\n        protocol=protocol,\n        source=source,\n        target=target,\n        tagged=tagged,\n        ack_required=ack_required,\n        res_required=res_required,\n        sequence=sequence,\n        pkt_type=pkt_type,\n    )\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation of header.</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of header.\"\"\"\n    target_serial_str = Serial(value=self.target_serial).to_string()\n    return (\n        f\"LifxHeader(type={self.pkt_type}, size={self.size}, \"\n        f\"source={self.source:#x}, target={target_serial_str}, \"\n        f\"seq={self.sequence}, tagged={self.tagged}, \"\n        f\"ack={self.ack_required}, res={self.res_required})\"\n    )\n</code></pre>"},{"location":"api/protocol/#serializer","title":"Serializer","text":"<p>Binary serialization and deserialization utilities.</p>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer","title":"FieldSerializer","text":"<pre><code>FieldSerializer(field_definitions: dict[str, dict[str, str]])\n</code></pre> <p>Serializer for structured fields with nested types.</p> PARAMETER DESCRIPTION <code>field_definitions</code> <p>Dict mapping field names to structure definitions</p> <p> TYPE: <code>dict[str, dict[str, str]]</code> </p> METHOD DESCRIPTION <code>pack_field</code> <p>Pack a structured field.</p> <code>unpack_field</code> <p>Unpack a structured field.</p> <code>get_field_size</code> <p>Get the size in bytes of a field structure.</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def __init__(self, field_definitions: dict[str, dict[str, str]]):\n    \"\"\"Initialize serializer with field definitions.\n\n    Args:\n        field_definitions: Dict mapping field names to structure definitions\n    \"\"\"\n    self.field_definitions = field_definitions\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer.pack_field","title":"pack_field","text":"<pre><code>pack_field(field_data: dict[str, Any], field_name: str) -&gt; bytes\n</code></pre> <p>Pack a structured field.</p> PARAMETER DESCRIPTION <code>field_data</code> <p>Dictionary of field values</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>field_name</code> <p>Name of the field structure (e.g., \"HSBK\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>Packed bytes</p> RAISES DESCRIPTION <code>ValueError</code> <p>If field_name is unknown</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def pack_field(self, field_data: dict[str, Any], field_name: str) -&gt; bytes:\n    \"\"\"Pack a structured field.\n\n    Args:\n        field_data: Dictionary of field values\n        field_name: Name of the field structure (e.g., \"HSBK\")\n\n    Returns:\n        Packed bytes\n\n    Raises:\n        ValueError: If field_name is unknown\n    \"\"\"\n    if field_name not in self.field_definitions:\n        raise ValueError(f\"Unknown field: {field_name}\")\n\n    field_def = self.field_definitions[field_name]\n    result = b\"\"\n\n    for attr_name, attr_type in field_def.items():\n        if attr_name not in field_data:\n            raise ValueError(f\"Missing attribute {attr_name} in {field_name}\")\n        result += pack_value(field_data[attr_name], attr_type)\n\n    return result\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer.unpack_field","title":"unpack_field","text":"<pre><code>unpack_field(\n    data: bytes, field_name: str, offset: int = 0\n) -&gt; tuple[dict[str, Any], int]\n</code></pre> <p>Unpack a structured field.</p> PARAMETER DESCRIPTION <code>data</code> <p>Bytes to unpack from</p> <p> TYPE: <code>bytes</code> </p> <code>field_name</code> <p>Name of the field structure</p> <p> TYPE: <code>str</code> </p> <code>offset</code> <p>Offset to start unpacking</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>tuple[dict[str, Any], int]</code> <p>Tuple of (field_dict, new_offset)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If field_name is unknown</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def unpack_field(\n    self, data: bytes, field_name: str, offset: int = 0\n) -&gt; tuple[dict[str, Any], int]:\n    \"\"\"Unpack a structured field.\n\n    Args:\n        data: Bytes to unpack from\n        field_name: Name of the field structure\n        offset: Offset to start unpacking\n\n    Returns:\n        Tuple of (field_dict, new_offset)\n\n    Raises:\n        ValueError: If field_name is unknown\n    \"\"\"\n    if field_name not in self.field_definitions:\n        raise ValueError(f\"Unknown field: {field_name}\")\n\n    field_def = self.field_definitions[field_name]\n    field_data: dict[str, Any] = {}\n    current_offset = offset\n\n    for attr_name, attr_type in field_def.items():\n        value, current_offset = unpack_value(data, attr_type, current_offset)\n        field_data[attr_name] = value\n\n    return field_data, current_offset\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer.get_field_size","title":"get_field_size","text":"<pre><code>get_field_size(field_name: str) -&gt; int\n</code></pre> <p>Get the size in bytes of a field structure.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>Name of the field structure</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Size in bytes</p> RAISES DESCRIPTION <code>ValueError</code> <p>If field_name is unknown</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def get_field_size(self, field_name: str) -&gt; int:\n    \"\"\"Get the size in bytes of a field structure.\n\n    Args:\n        field_name: Name of the field structure\n\n    Returns:\n        Size in bytes\n\n    Raises:\n        ValueError: If field_name is unknown\n    \"\"\"\n    if field_name not in self.field_definitions:\n        raise ValueError(f\"Unknown field: {field_name}\")\n\n    field_def = self.field_definitions[field_name]\n    return sum(TYPE_SIZES[attr_type] for attr_type in field_def.values())\n</code></pre>"},{"location":"api/protocol/#protocol-types","title":"Protocol Types","text":"<p>Common protocol type definitions and enums.</p>"},{"location":"api/protocol/#hsbk-type","title":"HSBK Type","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk","title":"LightHsbk  <code>dataclass</code>","text":"<pre><code>LightHsbk(hue: int, saturation: int, brightness: int, kelvin: int)\n</code></pre> <p>Auto-generated field structure.</p> METHOD DESCRIPTION <code>pack</code> <p>Pack to bytes.</p> <code>unpack</code> <p>Unpack from bytes.</p>"},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack to bytes.</p> Source code in <code>src/lifx/protocol/protocol_types.py</code> <pre><code>def pack(self) -&gt; bytes:\n    \"\"\"Pack to bytes.\"\"\"\n    from lifx.protocol import serializer\n\n    result = b\"\"\n\n    # hue: uint16\n    result += serializer.pack_value(self.hue, \"uint16\")\n    # saturation: uint16\n    result += serializer.pack_value(self.saturation, \"uint16\")\n    # brightness: uint16\n    result += serializer.pack_value(self.brightness, \"uint16\")\n    # kelvin: uint16\n    result += serializer.pack_value(self.kelvin, \"uint16\")\n\n    return result\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk.unpack","title":"unpack  <code>classmethod</code>","text":"<pre><code>unpack(data: bytes, offset: int = 0) -&gt; tuple[LightHsbk, int]\n</code></pre> <p>Unpack from bytes.</p> Source code in <code>src/lifx/protocol/protocol_types.py</code> <pre><code>@classmethod\ndef unpack(cls, data: bytes, offset: int = 0) -&gt; tuple[LightHsbk, int]:\n    \"\"\"Unpack from bytes.\"\"\"\n    from lifx.protocol import serializer\n\n    current_offset = offset\n    # hue: uint16\n    hue, current_offset = serializer.unpack_value(data, \"uint16\", current_offset)\n    # saturation: uint16\n    saturation, current_offset = serializer.unpack_value(\n        data, \"uint16\", current_offset\n    )\n    # brightness: uint16\n    brightness, current_offset = serializer.unpack_value(\n        data, \"uint16\", current_offset\n    )\n    # kelvin: uint16\n    kelvin, current_offset = serializer.unpack_value(data, \"uint16\", current_offset)\n\n    return cls(\n        hue=hue, saturation=saturation, brightness=brightness, kelvin=kelvin\n    ), current_offset\n</code></pre>"},{"location":"api/protocol/#light-waveform","title":"Light Waveform","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.LightWaveform","title":"LightWaveform","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#device-service","title":"Device Service","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.DeviceService","title":"DeviceService","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#multizone-application-request","title":"MultiZone Application Request","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.MultiZoneApplicationRequest","title":"MultiZoneApplicationRequest","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#multizone-effect-type","title":"MultiZone Effect Type","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.MultiZoneEffectType","title":"MultiZoneEffectType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#tile-effect-type","title":"Tile Effect Type","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.TileEffectType","title":"TileEffectType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#packet-definitions","title":"Packet Definitions","text":"<p>The protocol layer includes packet definitions for all LIFX message types. Major categories include:</p>"},{"location":"api/protocol/#device-messages","title":"Device Messages","text":"<ul> <li><code>DeviceGetService</code> / <code>DeviceStateService</code> - Service discovery</li> <li><code>DeviceGetLabel</code> / <code>DeviceStateLabel</code> - Device labels</li> <li><code>DeviceGetPower</code> / <code>DeviceSetPower</code> / <code>DeviceStatePower</code> - Power control</li> <li><code>DeviceGetVersion</code> / <code>DeviceStateVersion</code> - Firmware version</li> <li><code>DeviceGetLocation</code> / <code>DeviceStateLocation</code> - Location groups</li> <li><code>DeviceGetGroup</code> / <code>DeviceStateGroup</code> - Device groups</li> <li><code>DeviceGetInfo</code> / <code>DeviceStateInfo</code> - Runtime info (uptime, downtime)</li> </ul>"},{"location":"api/protocol/#light-messages","title":"Light Messages","text":"<ul> <li><code>LightGet</code> / <code>LightState</code> - Get/set light state</li> <li><code>LightSetColor</code> - Set color with transition</li> <li><code>LightSetWaveform</code> - Waveform effects (pulse, breathe)</li> <li><code>LightGetPower</code> / <code>LightSetPower</code> / <code>LightStatePower</code> - Light power control</li> <li><code>LightGetInfrared</code> / <code>LightSetInfrared</code> / <code>LightStateInfrared</code> - Infrared control</li> </ul>"},{"location":"api/protocol/#multizone-messages","title":"MultiZone Messages","text":"<ul> <li><code>MultiZoneGetColorZones</code> / <code>MultiZoneStateZone</code> / <code>MultiZoneStateMultiZone</code> - Zone state</li> <li><code>MultiZoneSetColorZones</code> - Set zone colors</li> <li><code>MultiZoneGetMultiZoneEffect</code> / <code>MultiZoneSetMultiZoneEffect</code> - Zone effects</li> </ul>"},{"location":"api/protocol/#tile-messages","title":"Tile Messages","text":"<ul> <li><code>TileGetDeviceChain</code> / <code>TileStateDeviceChain</code> - Tile chain info</li> <li><code>TileGet64</code> / <code>TileState64</code> - Get tile state</li> <li><code>TileSet64</code> - Set tile colors</li> <li><code>TileGetTileEffect</code> / <code>TileSetTileEffect</code> - Tile effects</li> </ul>"},{"location":"api/protocol/#protocol-models","title":"Protocol Models","text":"<p>Protocol data models for working with LIFX serial numbers and HEV cycles.</p>"},{"location":"api/protocol/#serial","title":"Serial","text":"<p>Type-safe, immutable serial number handling:</p>"},{"location":"api/protocol/#lifx.protocol.models.Serial","title":"Serial  <code>dataclass</code>","text":"<pre><code>Serial(value: bytes)\n</code></pre> <p>LIFX device serial number.</p> <p>Encapsulates a device serial number with conversion methods for different formats. The LIFX serial number is often the same as the device's MAC address, but can differ (particularly the least significant byte may be off by one).</p> ATTRIBUTE DESCRIPTION <code>value</code> <p>Serial number as 6 bytes</p> <p> TYPE: <code>bytes</code> </p> Example <pre><code># Create from string\nserial = Serial.from_string(\"d073d5123456\")\n\n# Convert to protocol format (8 bytes with padding)\nprotocol_bytes = serial.to_protocol()\n\n# Convert to string\nserial_str = serial.to_string()  # \"d073d5123456\"\n\n# Create from protocol format\nserial2 = Serial.from_protocol(protocol_bytes)\n</code></pre> METHOD DESCRIPTION <code>__post_init__</code> <p>Validate serial number after initialization.</p> <code>from_string</code> <p>Create Serial from string format.</p> <code>from_protocol</code> <p>Create Serial from protocol format (8 bytes with padding).</p> <code>to_string</code> <p>Convert serial to 12-digit hex string format.</p> <code>to_protocol</code> <p>Convert serial to 8-byte protocol format with padding.</p> <code>__str__</code> <p>Return string representation.</p> <code>__repr__</code> <p>Return detailed representation.</p>"},{"location":"api/protocol/#lifx.protocol.models.Serial-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.models.Serial.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate serial number after initialization.</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate serial number after initialization.\"\"\"\n    self._validate_type(self.value)\n    self._validate_length(self.value)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(serial: str) -&gt; Serial\n</code></pre> <p>Create Serial from string format.</p> <p>Accepts 12-digit hex string (with or without separators).</p> PARAMETER DESCRIPTION <code>serial</code> <p>12-digit hex string (e.g., \"d073d5123456\" or \"d0:73:d5:12:34:56\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Serial</code> <p>Serial instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If serial number is invalid</p> <code>TypeError</code> <p>If serial is not a string</p> Example <p>Serial.from_string(\"d073d5123456\") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56') Serial.from_string(\"d0:73:d5:12:34:56\")  # Also accepts separators Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>@classmethod\ndef from_string(cls, serial: str) -&gt; Serial:\n    \"\"\"Create Serial from string format.\n\n    Accepts 12-digit hex string (with or without separators).\n\n    Args:\n        serial: 12-digit hex string (e.g., \"d073d5123456\" or \"d0:73:d5:12:34:56\")\n\n    Returns:\n        Serial instance\n\n    Raises:\n        ValueError: If serial number is invalid\n        TypeError: If serial is not a string\n\n    Example:\n        &gt;&gt;&gt; Serial.from_string(\"d073d5123456\")\n        Serial(value=b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56')\n        &gt;&gt;&gt; Serial.from_string(\"d0:73:d5:12:34:56\")  # Also accepts separators\n        Serial(value=b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56')\n    \"\"\"\n    cls._validate_string_type(serial)\n    serial_clean = cls._remove_separators(serial)\n    cls._validate_hex_length(serial_clean)\n    serial_bytes = cls._parse_hex(serial_clean)\n\n    return cls(value=serial_bytes)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.from_protocol","title":"from_protocol  <code>classmethod</code>","text":"<pre><code>from_protocol(padded_serial: bytes) -&gt; Serial\n</code></pre> <p>Create Serial from protocol format (8 bytes with padding).</p> <p>The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.</p> PARAMETER DESCRIPTION <code>padded_serial</code> <p>8-byte serial number from protocol</p> <p> TYPE: <code>bytes</code> </p> RETURNS DESCRIPTION <code>Serial</code> <p>Serial instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If padded serial is not 8 bytes</p> Example <p>Serial.from_protocol(b\"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00\") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>@classmethod\ndef from_protocol(cls, padded_serial: bytes) -&gt; Serial:\n    \"\"\"Create Serial from protocol format (8 bytes with padding).\n\n    The LIFX protocol uses 8 bytes for the target field, with the serial number\n    in the first 6 bytes and 2 bytes of padding (zeros) at the end.\n\n    Args:\n        padded_serial: 8-byte serial number from protocol\n\n    Returns:\n        Serial instance\n\n    Raises:\n        ValueError: If padded serial is not 8 bytes\n\n    Example:\n        &gt;&gt;&gt; Serial.from_protocol(b\"\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56\\\\x00\\\\x00\")\n        Serial(value=b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56')\n    \"\"\"\n    if len(padded_serial) != 8:\n        raise ValueError(\n            f\"Padded serial number must be 8 bytes, got {len(padded_serial)}\"\n        )\n\n    # Extract first 6 bytes\n    return cls(value=padded_serial[:6])\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Convert serial to 12-digit hex string format.</p> RETURNS DESCRIPTION <code>str</code> <p>Serial number string in format \"xxxxxxxxxxxx\" (12 hex digits, no separators)</p> Example <p>serial = Serial.from_string(\"d073d5123456\") serial.to_string() 'd073d5123456'</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Convert serial to 12-digit hex string format.\n\n    Returns:\n        Serial number string in format \"xxxxxxxxxxxx\" (12 hex digits, no separators)\n\n    Example:\n        &gt;&gt;&gt; serial = Serial.from_string(\"d073d5123456\")\n        &gt;&gt;&gt; serial.to_string()\n        'd073d5123456'\n    \"\"\"\n    return self.value.hex()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.to_protocol","title":"to_protocol","text":"<pre><code>to_protocol() -&gt; bytes\n</code></pre> <p>Convert serial to 8-byte protocol format with padding.</p> <p>The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.</p> RETURNS DESCRIPTION <code>bytes</code> <p>8-byte serial number with padding (suitable for protocol)</p> Example <p>serial = Serial.from_string(\"d073d5123456\") serial.to_protocol() b'\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00'</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def to_protocol(self) -&gt; bytes:\n    \"\"\"Convert serial to 8-byte protocol format with padding.\n\n    The LIFX protocol uses 8 bytes for the target field, with the serial number\n    in the first 6 bytes and 2 bytes of padding (zeros) at the end.\n\n    Returns:\n        8-byte serial number with padding (suitable for protocol)\n\n    Example:\n        &gt;&gt;&gt; serial = Serial.from_string(\"d073d5123456\")\n        &gt;&gt;&gt; serial.to_protocol()\n        b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56\\\\x00\\\\x00'\n    \"\"\"\n    return self.value + b\"\\x00\\x00\"\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return detailed representation.</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return detailed representation.\"\"\"\n    return f\"Serial('{self.to_string()}')\"\n</code></pre>"},{"location":"api/protocol/#hev-cycle-state","title":"HEV Cycle State","text":"<p>HEV (High Energy Visible) cleaning cycle state:</p>"},{"location":"api/protocol/#lifx.protocol.models.HevCycleState","title":"HevCycleState  <code>dataclass</code>","text":"<pre><code>HevCycleState(duration_s: int, remaining_s: int, last_power: bool)\n</code></pre> <p>HEV cleaning cycle state.</p> <p>Represents the current state of a HEV (High Energy Visible) cleaning cycle, which uses anti-bacterial UV-C light to sanitize the environment.</p> ATTRIBUTE DESCRIPTION <code>duration_s</code> <p>Total duration of the cycle in seconds</p> <p> TYPE: <code>int</code> </p> <code>remaining_s</code> <p>Remaining time in the current cycle (0 if not running)</p> <p> TYPE: <code>int</code> </p> <code>last_power</code> <p>Whether the light was on during the last cycle</p> <p> TYPE: <code>bool</code> </p> Example <pre><code># Check if HEV cycle is running\nstate = await hev_light.get_hev_cycle()\nif state.remaining_s &gt; 0:\n    print(f\"Cleaning in progress: {state.remaining_s}s remaining\")\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.HevCycleState-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.protocol.models.HevCycleState.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Check if a HEV cycle is currently running.</p>"},{"location":"api/protocol/#hev-configuration","title":"HEV Configuration","text":"<p>HEV cycle configuration:</p>"},{"location":"api/protocol/#lifx.protocol.models.HevConfig","title":"HevConfig  <code>dataclass</code>","text":"<pre><code>HevConfig(indication: bool, duration_s: int)\n</code></pre> <p>HEV cycle configuration.</p> <p>Configuration settings for HEV cleaning cycles.</p> ATTRIBUTE DESCRIPTION <code>indication</code> <p>Whether to show visual indication during cleaning</p> <p> TYPE: <code>bool</code> </p> <code>duration_s</code> <p>Default duration for cleaning cycles in seconds</p> <p> TYPE: <code>int</code> </p> Example <pre><code># Configure HEV cycle with 2-hour duration and visual indication\nawait hev_light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre>"},{"location":"api/protocol/#code-generator","title":"Code Generator","text":"<p>The protocol generator reads <code>protocol.yml</code> and generates Python code.</p>"},{"location":"api/protocol/#lifx.protocol.generator","title":"generator","text":"<p>Code generator for LIFX protocol structures.</p> <p>Downloads the official protocol.yml from the LIFX GitHub repository and generates Python types and packet classes. The YAML is never stored locally, only parsed and converted into protocol classes.</p> CLASS DESCRIPTION <code>TypeRegistry</code> <p>Registry of all protocol types for validation.</p> FUNCTION DESCRIPTION <code>to_snake_case</code> <p>Convert PascalCase or camelCase to snake_case.</p> <code>apply_field_name_quirks</code> <p>Apply quirks to field names to avoid Python built-ins and reserved words.</p> <code>apply_extended_multizone_packet_quirks</code> <p>Apply quirks to extended multizone packet names to follow LIFX naming convention.</p> <code>format_long_import</code> <p>Format a long import statement across multiple lines.</p> <code>format_long_list</code> <p>Format a long list across multiple lines.</p> <code>parse_field_type</code> <p>Parse a field type string.</p> <code>camel_to_snake_upper</code> <p>Convert CamelCase to UPPER_SNAKE_CASE.</p> <code>generate_enum_code</code> <p>Generate Python Enum definitions with shortened names.</p> <code>convert_type_to_python</code> <p>Convert a protocol field type to Python type annotation.</p> <code>generate_pack_method</code> <p>Generate pack() method code for a field structure or packet.</p> <code>generate_unpack_method</code> <p>Generate unpack() classmethod code for a field structure or packet.</p> <code>generate_field_code</code> <p>Generate Python dataclass definitions for field structures.</p> <code>generate_nested_packet_code</code> <p>Generate nested Python packet class definitions.</p> <code>generate_types_file</code> <p>Generate complete types.py file.</p> <code>generate_packets_file</code> <p>Generate complete packets.py file.</p> <code>download_protocol</code> <p>Download and parse protocol.yml from LIFX GitHub repository.</p> <code>validate_protocol_spec</code> <p>Validate protocol specification for missing type references.</p> <code>should_skip_button_relay</code> <p>Check if a name should be skipped (Button or Relay related).</p> <code>filter_button_relay_items</code> <p>Filter out Button and Relay items from a dictionary.</p> <code>filter_button_relay_packets</code> <p>Filter out button and relay category packets.</p> <code>extract_packets_as_fields</code> <p>Extract packets that are used as field types in other structures.</p> <code>main</code> <p>Main generator entry point.</p>"},{"location":"api/protocol/#lifx.protocol.generator-classes","title":"Classes","text":""},{"location":"api/protocol/#lifx.protocol.generator.TypeRegistry","title":"TypeRegistry","text":"<pre><code>TypeRegistry()\n</code></pre> <p>Registry of all protocol types for validation.</p> <p>Tracks all defined types (enums, fields, packets, unions) to validate that all type references in the protocol specification are valid.</p> METHOD DESCRIPTION <code>register_enum</code> <p>Register an enum type.</p> <code>register_field</code> <p>Register a field structure type.</p> <code>register_packet</code> <p>Register a packet type.</p> <code>register_union</code> <p>Register a union type.</p> <code>is_enum</code> <p>Check if a type is an enum.</p> <code>has_type</code> <p>Check if a type is defined.</p> <code>get_all_types</code> <p>Get all registered types.</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize empty type registry.\"\"\"\n    self._enums: set[str] = set()\n    self._fields: set[str] = set()\n    self._packets: set[str] = set()\n    self._unions: set[str] = set()\n    self._basic_types: set[str] = {\n        \"uint8\",\n        \"uint16\",\n        \"uint32\",\n        \"uint64\",\n        \"int8\",\n        \"int16\",\n        \"int32\",\n        \"int64\",\n        \"float32\",\n        \"bool\",\n        \"byte\",\n        \"reserved\",  # Special type for reserved fields\n    }\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.TypeRegistry-functions","title":"Functions","text":"register_enum \u00b6 <pre><code>register_enum(name: str) -&gt; None\n</code></pre> <p>Register an enum type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Enum type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_enum(self, name: str) -&gt; None:\n    \"\"\"Register an enum type.\n\n    Args:\n        name: Enum type name\n    \"\"\"\n    self._enums.add(name)\n</code></pre> <code></code> register_field \u00b6 <pre><code>register_field(name: str) -&gt; None\n</code></pre> <p>Register a field structure type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Field structure type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_field(self, name: str) -&gt; None:\n    \"\"\"Register a field structure type.\n\n    Args:\n        name: Field structure type name\n    \"\"\"\n    self._fields.add(name)\n</code></pre> <code></code> register_packet \u00b6 <pre><code>register_packet(name: str) -&gt; None\n</code></pre> <p>Register a packet type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Packet type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_packet(self, name: str) -&gt; None:\n    \"\"\"Register a packet type.\n\n    Args:\n        name: Packet type name\n    \"\"\"\n    self._packets.add(name)\n</code></pre> <code></code> register_union \u00b6 <pre><code>register_union(name: str) -&gt; None\n</code></pre> <p>Register a union type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Union type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_union(self, name: str) -&gt; None:\n    \"\"\"Register a union type.\n\n    Args:\n        name: Union type name\n    \"\"\"\n    self._unions.add(name)\n</code></pre> <code></code> is_enum \u00b6 <pre><code>is_enum(name: str) -&gt; bool\n</code></pre> <p>Check if a type is an enum.</p> PARAMETER DESCRIPTION <code>name</code> <p>Type name to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the type is an enum</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def is_enum(self, name: str) -&gt; bool:\n    \"\"\"Check if a type is an enum.\n\n    Args:\n        name: Type name to check\n\n    Returns:\n        True if the type is an enum\n    \"\"\"\n    return name in self._enums\n</code></pre> <code></code> has_type \u00b6 <pre><code>has_type(name: str) -&gt; bool\n</code></pre> <p>Check if a type is defined.</p> PARAMETER DESCRIPTION <code>name</code> <p>Type name to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the type is defined</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def has_type(self, name: str) -&gt; bool:\n    \"\"\"Check if a type is defined.\n\n    Args:\n        name: Type name to check\n\n    Returns:\n        True if the type is defined\n    \"\"\"\n    return (\n        name in self._enums\n        or name in self._fields\n        or name in self._packets\n        or name in self._unions\n        or name in self._basic_types\n    )\n</code></pre> <code></code> get_all_types \u00b6 <pre><code>get_all_types() -&gt; set[str]\n</code></pre> <p>Get all registered types.</p> RETURNS DESCRIPTION <code>set[str]</code> <p>Set of all type names</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def get_all_types(self) -&gt; set[str]:\n    \"\"\"Get all registered types.\n\n    Returns:\n        Set of all type names\n    \"\"\"\n    return (\n        self._enums\n        | self._fields\n        | self._packets\n        | self._unions\n        | self._basic_types\n    )\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.generator.to_snake_case","title":"to_snake_case","text":"<pre><code>to_snake_case(name: str) -&gt; str\n</code></pre> <p>Convert PascalCase or camelCase to snake_case.</p> PARAMETER DESCRIPTION <code>name</code> <p>PascalCase or camelCase string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>snake_case string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def to_snake_case(name: str) -&gt; str:\n    \"\"\"Convert PascalCase or camelCase to snake_case.\n\n    Args:\n        name: PascalCase or camelCase string\n\n    Returns:\n        snake_case string\n    \"\"\"\n    # Insert underscore before uppercase letters (except at start)\n    snake = re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", name)\n    return snake.lower()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_field_name_quirks","title":"apply_field_name_quirks","text":"<pre><code>apply_field_name_quirks(python_name: str) -&gt; str\n</code></pre> <p>Apply quirks to field names to avoid Python built-ins and reserved words.</p> PARAMETER DESCRIPTION <code>python_name</code> <p>The Python field name (usually from to_snake_case)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Quirk-adjusted field name</p> Quirks applied <ul> <li>\"type\" -&gt; \"effect_type\" (avoids Python built-in)</li> </ul> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_field_name_quirks(python_name: str) -&gt; str:\n    \"\"\"Apply quirks to field names to avoid Python built-ins and reserved words.\n\n    Args:\n        python_name: The Python field name (usually from to_snake_case)\n\n    Returns:\n        Quirk-adjusted field name\n\n    Quirks applied:\n        - \"type\" -&gt; \"effect_type\" (avoids Python built-in)\n    \"\"\"\n    if python_name == \"type\":\n        return \"effect_type\"\n    return python_name\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_extended_multizone_packet_quirks","title":"apply_extended_multizone_packet_quirks","text":"<pre><code>apply_extended_multizone_packet_quirks(\n    packet_name: str, category_class: str\n) -&gt; str\n</code></pre> <p>Apply quirks to extended multizone packet names to follow LIFX naming convention.</p> <p>In the LIFX protocol, extended multizone packets should follow the standard naming pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).</p> PARAMETER DESCRIPTION <code>packet_name</code> <p>Packet name (after category prefix removal)</p> <p> TYPE: <code>str</code> </p> <code>category_class</code> <p>Category class name (e.g., \"MultiZone\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Quirk-adjusted packet name</p> Quirks applied <ul> <li>\"ExtendedGetColorZones\" -&gt; \"GetExtendedColorZones\"</li> <li>\"ExtendedSetColorZones\" -&gt; \"SetExtendedColorZones\"</li> <li>\"ExtendedStateMultiZone\" -&gt; \"StateExtendedColorZones\"</li> </ul> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_extended_multizone_packet_quirks(\n    packet_name: str, category_class: str\n) -&gt; str:\n    \"\"\"Apply quirks to extended multizone packet names to follow LIFX naming convention.\n\n    In the LIFX protocol, extended multizone packets should follow the standard naming\n    pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).\n\n    Args:\n        packet_name: Packet name (after category prefix removal)\n        category_class: Category class name (e.g., \"MultiZone\")\n\n    Returns:\n        Quirk-adjusted packet name\n\n    Quirks applied:\n        - \"ExtendedGetColorZones\" -&gt; \"GetExtendedColorZones\"\n        - \"ExtendedSetColorZones\" -&gt; \"SetExtendedColorZones\"\n        - \"ExtendedStateMultiZone\" -&gt; \"StateExtendedColorZones\"\n    \"\"\"\n    if category_class == \"MultiZone\":\n        if packet_name == \"ExtendedGetColorZones\":\n            return \"GetExtendedColorZones\"\n        elif packet_name == \"ExtendedSetColorZones\":\n            return \"SetExtendedColorZones\"\n        elif packet_name == \"ExtendedStateMultiZone\":\n            return \"StateExtendedColorZones\"\n    return packet_name\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.format_long_import","title":"format_long_import","text":"<pre><code>format_long_import(\n    items: list[str], prefix: str = \"from lifx.protocol.protocol_types import \"\n) -&gt; str\n</code></pre> <p>Format a long import statement across multiple lines.</p> PARAMETER DESCRIPTION <code>items</code> <p>List of import items (e.g., [\"Foo\", \"Bar as BazAlias\"])</p> <p> TYPE: <code>list[str]</code> </p> <code>prefix</code> <p>Import prefix</p> <p> TYPE: <code>str</code> DEFAULT: <code>'from lifx.protocol.protocol_types import '</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted import string with line breaks if needed</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def format_long_import(\n    items: list[str], prefix: str = \"from lifx.protocol.protocol_types import \"\n) -&gt; str:\n    \"\"\"Format a long import statement across multiple lines.\n\n    Args:\n        items: List of import items (e.g., [\"Foo\", \"Bar as BazAlias\"])\n        prefix: Import prefix\n\n    Returns:\n        Formatted import string with line breaks if needed\n    \"\"\"\n    if not items:\n        return \"\"\n\n    # Try single line first\n    single_line = prefix + \", \".join(items)\n    if len(single_line) &lt;= 120:\n        return single_line + \"\\n\"\n\n    # Multi-line format\n    lines = [prefix + \"(\"]\n    for i, item in enumerate(items):\n        if i &lt; len(items) - 1:\n            lines.append(f\"    {item},\")\n        else:\n            lines.append(f\"    {item},\")\n    lines.append(\")\")\n    return \"\\n\".join(lines) + \"\\n\"\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.format_long_list","title":"format_long_list","text":"<pre><code>format_long_list(\n    items: list[dict[str, Any]], max_line_length: int = 120\n) -&gt; str\n</code></pre> <p>Format a long list across multiple lines.</p> PARAMETER DESCRIPTION <code>items</code> <p>List of dict items to format</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>max_line_length</code> <p>Maximum line length before wrapping</p> <p> TYPE: <code>int</code> DEFAULT: <code>120</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted list string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def format_long_list(items: list[dict[str, Any]], max_line_length: int = 120) -&gt; str:\n    \"\"\"Format a long list across multiple lines.\n\n    Args:\n        items: List of dict items to format\n        max_line_length: Maximum line length before wrapping\n\n    Returns:\n        Formatted list string\n    \"\"\"\n    if not items:\n        return \"[]\"\n\n    # Try single line first\n    single_line = repr(items)\n    if len(single_line) &lt;= max_line_length:\n        return single_line\n\n    # Multi-line format with one item per line\n    lines = [\"[\"]\n    for i, item in enumerate(items):\n        item_str = repr(item)\n        if i &lt; len(items) - 1:\n            lines.append(f\"    {item_str},\")\n        else:\n            lines.append(f\"    {item_str},\")\n    lines.append(\"]\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.parse_field_type","title":"parse_field_type","text":"<pre><code>parse_field_type(field_type: str) -&gt; tuple[str, int | None, bool]\n</code></pre> <p>Parse a field type string.</p> PARAMETER DESCRIPTION <code>field_type</code> <p>Field type (e.g., 'uint16', '[32]uint8', '') <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Tuple of (base_type, array_count, is_nested)</p> <code>int | None</code> <ul> <li>base_type: The base type name</li> </ul> <code>bool</code> <ul> <li>array_count: Number of elements if array, None otherwise</li> </ul> <code>tuple[str, int | None, bool]</code> <ul> <li>is_nested: True if it's a nested structure () Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def parse_field_type(field_type: str) -&gt; tuple[str, int | None, bool]:\n    \"\"\"Parse a field type string.\n\n    Args:\n        field_type: Field type (e.g., 'uint16', '[32]uint8', '&lt;HSBK&gt;')\n\n    Returns:\n        Tuple of (base_type, array_count, is_nested)\n        - base_type: The base type name\n        - array_count: Number of elements if array, None otherwise\n        - is_nested: True if it's a nested structure (&lt;Type&gt;)\n    \"\"\"\n    # Check for array: [N]type\n    array_match = re.match(r\"\\[(\\d+)\\](.+)\", field_type)\n    if array_match:\n        count = int(array_match.group(1))\n        inner_type = array_match.group(2)\n        # Check if inner type is nested\n        if inner_type.startswith(\"&lt;\") and inner_type.endswith(\"&gt;\"):\n            return inner_type[1:-1], count, True\n        return inner_type, count, False\n\n    # Check for nested structure: &lt;Type&gt;\n    if field_type.startswith(\"&lt;\") and field_type.endswith(\"&gt;\"):\n        return field_type[1:-1], None, True\n\n    # Simple type\n    return field_type, None, False\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.camel_to_snake_upper","title":"camel_to_snake_upper","text":"<pre><code>camel_to_snake_upper(name: str) -&gt; str\n</code></pre> <p>Convert CamelCase to UPPER_SNAKE_CASE.</p> PARAMETER DESCRIPTION <code>name</code> <p>CamelCase string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>UPPER_SNAKE_CASE string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def camel_to_snake_upper(name: str) -&gt; str:\n    \"\"\"Convert CamelCase to UPPER_SNAKE_CASE.\n\n    Args:\n        name: CamelCase string\n\n    Returns:\n        UPPER_SNAKE_CASE string\n    \"\"\"\n    # Insert underscore before uppercase letters (except at start)\n    snake = re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", name)\n    return snake.upper()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_enum_code","title":"generate_enum_code","text":"<pre><code>generate_enum_code(enums: dict[str, Any]) -&gt; str\n</code></pre> <p>Generate Python Enum definitions with shortened names.</p> PARAMETER DESCRIPTION <code>enums</code> <p>Dictionary of enum definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python code string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_enum_code(enums: dict[str, Any]) -&gt; str:\n    \"\"\"Generate Python Enum definitions with shortened names.\n\n    Args:\n        enums: Dictionary of enum definitions\n\n    Returns:\n        Python code string\n    \"\"\"\n    code: list[str] = []\n\n    for enum_name, enum_def in sorted(enums.items()):\n        code.append(f\"class {enum_name}(IntEnum):\")\n        code.append('    \"\"\"Auto-generated enum.\"\"\"')\n        code.append(\"\")\n\n        # Handle both old format (dict) and new format (list of dicts)\n        if isinstance(enum_def, dict) and \"values\" in enum_def:\n            # New format: {type: \"uint16\", values: [{name: \"X\", value: 1}, ...]}\n            values = enum_def[\"values\"]\n            reserved_counter = 0\n\n            # Check if all values share a common prefix (enum name)\n            expected_prefix = camel_to_snake_upper(enum_name) + \"_\"\n            non_reserved = [\n                item[\"name\"] for item in values if item[\"name\"].lower() != \"reserved\"\n            ]\n            has_common_prefix = non_reserved and all(\n                name.startswith(expected_prefix) for name in non_reserved\n            )\n\n            for item in sorted(values, key=lambda x: x[\"value\"]):\n                protocol_name = item[\"name\"]\n                member_value = item[\"value\"]\n\n                # Handle reserved fields by making names unique\n                if protocol_name.lower() == \"reserved\":\n                    member_name = f\"RESERVED_{reserved_counter}\"\n                    reserved_counter += 1\n                # Remove redundant prefix for cleaner Python names\n                elif has_common_prefix and protocol_name.startswith(expected_prefix):\n                    member_name = protocol_name[len(expected_prefix) :]\n                else:\n                    member_name = protocol_name\n\n                code.append(f\"    {member_name} = {member_value}\")\n        else:\n            # Old format: {MEMBER: value, ...}\n            for member_name, member_value in sorted(\n                enum_def.items(), key=lambda x: x[1]\n            ):\n                code.append(f\"    {member_name} = {member_value}\")\n\n        code.append(\"\")\n        code.append(\"\")\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.convert_type_to_python","title":"convert_type_to_python","text":"<pre><code>convert_type_to_python(\n    field_type: str, type_aliases: dict[str, str] | None = None\n) -&gt; str\n</code></pre> <p>Convert a protocol field type to Python type annotation.</p> PARAMETER DESCRIPTION <code>field_type</code> <p>Protocol field type string</p> <p> TYPE: <code>str</code> </p> <code>type_aliases</code> <p>Optional dict for type name aliases</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python type annotation string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def convert_type_to_python(\n    field_type: str, type_aliases: dict[str, str] | None = None\n) -&gt; str:\n    \"\"\"Convert a protocol field type to Python type annotation.\n\n    Args:\n        field_type: Protocol field type string\n        type_aliases: Optional dict for type name aliases\n\n    Returns:\n        Python type annotation string\n    \"\"\"\n    if type_aliases is None:\n        type_aliases = {}\n\n    base_type, array_count, is_nested = parse_field_type(field_type)\n\n    if array_count:\n        if is_nested:\n            # Use alias if one exists\n            type_name = type_aliases.get(base_type, base_type)\n            return f\"list[{type_name}]\"\n        elif base_type in (\"uint8\", \"byte\"):\n            # Special case: byte arrays\n            return \"bytes\"\n        else:\n            return \"list[int]\"\n    elif is_nested:\n        # Use alias if one exists\n        return type_aliases.get(base_type, base_type)\n    elif base_type in (\"uint8\", \"uint16\", \"uint32\", \"uint64\"):\n        return \"int\"\n    elif base_type in (\"int8\", \"int16\", \"int32\", \"int64\"):\n        return \"int\"\n    elif base_type == \"float32\":\n        return \"float\"\n    elif base_type == \"bool\":\n        return \"bool\"\n    else:\n        return \"Any\"\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_pack_method","title":"generate_pack_method","text":"<pre><code>generate_pack_method(\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str\n</code></pre> <p>Generate pack() method code for a field structure or packet.</p> PARAMETER DESCRIPTION <code>fields_data</code> <p>List of field definitions</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>class_type</code> <p>Either \"field\" or \"packet\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'field'</code> </p> <code>enum_types</code> <p>Set of enum type names for detection</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python method code string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_pack_method(\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str:\n    \"\"\"Generate pack() method code for a field structure or packet.\n\n    Args:\n        fields_data: List of field definitions\n        class_type: Either \"field\" or \"packet\"\n        enum_types: Set of enum type names for detection\n\n    Returns:\n        Python method code string\n    \"\"\"\n    if enum_types is None:\n        enum_types = set()\n\n    code = []\n    code.append(\"    def pack(self) -&gt; bytes:\")\n    code.append('        \"\"\"Pack to bytes.\"\"\"')\n    code.append(\"        from lifx.protocol import serializer\")\n    code.append('        result = b\"\"')\n    code.append(\"\")\n\n    for field_item in fields_data:\n        # Handle reserved fields (no name)\n        if \"name\" not in field_item:\n            size_bytes = field_item.get(\"size_bytes\", 0)\n            code.append(f\"        # Reserved {size_bytes} bytes\")\n            code.append(f\"        result += serializer.pack_reserved({size_bytes})\")\n            continue\n\n        protocol_name = field_item[\"name\"]\n        field_type = field_item[\"type\"]\n        size_bytes = field_item.get(\"size_bytes\", 0)\n        python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n\n        base_type, array_count, is_nested = parse_field_type(field_type)\n\n        # Check if this is an enum (nested but in enum_types)\n        is_enum = is_nested and base_type in enum_types\n\n        # Handle different field types\n        if array_count:\n            if is_enum:\n                # Array of enums - pack as array of ints\n                code.append(f\"        # {python_name}: list[{base_type}] (enum array)\")\n                code.append(f\"        for item in self.{python_name}:\")\n                code.append(\n                    \"            result += serializer.pack_value(int(item), 'uint8')\"\n                )\n            elif is_nested:\n                # Array of nested structures\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(f\"        for item in self.{python_name}:\")\n                code.append(\"            result += item.pack()\")\n            elif base_type in (\"uint8\", \"byte\"):\n                # Byte array\n                code.append(f\"        # {python_name}: bytes ({size_bytes} bytes)\")\n                code.append(\n                    f\"        result += \"\n                    f\"serializer.pack_bytes(self.{python_name}, {size_bytes})\"\n                )\n            else:\n                # Array of primitives\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(\n                    f\"        result += \"\n                    f\"serializer.pack_array(self.{python_name}, '{base_type}', {array_count})\"\n                )\n        elif is_enum:\n            # Enum - pack as int\n            code.append(f\"        # {python_name}: {base_type} (enum)\")\n            code.append(\n                f\"        result += \"\n                f\"serializer.pack_value(int(self.{python_name}), 'uint8')\"\n            )\n        elif is_nested:\n            # Nested structure\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(f\"        result += self.{python_name}.pack()\")\n        else:\n            # Primitive type\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(\n                f\"        result += \"\n                f\"serializer.pack_value(self.{python_name}, '{base_type}')\"\n            )\n\n    code.append(\"\")\n    code.append(\"        return result\")\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_unpack_method","title":"generate_unpack_method","text":"<pre><code>generate_unpack_method(\n    class_name: str,\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str\n</code></pre> <p>Generate unpack() classmethod code for a field structure or packet.</p> PARAMETER DESCRIPTION <code>class_name</code> <p>Name of the class</p> <p> TYPE: <code>str</code> </p> <code>fields_data</code> <p>List of field definitions</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>class_type</code> <p>Either \"field\" or \"packet\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'field'</code> </p> <code>enum_types</code> <p>Set of enum type names for detection</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python method code string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_unpack_method(\n    class_name: str,\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str:\n    \"\"\"Generate unpack() classmethod code for a field structure or packet.\n\n    Args:\n        class_name: Name of the class\n        fields_data: List of field definitions\n        class_type: Either \"field\" or \"packet\"\n        enum_types: Set of enum type names for detection\n\n    Returns:\n        Python method code string\n    \"\"\"\n    if enum_types is None:\n        enum_types = set()\n\n    code = []\n    code.append(\"    @classmethod\")\n    code.append(\n        f\"    def unpack(cls, data: bytes, offset: int = 0) -&gt; tuple[{class_name}, int]:\"\n    )\n    code.append('        \"\"\"Unpack from bytes.\"\"\"')\n    code.append(\"        from lifx.protocol import serializer\")\n    code.append(\"        current_offset = offset\")\n\n    # Store field values\n    field_vars = []\n\n    for field_item in fields_data:\n        # Handle reserved fields (no name)\n        if \"name\" not in field_item:\n            size_bytes = field_item.get(\"size_bytes\", 0)\n            code.append(f\"        # Skip reserved {size_bytes} bytes\")\n            code.append(f\"        current_offset += {size_bytes}\")\n            continue\n\n        protocol_name = field_item[\"name\"]\n        field_type = field_item[\"type\"]\n        size_bytes = field_item.get(\"size_bytes\", 0)\n        python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n        field_vars.append(python_name)\n\n        base_type, array_count, is_nested = parse_field_type(field_type)\n\n        # Check if this is an enum (nested but in enum_types)\n        is_enum = is_nested and base_type in enum_types\n\n        # Handle different field types\n        if array_count:\n            if is_enum:\n                # Array of enums\n                code.append(f\"        # {python_name}: list[{base_type}] (enum array)\")\n                code.append(f\"        {python_name} = []\")\n                code.append(f\"        for _ in range({array_count}):\")\n                code.append(\n                    \"            item_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)\"\n                )\n                code.append(f\"            {python_name}.append({base_type}(item_raw))\")\n            elif is_nested:\n                # Array of nested structures\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(f\"        {python_name} = []\")\n                code.append(f\"        for _ in range({array_count}):\")\n                code.append(\n                    f\"            item, current_offset = {base_type}.unpack(data, current_offset)\"\n                )\n                code.append(f\"            {python_name}.append(item)\")\n            elif base_type in (\"uint8\", \"byte\"):\n                # Byte array\n                code.append(f\"        # {python_name}: bytes ({size_bytes} bytes)\")\n                code.append(\n                    f\"        {python_name}, current_offset = serializer.unpack_bytes(\"\n                )\n                code.append(f\"            data, {size_bytes}, current_offset\")\n                code.append(\"        )\")\n            else:\n                # Array of primitives\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(\n                    f\"        {python_name}, current_offset = serializer.unpack_array(\"\n                )\n                code.append(\n                    f\"            data, '{base_type}', {array_count}, current_offset\"\n                )\n                code.append(\"        )\")\n        elif is_enum:\n            # Enum - unpack as int then convert\n            code.append(f\"        # {python_name}: {base_type} (enum)\")\n            code.append(\n                f\"        {python_name}_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)\"\n            )\n            code.append(f\"        {python_name} = {base_type}({python_name}_raw)\")\n        elif is_nested:\n            # Nested structure\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(\n                f\"        {python_name}, current_offset = {base_type}.unpack(data, current_offset)\"\n            )\n        else:\n            # Primitive type\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(\n                f\"        {python_name}, current_offset = serializer.unpack_value(data, '{base_type}', current_offset)\"\n            )\n\n    code.append(\"\")\n    # Create instance - format long return statements\n    field_args = \", \".join([f\"{name}={name}\" for name in field_vars])\n    return_stmt = f\"        return cls({field_args}), current_offset\"\n\n    # If too long, break across multiple lines\n    if len(return_stmt) &gt; 120:\n        code.append(\"        return (\")\n        code.append(\"            cls(\")\n        for i, name in enumerate(field_vars):\n            if i &lt; len(field_vars) - 1:\n                code.append(f\"                {name}={name},\")\n            else:\n                code.append(f\"                {name}={name},\")\n        code.append(\"            ),\")\n        code.append(\"            current_offset,\")\n        code.append(\"        )\")\n    else:\n        code.append(return_stmt)\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_field_code","title":"generate_field_code","text":"<pre><code>generate_field_code(\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enum_types: set[str] | None = None,\n) -&gt; tuple[str, dict[str, dict[str, str]]]\n</code></pre> <p>Generate Python dataclass definitions for field structures.</p> PARAMETER DESCRIPTION <code>fields</code> <p>Dictionary of field definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Dictionary of compound field definitions</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>unions</code> <p>Dictionary of union definitions (treated as fields)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>packets_as_fields</code> <p>Dictionary of packets that are also used as field types</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>enum_types</code> <p>Set of enum type names</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Tuple of (code string, field mappings dict)</p> <code>dict[str, dict[str, str]]</code> <p>Field mappings: {ClassName: {python_name: protocol_name}}</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_field_code(\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enum_types: set[str] | None = None,\n) -&gt; tuple[str, dict[str, dict[str, str]]]:\n    \"\"\"Generate Python dataclass definitions for field structures.\n\n    Args:\n        fields: Dictionary of field definitions\n        compound_fields: Dictionary of compound field definitions\n        unions: Dictionary of union definitions (treated as fields)\n        packets_as_fields: Dictionary of packets that are also used as field types\n        enum_types: Set of enum type names\n\n    Returns:\n        Tuple of (code string, field mappings dict)\n        Field mappings: {ClassName: {python_name: protocol_name}}\n    \"\"\"\n    if enum_types is None:\n        enum_types = set()\n\n    code = []\n    field_mappings: dict[str, dict[str, str]] = {}\n    all_fields = {**fields}\n    if compound_fields:\n        all_fields.update(compound_fields)\n    if unions:\n        all_fields.update(unions)\n    if packets_as_fields:\n        all_fields.update(packets_as_fields)\n\n    for field_name, field_def in sorted(all_fields.items()):\n        code.append(\"@dataclass\")\n        code.append(f\"class {field_name}:\")\n\n        # Check if this is a union (has comment indicating it's a union)\n        is_union = isinstance(field_def, dict) and \"comment\" in field_def\n        if is_union:\n            code.append(\n                f'    \"\"\"Auto-generated union structure. {field_def.get(\"comment\", \"\")}\"\"\"'\n            )\n        else:\n            code.append('    \"\"\"Auto-generated field structure.\"\"\"')\n        code.append(\"\")\n\n        field_map: dict[str, str] = {}\n        fields_data = []\n\n        # Handle both old format (dict) and new format (list of dicts)\n        if isinstance(field_def, dict) and \"fields\" in field_def:\n            # New format: {size_bytes: N, fields: [{name: \"X\", type: \"uint16\"}, ...]}\n            field_list = field_def[\"fields\"]\n\n            # For unions, treat as a raw bytes field (they overlay, so just store raw data)\n            if is_union:\n                size_bytes = field_def.get(\"size_bytes\", 16)\n                code.append(f\"    data: bytes  # Union of {size_bytes} bytes\")\n                field_map[\"data\"] = \"data\"\n                # For pack/unpack, use bytes field\n                fields_data = [\n                    {\n                        \"name\": \"data\",\n                        \"type\": f\"[{size_bytes}]byte\",\n                        \"size_bytes\": size_bytes,\n                    }\n                ]\n            else:\n                # Normal field structure - process all fields\n                fields_data = field_list  # Save for pack/unpack generation\n                for field_item in field_list:\n                    # Skip reserved fields without names (they won't be in dataclass)\n                    if \"name\" not in field_item:\n                        continue\n                    protocol_name = field_item[\"name\"]\n                    attr_type = field_item[\"type\"]\n                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n                    python_type = convert_type_to_python(attr_type)\n\n                    code.append(f\"    {python_name}: {python_type}\")\n                    field_map[python_name] = protocol_name\n        else:\n            # Old format: {attr_name: type, ...}\n            # Convert to new format for pack/unpack generation\n            for protocol_name, attr_type in field_def.items():\n                python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n                python_type = convert_type_to_python(attr_type)\n                code.append(f\"    {python_name}: {python_type}\")\n                field_map[python_name] = protocol_name\n                # Build fields_data for old format\n                fields_data.append({\"name\": protocol_name, \"type\": attr_type})\n\n        field_mappings[field_name] = field_map\n\n        # Add pack/unpack methods\n        if fields_data:\n            code.append(\"\")\n            code.append(generate_pack_method(fields_data, \"field\", enum_types))\n            code.append(\"\")\n            code.append(\n                generate_unpack_method(field_name, fields_data, \"field\", enum_types)\n            )\n\n        code.append(\"\")\n        code.append(\"\")\n\n    return \"\\n\".join(code), field_mappings\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_nested_packet_code","title":"generate_nested_packet_code","text":"<pre><code>generate_nested_packet_code(\n    packets: dict[str, Any], type_aliases: dict[str, str] | None = None\n) -&gt; str\n</code></pre> <p>Generate nested Python packet class definitions.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions (grouped by category)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>type_aliases</code> <p>Optional dict mapping type names to their aliases (for collision resolution)</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python code string with nested packet classes</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_nested_packet_code(\n    packets: dict[str, Any], type_aliases: dict[str, str] | None = None\n) -&gt; str:\n    \"\"\"Generate nested Python packet class definitions.\n\n    Args:\n        packets: Dictionary of packet definitions (grouped by category)\n        type_aliases: Optional dict mapping type names to their aliases (for collision resolution)\n\n    Returns:\n        Python code string with nested packet classes\n    \"\"\"\n    if type_aliases is None:\n        type_aliases = {}\n\n    code = []\n\n    # Flatten packets if they're grouped by category\n    flat_packets: list[tuple[str, str, dict[str, Any]]] = []\n\n    # Check if packets are grouped by category (new format)\n    sample_key = next(iter(packets.keys())) if packets else None\n    if sample_key and isinstance(packets[sample_key], dict):\n        sample_value = packets[sample_key]\n        # Check if this is a category grouping (contains nested packet dicts)\n        if any(isinstance(v, dict) and \"pkt_type\" in v for v in sample_value.values()):\n            # New format: grouped by category\n            for category, category_packets in packets.items():\n                for packet_name, packet_def in category_packets.items():\n                    flat_packets.append((category, packet_name, packet_def))\n        else:\n            # Old format: flat packets with category field\n            for packet_name, packet_def in packets.items():\n                category = packet_def.get(\"category\", \"misc\")\n                flat_packets.append((category, packet_name, packet_def))\n\n    # Group by category\n    categories: dict[str, list[tuple[str, dict[str, Any]]]] = {}\n    for category, packet_name, packet_def in flat_packets:\n        if category not in categories:\n            categories[category] = []\n        categories[category].append((packet_name, packet_def))\n\n    # Generate category classes with nested packet classes\n    for category in sorted(categories.keys()):\n        # Generate category class\n        # Quirk: Convert category names to proper camel case (multi_zone -&gt; MultiZone)\n        # Split on underscores, capitalize each part, then join\n        parts = category.split(\"_\")\n        category_class = \"\".join(part.capitalize() for part in parts)\n        code.append(\"\")\n        code.append(f\"class {category_class}(Packet):\")\n        code.append(f'    \"\"\"{category_class} category packets.\"\"\"')\n        code.append(\"\")\n\n        # Generate nested packet classes\n        for packet_name, packet_def in sorted(categories[category]):\n            pkt_type = packet_def[\"pkt_type\"]\n            fields_data = packet_def.get(\"fields\", [])\n\n            # Remove category prefix from packet name (e.g., DeviceGetLabel -&gt; GetLabel)\n            # The packet name format is: CategoryActionTarget (e.g., DeviceGetLabel, LightSetColor)\n            # Use case-insensitive matching to handle multi_zone -&gt; Multizone -&gt; MultiZone\n            short_name = packet_name\n            if packet_name.lower().startswith(category_class.lower()):\n                short_name = packet_name[len(category_class) :]\n\n            # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor\n            # for better clarity (Set and SetColor are different packets)\n            if category_class == \"Light\":\n                if short_name == \"Get\":\n                    short_name = \"GetColor\"\n                elif short_name == \"State\":\n                    short_name = \"StateColor\"\n\n            # Quirk: Rename extended multizone packets to follow standard naming convention\n            short_name = apply_extended_multizone_packet_quirks(\n                short_name, category_class\n            )\n\n            code.append(\"    @dataclass\")\n            code.append(f\"    class {short_name}(Packet):\")\n            code.append(f'        \"\"\"Packet type {pkt_type}.\"\"\"')\n            code.append(\"\")\n            code.append(f\"        PKT_TYPE: ClassVar[int] = {pkt_type}\")\n\n            # Format fields_data - split long lists across multiple lines\n            # Account for the prefix \"        _fields: ClassVar[list[dict[str, Any]]] = \" which is ~50 chars\n            fields_repr = format_long_list(fields_data, max_line_length=70)\n            if \"\\n\" in fields_repr:\n                # Multi-line format - indent properly\n                code.append(\"        _fields: ClassVar[list[dict[str, Any]]] = (\")\n                for line in fields_repr.split(\"\\n\"):\n                    if line.strip():\n                        code.append(f\"        {line}\")\n                code.append(\"        )\")\n            else:\n                code.append(\n                    f\"        _fields: ClassVar[list[dict[str, Any]]] = {fields_repr}\"\n                )\n\n            # Add packet metadata for smart request handling\n            # Classify packet by name pattern: Get*, Set*, State*, or OTHER\n            packet_kind = \"OTHER\"\n            if short_name.startswith(\"Get\"):\n                packet_kind = \"GET\"\n            elif short_name.startswith(\"Set\"):\n                packet_kind = \"SET\"\n            elif short_name.startswith(\"State\"):\n                packet_kind = \"STATE\"\n\n            # Quirk: CopyFrameBuffer is semantically a SET operation\n            # It modifies device state without returning data\n            if category_class == \"Tile\" and short_name == \"CopyFrameBuffer\":\n                packet_kind = \"SET\"\n\n            code.append(\"\")\n            code.append(\"        # Packet metadata for automatic handling\")\n            code.append(f\"        _packet_kind: ClassVar[str] = {repr(packet_kind)}\")\n\n            # Requires acknowledgement/response based on packet kind\n            # GET requests: ack_required=False, res_required=False (device responds anyway)\n            # SET requests: ack_required=True, res_required=False (need acknowledgement)\n            requires_ack = packet_kind == \"SET\"\n            requires_response = False\n            code.append(f\"        _requires_ack: ClassVar[bool] = {requires_ack}\")\n            code.append(\n                f\"        _requires_response: ClassVar[bool] = {requires_response}\"\n            )\n            code.append(\"\")\n\n            # Generate dataclass fields (only non-reserved)\n            has_fields = False\n            if isinstance(fields_data, list):\n                for field_item in fields_data:\n                    # Skip reserved fields\n                    if \"name\" not in field_item:\n                        continue\n                    protocol_name = field_item[\"name\"]\n                    field_type = field_item[\"type\"]\n                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n                    python_type = convert_type_to_python(field_type, type_aliases)\n                    code.append(f\"        {python_name}: {python_type}\")\n                    has_fields = True\n\n            if not has_fields:\n                code.append(\"        pass\")\n\n            code.append(\"\")\n\n        code.append(\"\")\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_types_file","title":"generate_types_file","text":"<pre><code>generate_types_file(\n    enums: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Generate complete types.py file.</p> PARAMETER DESCRIPTION <code>enums</code> <p>Enum definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Field structure definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Compound field definitions</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>unions</code> <p>Union definitions</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>packets_as_fields</code> <p>Packets that are also used as field types</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Complete Python file content</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_types_file(\n    enums: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"Generate complete types.py file.\n\n    Args:\n        enums: Enum definitions\n        fields: Field structure definitions\n        compound_fields: Compound field definitions\n        unions: Union definitions\n        packets_as_fields: Packets that are also used as field types\n\n    Returns:\n        Complete Python file content\n    \"\"\"\n    header = '''\"\"\"Auto-generated LIFX protocol types.\n\nDO NOT EDIT THIS FILE MANUALLY.\nGenerated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml\nby protocol/generator.py\n\nUses Pythonic naming conventions (snake_case fields, shortened enums) while\nmaintaining compatibility with the official LIFX protocol through mappings.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom enum import IntEnum\n\n\n'''\n\n    code = header\n    code += generate_enum_code(enums)\n    code += \"\\n\"\n\n    # Extract enum names for pack/unpack generation\n    enum_names = set(enums.keys())\n\n    field_code, field_mappings = generate_field_code(\n        fields, compound_fields, unions, packets_as_fields, enum_names\n    )\n    code += field_code\n    code += \"\\n\"\n\n    # Add type aliases for common names\n    code += \"# Type aliases for convenience\\n\"\n    all_field_names = {\n        **fields,\n        **(compound_fields or {}),\n        **(unions or {}),\n        **(packets_as_fields or {}),\n    }\n    if \"TileStateDevice\" in all_field_names:\n        code += \"TileDevice = TileStateDevice  # Pythonic alias\\n\"\n    code += \"\\n\"\n\n    # Add field name mappings as module-level constant (formatted for readability)\n    code += \"# Field name mappings: Python name -&gt; Protocol name\\n\"\n    code += \"# Used by serializer to translate between conventions\\n\"\n    code += \"FIELD_MAPPINGS: dict[str, dict[str, str]] = {\\n\"\n    for class_name in sorted(field_mappings.keys()):\n        mappings = field_mappings[class_name]\n        # Format each class mapping - if too long, break it into multiple lines\n        mappings_str = repr(mappings)\n        line = f\"    {repr(class_name)}: {mappings_str},\"\n        if len(line) &gt; 120:\n            # Multi-line format\n            code += f\"    {repr(class_name)}: {{\\n\"\n            for py_name, proto_name in sorted(mappings.items()):\n                code += f\"        {repr(py_name)}: {repr(proto_name)},\\n\"\n            code += \"    },\\n\"\n        else:\n            code += line + \"\\n\"\n    code += \"}\\n\"\n    code += \"\\n\"\n\n    return code\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_packets_file","title":"generate_packets_file","text":"<pre><code>generate_packets_file(\n    packets: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enums: dict[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Generate complete packets.py file.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Packet definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Field definitions (for imports)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Compound field definitions (for imports)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>unions</code> <p>Union definitions (for imports)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>packets_as_fields</code> <p>Packets that are also used as field types (for imports)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>enums</code> <p>Enum definitions for detecting enum types</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Complete Python file content</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_packets_file(\n    packets: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enums: dict[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"Generate complete packets.py file.\n\n    Args:\n        packets: Packet definitions\n        fields: Field definitions (for imports)\n        compound_fields: Compound field definitions (for imports)\n        unions: Union definitions (for imports)\n        packets_as_fields: Packets that are also used as field types (for imports)\n        enums: Enum definitions for detecting enum types\n\n    Returns:\n        Complete Python file content\n    \"\"\"\n    # Extract enum names for pack/unpack generation\n    enum_names = set(enums.keys()) if enums else set()\n\n    # Collect all field types and enum types used in packets\n    used_fields = set()\n    used_enums = set()\n    all_fields = {**fields}\n    if compound_fields:\n        all_fields.update(compound_fields)\n    if unions:\n        all_fields.update(unions)\n    if packets_as_fields:\n        all_fields.update(packets_as_fields)\n\n    # Flatten packets to scan for used field types\n    flat_packets: list[dict[str, Any]] = []\n    for value in packets.values():\n        if isinstance(value, dict):\n            # Check if this is a category grouping\n            if any(isinstance(v, dict) and \"pkt_type\" in v for v in value.values()):\n                # New format: grouped by category\n                for packet_def in value.values():\n                    flat_packets.append(packet_def)\n            elif \"pkt_type\" in value:\n                # Old format: direct packet\n                flat_packets.append(value)\n\n    for packet_def in flat_packets:\n        fields_data = packet_def.get(\"fields\", [])\n        # Handle both list and dict formats\n        if isinstance(fields_data, list):\n            for field_item in fields_data:\n                if \"type\" in field_item:\n                    field_type = field_item[\"type\"]\n                    base_type, _, is_nested = parse_field_type(field_type)\n                    if is_nested:\n                        if base_type in all_fields:\n                            used_fields.add(base_type)\n                        elif base_type in enum_names:\n                            used_enums.add(base_type)\n        elif isinstance(fields_data, dict):\n            for field_type in fields_data.values():\n                base_type, _, is_nested = parse_field_type(field_type)\n                if is_nested:\n                    if base_type in all_fields:\n                        used_fields.add(base_type)\n                    elif base_type in enum_names:\n                        used_enums.add(base_type)\n\n    # Generate imports with collision detection\n    imports = \"\"\n    all_imports = sorted(used_fields | used_enums)\n    if all_imports:\n        # Detect name collisions with packet category names\n        category_names = set()\n        for category in packets.keys():\n            if isinstance(packets[category], dict):\n                # Convert category name to class name (same as in generate_nested_packet_code)\n                parts = category.split(\"_\")\n                category_class = \"\".join(part.capitalize() for part in parts)\n                category_names.add(category_class)\n\n        # Generate import list with aliases for collisions\n        import_items = []\n        type_aliases = {}  # Map original name to aliased name\n        for name in all_imports:\n            if name in category_names:\n                # Use alias to avoid collision\n                aliased_name = f\"{name}Field\"\n                import_items.append(f\"{name} as {aliased_name}\")\n                type_aliases[name] = aliased_name\n            else:\n                import_items.append(name)\n\n        imports = format_long_import(import_items) + \"\\n\"\n    else:\n        type_aliases = {}\n        imports = \"\"\n\n    header = f'''\"\"\"Auto-generated LIFX protocol packets.\n\nDO NOT EDIT THIS FILE MANUALLY.\nGenerated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml\nby protocol/generator.py\n\nUses nested packet classes organized by category (Device, Light, etc.).\nEach packet inherits from base Packet class which provides generic pack/unpack.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Any, ClassVar\n\nfrom lifx.protocol.base import Packet\n{imports}\n'''\n\n    code = header\n    packet_code = generate_nested_packet_code(packets, type_aliases)\n    code += packet_code\n\n    # Generate packet registry for nested classes\n    code += \"\\n\\n\"\n    code += \"# Packet Registry - maps packet type to nested packet class\\n\"\n    code += \"PACKET_REGISTRY: dict[int, type[Packet]] = {\\n\"\n\n    # Build registry with nested class paths\n    registry_items = []\n    for category, value in packets.items():\n        if isinstance(value, dict):\n            # Check if this is a category grouping\n            if any(isinstance(v, dict) and \"pkt_type\" in v for v in value.values()):\n                # New format: grouped by category\n                # Quirk: Convert category names to proper camel case (multi_zone -&gt; MultiZone)\n                parts = category.split(\"_\")\n                category_class = \"\".join(part.capitalize() for part in parts)\n                for packet_name, packet_def in value.items():\n                    pkt_type = packet_def.get(\"pkt_type\")\n                    if pkt_type is not None:\n                        # Remove category prefix to get short name\n                        # Use case-insensitive matching to handle multi_zone -&gt; Multizone -&gt; MultiZone\n                        short_name = packet_name\n                        if packet_name.lower().startswith(category_class.lower()):\n                            short_name = packet_name[len(category_class) :]\n\n                        # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor\n                        if category_class == \"Light\":\n                            if short_name == \"Get\":\n                                short_name = \"GetColor\"\n                            elif short_name == \"State\":\n                                short_name = \"StateColor\"\n\n                        # Quirk: Rename extended multizone packets to follow standard naming convention\n                        short_name = apply_extended_multizone_packet_quirks(\n                            short_name, category_class\n                        )\n\n                        # Full path: Category.ShortName\n                        full_path = f\"{category_class}.{short_name}\"\n                        registry_items.append((pkt_type, full_path))\n\n    # Sort by packet type for readability\n    for pkt_type, full_path in sorted(registry_items):\n        code += f\"    {pkt_type}: {full_path},\\n\"\n\n    code += \"}\\n\"\n    code += \"\\n\\n\"\n    code += \"def get_packet_class(pkt_type: int) -&gt; type[Packet] | None:\\n\"\n    code += '    \"\"\"Get packet class for a given packet type.\\n'\n    code += \"\\n\"\n    code += \"    Args:\\n\"\n    code += \"        pkt_type: Packet type number\\n\"\n    code += \"\\n\"\n    code += \"    Returns:\\n\"\n    code += \"        Nested packet class, or None if unknown\\n\"\n    code += '    \"\"\"\\n'\n    code += \"    return PACKET_REGISTRY.get(pkt_type)\\n\"\n\n    return code\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.download_protocol","title":"download_protocol","text":"<pre><code>download_protocol() -&gt; dict[str, Any]\n</code></pre> <p>Download and parse protocol.yml from LIFX GitHub repository.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Parsed protocol dictionary</p> RAISES DESCRIPTION <code>URLError</code> <p>If download fails</p> <code>YAMLError</code> <p>If parsing fails</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def download_protocol() -&gt; dict[str, Any]:\n    \"\"\"Download and parse protocol.yml from LIFX GitHub repository.\n\n    Returns:\n        Parsed protocol dictionary\n\n    Raises:\n        URLError: If download fails\n        yaml.YAMLError: If parsing fails\n    \"\"\"\n    parsed_url = urlparse(PROTOCOL_URL)\n    if parsed_url.scheme == \"https\" and parsed_url.netloc.startswith(\n        \"raw.githubusercontent.com\"\n    ):\n        print(f\"Downloading protocol.yml from {PROTOCOL_URL}...\")\n        with urlopen(PROTOCOL_URL) as response:  # nosec B310\n            protocol_data = response.read()\n\n        print(\"Parsing protocol specification...\")\n        protocol = yaml.safe_load(protocol_data)\n        return protocol\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.validate_protocol_spec","title":"validate_protocol_spec","text":"<pre><code>validate_protocol_spec(protocol: dict[str, Any]) -&gt; list[str]\n</code></pre> <p>Validate protocol specification for missing type references.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>Parsed protocol dictionary</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of error messages (empty if validation passes)</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def validate_protocol_spec(protocol: dict[str, Any]) -&gt; list[str]:\n    \"\"\"Validate protocol specification for missing type references.\n\n    Args:\n        protocol: Parsed protocol dictionary\n\n    Returns:\n        List of error messages (empty if validation passes)\n    \"\"\"\n    errors: list[str] = []\n    registry = TypeRegistry()\n\n    # Register all types\n    enums = protocol.get(\"enums\", {})\n    fields = protocol.get(\"fields\", {})\n    compound_fields = protocol.get(\"compound_fields\", {})\n    unions = protocol.get(\"unions\", {})\n    packets = protocol.get(\"packets\", {})\n\n    # Register enums\n    for enum_name in enums.keys():\n        registry.register_enum(enum_name)\n\n    # Register field structures\n    for field_name in fields.keys():\n        registry.register_field(field_name)\n\n    # Register compound fields\n    for field_name in compound_fields.keys():\n        registry.register_field(field_name)\n\n    # Register unions\n    for union_name in unions.keys():\n        registry.register_union(union_name)\n\n    # Register packets (flatten by category)\n    for category_packets in packets.values():\n        if isinstance(category_packets, dict):\n            for packet_name in category_packets.keys():\n                registry.register_packet(packet_name)\n\n    # Validate field type references\n    def validate_field_types(struct_name: str, struct_def: dict[str, Any]) -&gt; None:\n        \"\"\"Validate all field types in a structure.\"\"\"\n        if isinstance(struct_def, dict) and \"fields\" in struct_def:\n            for field_item in struct_def[\"fields\"]:\n                if \"type\" in field_item:\n                    field_type = field_item[\"type\"]\n                    field_name = field_item.get(\"name\", \"reserved\")\n                    base_type, _, _ = parse_field_type(field_type)\n\n                    # Check if type is defined\n                    if not registry.has_type(base_type):\n                        errors.append(\n                            f\"{struct_name}.{field_name}: Unknown type '{base_type}' in field type '{field_type}'\"\n                        )\n\n    # Validate fields\n    for field_name, field_def in fields.items():\n        validate_field_types(f\"fields.{field_name}\", field_def)\n\n    # Validate compound fields\n    for field_name, field_def in compound_fields.items():\n        validate_field_types(f\"compound_fields.{field_name}\", field_def)\n\n    # Validate unions\n    for union_name, union_def in unions.items():\n        validate_field_types(f\"unions.{union_name}\", union_def)\n\n    # Validate packets\n    for category, category_packets in packets.items():\n        if isinstance(category_packets, dict):\n            for packet_name, packet_def in category_packets.items():\n                if isinstance(packet_def, dict):\n                    validate_field_types(\n                        f\"packets.{category}.{packet_name}\", packet_def\n                    )\n\n    return errors\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.should_skip_button_relay","title":"should_skip_button_relay","text":"<pre><code>should_skip_button_relay(name: str) -&gt; bool\n</code></pre> <p>Check if a name should be skipped (Button or Relay related).</p> PARAMETER DESCRIPTION <code>name</code> <p>Type name to check (enum, field, union, packet, or category)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the name starts with Button or Relay, False otherwise</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def should_skip_button_relay(name: str) -&gt; bool:\n    \"\"\"Check if a name should be skipped (Button or Relay related).\n\n    Args:\n        name: Type name to check (enum, field, union, packet, or category)\n\n    Returns:\n        True if the name starts with Button or Relay, False otherwise\n    \"\"\"\n    return name.startswith(\"Button\") or name.startswith(\"Relay\")\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.filter_button_relay_items","title":"filter_button_relay_items","text":"<pre><code>filter_button_relay_items(items: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Filter out Button and Relay items from a dictionary.</p> PARAMETER DESCRIPTION <code>items</code> <p>Dictionary of items to filter</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Filtered dictionary without Button/Relay items</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def filter_button_relay_items(items: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Filter out Button and Relay items from a dictionary.\n\n    Args:\n        items: Dictionary of items to filter\n\n    Returns:\n        Filtered dictionary without Button/Relay items\n    \"\"\"\n    return {\n        name: value\n        for name, value in items.items()\n        if not should_skip_button_relay(name)\n    }\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.filter_button_relay_packets","title":"filter_button_relay_packets","text":"<pre><code>filter_button_relay_packets(packets: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Filter out button and relay category packets.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions (grouped by category)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Filtered dictionary without button/relay categories</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def filter_button_relay_packets(packets: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Filter out button and relay category packets.\n\n    Args:\n        packets: Dictionary of packet definitions (grouped by category)\n\n    Returns:\n        Filtered dictionary without button/relay categories\n    \"\"\"\n    return {\n        category: category_packets\n        for category, category_packets in packets.items()\n        if category not in (\"button\", \"relay\")\n    }\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.extract_packets_as_fields","title":"extract_packets_as_fields","text":"<pre><code>extract_packets_as_fields(\n    packets: dict[str, Any], fields: dict[str, Any]\n) -&gt; dict[str, Any]\n</code></pre> <p>Extract packets that are used as field types in other structures.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Dictionary of field definitions to scan</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary of packet definitions that are referenced as field types</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def extract_packets_as_fields(\n    packets: dict[str, Any], fields: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Extract packets that are used as field types in other structures.\n\n    Args:\n        packets: Dictionary of packet definitions\n        fields: Dictionary of field definitions to scan\n\n    Returns:\n        Dictionary of packet definitions that are referenced as field types\n    \"\"\"\n    packets_as_fields = {}\n\n    # Flatten packets first\n    flat_packets = {}\n    for category, category_packets in packets.items():\n        if isinstance(category_packets, dict):\n            for packet_name, packet_def in category_packets.items():\n                if isinstance(packet_def, dict) and \"pkt_type\" in packet_def:\n                    flat_packets[packet_name] = packet_def\n\n    # Scan all fields for references to packet types\n    all_structures = {**fields}\n\n    for struct_def in all_structures.values():\n        if isinstance(struct_def, dict) and \"fields\" in struct_def:\n            for field_item in struct_def[\"fields\"]:\n                if \"type\" in field_item:\n                    field_type = field_item[\"type\"]\n                    base_type, _, is_nested = parse_field_type(field_type)\n\n                    # Check if this references a packet\n                    if is_nested and base_type in flat_packets:\n                        packets_as_fields[base_type] = flat_packets[base_type]\n\n    return packets_as_fields\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Main generator entry point.</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Main generator entry point.\"\"\"\n    try:\n        # Download and parse protocol from GitHub\n        protocol = download_protocol()\n    except Exception as e:\n        print(f\"Error: Failed to download protocol.yml: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Extract sections\n    enums = protocol.get(\"enums\", {})\n    fields = protocol.get(\"fields\", {})\n    compound_fields = protocol.get(\"compound_fields\", {})\n    unions = protocol.get(\"unions\", {})\n    packets = protocol.get(\"packets\", {})\n\n    # Filter out Button and Relay items (not relevant for light control)\n    print(\"Filtering out Button and Relay items...\")\n    enums = filter_button_relay_items(enums)\n    fields = filter_button_relay_items(fields)\n    compound_fields = filter_button_relay_items(compound_fields)\n    unions = filter_button_relay_items(unions)\n    packets = filter_button_relay_packets(packets)\n\n    # Rebuild protocol dict with filtered items for validation\n    filtered_protocol = {\n        **protocol,\n        \"enums\": enums,\n        \"fields\": fields,\n        \"compound_fields\": compound_fields,\n        \"unions\": unions,\n        \"packets\": packets,\n    }\n\n    # Validate filtered protocol specification\n    print(\"Validating protocol specification...\")\n    validation_errors = validate_protocol_spec(filtered_protocol)\n    if validation_errors:\n        print(\"Validation failed with the following errors:\", file=sys.stderr)\n        for error in validation_errors:\n            print(f\"  - {error}\", file=sys.stderr)\n        sys.exit(1)\n    print(\"Validation passed!\")\n\n    # Extract packets that are used as field types (e.g., DeviceStateVersion)\n    packets_as_fields = extract_packets_as_fields(packets, fields)\n\n    print(f\"Found {len(unions)} unions\")\n    print(\n        f\"Found {len(packets_as_fields)} packets used as field types: {list(packets_as_fields.keys())}\"\n    )\n\n    # Determine output directory\n    project_root = Path(__file__).parent.parent.parent.parent\n    protocol_dir = project_root / \"src\" / \"lifx\" / \"protocol\"\n\n    # Generate protocol_types.py (avoid conflict with Python's types module)\n    types_code = generate_types_file(\n        enums, fields, compound_fields, unions, packets_as_fields\n    )\n    types_file = protocol_dir / \"protocol_types.py\"\n    with open(types_file, \"w\") as f:\n        f.write(types_code)\n    print(f\"Generated {types_file}\")\n\n    # Generate packets.py\n    packets_code = generate_packets_file(\n        packets, fields, compound_fields, unions, packets_as_fields, enums\n    )\n    packets_file = protocol_dir / \"packets.py\"\n    with open(packets_file, \"w\") as f:\n        f.write(packets_code)\n    print(f\"Generated {packets_file}\")\n</code></pre>"},{"location":"api/protocol/#examples","title":"Examples","text":""},{"location":"api/protocol/#working-with-serial-numbers","title":"Working with Serial Numbers","text":"<p>The <code>Serial</code> dataclass provides type-safe, immutable serial number handling:</p> <pre><code>from lifx.protocol.models import Serial\n\n# Create from string (accepts hex with or without separators)\nserial = Serial.from_string(\"d073d5123456\")\nserial = Serial.from_string(\"d0:73:d5:12:34:56\")  # Also works\n\n# Convert between formats\nprotocol_bytes = serial.to_protocol()  # 8 bytes with padding\nserial_string = serial.to_string()     # \"d073d5123456\"\nserial_bytes = serial.value            # 6 bytes (immutable/frozen)\n\n# Create from protocol format (8 bytes)\nserial = Serial.from_protocol(b\"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00\")\nprint(serial)  # \"d073d5123456\"\n\n# String representations\nprint(str(serial))   # \"d073d5123456\"\nprint(repr(serial))  # \"Serial('d073d5123456')\"\n</code></pre>"},{"location":"api/protocol/#using-protocol-packets-directly","title":"Using Protocol Packets Directly","text":"<pre><code>from lifx.network.connection import DeviceConnection\nfrom lifx.protocol.packets import LightSetColor, LightGet, LightState\nfrom lifx.protocol.protocol_types import LightHsbk\nfrom lifx.protocol.models import Serial\n\n\nasync def main():\n    serial = Serial.from_string(\"d073d5123456\")\n\n    async with DeviceConnection(serial.to_string(), \"192.168.1.100\") as conn:\n        # Create a packet\n        packet = LightSetColor(\n            reserved=0,\n            color=LightHsbk(\n                hue=240 * 182, saturation=65535, brightness=32768, kelvin=3500\n            ),\n            duration=1000,  # milliseconds\n        )\n\n        # Send without waiting for response\n        await conn.send_packet(packet)\n\n        # Request with response\n        response = await conn.request_response(LightGet(), LightState)\n        print(f\"Hue: {response.color.hue / 182}\u00b0\")\n</code></pre>"},{"location":"api/protocol/#binary-serialization","title":"Binary Serialization","text":"<pre><code>from lifx.protocol.packets import DeviceSetLabel\nfrom lifx.protocol.serializer import Serializer\n\n# Create packet\npacket = DeviceSetLabel(label=b\"Kitchen Light\\0\" + b\"\\0\" * 19)\n\n# Serialize to bytes\ndata = packet.pack()\nprint(f\"Packet size: {len(data)} bytes\")\n\n# Deserialize from bytes\nunpacked = DeviceSetLabel.unpack(data)\nprint(f\"Label: {unpacked.label.decode('utf-8').rstrip('\\0')}\")\n</code></pre>"},{"location":"api/protocol/#protocol-header_1","title":"Protocol Header","text":"<pre><code>from lifx.protocol.header import LifxHeader\nfrom lifx.protocol.models import Serial\n\n# Create header with Serial\nserial = Serial.from_string(\"d073d5123456\")\nheader = LifxHeader(\n    size=36,\n    protocol=1024,\n    addressable=True,\n    tagged=False,\n    origin=0,\n    source=0x12345678,\n    target=serial.to_protocol(),  # 8 bytes with padding\n    reserved1=b\"\\x00\" * 6,\n    ack_required=False,\n    res_required=True,\n    sequence=42,\n    reserved2=0,\n    pkt_type=101,  # LightGet\n    reserved3=0,\n)\n\n# Serialize\ndata = header.pack()\nprint(f\"Header: {data.hex()}\")\n\n# Deserialize\nunpacked_header = LifxHeader.unpack(data)\nprint(f\"Packet type: {unpacked_header.pkt_type}\")\nprint(f\"Target serial: {Serial.from_protocol(unpacked_header.target)}\")\n</code></pre>"},{"location":"api/protocol/#protocol-constants","title":"Protocol Constants","text":""},{"location":"api/protocol/#message-types","title":"Message Types","text":"<p>Each packet class has a <code>PKT_TYPE</code> constant defining its protocol message type:</p> <pre><code>from lifx.protocol.packets import LightSetColor, LightGet, DeviceGetLabel\n\nprint(f\"LightSetColor type: {LightSetColor.PKT_TYPE}\")  # 102\nprint(f\"LightGet type: {LightGet.PKT_TYPE}\")  # 101\nprint(f\"DeviceGetLabel type: {DeviceGetLabel.PKT_TYPE}\")  # 23\n</code></pre>"},{"location":"api/protocol/#waveform-types","title":"Waveform Types","text":"<pre><code>from lifx.protocol.protocol_types import LightWaveform\n\n# Available waveforms\nLightWaveform.SAW\nLightWaveform.SINE\nLightWaveform.HALF_SINE\nLightWaveform.TRIANGLE\nLightWaveform.PULSE\n</code></pre>"},{"location":"api/protocol/#product-registry","title":"Product Registry","text":"<p>The product registry provides automatic device type detection and capability information:</p>"},{"location":"api/protocol/#lifx.products.ProductInfo","title":"ProductInfo  <code>dataclass</code>","text":"<pre><code>ProductInfo(\n    pid: int,\n    name: str,\n    vendor: int,\n    capabilities: int,\n    temperature_range: TemperatureRange | None,\n    min_ext_mz_firmware: int | None,\n)\n</code></pre> <p>Information about a LIFX product.</p> ATTRIBUTE DESCRIPTION <code>pid</code> <p>Product ID</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Product name</p> <p> TYPE: <code>str</code> </p> <code>vendor</code> <p>Vendor ID (always 1 for LIFX)</p> <p> TYPE: <code>int</code> </p> <code>capabilities</code> <p>Bitfield of ProductCapability flags</p> <p> TYPE: <code>int</code> </p> <code>temperature_range</code> <p>Min/max color temperature in Kelvin</p> <p> TYPE: <code>TemperatureRange | None</code> </p> <code>min_ext_mz_firmware</code> <p>Minimum firmware version for extended multizone</p> <p> TYPE: <code>int | None</code> </p> METHOD DESCRIPTION <code>has_capability</code> <p>Check if product has a specific capability.</p> <code>supports_extended_multizone</code> <p>Check if extended multizone is supported for given firmware version.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.products.ProductInfo.has_color","title":"has_color  <code>property</code>","text":"<pre><code>has_color: bool\n</code></pre> <p>Check if product supports color.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_infrared","title":"has_infrared  <code>property</code>","text":"<pre><code>has_infrared: bool\n</code></pre> <p>Check if product supports infrared.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_multizone","title":"has_multizone  <code>property</code>","text":"<pre><code>has_multizone: bool\n</code></pre> <p>Check if product supports multizone.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_chain","title":"has_chain  <code>property</code>","text":"<pre><code>has_chain: bool\n</code></pre> <p>Check if product supports chaining.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_matrix","title":"has_matrix  <code>property</code>","text":"<pre><code>has_matrix: bool\n</code></pre> <p>Check if product supports matrix (2D grid).</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_relays","title":"has_relays  <code>property</code>","text":"<pre><code>has_relays: bool\n</code></pre> <p>Check if product has relays.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_buttons","title":"has_buttons  <code>property</code>","text":"<pre><code>has_buttons: bool\n</code></pre> <p>Check if product has buttons.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_hev","title":"has_hev  <code>property</code>","text":"<pre><code>has_hev: bool\n</code></pre> <p>Check if product supports HEV.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_extended_multizone","title":"has_extended_multizone  <code>property</code>","text":"<pre><code>has_extended_multizone: bool\n</code></pre> <p>Check if product supports extended multizone.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.products.ProductInfo.has_capability","title":"has_capability","text":"<pre><code>has_capability(capability: ProductCapability) -&gt; bool\n</code></pre> <p>Check if product has a specific capability.</p> PARAMETER DESCRIPTION <code>capability</code> <p>Capability to check</p> <p> TYPE: <code>ProductCapability</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if product has the capability</p> Source code in <code>src/lifx/products/registry.py</code> <pre><code>def has_capability(self, capability: ProductCapability) -&gt; bool:\n    \"\"\"Check if product has a specific capability.\n\n    Args:\n        capability: Capability to check\n\n    Returns:\n        True if product has the capability\n    \"\"\"\n    return bool(self.capabilities &amp; capability)\n</code></pre>"},{"location":"api/protocol/#lifx.products.ProductInfo.supports_extended_multizone","title":"supports_extended_multizone","text":"<pre><code>supports_extended_multizone(firmware_version: int | None = None) -&gt; bool\n</code></pre> <p>Check if extended multizone is supported for given firmware version.</p> PARAMETER DESCRIPTION <code>firmware_version</code> <p>Firmware version to check (optional)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if extended multizone is supported</p> Source code in <code>src/lifx/products/registry.py</code> <pre><code>def supports_extended_multizone(self, firmware_version: int | None = None) -&gt; bool:\n    \"\"\"Check if extended multizone is supported for given firmware version.\n\n    Args:\n        firmware_version: Firmware version to check (optional)\n\n    Returns:\n        True if extended multizone is supported\n    \"\"\"\n    if not self.has_extended_multizone:\n        return False\n    if self.min_ext_mz_firmware is None:\n        return True\n    if firmware_version is None:\n        return True\n    return firmware_version &gt;= self.min_ext_mz_firmware\n</code></pre>"},{"location":"api/protocol/#lifx.products.ProductCapability","title":"ProductCapability","text":"<p>               Bases: <code>IntEnum</code></p> <p>Product capability flags.</p>"},{"location":"api/protocol/#using-the-product-registry","title":"Using the Product Registry","text":"<pre><code>from lifx.products import get_product, get_device_class_name\n\n# Get product info by product ID\nproduct_info = get_product(product_id=27)\n\n# Get appropriate device class name\nclass_name = get_device_class_name(product_id=27)  # Returns \"Light\", \"MultiZoneLight\", etc.\n</code></pre>"},{"location":"api/protocol/#protocol-updates","title":"Protocol Updates","text":"<p>To update to the latest LIFX protocol:</p> <ol> <li>Download the latest <code>protocol.yml</code> from the    LIFX public-protocol repository</li> <li>Save it to the project root</li> <li>Run the generator: <code>uv run python -m lifx.protocol.generator</code></li> <li>Review the generated code changes</li> <li>Run tests: <code>uv run pytest</code></li> </ol> <p>The generator will automatically:</p> <ul> <li>Parse the YAML specification</li> <li>Generate Python dataclasses for all packet types</li> <li>Create enums for protocol constants</li> <li>Add serialization/deserialization methods</li> <li>Filter out Button/Relay messages (out of scope)</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>lifx-async is built as a layered architecture with clear separation of concerns.</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"Layer 4: High-Level API\"\n        API[api.py&lt;br/&gt;discover, find_lights, etc.]\n        DeviceGroup[DeviceGroup&lt;br/&gt;Batch operations]\n    end\n\n    subgraph \"Layer 3: Device Layer\"\n        Device[Device&lt;br/&gt;Base class]\n        Light[Light&lt;br/&gt;Color control]\n        Hev[HevLight&lt;br /&gt;HEV support]\n        Infrared[InfraredLight&lt;br /&gt;Infrared support]\n        MultiZone[MultiZoneLight&lt;br/&gt;Linear/1D zones]\n        Tile[TileDevice&lt;br/&gt;Matrix/2D zones]\n    end\n\n    subgraph \"Layer 2: Network Layer\"\n        Discovery[Discovery&lt;br/&gt;UDP broadcast]\n        Connection[Connection&lt;br/&gt;Connection pooling]\n        Transport[Transport&lt;br/&gt;UDP sockets]\n    end\n\n    subgraph \"Layer 1: Protocol Layer\"\n        Generator[Generator&lt;br/&gt;YAML \u2192 Python]\n        Types[Protocol Types&lt;br/&gt;Enums, HSBK, etc.]\n        Packets[Packets&lt;br/&gt;Message classes]\n    end\n\n    subgraph \"External\"\n        YAML[protocol.yml&lt;br/&gt;LIFX specification]\n        Network[UDP Network&lt;br/&gt;Port 56700]\n    end\n\n    API --&gt; DeviceGroup\n    DeviceGroup --&gt; Light\n    DeviceGroup --&gt; Hev\n    DeviceGroup --&gt; Infrared\n    DeviceGroup --&gt; MultiZone\n    DeviceGroup --&gt; Tile\n    API --&gt; Discovery\n    Device --&gt; Connection\n    Light --&gt; Device\n    Hev --&gt; Light\n    Infrared --&gt; Light\n    MultiZone --&gt; Light\n    Tile --&gt; Light\n    Connection --&gt; Transport\n    Connection --&gt; Packets\n    Discovery --&gt; Transport\n    Packets --&gt; Types\n    Transport --&gt; Network\n    Generator --&gt; YAML\n    Generator -.generates.-&gt; Types\n    Generator -.generates.-&gt; Packets\n\n    style API fill:#e1f5e1\n    style Device fill:#e1f0ff\n    style Connection fill:#fff4e1\n    style Generator fill:#ffe1f0</code></pre>"},{"location":"architecture/overview/#layer-responsibilities","title":"Layer Responsibilities","text":""},{"location":"architecture/overview/#layer-1-protocol-layer","title":"Layer 1: Protocol Layer","text":"<p>Purpose: Handle LIFX binary protocol</p> <ul> <li>Auto-Generated: All code generated from <code>protocol.yml</code></li> <li>Type-Safe: Full type hints for all structures</li> <li>Binary Serialization: Pack/unpack protocol messages</li> <li>No Business Logic: Pure data structures</li> </ul> <p>Key Files:</p> <ul> <li><code>protocol_types.py</code> - Enums, HSBK, field structures</li> <li><code>packets.py</code> - Packet class definitions</li> <li><code>generator.py</code> - Code generation from YAML</li> </ul> <p>Example:</p> <pre><code>from lifx.protocol.packets import Light\nfrom lifx.color import HSBK\n\n# Create a packet\npacket = Light.SetColor(\n    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0\n)\n\n# Serialize to bytes\ndata = packet.pack()\n</code></pre>"},{"location":"architecture/overview/#layer-2-network-layer","title":"Layer 2: Network Layer","text":"<p>Purpose: Handle network communication</p> <ul> <li>UDP Transport: Async socket operations</li> <li>Discovery: Broadcast-based device discovery</li> <li>Connection Pooling: Efficient connection reuse (LRU cache)</li> <li>Retry Logic: Automatic retry with exponential backoff</li> </ul> <p>Key Files:</p> <ul> <li><code>transport.py</code> - UDP socket wrapper</li> <li><code>discovery.py</code> - Device discovery</li> <li><code>connection.py</code> - Connection management</li> <li><code>message.py</code> - Message building</li> </ul> <p>Example:</p> <pre><code>from lifx.network.connection import DeviceConnection\n\nconn = DeviceConnection(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n# Connection automatically pooled\nresponse = await conn.request_response(packet, response_type)\n</code></pre>"},{"location":"architecture/overview/#layer-3-device-layer","title":"Layer 3: Device Layer","text":"<p>Purpose: Device abstractions with high-level operations</p> <ul> <li>Device Types: Base, Light, HevLight, InfraredLight, MultiZoneLight, TileDevice</li> <li>State Caching: Cache with configurable TTL</li> <li>Type Detection: Automatic capability detection</li> <li>Async Context Managers: Automatic resource cleanup</li> </ul> <p>Key Files:</p> <ul> <li><code>base.py</code> - Base Device class</li> <li><code>light.py</code> - Light class</li> <li><code>hev.py</code> - HevLight class</li> <li><code>infrared.py</code> - InfraredLight class</li> <li><code>multizone.py</code> - MultiZoneLight class</li> <li><code>tile.py</code> - TileDevice class</li> </ul> <p>Example:</p> <pre><code>from lifx.devices.light import Light\n\nasync with Light(serial, ip) as light:\n    # High-level operations\n    await light.set_color(Colors.BLUE)\n    await light.pulse(Colors.RED, period=1.0, cycles=5)\n</code></pre>"},{"location":"architecture/overview/#layer-4-high-level-api","title":"Layer 4: High-Level API","text":"<p>Purpose: Simple, batteries-included API</p> <ul> <li>Simplified Discovery: One-line device discovery</li> <li>Batch Operations: Control multiple devices</li> <li>Direct Connection: Connect by IP without discovery</li> <li>Filtered Discovery: Find devices by label or serial</li> </ul> <p>Key Files:</p> <ul> <li><code>api.py</code> - High-level functions</li> <li><code>color.py</code> - Color utilities</li> </ul> <p>Example:</p> <pre><code>from lifx import discover, Colors\n\nasync with discover() as group:\n    await group.set_color(Colors.BLUE)\n</code></pre>"},{"location":"architecture/overview/#data-flow","title":"Data Flow","text":""},{"location":"architecture/overview/#sending-a-command","title":"Sending a Command","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Light\n    participant Connection\n    participant Transport\n    participant Device\n\n    User-&gt;&gt;Light: set_color(Colors.BLUE)\n    Light-&gt;&gt;Light: Convert to HSBK\n    Light-&gt;&gt;Connection: send_packet(SetColor)\n    Connection-&gt;&gt;Connection: Serialize packet\n    Connection-&gt;&gt;Transport: send_message(bytes)\n    Transport-&gt;&gt;Device: UDP packet\n    Device--&gt;&gt;Transport: UDP acknowledgment\n    Transport--&gt;&gt;Connection: Response\n    Connection--&gt;&gt;Connection: Deserialize packet\n    Connection--&gt;&gt;Light: Reply\n    Light--&gt;&gt;User: Success</code></pre>"},{"location":"architecture/overview/#discovery-process","title":"Discovery Process","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Discovery\n    participant Transport\n    participant Network\n    participant Devices\n\n    User-&gt;&gt;Discovery: discover_devices(timeout=3.0)\n    Discovery-&gt;&gt;Transport: Open UDP socket\n    Discovery-&gt;&gt;Transport: Send broadcast (GetService)\n    Transport-&gt;&gt;Network: Broadcast on 255.255.255.255\n    Network-&gt;&gt;Devices: Broadcast packet\n    Devices--&gt;&gt;Network: StateService responses\n    Network--&gt;&gt;Transport: Multiple responses\n    Transport--&gt;&gt;Discovery: Parse responses\n    Discovery-&gt;&gt;Discovery: Collect device info\n    Discovery--&gt;&gt;User: List[DiscoveredDevice]</code></pre>"},{"location":"architecture/overview/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"architecture/overview/#async-first","title":"Async-First","text":"<p>Why: LIFX operations involve network I/O which benefits from async</p> <pre><code># Multiple devices controlled concurrently\nawait asyncio.gather(\n    light1.set_color(Colors.RED),\n    light2.set_color(Colors.BLUE),\n    light3.set_color(Colors.GREEN),\n)\n</code></pre>"},{"location":"architecture/overview/#connection-pooling","title":"Connection Pooling","text":"<p>Why: Reduces overhead and improves performance</p> <pre><code># Same connection reused automatically\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.RED)  # Connection 1\n    await light.set_brightness(0.5)  # Reuses Connection 1\n    await light.get_label()  # Reuses Connection 1\n</code></pre>"},{"location":"architecture/overview/#state-caching","title":"State Caching","text":"<p>Why: Reduces network traffic</p> <pre><code># First call: network request\nlabel1 = await light.get_label()\n\n# Second call within TTL: uses cache\nlabel2 = await light.get_label()  # No network request\n</code></pre>"},{"location":"architecture/overview/#code-generation","title":"Code Generation","text":"<p>Why: Protocol updates are automatic, reduces errors</p> <pre><code># Regenerate code\nuv run python -m lifx.protocol.generator\n</code></pre>"},{"location":"architecture/overview/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/overview/#connection-pool","title":"Connection Pool","text":"<ul> <li>LRU Cache: Least Recently Used eviction</li> <li>Max Size: Configurable (default: 128)</li> <li>Metrics: Track hits, misses, evictions</li> </ul>"},{"location":"architecture/overview/#state-caching_1","title":"State Caching","text":"<ul> <li>TTL: Configurable per device</li> <li>Default: 5 seconds</li> <li>Invalidation: Manual via <code>invalidate_cache()</code></li> </ul>"},{"location":"architecture/overview/#concurrency-model","title":"Concurrency Model","text":"<p>Each connection supports concurrent requests:</p> <pre><code>async with DeviceConnection(serial, ip) as conn:\n    # All three execute concurrently\n    results = await asyncio.gather(\n        conn.request_response(packet1, type1),\n        conn.request_response(packet2, type2),\n        conn.request_response(packet3, type3),\n    )\n</code></pre> <p>How it works:</p> <ul> <li>Background receiver task continuously reads UDP packets</li> <li>Responses matched to requests by sequence number</li> <li>Each request waits on an <code>asyncio.Event</code></li> <li>Single UDP socket per connection</li> </ul>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.11 or higher</li> <li>Network: Local network access to LIFX devices</li> <li>OS: Linux, macOS, Windows</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p><code>uv</code> is a fast Python package installer and resolver written in Rust. It's significantly faster than pip and is the recommended installation method:</p> <pre><code>uv pip install lifx-async\n</code></pre> <p>If you don't have <code>uv</code> installed yet:</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Or with pip\npip install uv\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>If you prefer to use pip:</p> <pre><code>pip install lifx-async\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>For the latest development version:</p> <pre><code>git clone https://github.com/Djelibeybi/lifx-async.git\ncd lifx\n\n# Using uv (recommended)\nuv pip install -e .\n\n# Or using pip\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#with-development-dependencies","title":"With Development Dependencies","text":"<p>To install with development tools (recommended for contributors):</p> <pre><code>git clone https://github.com/Djelibeybi/lifx-async.git\ncd lifx\n\n# Using uv (recommended)\nuv sync\n\n# Or using pip\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that lifx-async is installed correctly:</p> <pre><code>import lifx\n\nprint(lifx.__version__)\n</code></pre> <p>Or run a quick discovery:</p> <pre><code>import asyncio\nfrom lifx import discover\n\n\nasync def main():\n    async with discover(timeout=3.0) as group:\n        print(f\"Found {len(group)} devices\")\n        for device in group:\n            label = await device.get_label()\n            print(f\"  - {label}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-error","title":"Import Error","text":"<p>If you see <code>ModuleNotFoundError: No module named 'lifx'</code>:</p> <ol> <li>Ensure lifx-async is installed: <code>uv pip list | grep lifx-async</code> or <code>pip list | grep lifx-async</code></li> <li>Check your Python version: <code>python --version</code></li> <li>Verify you're using the correct Python environment</li> </ol>"},{"location":"getting-started/installation/#network-discovery-issues","title":"Network Discovery Issues","text":"<p>If discovery doesn't find devices:</p> <ol> <li>Ensure LIFX devices are on the same network</li> <li>Check firewall settings allow UDP broadcasts</li> <li>Try increasing the timeout: <code>discover(timeout=10.0)</code></li> <li>Use direct connection if you know the IP: <code>Light.from_ip(\"192.168.1.100\")</code></li> </ol>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>On some systems, you may need elevated permissions for network operations:</p> <pre><code># Linux/macOS\nsudo python your_script.py\n\n# Or add your user to the appropriate group\nsudo usermod -a -G netdev $USER  # Linux\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Start controlling your lights</li> <li>API Reference - Complete API documentation</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get up and running with lifx-async in minutes!</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#1-discover-lights","title":"1. Discover Lights","text":"<p>The simplest way to find and control LIFX lights:</p> <pre><code>import asyncio\nfrom lifx import discover\n\n\nasync def main():\n    async with discover(timeout=3.0) as group:\n        print(f\"Found {len(group)} lights\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#2-control-a-light","title":"2. Control a Light","text":"<p>Turn on a light and change its color:</p> <pre><code>import asyncio\nfrom lifx import discover, Colors\n\n\nasync def main():\n    async with discover() as group:\n        if group.lights:\n            light = group.lights[0]\n            await light.set_power(True)\n            await light.set_color(Colors.BLUE, duration=1.0)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#3-batch-operations","title":"3. Batch Operations","text":"<p>Control multiple lights at once:</p> <pre><code>import asyncio\nfrom lifx import discover, Colors\n\n\nasync def main():\n    async with discover() as group:\n        # Turn all lights on and blue\n        await group.set_power(True)\n        await group.set_color(Colors.BLUE, duration=1.0)\n\n        # Set brightness\n        await group.set_brightness(0.5)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#direct-connection-no-discovery","title":"Direct Connection (No Discovery)","text":"<p>If you know the IP:</p> <pre><code>import asyncio\nfrom lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        await light.set_color(Colors.RED)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#find-specific-device","title":"Find Specific Device","text":"<p>Find a device by label:</p> <pre><code>import asyncio\nfrom lifx import find_lights\n\n\nasync def main():\n    lights = await find_lights(label_contains=\"Bedroom\")\n    if lights:\n        async with lights[0] as light:\n            await light.set_color(Colors.WARM_WHITE)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#color-presets","title":"Color Presets","text":"<p>Use built-in color presets:</p> <pre><code>from lifx import Colors\n\n# Primary colors\nColors.RED\nColors.GREEN\nColors.BLUE\n\n# White variants\nColors.WARM_WHITE\nColors.COOL_WHITE\nColors.DAYLIGHT\n\n# Pastels\nColors.PASTEL_BLUE\nColors.PASTEL_PINK\n</code></pre>"},{"location":"getting-started/quickstart/#rgb-to-hsbk","title":"RGB to HSBK","text":"<p>Convert RGB values to HSBK:</p> <pre><code>from lifx import HSBK\n\n# Create color from RGB\npurple = HSBK.from_rgb(128, 0, 128)\nawait light.set_color(purple)\n</code></pre>"},{"location":"getting-started/quickstart/#effects","title":"Effects","text":"<p>Create visual effects:</p> <pre><code>import asyncio\nfrom lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Pulse effect\n        await light.pulse(Colors.RED, period=1.0, cycles=5)\n\n        # Breathe effect (infinite)\n        await light.breathe(Colors.BLUE, period=2.0, cycles=0)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>Always use proper error handling:</p> <pre><code>import asyncio\nfrom lifx import discover, LifxError\n\n\nasync def main():\n    try:\n        async with discover(timeout=3.0) as group:\n            if not group:\n                print(\"No devices found\")\n                return\n\n            await group.set_color(Colors.GREEN)\n    except LifxError as e:\n        print(f\"LIFX error: {e}\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Architecture - How lifx-async works</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced lifx patterns and techniques for building robust LIFX integrations.</p>"},{"location":"user-guide/advanced-usage/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Connection Management</li> <li>Concurrency Patterns</li> <li>State Caching</li> <li>Error Handling</li> <li>Device Capabilities</li> <li>Custom Effects</li> <li>Performance Optimization</li> </ul>"},{"location":"user-guide/advanced-usage/#connection-management","title":"Connection Management","text":""},{"location":"user-guide/advanced-usage/#understanding-connection-pooling","title":"Understanding Connection Pooling","text":"<p>lifx-async automatically pools connections for efficient reuse:</p> <pre><code>from lifx import Light\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # All these operations reuse the same connection\n        await light.set_power(True)\n        await light.set_color(Colors.BLUE)\n        await light.get_label()\n        # Connection automatically closed when exiting context\n</code></pre> <p>Benefits:</p> <ul> <li>Reduced overhead from socket creation/teardown</li> <li>Lower latency for repeated operations</li> <li>Automatic cleanup on context exit</li> </ul>"},{"location":"user-guide/advanced-usage/#concurrency-patterns","title":"Concurrency Patterns","text":""},{"location":"user-guide/advanced-usage/#concurrent-requests-single-device","title":"Concurrent Requests (Single Device)","text":"<p>Send multiple requests concurrently to one device:</p> <pre><code>import asyncio\nfrom lifx import Light\n\nasync def concurrent_operations():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # These execute concurrently!\n        label, power, color = await asyncio.gather(\n            light.get_label(),\n            light.get_power(),\n            light.get_color(),\n        )\n\n        print(f\"{label}: Power={power}, Color={color}\")\n</code></pre> <p>Performance Note: Concurrent requests execute with maximum parallelism. However, per the LIFX protocol specification, devices can handle approximately 20 messages per second. When sending many concurrent requests to a single device, consider implementing rate limiting in your application to avoid overwhelming the device.</p>"},{"location":"user-guide/advanced-usage/#multi-device-control","title":"Multi-Device Control","text":"<p>Control multiple devices in parallel:</p> <pre><code>import asyncio\nfrom lifx import discover, Colors\n\nasync def multi_device_control():\n    async with discover() as group:\n        # Create different tasks for different devices\n        tasks = [\n            group.devices[0].set_color(Colors.RED),\n            group.devices[1].set_color(Colors.GREEN),\n            group.devices[2].set_color(Colors.BLUE),\n        ]\n\n        # Execute all at once\n        await asyncio.gather(*tasks)\n</code></pre>"},{"location":"user-guide/advanced-usage/#batched-discovery","title":"Batched Discovery","text":"<p>Discover devices in batches for large networks:</p> <pre><code>from lifx.network.discovery import discover_devices\n\nasync def discover_in_batches():\n    # First batch: quick discovery\n    devices_quick = await discover_devices(\n        timeout=1.0,\n        broadcast_address=\"255.255.255.255\"\n    )\n\n    # Second batch: thorough discovery\n    if len(devices_quick) &lt; expected_count:\n        devices_full = await discover_devices(\n            timeout=5.0,\n            broadcast_address=\"255.255.255.255\"\n        )\n        return devices_full\n\n    return devices_quick\n</code></pre>"},{"location":"user-guide/advanced-usage/#state-caching","title":"State Caching","text":""},{"location":"user-guide/advanced-usage/#cache-configuration","title":"Cache Configuration","text":"<p>Configure cache TTL per device:</p> <pre><code>from lifx import Light\n\n# Short cache for frequently changing state\nlight = Light(\n    serial=\"d073d5000001\",\n    ip=\"192.168.1.100\",\n    cache_ttl=1.0  # 1 second cache\n)\n\n# Longer cache for stable metadata\nlight_stable = Light(\n    serial=\"d073d5000001\",\n    ip=\"192.168.1.100\",\n    cache_ttl=60.0  # 1 minute cache\n)\n</code></pre>"},{"location":"user-guide/advanced-usage/#manual-cache-control","title":"Manual Cache Control","text":"<pre><code>async def cache_management():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # First call: network request\n        color1 = await light.get_color()\n\n        # Second call within TTL: uses cache\n        color2 = await light.get_color()  # No network request!\n\n        # Force refresh by invalidating cache\n        light.invalidate_cache()\n        color3 = await light.get_color()  # Network request\n</code></pre>"},{"location":"user-guide/advanced-usage/#cache-ttl-categories","title":"Cache TTL Categories","text":"<p>lifx-async uses different TTLs for different data types:</p> <pre><code># Built-in TTL values (in Device class)\nSTATE_CACHE_TTL = 5.0        # Color, power, zones (changes frequently)\nMETADATA_CACHE_TTL = 180.0   # Label, version, info (rarely changes)\n</code></pre>"},{"location":"user-guide/advanced-usage/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/advanced-usage/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>from lifx.exceptions import (\n    LifxError,              # Base exception\n    LifxTimeoutError,       # Request timeout\n    LifxConnectionError,    # Connection failed\n    LifxProtocolError,      # Invalid protocol response\n    LifxDeviceNotFoundError,# Device not discovered\n    LifxNetworkError,       # Network issues\n    LifxUnsupportedCommandError,  # Device doesn't support operation\n)\n</code></pre>"},{"location":"user-guide/advanced-usage/#robust-error-handling","title":"Robust Error Handling","text":"<pre><code>import asyncio\nfrom lifx import Light, Colors\nfrom lifx.exceptions import LifxTimeoutError, LifxConnectionError\n\nasync def resilient_control():\n    max_retries = 3\n\n    for attempt in range(max_retries):\n        try:\n            async with await Light.from_ip(\"192.168.1.100\") as light:\n                await light.set_color(Colors.BLUE)\n                print(\"Success!\")\n                return\n\n        except LifxTimeoutError:\n            print(f\"Timeout (attempt {attempt + 1}/{max_retries})\")\n            if attempt &lt; max_retries - 1:\n                await asyncio.sleep(1.0)  # Wait before retry\n\n        except LifxConnectionError as e:\n            print(f\"Connection failed: {e}\")\n            break  # Don't retry connection errors\n\n    print(\"All retries exhausted\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>from lifx import discover\nfrom lifx.exceptions import LifxError\n\nasync def best_effort_control():\n    async with discover() as group:\n        results = []\n\n        # Try to control all lights, continue on errors\n        for light in group.lights:\n            try:\n                await light.set_color(Colors.GREEN)\n                results.append((light, \"success\"))\n            except LifxError as e:\n                results.append((light, f\"failed: {e}\"))\n\n        # Report results\n        for light, status in results:\n            label = await light.get_label() if status == \"success\" else \"Unknown\"\n            print(f\"{label}: {status}\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#device-capabilities","title":"Device Capabilities","text":""},{"location":"user-guide/advanced-usage/#detecting-capabilities","title":"Detecting Capabilities","text":"<p>Light capabilities are automatically populated:</p> <pre><code>from lifx import Light\nfrom lifx.products.registry import ProductCapability\n\nasync def check_capabilities():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n\n        print(f\"Product: {light.model}\")\n        print(f\"Capabilities: {light.capabilities}\")\n\n        # Check specific capabilities\n        if ProductCapability.COLOR in light.capabilities:\n            await light.set_color(Colors.BLUE)\n\n        if ProductCapability.MULTIZONE in light.capabilities:\n            print(\"This is a multizone device!\")\n\n        if ProductCapability.INFRARED in light.capabilities:\n            print(\"Supports infrared!\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#capability-based-logic","title":"Capability-Based Logic","text":"<pre><code>from lifx import discover\nfrom lifx.products.registry import ProductCapability\n\nasync def capability_aware_control():\n    async with discover() as group:\n\n        for device in group.devices:\n\n            # Color devices\n            if ProductCapability.COLOR in device.capabilities:\n                await device.set_color(Colors.PURPLE)\n\n            # Multizone devices\n            if ProductCapability.MULTIZONE in device.capabilities:\n                await device.set_zone_color(0, 8, Colors.RED)\n</code></pre>"},{"location":"user-guide/advanced-usage/#custom-effects","title":"Custom Effects","text":""},{"location":"user-guide/advanced-usage/#creating-smooth-transitions","title":"Creating Smooth Transitions","text":"<pre><code>import asyncio\nfrom lifx import Light, HSBK\n\nasync def smooth_color_cycle():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        hues = [0, 60, 120, 180, 240, 300, 360]\n\n        for hue in hues:\n            color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)\n            await light.set_color(color, duration=2.0)  # 2 second transition\n            await asyncio.sleep(2.0)\n</code></pre>"},{"location":"user-guide/advanced-usage/#synchronized-multi-device-effects","title":"Synchronized Multi-Device Effects","text":"<pre><code>import asyncio\nfrom lifx import discover, Colors\n\nasync def synchronized_flash():\n    async with discover() as group:\n        # Flash all devices simultaneously\n        for _ in range(5):\n            await group.set_color(Colors.RED, duration=0.0)\n            await asyncio.sleep(0.2)\n            await group.set_color(Colors.OFF, duration=0.0)\n            await asyncio.sleep(0.2)\n</code></pre>"},{"location":"user-guide/advanced-usage/#wave-effect-across-devices","title":"Wave Effect Across Devices","text":"<pre><code>import asyncio\nfrom lifx import discover, Colors\n\nasync def wave_effect():\n    async with discover() as group:\n        for i, device in enumerate(group.devices):\n            # Each device changes color with a delay\n            asyncio.create_task(\n                delayed_color_change(device, Colors.BLUE, delay=i * 0.3)\n            )\n\nasync def delayed_color_change(device, color, delay):\n    await asyncio.sleep(delay)\n    await device.set_color(color, duration=1.0)\n</code></pre>"},{"location":"user-guide/advanced-usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user-guide/advanced-usage/#minimize-network-requests","title":"Minimize Network Requests","text":"<pre><code># \u274c Inefficient: Multiple round-trips\nasync def inefficient():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        await light.set_power(True)\n        await asyncio.sleep(0.1)\n        await light.set_color(Colors.BLUE)\n        await asyncio.sleep(0.1)\n        await light.set_brightness(0.8)\n\n# \u2705 Efficient: Set color and brightness together\nasync def efficient():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        await light.set_power(True)\n        # Set color includes brightness\n        color = HSBK(hue=240, saturation=1.0, brightness=0.8, kelvin=3500)\n        await light.set_color(color, duration=0.0)\n</code></pre>"},{"location":"user-guide/advanced-usage/#batch-operations","title":"Batch Operations","text":"<pre><code># \u274c Sequential: Takes N * latency\nasync def sequential():\n    async with discover() as group:\n        for device in group.devices:\n            await device.set_color(Colors.GREEN)\n\n# \u2705 Parallel: Takes ~latency\nasync def parallel():\n    async with discover() as group:\n        await group.set_color(Colors.GREEN)\n</code></pre>"},{"location":"user-guide/advanced-usage/#cache-warm-up","title":"Cache Warm-Up","text":"<pre><code>async def warm_up_cache():\n    async with discover() as group:\n        # Pre-fetch frequently accessed data\n        await asyncio.gather(\n            *[device.get_label() for device in group.devices],\n            *[device.get_version() for device in group.devices],\n        )\n\n        # Now cached data is available instantly\n        for device in group.devices:\n            label = await device.get_label()  # From cache\n            print(f\"Device: {label}\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#connection-reuse","title":"Connection Reuse","text":"<pre><code># \u274c Creates new connection each time\nasync def no_reuse():\n    for _ in range(10):\n        async with await Light.from_ip(\"192.168.1.100\") as light:\n            await light.set_brightness(0.5)\n        # Connection closed here\n\n# \u2705 Reuses connection\nasync def with_reuse():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        for _ in range(10):\n            await light.set_brightness(0.5)\n        # Connection closed once at end\n</code></pre>"},{"location":"user-guide/advanced-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Troubleshooting Guide - Common issues and solutions</li> <li>Protocol Reference - Low-level protocol details</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/protocol-deep-dive/","title":"Protocol Deep Dive","text":"<p>Understanding the LIFX protocol and how lifx implements it.</p>"},{"location":"user-guide/protocol-deep-dive/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Protocol Overview</li> <li>Packet Structure</li> <li>Message Flow</li> <li>Protocol Types</li> <li>Code Generation</li> <li>Low-Level Usage</li> </ul>"},{"location":"user-guide/protocol-deep-dive/#protocol-overview","title":"Protocol Overview","text":"<p>The LIFX LAN Protocol is a binary protocol using UDP for communication:</p> <ul> <li>Port: 56700 (UDP)</li> <li>Packet Size: Variable (36-byte header + payload)</li> <li>Transport: Unreliable (UDP) with application-level reliability</li> <li>Discovery: Broadcast-based (255.255.255.255)</li> </ul>"},{"location":"user-guide/protocol-deep-dive/#protocol-layers","title":"Protocol Layers","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Application (lifx API)        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Packet Classes (packets.py)        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Models (models.py)                 \u2502\n\u2502  Serialization (serializer.py)      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Header (header.py)                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  UDP Transport                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#packet-structure","title":"Packet Structure","text":""},{"location":"user-guide/protocol-deep-dive/#header-format-36-bytes","title":"Header Format (36 bytes)","text":"<p>Every LIFX packet starts with a 36-byte header:</p> <pre><code>from lifx.protocol.header import LifxHeader\nfrom lifx.protocol.models import Serial\n\n# Create serial number\nserial = Serial.from_string(\"d073d5123456\")\n\nheader = LifxHeader(\n    size=64,                    # Total packet size (header + payload)\n    protocol=1024,              # Protocol version (always 1024)\n    addressable=True,           # Addressing mode\n    tagged=False,               # Broadcast vs unicast\n    source=0x12345678,          # Unique client ID\n    target=serial.to_protocol(), # Device serial (8 bytes with padding)\n    res_required=True,          # Expects response\n    ack_required=False,         # Expects acknowledgment\n    sequence=1,                 # Sequence number (0-255)\n    pkt_type=101,               # Message type\n)\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#header-fields","title":"Header Fields","text":"Field Size Description size 2 bytes Total packet size including header origin 2 bits Message origin (always 0) tagged 1 bit Broadcast (1) or targeted (0) addressable 1 bit Addressing mode (always 1) protocol 12 bits Protocol number (always 1024) source 4 bytes Unique client identifier target 8 bytes Device MAC address (6 bytes + 2 padding) reserved 6 bytes Reserved for future use res_required 1 bit Response required flag ack_required 1 bit Acknowledgment required flag reserved 6 bits Reserved sequence 1 byte Wrap-around sequence number reserved 8 bytes Reserved pkt_type 2 bytes Message type identifier reserved 2 bytes Reserved"},{"location":"user-guide/protocol-deep-dive/#payload","title":"Payload","text":"<p>Variable-length payload following the header:</p> <pre><code># Example: SetColor payload (13 bytes)\n{\n    'reserved': 0,              # 1 byte\n    'color': HSBK(...),         # 8 bytes (4 \u00d7 uint16)\n    'duration': 1000,           # 4 bytes (uint32, milliseconds)\n}\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#message-flow","title":"Message Flow","text":""},{"location":"user-guide/protocol-deep-dive/#discovery-process","title":"Discovery Process","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Network\n    participant Device1\n    participant Device2\n\n    Client-&gt;&gt;Network: Broadcast GetService (tagged=1)\n    Network-&gt;&gt;Device1: GetService\n    Network-&gt;&gt;Device2: GetService\n    Device1--&gt;&gt;Client: StateService (port 56700)\n    Device2--&gt;&gt;Client: StateService (port 56700)\n    Client-&gt;&gt;Client: Collect responses</code></pre>"},{"location":"user-guide/protocol-deep-dive/#request-response-pattern","title":"Request-Response Pattern","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Device\n\n    Client-&gt;&gt;Device: GetLabel (seq=1, res_required=1)\n    Device--&gt;&gt;Client: StateLabel (seq=1, \"Living Room\")\n\n    Client-&gt;&gt;Device: SetColor (seq=2, res_required=0, ack_required=1)\n    Device--&gt;&gt;Client: Acknowledgement (seq=2)</code></pre>"},{"location":"user-guide/protocol-deep-dive/#concurrent-requests","title":"Concurrent Requests","text":"<p>lifx-async supports concurrent requests on a single connection:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Device\n\n    Client-&gt;&gt;Device: Request 1 (seq=1)\n    Client-&gt;&gt;Device: Request 2 (seq=2)\n    Client-&gt;&gt;Device: Request 3 (seq=3)\n\n    Device--&gt;&gt;Client: Handle Response 2 (seq=2)\n    Device--&gt;&gt;Client: Handle Response 1(seq=1)\n    Device--&gt;&gt;Client: Handle Response 3 (seq=3)</code></pre>"},{"location":"user-guide/protocol-deep-dive/#protocol-types","title":"Protocol Types","text":""},{"location":"user-guide/protocol-deep-dive/#color-representation","title":"Color Representation","text":"<p>LIFX uses HSBK color space:</p> <pre><code>from lifx.color import HSBK\n\ncolor = HSBK(\n    hue=180.0,         # 0-360 degrees\n    saturation=1.0,    # 0.0-1.0\n    brightness=0.75,   # 0.0-1.0\n    kelvin=3500,       # 1500-9000\n)\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#packet-categories","title":"Packet Categories","text":"<p>Packets are organized by category:</p> Category Purpose Examples <code>Device</code> Device-wide operations GetLabel, SetLabel, GetPower <code>Light</code> Light control SetColor, GetColor, SetWaveform <code>MultiZone</code> Strip/beam control SetColorZones, GetColorZones <code>Tile</code> Tile device control GetTileState64, SetTileState64"},{"location":"user-guide/protocol-deep-dive/#common-packet-types","title":"Common Packet Types","text":"<pre><code>from lifx.protocol import packets\n\n# Device packets\nget_label = packets.Device.GetLabel()              # pkt_type=23\nset_label = packets.Device.SetLabel(label=\"Room\")  # pkt_type=24\n\n# Light packets\nget_color = packets.Light.Get()                    # pkt_type=101\nset_color = packets.Light.SetColor(               # pkt_type=102\n    color=HSBK(...),\n    duration=1000\n)\n\n# MultiZone packets\nget_zones = packets.MultiZone.GetColorZones(      # pkt_type=502\n    start_index=0,\n    end_index=8\n)\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#code-generation","title":"Code Generation","text":""},{"location":"user-guide/protocol-deep-dive/#from-protocolyml","title":"From protocol.yml","text":"<p>lifx-async auto-generates protocol code from the official LIFX specification:</p> <pre><code># protocol.yml excerpt\npackets:\n  - name: SetColor\n    pkt_type: 102\n    category: light\n    fields:\n      - name: reserved\n        type: uint8\n      - name: color\n        type: HSBK\n      - name: duration\n        type: uint32\n</code></pre> <p>Generates:</p> <pre><code># packets.py (generated)\n@dataclass\nclass SetColor:\n    PKT_TYPE: ClassVar[int] = 102\n    CATEGORY: ClassVar[str] = \"Light\"\n\n    reserved: int = 0\n    color: HSBK = field(default_factory=HSBK)\n    duration: int = 0\n\n    def pack(self) -&gt; bytes:\n        # Serialization logic\n        ...\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#regenerating-protocol-code","title":"Regenerating Protocol Code","text":"<pre><code># Regenerate Python code\nuv run python -m lifx.protocol.generator\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#generator-features","title":"Generator Features","text":"<ul> <li>Type Safety: Full type hints for all structures</li> <li>Validation: Bounds checking for protocol values</li> <li>Documentation: Docstrings from protocol comments</li> <li>Filtering: Excludes non-lighting categories (Button, Relay)</li> </ul>"},{"location":"user-guide/protocol-deep-dive/#low-level-usage","title":"Low-Level Usage","text":""},{"location":"user-guide/protocol-deep-dive/#direct-protocol-usage","title":"Direct Protocol Usage","text":"<pre><code>from lifx.network.connection import DeviceConnection\nfrom lifx.protocol import packets\nfrom lifx.protocol.protocol_types import HSBK\n\nasync def low_level_control():\n    # Create connection\n    conn = DeviceConnection(\n        serial=\"d073d5000001\",\n        ip=\"192.168.1.100\"\n    )\n\n    # Create packet\n    packet = packets.Light.SetColor(\n        reserved=0,\n        color=HSBK(hue=32768, saturation=65535, brightness=49151, kelvin=3500),\n        duration=1000\n    )\n\n    # Send and receive response\n    response = await conn.request(\n        packet,\n        timeout=2.0\n    )\n\n    print(f\"Response: {response}\")\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#protocol-constants","title":"Protocol Constants","text":""},{"location":"user-guide/protocol-deep-dive/#important-values","title":"Important Values","text":"<pre><code># Ports\nLIFX_UDP_PORT = 56700\n\n# Protocol version\nLIFX_PROTOCOL_VERSION = 1024\n\n# Color limits\nHUE_MAX = 65535        # Maps to 360\u00b0\nSATURATION_MAX = 65535 # Maps to 100%\nBRIGHTNESS_MAX = 65535 # Maps to 100%\nKELVIN_MIN = 1500\nKELVIN_MAX = 9000\n\n# Timing\nMAX_DURATION = 0xFFFFFFFF  # ~49 days in milliseconds\nMIN_DURATION = 0           # Instant\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#next-steps","title":"Next Steps","text":"<ul> <li>Connection Management - Connection patterns</li> <li>API Reference - Protocol API documentation</li> <li>Architecture - System architecture</li> </ul>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Common issues and solutions when working with lifx.</p>"},{"location":"user-guide/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Discovery Issues</li> <li>Connection Problems</li> <li>Timeout Errors</li> <li>Performance Issues</li> <li>Debugging Tips</li> </ul>"},{"location":"user-guide/troubleshooting/#discovery-issues","title":"Discovery Issues","text":""},{"location":"user-guide/troubleshooting/#no-devices-found","title":"No Devices Found","text":"<p>Symptom: <code>discover()</code> returns an empty group</p> <p>Common Causes:</p> <ol> <li> <p>Devices not on same network <pre><code># Check network connectivity\nimport asyncio\nfrom lifx.network.discovery import discover_devices\n\ndevices = await discover_devices(timeout=5.0)\nprint(f\"Found {len(devices)} devices\")\n</code></pre></p> </li> <li> <p>Firewall blocking UDP port 56700 <pre><code># Linux: Check if port is open\nsudo netstat -an | grep 56700\n\n# Allow UDP on port 56700\nsudo ufw allow 56700/udp\n</code></pre></p> </li> <li> <p>Broadcast address incorrect</p> </li> </ol> <p>Try different broadcast addresses:</p> <pre><code>from lifx import discover\n\n# Default (255.255.255.255)\nasync with discover() as group:\n    pass\n\n# Network-specific (e.g., 192.168.1.255)\nasync with discover(broadcast_address=\"192.168.1.255\") as group:\n    pass\n</code></pre> <p>Solution:</p> <pre><code>import asyncio\nfrom lifx.network.discovery import discover_devices\n\nasync def diagnose_discovery():\n    print(\"Attempting discovery...\")\n\n    # Try with extended timeout\n    devices = await discover_devices(\n        timeout=10.0,\n        broadcast_address=\"255.255.255.255\"\n    )\n\n    if not devices:\n        print(\"No devices found. Check:\")\n        print(\"1. Devices are powered on\")\n        print(\"2. Devices are on the same network\")\n        print(\"3. Firewall allows UDP port 56700\")\n        print(\"4. Try a network-specific broadcast address\")\n    else:\n        print(f\"Found {len(devices)} devices:\")\n        for device in devices:\n            print(f\"  - {device.serial} at {device.ip}\")\n\nasyncio.run(diagnose_discovery())\n</code></pre>"},{"location":"user-guide/troubleshooting/#partial-device-discovery","title":"Partial Device Discovery","text":"<p>Symptom: Only some devices discovered</p> <p>Causes:</p> <ul> <li>Devices on different subnets</li> <li>Network congestion</li> <li>Devices slow to respond</li> </ul> <p>Solution:</p> <pre><code>async def thorough_discovery():\n    # Multiple discovery passes with different timeouts\n    all_devices = set()\n\n    for timeout in [3.0, 5.0, 10.0]:\n        devices = await discover_devices(timeout=timeout)\n        for device in devices:\n            all_devices.add((device.serial, device.ip))\n\n    print(f\"Total devices found: {len(all_devices)}\")\n    return all_devices\n</code></pre>"},{"location":"user-guide/troubleshooting/#connection-problems","title":"Connection Problems","text":""},{"location":"user-guide/troubleshooting/#connection-refused","title":"Connection Refused","text":"<p>Symptom: <code>LifxConnectionError: Connection refused</code></p> <p>Causes:</p> <ul> <li>Incorrect IP address</li> <li>Device powered off</li> <li>Network unreachable</li> </ul> <p>Solution:</p> <pre><code>from lifx import Light\nfrom lifx.exceptions import LifxConnectionError\nimport asyncio\n\nasync def test_connection(ip: str):\n    try:\n        async with await Light.from_ip(ip) as light:\n            label = await light.get_label()\n            print(f\"Connected to: {label}\")\n            return True\n\n    except LifxConnectionError as e:\n        print(f\"Connection failed: {e}\")\n        print(\"Check:\")\n        print(\"1. Device IP is correct\")\n        print(\"2. Device is powered on\")\n        print(\"3. Device is reachable (try ping)\")\n        return False\n\n# Test connectivity\nasyncio.run(test_connection(\"192.168.1.100\"))\n</code></pre>"},{"location":"user-guide/troubleshooting/#connection-drops","title":"Connection Drops","text":"<p>Symptom: Intermittent <code>LifxConnectionError</code> or <code>LifxNetworkError</code></p> <p>Causes:</p> <ul> <li>WiFi signal weak</li> <li>Network congestion</li> <li>Device overloaded</li> </ul> <p>Solution:</p> <pre><code>import asyncio\nfrom lifx import Light\nfrom lifx.exceptions import LifxError\n\nasync def resilient_operation(ip: str, max_retries: int = 3):\n    \"\"\"Retry operations with exponential backoff\"\"\"\n    async with await Light.from_ip(ip) as light:\n        for attempt in range(max_retries):\n            try:\n                await light.set_power(True)\n                print(\"Success!\")\n                return\n            except LifxError as e:\n                wait_time = 2 ** attempt  # 1s, 2s, 4s\n                print(f\"Attempt {attempt + 1} failed: {e}\")\n\n                if attempt &lt; max_retries - 1:\n                    print(f\"Retrying in {wait_time}s...\")\n                    await asyncio.sleep(wait_time)\n\n    print(\"All retries exhausted\")\n</code></pre>"},{"location":"user-guide/troubleshooting/#timeout-errors","title":"Timeout Errors","text":""},{"location":"user-guide/troubleshooting/#request-timeouts","title":"Request Timeouts","text":"<p>Symptom: <code>LifxTimeoutError: Request timed out after X seconds</code></p> <p>Causes:</p> <ul> <li>Device slow to respond</li> <li>Network latency high</li> <li>Device busy processing other requests</li> </ul> <p>Solution:</p> <pre><code>from lifx import Light\n\n# Increase timeout for slow devices\nasync with await Light.from_ip(ip, timeout=5.0) as light:\n    light.get_color()\n</code></pre>"},{"location":"user-guide/troubleshooting/#discovery-timeout-too-short","title":"Discovery Timeout Too Short","text":"<p>Symptom: Some devices not found</p> <p>Solution:</p> <pre><code>from lifx import discover\n\n# Increase discovery timeout\nasync with discover(timeout=10.0) as group:  # Default is 3.0\n    print(f\"Found {len(group.devices)} devices\")\n</code></pre>"},{"location":"user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"user-guide/troubleshooting/#slow-operations","title":"Slow Operations","text":"<p>Symptom: Operations take longer than expected</p> <p>Diagnosis:</p> <pre><code>import time\nfrom lifx import Light\n\nasync def measure_latency():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Measure single request\n        start = time.time()\n        await light.get_label()\n        elapsed = time.time() - start\n        print(f\"Single request: {elapsed*1000:.2f}ms\")\n\n        # Measure sequential requests\n        start = time.time()\n        for _ in range(10):\n            await light.get_label()\n        elapsed = time.time() - start\n        print(f\"10 sequential: {elapsed*1000:.2f}ms ({elapsed*100:.2f}ms avg)\")\n\n        # Measure concurrent requests\n        start = time.time()\n        await asyncio.gather(*[light.get_label() for _ in range(10)])\n        elapsed = time.time() - start\n        print(f\"10 concurrent: {elapsed*1000:.2f}ms\")\n</code></pre> <p>Common Causes:</p> <ol> <li>Sequential instead of concurrent operations</li> </ol> <p>Slow approach (sequential):    <pre><code>for device in devices:\n    await device.set_color(Colors.BLUE)\n</code></pre></p> <p>Fast approach (concurrent):    <pre><code>await asyncio.gather(\n    *[device.set_color(Colors.BLUE) for device in devices]\n)\n</code></pre></p> <ol> <li>Not using connection pooling</li> </ol> <p>Inefficient (creates new connection each time):    <pre><code>for i in range(10):\n    async with await Light.from_ip(ip) as light:\n        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)\n</code></pre></p> <p>Efficient (reuses connection):    <pre><code>async with await Light.from_ip(ip) as light:\n    for i in range(10):\n        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)\n</code></pre></p> <ol> <li>Cache disabled or TTL too short</li> </ol> <pre><code># Use appropriate cache TTL\nlight = Light(\n    serial=\"d073d5000001\",\n    ip=\"192.168.1.100\",\n    cache_ttl=5.0  # Cache for 5 seconds\n)\n</code></pre>"},{"location":"user-guide/troubleshooting/#docker-container-networking","title":"Docker / Container Networking","text":"<p>Symptom: Discovery doesn't work in Docker container</p> <p>Cause: Container network isolation</p> <p>Solution:</p> <pre><code># docker-compose.yml\nservices:\n  app:\n    network_mode: \"host\"  # Use host network for UDP broadcast\n</code></pre> <p>Or use manual device specification:</p> <pre><code># Don't rely on discovery\nfrom lifx import Light\n\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n</code></pre>"},{"location":"user-guide/troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"user-guide/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\n\n# Enable DEBUG logging for lifx\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Or for specific modules\nlogging.getLogger('lifx.network').setLevel(logging.DEBUG)\nlogging.getLogger('lifx.devices').setLevel(logging.DEBUG)\n</code></pre>"},{"location":"user-guide/troubleshooting/#check-product-registry","title":"Check Product Registry","text":"<pre><code>from lifx.products import get_product, get_registry\n\n# List all known products\nregistry = get_registry()\nfor product_id, product in registry.items():\n    print(f\"{product_id}: {product.name}\")\n\n# Check specific product\nproduct = get_product(27)  # LIFX A19\nif product:\n    print(f\"Name: {product.name}\")\n    print(f\"Capabilities: {product.capabilities}\")\n</code></pre>"},{"location":"user-guide/troubleshooting/#verify-device-reachability","title":"Verify Device Reachability","text":"<pre><code># Ping device\nping 192.168.1.100\n\n# Check UDP port (requires nmap)\nsudo nmap -sU -p 56700 192.168.1.100\n\n# Test with netcat\necho -n \"test\" | nc -u 192.168.1.100 56700\n</code></pre>"},{"location":"user-guide/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check GitHub Issues: github.com/Djelibeybi/lifx-async/issues</li> <li>Enable debug logging: Capture logs with <code>logging.DEBUG</code></li> <li>Provide details:</li> <li>Python version</li> <li>lifx version</li> <li>Device model and firmware version</li> <li>Network configuration</li> <li>Minimal reproduction code</li> <li>Full error traceback</li> </ol>"},{"location":"user-guide/troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Meaning Solution <code>LifxTimeoutError</code> Device didn't respond Increase timeout, check network <code>LifxConnectionError</code> Can't connect to device Check IP, firewall, device power <code>LifxDeviceNotFoundError</code> Device not discovered Check network, increase timeout <code>LifxProtocolError</code> Invalid response Update firmware, check device type <code>LifxUnsupportedCommandError</code> Device doesn't support command Check device capabilities <code>AttributeError: 'Light' has no attribute 'set_zone_color'</code> Wrong device class Use <code>MultiZoneLight</code>"},{"location":"user-guide/troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Usage - Optimization patterns</li> <li>API Reference - Complete API documentation</li> <li>FAQ - Frequently asked questions</li> </ul>"}]}