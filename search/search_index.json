{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"lifx-async","text":"<p>A modern, type-safe, async Python library for controlling LIFX lights over the local network.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udce6 No Runtime Dependencies: only Python standard libraries required</li> <li>\ud83c\udfaf Type-Safe: Full type hints with strict Pyright validation</li> <li>\ud83d\udd0c Async Generators: Provides <code>async for</code> usage pattern</li> <li>\u26a1 Async Context Managers: Provides <code>async with</code> and <code>await</code> usage patterns</li> <li>\ud83d\udd0c Lazy Connections: Auto-open on first request, explicit cleanup</li> <li>\ud83c\udfd7\ufe0f Layered Architecture: Protocol \u2192 Network \u2192 Device \u2192 API</li> <li>\ud83d\udd04 Protocol Generator: generates LIFX protocol <code>Packets</code>, <code>Fields</code> and <code>Enum</code> classes from LIFX public protocol definition</li> <li>\ud83c\udf08 Comprehensive Support: supports all LIFX smart lighting products including Color, White, Warm to White, Filament, Clean, Night Vision, Z, Beam, String, Neon, Permanent Outdoor, Tile, Candle, Ceiling, Path, Spot, and Luna.</li> </ul>"},{"location":"#examples","title":"Examples","text":"DiscoveryDirect ConnectionColor Control <pre><code>import asyncio\nfrom lifx import discover, Colors\n\nasync def main():\n    # Discover devices asynchronously:\n    async for device in discover():\n        # Control each device as it is discovered\n        await device.set_power(True)\n        await device.set_color(Colors.BLUE, duration=1.0)\n\nasyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom lifx import Light, HSBK\n\nasync def main():\n    # Connect most efficiently without discovery using serial and IP\n    async with Light(serial=\"d073d5010203\", ip=\"192.168.1.100\") as light:\n        # Using Light as a context manager auto-populates non-volatile state information\n        print(f\"{light.label} is a {light.model} at {light.location} in the {light.group} group.\")\n\n        await light.set_color(HSBK(hue=0, saturation=1.0, brightness=0.8, kelvin=3500), duration=2.0)\n\nasyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom lifx import Light, HSBK, Colors\n\nasync def main():\n    async with Light(serial=\"d073d5010203\", ip=\"192.168.1.100\") as light:\n        # Use RGB\n        red = HSBK.from_rgb(255, 0, 0)\n        await light.set_color(red)\n\n        # Use presets\n        await light.set_color(Colors.WARM_WHITE)\n\n        # Custom HSBK\n        custom = HSBK(\n            hue=180,         # 0-360 degrees\n            saturation=0.7,  # 0.0-1.0\n            brightness=0.8,  # 0.0-1.0\n            kelvin=3500,     # 1500-9000\n        )\n        await light.set_color(custom)\n\nasyncio.run(main())\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Using uv (recommended)\nuv pip install lifx-async\n\n# Or using pip\npip install lifx-async\n</code></pre> <p>For development:</p> <pre><code>git clone https://github.com/Djelibeybi/lifx-async.git\ncd lifx\nuv sync\n</code></pre>"},{"location":"#why-lifx-async","title":"Why lifx-async?","text":""},{"location":"#modern-python","title":"Modern Python","text":"<ul> <li>Async For and Async With: extensive use of asynchronous generators and context managers</li> <li>Async/Await: Native asyncio support for concurrent operations</li> <li>Type Hints: Full type annotations for better IDE support</li> <li>Python 3.11+: Modern language features and performance</li> </ul>"},{"location":"#reliable","title":"Reliable","text":"<ul> <li>Comprehensive Tests: over 700 tests covering over 90% of the source code</li> <li>Lazy Connections: Auto-open on first request</li> <li>Stores State: Reduces network traffic</li> </ul>"},{"location":"#developer-friendly","title":"Developer Friendly","text":"<ul> <li>Clear API: Intuitive, Pythonic interface</li> <li>Rich Documentation: Extensive guides and examples</li> <li>Code Generation: Protocol updates are automatic</li> <li>No External Dependencies: Only Python standard libraries required</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>Documentation: https://lifx.readthedocs.io</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>Universal Permissive License 1.0 - see LICENSE for details.</p>"},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v473-2025-12-16","title":"v4.7.3 (2025-12-16)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>devices: Capture component colors before set_power turns off light   (<code>a99abee</code>)</li> </ul>"},{"location":"changelog/#v472-2025-12-16","title":"v4.7.2 (2025-12-16)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>api: Close device connections in DeviceGroup context manager   (<code>054bfee</code>)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>api: Add dataclass documentation and improve navigation   (<code>c859c87</code>)</li> </ul>"},{"location":"changelog/#v471-2025-12-13","title":"v4.7.1 (2025-12-13)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>devices: Add length parameter to copy_frame_buffer()   (<code>6a74690</code>)</li> </ul>"},{"location":"changelog/#v470-2025-12-13","title":"v4.7.0 (2025-12-13)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>devices: Add fast parameter to set_extended_color_zones()   (<code>0276fca</code>)</li> </ul>"},{"location":"changelog/#v461-2025-12-12","title":"v4.6.1 (2025-12-12)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>devices: Check for power and brightness for Ceiling components   (<code>bd1b92f</code>)</li> </ul>"},{"location":"changelog/#v460-2025-12-11","title":"v4.6.0 (2025-12-11)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>devices: Add CeilingLightState dataclass for ceiling component state   (<code>607f15c</code>)</li> </ul>"},{"location":"changelog/#v451-2025-12-11","title":"v4.5.1 (2025-12-11)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>devices: Export CeilingLight add add user guide and API documentation   (<code>10e0089</code>)</li> </ul>"},{"location":"changelog/#v450-2025-12-08","title":"v4.5.0 (2025-12-08)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>devices: Add CeilingLight with independent uplight/downlight component control   (<code>95fc5a6</code>)</li> </ul>"},{"location":"changelog/#v441-2025-12-03","title":"v4.4.1 (2025-12-03)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>theme: Prevent color displacement in multi-tile matrix theme application   (<code>ca936ec</code>)</li> </ul>"},{"location":"changelog/#v440-2025-11-29","title":"v4.4.0 (2025-11-29)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>devices: Add factory pattern with automatic type detection and state management   (<code>4374248</code>)</li> </ul>"},{"location":"changelog/#v439-2025-11-27","title":"v4.3.9 (2025-11-27)","text":""},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>network: Propagate timeout from request() to internal methods   (<code>b35ebea</code>)</li> </ul>"},{"location":"changelog/#v438-2025-11-25","title":"v4.3.8 (2025-11-25)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>network: Raise exception on StateUnhandled instead of returning False   (<code>5ca3e8a</code>)</li> </ul>"},{"location":"changelog/#v437-2025-11-25","title":"v4.3.7 (2025-11-25)","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>devices: Raise LifxUnsupportedCommandError on StateUnhandled responses   (<code>ec142cf</code>)</li> </ul>"},{"location":"changelog/#v436-2025-11-25","title":"v4.3.6 (2025-11-25)","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>network: Return StateUnhandled packets instead of raising exception   (<code>f27e848</code>)</li> </ul>"},{"location":"changelog/#v435-2025-11-22","title":"v4.3.5 (2025-11-22)","text":""},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>devices: Allow MatrixEffect without palette   (<code>fb31df5</code>)</li> </ul>"},{"location":"changelog/#v434-2025-11-22","title":"v4.3.4 (2025-11-22)","text":""},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>network: Exclude retry sleep time from timeout budget   (<code>312d7a7</code>)</li> </ul>"},{"location":"changelog/#v433-2025-11-22","title":"v4.3.3 (2025-11-22)","text":""},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li> <p>Give MatrixLight.get64() some default parameters   (<code>a69a49c</code>)</p> </li> <li> <p>themes: Apply theme colors to all zones via proper canvas interpolation   (<code>f1628c4</code>)</p> </li> </ul>"},{"location":"changelog/#v432-2025-11-22","title":"v4.3.2 (2025-11-22)","text":""},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>effects: Add name property to LIFXEffect and subclasses   (<code>deb8a54</code>)</li> </ul>"},{"location":"changelog/#v431-2025-11-22","title":"v4.3.1 (2025-11-22)","text":""},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>Actually rename the matrix methods   (<code>061aaa7</code>)</li> </ul>"},{"location":"changelog/#v430-2025-11-22","title":"v4.3.0 (2025-11-22)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>effects: Unify effect enums and simplify API   (<code>df1c3c8</code>)</li> </ul>"},{"location":"changelog/#v421-2025-11-21","title":"v4.2.1 (2025-11-21)","text":""},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>Get_wifi_info now returns signal and rssi correctly   (<code>6db03b3</code>)</li> </ul>"},{"location":"changelog/#v420-2025-11-21","title":"v4.2.0 (2025-11-21)","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>api: Remove obsolete reference to MessageBuilder   (<code>9847948</code>)</li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>devices: Add ambient light sensor support   (<code>75f0673</code>)</li> </ul>"},{"location":"changelog/#v410-2025-11-20","title":"v4.1.0 (2025-11-20)","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>network: Replace polling architecture with event-driven background receiver   (<code>9862eac</code>)</li> </ul>"},{"location":"changelog/#v402-2025-11-19","title":"v4.0.2 (2025-11-19)","text":""},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>Product registry generation   (<code>2742a18</code>)</li> </ul>"},{"location":"changelog/#v401-2025-11-18","title":"v4.0.1 (2025-11-18)","text":""},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>devices: Prevent connection leaks in temporary device queries   (<code>0ee8d0c</code>)</li> </ul>"},{"location":"changelog/#v400-2025-11-18","title":"v4.0.0 (2025-11-18)","text":""},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>devices: Replace TileDevice with MatrixLight implementation   (<code>1b8bc39</code>)</li> </ul>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>devices: TileDevice class has been removed and replaced with MatrixLight</li> </ul>"},{"location":"changelog/#v310-2025-11-17","title":"v3.1.0 (2025-11-17)","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Remove connection pool in favor of lazy device-owned connections   (<code>11b3cb2</code>)</li> </ul>"},{"location":"changelog/#v301-2025-11-17","title":"v3.0.1 (2025-11-17)","text":""},{"location":"changelog/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li>Get_power() now returns an integer value not a boolean   (<code>3644bb9</code>)</li> </ul>"},{"location":"changelog/#v300-2025-11-16","title":"v3.0.0 (2025-11-16)","text":""},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li> <p>Convert discovery methods to async generators   (<code>0d41880</code>)</p> </li> <li> <p>Replace event-based request/response with async generators   (<code>fa50734</code>)</p> </li> </ul>"},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Internal connection architecture completely refactored</li> </ul>"},{"location":"changelog/#v222-2025-11-14","title":"v2.2.2 (2025-11-14)","text":""},{"location":"changelog/#bug-fixes_19","title":"Bug Fixes","text":"<ul> <li>devices: Replace hardcoded timeout and retry values with constants   (<code>989afe2</code>)</li> </ul>"},{"location":"changelog/#v221-2025-11-14","title":"v2.2.1 (2025-11-14)","text":""},{"location":"changelog/#bug-fixes_20","title":"Bug Fixes","text":"<ul> <li>network: Resolve race condition in concurrent request handling   (<code>8bb7bc6</code>)</li> </ul>"},{"location":"changelog/#v220-2025-11-14","title":"v2.2.0 (2025-11-14)","text":""},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>network: Add jitter to backoff and consolidate retry logic   (<code>0dfb1a2</code>)</li> </ul>"},{"location":"changelog/#v210-2025-11-14","title":"v2.1.0 (2025-11-14)","text":""},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>Add mac_address property to Device class   (<code>bd101a0</code>)</li> </ul>"},{"location":"changelog/#v200-2025-11-14","title":"v2.0.0 (2025-11-14)","text":""},{"location":"changelog/#refactoring","title":"Refactoring","text":"<ul> <li>Simplify state caching and remove TTL system   (<code>fd15587</code>)</li> </ul>"},{"location":"changelog/#v131-2025-11-12","title":"v1.3.1 (2025-11-12)","text":""},{"location":"changelog/#bug-fixes_21","title":"Bug Fixes","text":"<ul> <li>Add Theme, ThemeLibrary, get_theme to main lifx package exports   (<code>6b41bb8</code>)</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li> <p>Add mkdocs-llmstxt to create llms.txt and llms-full.txt   (<code>4dd378c</code>)</p> </li> <li> <p>Remove effects release notes   (<code>2fdabc0</code>)</p> </li> </ul>"},{"location":"changelog/#v130-2025-11-10","title":"v1.3.0 (2025-11-10)","text":""},{"location":"changelog/#features_12","title":"Features","text":"<ul> <li>Add software effects   (<code>be768fb</code>)</li> </ul>"},{"location":"changelog/#v121-2025-11-08","title":"v1.2.1 (2025-11-08)","text":""},{"location":"changelog/#bug-fixes_22","title":"Bug Fixes","text":"<ul> <li>Implement tile effect parameters as local quirk   (<code>f4ada9b</code>)</li> </ul>"},{"location":"changelog/#v120-2025-11-07","title":"v1.2.0 (2025-11-07)","text":""},{"location":"changelog/#features_13","title":"Features","text":"<ul> <li>Add theme support   (<code>82477cd</code>)</li> </ul>"},{"location":"changelog/#v113-2025-11-06","title":"v1.1.3 (2025-11-06)","text":""},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>Reduce network traffic when updating individual color values   (<code>679b717</code>)</li> </ul>"},{"location":"changelog/#v112-2025-11-05","title":"v1.1.2 (2025-11-05)","text":""},{"location":"changelog/#bug-fixes_23","title":"Bug Fixes","text":"<ul> <li>Dummy fix to trigger semantic release   (<code>86ad8b4</code>)</li> </ul>"},{"location":"changelog/#v111-2025-11-05","title":"v1.1.1 (2025-11-05)","text":""},{"location":"changelog/#bug-fixes_24","title":"Bug Fixes","text":"<ul> <li>Dummy fix to trigger semantic release   (<code>12786b5</code>)</li> </ul>"},{"location":"changelog/#v110-2025-11-05","title":"v1.1.0 (2025-11-05)","text":""},{"location":"changelog/#features_14","title":"Features","text":"<ul> <li>Replace cache TTL system with timestamped state attributes   (<code>5ae147a</code>)</li> </ul>"},{"location":"changelog/#v100-2025-11-04","title":"v1.0.0 (2025-11-04)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#what-is-lifx-async","title":"What is lifx-async?","text":"<p>lifx-async is a modern, async Python library for controlling LIFX smart lighting devices over your local network. It provides a type-safe, high-performance interface for device discovery, color control, effects, and more.</p>"},{"location":"faq/#which-devices-are-supported","title":"Which devices are supported?","text":"<p>lifx-async supports all LIFX lighting products, including:</p> <ul> <li>Light: A19, BR30, Downlight, etc.</li> <li>HEV: Clean</li> <li>Infrared: Nightvision</li> <li>Multizone: LIFX Z, Beam, Neon, String</li> <li>Matrix: LIFX Tile, Candle, Ceiling, Path, Spot</li> </ul> <p>LIFX Switches are out of scope for this lighting-focused library and are therefore not supported.</p>"},{"location":"faq/#do-i-need-cloud-access","title":"Do I need cloud access?","text":"<p>No! lifx-async communicates directly with devices over your local network. No cloud connection or LIFX account required.</p>"},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>Python 3.11 or higher is required.</p>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#how-do-i-install-lifx-async","title":"How do I install lifx-async?","text":"<pre><code># Using uv (recommended)\nuv pip install lifx-async\n\n# Or using pip\npip install lifx-async\n</code></pre> <p>See the Installation Guide for more options.</p>"},{"location":"faq/#why-cant-discovery-find-my-devices","title":"Why can't discovery find my devices?","text":"<p>Common issues:</p> <ol> <li>Same Network: Ensure your computer and LIFX devices are on the same network</li> <li>Firewall: Check firewall settings allow UDP broadcasts</li> <li>Timeout: Try increasing timeout: <code>discover(timeout=10.0)</code></li> <li>Router: Some routers block broadcast packets - try direct connection</li> </ol> <p>Workaround - Connect directly using IP and serial:</p> <pre><code>async with await Light(serial=\"d073d5000000\",  ip=\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n</code></pre>"},{"location":"faq/#do-i-need-to-know-my-devices-ip-address","title":"Do I need to know my device's IP address?","text":"<p>No! Discovery finds devices automatically:</p> <pre><code>from lifx import discover\n\nasync for device in discover():\n    print(f\"Found {device.serial} at {device.ip}\")\n</code></pre> <p>If you do know the IP, you can connect directly for faster connection.</p>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#how-do-i-control-multiple-lights-at-once","title":"How do I control multiple lights at once?","text":"<p>Use <code>DeviceGroup</code> for batch operations:</p> <pre><code>from lifx import discover, DeviceGroup, Colors\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\n# All lights at once\nawait group.set_power(True)\nawait group.set_color(Colors.BLUE)\nawait group.set_brightness(0.5)\n</code></pre>"},{"location":"faq/#how-do-i-set-a-specific-rgb-color","title":"How do I set a specific RGB color?","text":"<p>Use <code>HSBK.from_rgb()</code>:</p> <pre><code>from lifx import HSBK\n\n# Create color from RGB (0-255)\npurple = HSBK.from_rgb(128, 0, 128)\nawait light.set_color(purple)\n\n# Or use hex\ncolor = HSBK.from_rgb(0xFF, 0x00, 0xFF)\n</code></pre>"},{"location":"faq/#can-i-control-lights-concurrently","title":"Can I control lights concurrently?","text":"<p>Yes! Use <code>asyncio.gather()</code>:</p> <pre><code>import asyncio\n\n# Control multiple lights in parallel\nawait asyncio.gather(\n    light1.set_color(Colors.RED),\n    light2.set_color(Colors.GREEN),\n    light3.set_color(Colors.BLUE),\n)\n</code></pre>"},{"location":"faq/#how-do-i-find-a-specific-device","title":"How do I find a specific device?","text":"<p>By label:</p> <pre><code>lights = await find_lights(label_contains=\"Bedroom\")\n</code></pre> <p>By serial number:</p> <pre><code>device = await find_by_serial(\"d073d5123456\")\n</code></pre>"},{"location":"faq/#what-are-the-available-color-presets","title":"What are the available color presets?","text":"<p>See <code>Colors</code> for the complete list:</p> <pre><code>from lifx import Colors\n\n# Primary colors\nColors.RED, Colors.GREEN, Colors.BLUE\n\n# White variants\nColors.WARM_WHITE, Colors.COOL_WHITE, Colors.DAYLIGHT\n\n# Pastels\nColors.PASTEL_BLUE, Colors.PASTEL_PINK\n</code></pre>"},{"location":"faq/#how-do-i-create-smooth-transitions","title":"How do I create smooth transitions?","text":"<p>Use the <code>duration</code> parameter (in seconds):</p> <pre><code># Fade to blue over 2 seconds\nawait light.set_color(Colors.BLUE, duration=2.0)\n\n# Fade brightness over 3 seconds\nawait light.set_brightness(0.5, duration=3.0)\n</code></pre>"},{"location":"faq/#can-i-create-pulsing-effects","title":"Can I create pulsing effects?","text":"<p>Yes! Use the <code>pulse()</code> or <code>breathe()</code> methods:</p> <pre><code># Pulse red 5 times\nawait light.pulse(Colors.RED, period=1.0, cycles=5)\n\n# Breathe blue infinitely\nawait light.breathe(Colors.BLUE, period=2.0, cycles=0)\n</code></pre>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#is-lifx-async-fast","title":"Is lifx-async fast?","text":"<p>Yes! Key performance features:</p> <ul> <li>Async I/O: Non-blocking operations</li> <li>Lazy Connections: Auto-open on first request, reuse for all operations</li> <li>Non-volatile State Caching: Reduces redundant network requests</li> <li>Concurrent Devices: Operations on different devices run in parallel</li> <li>Request Serialization: Prevents response mixing on same connection</li> </ul>"},{"location":"faq/#how-is-state-stored","title":"How is state stored?","text":"<p>Selected device properties that are considered non-volatile, including product ID and firmware version are cached after they are fetched for the first time. Properties return <code>None</code> if no value has been fetched yet:</p> <pre><code># Check cached semi-static state (label, version, firmware, etc.)\nlabel = light.label\nif label:\n    # Use cached label value\n    print(f\"Cached label: {label}\")\nelse:\n    # No cached value, fetch from device\n    label = await light.get_label()\n</code></pre> <p>Note: Volatile state (power, color, hev_cycle, zones, tile_colors) is not cached and must always be fetched using <code>get_*()</code> methods.</p> <p>To always get fresh data:</p> <pre><code># Use get_* methods to always fetch from device\n# get_color() returns all three values in one call\ncolor, power, label = await light.get_color()  # Returns (color, power, label)\n\n# Or fetch specific info separately\nversion = await light.get_version()  # Get firmware and hardware version\n</code></pre> <p>If you use a light as an async context manager, it will automatically populate all of the non-volatile properties:</p> <pre><code>async with Light(serial=\"d073d5000000\",  ip=\"192.168.1.100\") as light:\n    print(f\"{light.label} is a {light.model} and is in the {light.group} group.\")\n</code></pre>"},{"location":"faq/#can-i-control-devices-from-multiple-computers","title":"Can I control devices from multiple computers?","text":"<p>Yes! lifx-async doesn't require exclusive access. Multiple instances (even on different computers) can control the same devices.</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#i-get-lifxtimeouterror","title":"I get <code>LifxTimeoutError</code>","text":"<p>Common causes:</p> <ol> <li>Device offline: Check device is powered and connected</li> <li>Network issues: Verify network connectivity</li> <li>Firewall: Ensure UDP port 56700 is open</li> <li>Timeout too short: Increase timeout value</li> </ol>"},{"location":"faq/#connection-fails-with-lifxconnectionerror","title":"Connection fails with <code>LifxConnectionError</code>","text":"<p>Try:</p> <ol> <li>Restart device: Power cycle the LIFX device</li> <li>Check IP: Verify IP address is correct</li> <li>Firewall: Check firewall allows UDP 56700</li> <li>Network: Ensure same subnet</li> </ol>"},{"location":"faq/#effects-dont-work-as-expected","title":"Effects don't work as expected","text":"<p>Make sure you're using the correct duration/period values:</p> <pre><code># Period is in seconds\nawait light.pulse(Colors.RED, period=1.0, cycles=5)\n\n# Duration is in seconds (milliseconds * 1000)\nawait light.set_color(Colors.BLUE, duration=2.0)\n</code></pre>"},{"location":"faq/#type-checker-errors","title":"Type checker errors","text":"<p>lifx-async is fully type-hinted. If you get type errors:</p> <ol> <li>Ensure you're using Python 3.11+</li> <li>Update your type checker (Pyright, mypy)</li> <li>Check you're using correct types</li> </ol>"},{"location":"faq/#development","title":"Development","text":""},{"location":"faq/#how-do-i-contribute","title":"How do I contribute?","text":"<p>Quick start:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes with tests</li> <li>Submit a pull request</li> </ol>"},{"location":"faq/#how-do-i-run-tests","title":"How do I run tests?","text":"<pre><code>uv run --frozen pytest\n</code></pre>"},{"location":"faq/#how-do-i-generate-protocol-code","title":"How do I generate protocol code?","text":"<pre><code>uv run python -m lifx.protocol.generator\n</code></pre> <p>This downloads the latest <code>protocol.yml</code> from LIFX and regenerates Python code.</p>"},{"location":"faq/#where-is-the-protocol-specification","title":"Where is the protocol specification?","text":"<p>The official LIFX protocol specification is at: https://github.com/LIFX/public-protocol/blob/main/protocol.yml</p> <p>lifx-async automatically downloads and generates Python code from this specification.</p>"},{"location":"faq/#advanced","title":"Advanced","text":""},{"location":"faq/#can-i-use-lifx-async-without-async","title":"Can I use lifx-async without async?","text":"<p>No.</p>"},{"location":"faq/#how-do-i-access-low-level-protocol","title":"How do I access low-level protocol?","text":"<pre><code>from lifx.protocol.packets import Light\nfrom lifx.protocol.protocol_types import HSBK\n\n# Create a packet directly\npacket = Light.SetColor(\n    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0\n)\n\n# Send via connection\nasync with DeviceConnection(serial, ip) as conn:\n    reply = await conn.request(packet)\n</code></pre>"},{"location":"faq/#how-does-connection-management-work","title":"How does connection management work?","text":"<p>Each device owns its own connection that opens lazily on first request. The connection is reused for all subsequent operations on that device. Connections are automatically closed when you exit the device's context manager, or you can manually call <code>await device.connection.close()</code>.</p>"},{"location":"faq/#still-have-questions","title":"Still have questions?","text":"<ul> <li>Documentation: Browse the API Reference</li> <li>Issues: Report bugs on GitHub Issues</li> <li>Discussions: Ask questions in   GitHub Discussions</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference documentation for lifx-async.</p>"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>lifx/\n\u251c\u2500\u2500 __init__.py               # High-level API exports\n\u251c\u2500\u2500 api.py                    # Simplified discovery and device group functions\n\u251c\u2500\u2500 color.py                  # Color utilities (HSBK, Colors)\n\u251c\u2500\u2500 const.py                  # Network constants and URLs\n\u251c\u2500\u2500 exceptions.py             # Exception hierarchy\n\u251c\u2500\u2500 devices/                  # Device classes\n\u2502   \u251c\u2500\u2500 base.py              # Base Device class\n\u2502   \u251c\u2500\u2500 light.py             # Light device (color control)\n\u2502   \u251c\u2500\u2500 hev.py               # HevLight device (anti-bacterial cleaning)\n\u2502   \u251c\u2500\u2500 infrared.py          # InfraredLight device (night vision)\n\u2502   \u251c\u2500\u2500 multizone.py         # MultiZoneLight (strips/beams)\n\u2502   \u2514\u2500\u2500 matrix.py            # MatrixLight (2D matrix devices: tiles, candle, path)\n\u251c\u2500\u2500 network/                  # Network layer\n\u2502   \u251c\u2500\u2500 connection.py        # Device connections with lazy opening\n\u2502   \u251c\u2500\u2500 discovery.py         # Network device discovery\n\u2502   \u251c\u2500\u2500 message.py           # Message building and parsing\n\u2502   \u2514\u2500\u2500 transport.py         # UDP transport\n\u251c\u2500\u2500 products/                 # Product registry\n\u2502   \u251c\u2500\u2500 registry.py          # Auto-generated product database\n\u2502   \u251c\u2500\u2500 generator.py         # Generator to download/parse products.json\n\u2502   \u2514\u2500\u2500 __init__.py          # Public API exports\n\u2514\u2500\u2500 protocol/                 # Protocol layer (auto-generated)\n    \u251c\u2500\u2500 base.py              # Base packet class\n    \u251c\u2500\u2500 generator.py         # Code generator from protocol.yml\n    \u251c\u2500\u2500 header.py            # Protocol header (36 bytes)\n    \u251c\u2500\u2500 models.py            # Protocol models (Serial, HEV types)\n    \u251c\u2500\u2500 packets.py           # Packet definitions\n    \u251c\u2500\u2500 protocol_types.py    # Type definitions and enums\n    \u2514\u2500\u2500 serializer.py        # Binary serialization/deserialization\n</code></pre>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#high-level-api","title":"High-Level API","text":"<p>Main entry points for most users:</p> <ul> <li><code>discover()</code> - Simple device discovery</li> <li><code>find_by_serial()</code> - Find device by serial number</li> <li><code>find_by_label()</code> - Find devices by label (exact or substring)</li> <li><code>find_by_ip()</code> - Find device by IP address</li> <li><code>DeviceGroup</code> - Batch operations</li> </ul>"},{"location":"api/#device-classes","title":"Device Classes","text":"<p>Control your LIFX devices:</p> <ul> <li><code>Device</code> - Base device operations</li> <li><code>Light</code> - Color control</li> <li><code>HevLight</code> - Anti-bacterial cleaning cycles</li> <li><code>InfraredLight</code> - Night vision infrared LED</li> <li><code>MultiZoneLight</code> - Strips/beams</li> <li><code>MatrixLight</code> - 2D matrix devices (tiles, candle, path)</li> </ul>"},{"location":"api/#color-utilities","title":"Color Utilities","text":"<p>Work with colors:</p> <ul> <li><code>HSBK</code> - Color representation</li> <li><code>Colors</code> - Built-in presets</li> </ul>"},{"location":"api/#network-layer","title":"Network Layer","text":"<p>Low-level network operations:</p> <ul> <li><code>discover_devices()</code> - Low-level discovery</li> <li><code>DeviceConnection</code> - Device connections</li> </ul>"},{"location":"api/#products-registry","title":"Products Registry","text":"<p>Device capabilities and automatic type detection:</p> <ul> <li><code>ProductInfo</code> - Product information</li> <li><code>ProductCapability</code> - Device capabilities</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":"<p>Error handling:</p> <ul> <li><code>LifxError</code> - Base exception</li> <li><code>LifxTimeoutError</code> - Timeout errors</li> <li><code>LifxConnectionError</code> - Connection errors</li> </ul>"},{"location":"api/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/#async-context-managers","title":"Async Context Managers","text":"<p>All device classes support async context managers for automatic resource cleanup:</p> <pre><code>async with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n# Connection automatically closed\n</code></pre>"},{"location":"api/#batch-operations","title":"Batch Operations","text":"<p>Use <code>DeviceGroup</code> for efficient batch operations:</p> <pre><code>from lifx import discover, DeviceGroup, Colors\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\n\ngroup = DeviceGroup(devices)\nawait group.set_power(True)\nawait group.set_color(Colors.BLUE)\n</code></pre>"},{"location":"api/#connection-lifecycle","title":"Connection Lifecycle","text":"<p>Connections open lazily on first request and reuse the same socket:</p> <pre><code># Multiple operations reuse the same connection\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.RED)\n    await light.set_brightness(0.5)\n    await light.get_label()\n# Connection automatically closed on exit\n</code></pre>"},{"location":"api/#concurrent-requests","title":"Concurrent Requests","text":"<p>Devices support concurrent requests via asyncio.gather:</p> <pre><code># Execute multiple operations concurrently\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    # Note: get_color() returns (color, power, label) tuple\n    (color, power, label), version = await asyncio.gather(\n        light.get_color(),\n        light.get_version()\n    )\n    brightness = color.brightness\n    print(f\"{label}: Brightness={brightness}, Firmware={version.firmware}\")\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>lifx-async is fully type-hinted. Use a type checker like Pyright or mypy:</p> <pre><code>from lifx import Light, HSBK\n\n\nasync def set_custom_color(light: Light, hue: float) -&gt; None:\n    color: HSBK = HSBK(hue=hue, saturation=1.0, brightness=0.8, kelvin=3500)\n    await light.set_color(color)\n</code></pre>"},{"location":"api/#api-sections","title":"API Sections","text":"<ul> <li> High-Level API</li> </ul> <p>Simple, batteries-included API for common tasks</p> <p> High-Level API</p> <ul> <li> Device Classes</li> </ul> <p>Control LIFX lights, strips, tiles, and matrix devices</p> <p> Devices</p> <ul> <li> Color Utilities</li> </ul> <p>Work with colors, RGB, and HSBK</p> <p> Colors</p> <ul> <li> Network Layer</li> </ul> <p>Low-level network operations</p> <p> Network</p> <ul> <li> Protocol Layer</li> </ul> <p>Auto-generated protocol structures</p> <p> Protocol</p> <ul> <li> Exceptions</li> </ul> <p>Error handling and exception hierarchy</p> <p> Exceptions</p>"},{"location":"api/#best-practices","title":"Best Practices","text":""},{"location":"api/#always-use-context-managers","title":"Always Use Context Managers","text":"<pre><code># \u2705 Good - automatic cleanup\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n\n# \u274c Bad - manual cleanup required\nlight = Light(\"d073d5123456\", \"192.168.1.100\")\nawait light.connect()\nawait light.set_color(Colors.BLUE)\nawait light.disconnect()\n</code></pre>"},{"location":"api/#handle-exceptions","title":"Handle Exceptions","text":"<pre><code>from lifx import discover, Colors, LifxError\n\ntry:\n    async for device in discover():\n        await device.set_color(Colors.GREEN)\nexcept LifxError as e:\n    print(f\"LIFX error: {e}\")\n</code></pre>"},{"location":"api/#use-type-hints","title":"Use Type Hints","text":"<pre><code>from lifx import Light, HSBK\n\n\nasync def control_light(light: Light) -&gt; str:\n    label: str = await light.get_label()\n    return label\n</code></pre>"},{"location":"api/#further-reading","title":"Further Reading","text":"<ul> <li>Architecture - How lifx-async works</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"api/colors/","title":"Color Utilities","text":"<p>lifx-async provides comprehensive color utilities for working with LIFX's HSBK color model and converting to/from RGB.</p>"},{"location":"api/colors/#hsbk-class","title":"HSBK Class","text":"<p>The <code>HSBK</code> class represents colors in the Hue, Saturation, Brightness, Kelvin color model used by LIFX devices.</p>"},{"location":"api/colors/#lifx.color.HSBK","title":"HSBK","text":"<pre><code>HSBK(hue: int, saturation: float, brightness: float, kelvin: int)\n</code></pre> <p>User-friendly HSBK color representation.</p> <p>LIFX devices use HSBK (Hue, Saturation, Brightness, Kelvin) color space. This class provides a convenient interface with normalized values and conversion to/from RGB.</p> ATTRIBUTE DESCRIPTION <code>hue</code> <p>Hue value in degrees (0-360)</p> <p> TYPE: <code>int</code> </p> <code>saturation</code> <p>Saturation (0.0-1.0, where 0 is white and 1 is fully saturated)</p> <p> TYPE: <code>float</code> </p> <code>brightness</code> <p>Brightness (0.0-1.0, where 0 is off and 1 is full brightness)</p> <p> TYPE: <code>float</code> </p> <code>kelvin</code> <p>Color temperature in Kelvin (1500-9000, typically 2500-9000 for LIFX)</p> <p> TYPE: <code>int</code> </p> Example <pre><code># Create a red color\nred = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)\n\n# Create from RGB\npurple = HSBK.from_rgb(128, 0, 128)\n\n# Convert to RGB\nr, g, b = purple.to_rgb()\n</code></pre> METHOD DESCRIPTION <code>__eq__</code> <p>Two colors are equal if they have the same HSBK values.</p> <code>__hash__</code> <p>Returns a hash of this color as an integer.</p> <code>__str__</code> <p>Return a string representation of the HSBK values for this color.</p> <code>__repr__</code> <p>Return a string representation of the HSBK values for this color.</p> <code>from_rgb</code> <p>Create HSBK from RGB values.</p> <code>to_rgb</code> <p>Convert HSBK to RGB values.</p> <code>to_protocol</code> <p>Convert to protocol HSBK for packet serialization.</p> <code>from_protocol</code> <p>Create HSBK from protocol HSBK.</p> <code>with_hue</code> <p>Create a new HSBK with modified hue.</p> <code>with_saturation</code> <p>Create a new HSBK with modified saturation.</p> <code>with_brightness</code> <p>Create a new HSBK with modified brightness.</p> <code>with_kelvin</code> <p>Create a new HSBK with modified color temperature.</p> <code>clone</code> <p>Create a copy of this color.</p> <code>as_tuple</code> <p>Return HSBK values as a tuple of protocol uint16 values.</p> <code>as_dict</code> <p>Return HSBK values as a dictionary of user-friendly values.</p> <code>limit_distance_to</code> <p>Return a new color with hue limited to 90 degrees from another color.</p> <code>average</code> <p>Calculate the average color of a list of HSBK colors.</p> Source code in <code>src/lifx/color.py</code> <pre><code>def __init__(\n    self, hue: int, saturation: float, brightness: float, kelvin: int\n) -&gt; None:\n    \"\"\"Instantiate a color using hue, saturation, brightness and kelvin.\"\"\"\n\n    validate_hue(hue)\n    validate_saturation(saturation)\n    validate_brightness(brightness)\n    validate_kelvin(kelvin)\n\n    self._hue = hue\n    self._saturation = saturation\n    self._brightness = brightness\n    self._kelvin = kelvin\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK-attributes","title":"Attributes","text":""},{"location":"api/colors/#lifx.color.HSBK.hue","title":"hue  <code>property</code>","text":"<pre><code>hue: int\n</code></pre> <p>Return hue.</p>"},{"location":"api/colors/#lifx.color.HSBK.saturation","title":"saturation  <code>property</code>","text":"<pre><code>saturation: float\n</code></pre> <p>Return saturation.</p>"},{"location":"api/colors/#lifx.color.HSBK.brightness","title":"brightness  <code>property</code>","text":"<pre><code>brightness: float\n</code></pre> <p>Return brightness.</p>"},{"location":"api/colors/#lifx.color.HSBK.kelvin","title":"kelvin  <code>property</code>","text":"<pre><code>kelvin: int\n</code></pre> <p>Return kelvin.</p>"},{"location":"api/colors/#lifx.color.HSBK-functions","title":"Functions","text":""},{"location":"api/colors/#lifx.color.HSBK.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Two colors are equal if they have the same HSBK values.</p> Source code in <code>src/lifx/color.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Two colors are equal if they have the same HSBK values.\"\"\"\n    if not isinstance(other, HSBK):  # pragma: no cover\n        return NotImplemented\n    return (\n        other.hue == self.hue\n        and other.saturation == self.saturation\n        and other.brightness == self.brightness\n        and other.kelvin == self.kelvin\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Returns a hash of this color as an integer.</p> Source code in <code>src/lifx/color.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Returns a hash of this color as an integer.\"\"\"\n    return hash(\n        (self.hue, self.saturation, self.brightness, self.kelvin)\n    )  # pragma: no cover\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the HSBK values for this color.</p> Source code in <code>src/lifx/color.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the HSBK values for this color.\"\"\"\n    string = (\n        f\"Hue: {self.hue}, Saturation: {self.saturation:.4f}, \"\n        f\"Brightness: {self.brightness:.4f}, Kelvin: {self.kelvin}\"\n    )\n    return string\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the HSBK values for this color.</p> Source code in <code>src/lifx/color.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the HSBK values for this color.\"\"\"\n    repr = (\n        f\"HSBK(hue={self.hue}, saturation={self.saturation:.2f}, \"\n        f\"brightness={self.brightness:.2f}, kelvin={self.kelvin})\"\n    )\n    return repr\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.from_rgb","title":"from_rgb  <code>classmethod</code>","text":"<pre><code>from_rgb(red: int, green: int, blue: int) -&gt; HSBK\n</code></pre> <p>Create HSBK from RGB values.</p> PARAMETER DESCRIPTION <code>red</code> <p>Red component (0-255)</p> <p> TYPE: <code>int</code> </p> <code>green</code> <p>Green component (0-255)</p> <p> TYPE: <code>int</code> </p> <code>blue</code> <p>Blue component (0-255)</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>HSBK instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If RGB values are out of range (0-255)</p> Example <pre><code># Pure red\nred = HSBK.from_rgb(255, 0, 0)\n\n# Purple with warm white\npurple = HSBK.from_rgb(128, 0, 128, kelvin=2500)\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>@classmethod\ndef from_rgb(cls, red: int, green: int, blue: int) -&gt; HSBK:\n    \"\"\"Create HSBK from RGB values.\n\n    Args:\n        red: Red component (0-255)\n        green: Green component (0-255)\n        blue: Blue component (0-255)\n\n    Returns:\n        HSBK instance\n\n    Raises:\n        ValueError: If RGB values are out of range (0-255)\n\n    Example:\n        ```python\n        # Pure red\n        red = HSBK.from_rgb(255, 0, 0)\n\n        # Purple with warm white\n        purple = HSBK.from_rgb(128, 0, 128, kelvin=2500)\n        ```\n    \"\"\"\n\n    def _validate_rgb_component(value: int, name: str) -&gt; None:\n        if not (0 &lt;= value &lt;= 255):\n            raise ValueError(f\"{name} must be between 0 and 255, got {value}\")\n\n    _validate_rgb_component(red, \"Red\")\n    _validate_rgb_component(green, \"Green\")\n    _validate_rgb_component(blue, \"Blue\")\n\n    # Normalize to 0-1\n    red_norm = red / 255\n    green_norm = green / 255\n    blue_norm = blue / 255\n\n    # Convert to HSV using colorsys\n    h, s, v = colorsys.rgb_to_hsv(red_norm, green_norm, blue_norm)\n\n    # Convert to LIFX ranges\n    hue = round(h * 360)  # 0-1 -&gt; 0-360\n    saturation = round(s, 2)  # Already 0-1\n    brightness = round(v, 2)  # Already 0-1\n\n    return cls(\n        hue=hue,\n        saturation=saturation,\n        brightness=brightness,\n        kelvin=KELVIN_NEUTRAL,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.to_rgb","title":"to_rgb","text":"<pre><code>to_rgb() -&gt; tuple[int, int, int]\n</code></pre> <p>Convert HSBK to RGB values.</p> <p>Color temperature (kelvin) is not considered in this conversion, as it only affects the white point of the device.</p> RETURNS DESCRIPTION <code>tuple[int, int, int]</code> <p>Tuple of (red, green, blue) with values 0-255</p> Example <pre><code>color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)\nr, g, b = color.to_rgb()  # Returns (0, 255, 0) - green\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def to_rgb(self) -&gt; tuple[int, int, int]:\n    \"\"\"Convert HSBK to RGB values.\n\n    Color temperature (kelvin) is not considered in this conversion,\n    as it only affects the white point of the device.\n\n    Returns:\n        Tuple of (red, green, blue) with values 0-255\n\n    Example:\n        ```python\n        color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)\n        r, g, b = color.to_rgb()  # Returns (0, 255, 0) - green\n        ```\n    \"\"\"\n    # Convert to colorsys ranges\n    h = self._hue / 360  # 0-360 -&gt; 0-1\n    s = self._saturation  # Already 0-1\n    v = self._brightness  # Already 0-1\n\n    # Convert using colorsys\n    red_norm, green_norm, blue_norm = colorsys.hsv_to_rgb(h, s, v)\n\n    # Scale to 0-255 and round\n    red = int(round(red_norm * 255))\n    green = int(round(green_norm * 255))\n    blue = int(round(blue_norm * 255))\n\n    return red, green, blue\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.to_protocol","title":"to_protocol","text":"<pre><code>to_protocol() -&gt; LightHsbk\n</code></pre> <p>Convert to protocol HSBK for packet serialization.</p> <p>LIFX protocol uses uint16 values for all HSBK components: - Hue: 0-65535 (represents 0-360 degrees) - Saturation: 0-65535 (represents 0-100%) - Brightness: 0-65535 (represents 0-100%) - Kelvin: Direct value in Kelvin</p> RETURNS DESCRIPTION <code>LightHsbk</code> <p>LightHsbk instance for packet serialization</p> Example <pre><code>color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\nprotocol_color = color.to_protocol()\n# Use in packet: LightSetColor(color=protocol_color, ...)\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def to_protocol(self) -&gt; LightHsbk:\n    \"\"\"Convert to protocol HSBK for packet serialization.\n\n    LIFX protocol uses uint16 values for all HSBK components:\n    - Hue: 0-65535 (represents 0-360 degrees)\n    - Saturation: 0-65535 (represents 0-100%)\n    - Brightness: 0-65535 (represents 0-100%)\n    - Kelvin: Direct value in Kelvin\n\n    Returns:\n        LightHsbk instance for packet serialization\n\n    Example:\n        ```python\n        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\n        protocol_color = color.to_protocol()\n        # Use in packet: LightSetColor(color=protocol_color, ...)\n        ```\n    \"\"\"\n    hue_u16 = int(round(0x10000 * self._hue) / 360) % 0x10000\n    saturation_u16 = int(round(0xFFFF * self._saturation))\n    brightness_u16 = int(round(0xFFFF * self._brightness))\n\n    return LightHsbk(\n        hue=hue_u16,\n        saturation=saturation_u16,\n        brightness=brightness_u16,\n        kelvin=self._kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.from_protocol","title":"from_protocol  <code>classmethod</code>","text":"<pre><code>from_protocol(protocol: LightHsbk) -&gt; HSBK\n</code></pre> <p>Create HSBK from protocol HSBK.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>LightHsbk instance from packet deserialization</p> <p> TYPE: <code>LightHsbk</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>User-friendly HSBK instance</p> Example <pre><code># After receiving LightState packet\nstate = await device.get_state()\ncolor = HSBK.from_protocol(state.color)\nprint(f\"Hue: {color.hue}\u00b0, Brightness: {color.brightness * 100}%\")\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>@classmethod\ndef from_protocol(cls, protocol: LightHsbk) -&gt; HSBK:\n    \"\"\"Create HSBK from protocol HSBK.\n\n    Args:\n        protocol: LightHsbk instance from packet deserialization\n\n    Returns:\n        User-friendly HSBK instance\n\n    Example:\n        ```python\n        # After receiving LightState packet\n        state = await device.get_state()\n        color = HSBK.from_protocol(state.color)\n        print(f\"Hue: {color.hue}\u00b0, Brightness: {color.brightness * 100}%\")\n        ```\n    \"\"\"\n    # Convert from uint16 ranges to user-friendly ranges\n    hue = round(float(protocol.hue) * 360 / 0x10000)\n    saturation = round(float(protocol.saturation) / 0xFFFF, 2)\n    brightness = round(float(protocol.brightness) / 0xFFFF, 2)\n\n    return cls(\n        hue=hue,\n        saturation=saturation,\n        brightness=brightness,\n        kelvin=protocol.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_hue","title":"with_hue","text":"<pre><code>with_hue(hue: int) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified hue.</p> PARAMETER DESCRIPTION <code>hue</code> <p>New hue value (0-360)</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_hue(self, hue: int) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified hue.\n\n    Args:\n        hue: New hue value (0-360)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=hue,\n        saturation=self.saturation,\n        brightness=self.brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_saturation","title":"with_saturation","text":"<pre><code>with_saturation(saturation: float) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified saturation.</p> PARAMETER DESCRIPTION <code>saturation</code> <p>New saturation value (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_saturation(self, saturation: float) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified saturation.\n\n    Args:\n        saturation: New saturation value (0.0-1.0)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=saturation,\n        brightness=self.brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_brightness","title":"with_brightness","text":"<pre><code>with_brightness(brightness: float) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified brightness.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>New brightness value (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_brightness(self, brightness: float) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified brightness.\n\n    Args:\n        brightness: New brightness value (0.0-1.0)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=self.saturation,\n        brightness=brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.with_kelvin","title":"with_kelvin","text":"<pre><code>with_kelvin(kelvin: int) -&gt; HSBK\n</code></pre> <p>Create a new HSBK with modified color temperature.</p> PARAMETER DESCRIPTION <code>kelvin</code> <p>New kelvin value (1500-9000)</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance</p> Source code in <code>src/lifx/color.py</code> <pre><code>def with_kelvin(self, kelvin: int) -&gt; HSBK:\n    \"\"\"Create a new HSBK with modified color temperature.\n\n    Args:\n        kelvin: New kelvin value (1500-9000)\n\n    Returns:\n        New HSBK instance\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=self.saturation,\n        brightness=self.brightness,\n        kelvin=kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.clone","title":"clone","text":"<pre><code>clone() -&gt; HSBK\n</code></pre> <p>Create a copy of this color.</p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance with the same values</p> Source code in <code>src/lifx/color.py</code> <pre><code>def clone(self) -&gt; HSBK:\n    \"\"\"Create a copy of this color.\n\n    Returns:\n        New HSBK instance with the same values\n    \"\"\"\n    return HSBK(\n        hue=self.hue,\n        saturation=self.saturation,\n        brightness=self.brightness,\n        kelvin=self.kelvin,\n    )\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.as_tuple","title":"as_tuple","text":"<pre><code>as_tuple() -&gt; tuple[int, int, int, int]\n</code></pre> <p>Return HSBK values as a tuple of protocol uint16 values.</p> RETURNS DESCRIPTION <code>int</code> <p>Tuple of (hue_u16, saturation_u16, brightness_u16, kelvin)</p> <code>int</code> <p>where u16 values are in range 0-65535</p> Example <pre><code>color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\nhue, sat, bri, kel = color.as_tuple()\n# Use in protocol operations\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def as_tuple(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Return HSBK values as a tuple of protocol uint16 values.\n\n    Returns:\n        Tuple of (hue_u16, saturation_u16, brightness_u16, kelvin)\n        where u16 values are in range 0-65535\n\n    Example:\n        ```python\n        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\n        hue, sat, bri, kel = color.as_tuple()\n        # Use in protocol operations\n        ```\n    \"\"\"\n    protocol = self.to_protocol()\n    return (protocol.hue, protocol.saturation, protocol.brightness, protocol.kelvin)\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, float | int]\n</code></pre> <p>Return HSBK values as a dictionary of user-friendly values.</p> RETURNS DESCRIPTION <code>dict[str, float | int]</code> <p>Dictionary with keys: hue (float), saturation (float),</p> <code>dict[str, float | int]</code> <p>brightness (float), kelvin (int)</p> Example <pre><code>color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\ncolor_dict = color.as_dict()\n# {'hue': 180.0, 'saturation': 0.5, 'brightness': 0.75, 'kelvin': 3500}\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def as_dict(self) -&gt; dict[str, float | int]:\n    \"\"\"Return HSBK values as a dictionary of user-friendly values.\n\n    Returns:\n        Dictionary with keys: hue (float), saturation (float),\n        brightness (float), kelvin (int)\n\n    Example:\n        ```python\n        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)\n        color_dict = color.as_dict()\n        # {'hue': 180.0, 'saturation': 0.5, 'brightness': 0.75, 'kelvin': 3500}\n        ```\n    \"\"\"\n    return {\n        \"hue\": self.hue,\n        \"saturation\": self.saturation,\n        \"brightness\": self.brightness,\n        \"kelvin\": self.kelvin,\n    }\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.limit_distance_to","title":"limit_distance_to","text":"<pre><code>limit_distance_to(other: HSBK) -&gt; HSBK\n</code></pre> <p>Return a new color with hue limited to 90 degrees from another color.</p> <p>This is useful for preventing large hue jumps when interpolating between colors. If the hue difference is greater than 90 degrees, the hue is adjusted to be within 90 degrees of the target hue.</p> PARAMETER DESCRIPTION <code>other</code> <p>Reference color to limit distance to</p> <p> TYPE: <code>HSBK</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance with limited hue distance</p> Example <pre><code>red = HSBK(hue=10, saturation=1.0, brightness=1.0, kelvin=3500)\nblue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)\n\n# Limit red's hue to be within 90 degrees of blue's hue\nadjusted = red.limit_distance_to(blue)\n# Result: hue is adjusted to be within 90 degrees of 240\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>def limit_distance_to(self, other: HSBK) -&gt; HSBK:\n    \"\"\"Return a new color with hue limited to 90 degrees from another color.\n\n    This is useful for preventing large hue jumps when interpolating between colors.\n    If the hue difference is greater than 90 degrees, the hue is adjusted to be\n    within 90 degrees of the target hue.\n\n    Args:\n        other: Reference color to limit distance to\n\n    Returns:\n        New HSBK instance with limited hue distance\n\n    Example:\n        ```python\n        red = HSBK(hue=10, saturation=1.0, brightness=1.0, kelvin=3500)\n        blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)\n\n        # Limit red's hue to be within 90 degrees of blue's hue\n        adjusted = red.limit_distance_to(blue)\n        # Result: hue is adjusted to be within 90 degrees of 240\n        ```\n    \"\"\"\n    raw_dist = (\n        self.hue - other.hue if self.hue &gt; other.hue else other.hue - self.hue\n    )\n    dist = 360 - raw_dist if raw_dist &gt; 180 else raw_dist\n    if abs(dist) &gt; 90:\n        h = self.hue + 90 if (other.hue + dist) % 360 == self.hue else self.hue - 90\n        h = h + 360 if h &lt; 0 else h\n        return HSBK(h, self.saturation, self.brightness, self.kelvin)\n    else:\n        return self\n</code></pre>"},{"location":"api/colors/#lifx.color.HSBK.average","title":"average  <code>classmethod</code>","text":"<pre><code>average(colors: list[HSBK]) -&gt; HSBK\n</code></pre> <p>Calculate the average color of a list of HSBK colors.</p> <p>Uses circular mean for hue to correctly handle hue wraparound (e.g., average of 10\u00b0 and 350\u00b0 is 0\u00b0, not 180\u00b0).</p> PARAMETER DESCRIPTION <code>colors</code> <p>List of HSBK colors to average (must not be empty)</p> <p> TYPE: <code>list[HSBK]</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>New HSBK instance with averaged values</p> RAISES DESCRIPTION <code>ValueError</code> <p>If colors list is empty</p> Example <pre><code>red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)\ngreen = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)\nblue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)\n\navg_color = HSBK.average([red, green, blue])\n# Result: average of the three primary colors\n</code></pre> Source code in <code>src/lifx/color.py</code> <pre><code>@classmethod\ndef average(cls, colors: list[HSBK]) -&gt; HSBK:\n    \"\"\"Calculate the average color of a list of HSBK colors.\n\n    Uses circular mean for hue to correctly handle hue wraparound\n    (e.g., average of 10\u00b0 and 350\u00b0 is 0\u00b0, not 180\u00b0).\n\n    Args:\n        colors: List of HSBK colors to average (must not be empty)\n\n    Returns:\n        New HSBK instance with averaged values\n\n    Raises:\n        ValueError: If colors list is empty\n\n    Example:\n        ```python\n        red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)\n        green = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)\n        blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)\n\n        avg_color = HSBK.average([red, green, blue])\n        # Result: average of the three primary colors\n        ```\n    \"\"\"\n    if not colors:\n        raise ValueError(\"Cannot average an empty list of colors\")\n\n    hue_x_total = 0.0\n    hue_y_total = 0.0\n    saturation_total = 0.0\n    brightness_total = 0.0\n    kelvin_total = 0.0\n\n    for color in colors:\n        hue_x_total += math.sin(color.hue * 2.0 * math.pi / 360)\n        hue_y_total += math.cos(color.hue * 2.0 * math.pi / 360)\n        saturation_total += color.saturation\n        brightness_total += color.brightness\n        kelvin_total += color.kelvin\n\n    hue = math.atan2(hue_x_total, hue_y_total) / (2.0 * math.pi)\n    if hue &lt; 0.0:\n        hue += 1.0\n    hue *= 360\n    hue = round(hue)\n    saturation = round(saturation_total / len(colors), 2)\n    brightness = round(brightness_total / len(colors), 2)\n    kelvin = round(kelvin_total / len(colors))\n\n    return cls(hue, saturation, brightness, kelvin)\n</code></pre>"},{"location":"api/colors/#colors-class","title":"Colors Class","text":"<p>The <code>Colors</code> class provides convenient color presets for common colors.</p>"},{"location":"api/colors/#lifx.color.Colors","title":"Colors","text":"<p>Common color presets for convenience.</p>"},{"location":"api/colors/#examples","title":"Examples","text":""},{"location":"api/colors/#creating-colors","title":"Creating Colors","text":"<pre><code>from lifx import HSBK, Colors\n\n# Use built-in color presets\ncolor = Colors.BLUE\n\n# Create custom colors\ncustom = HSBK(hue=180.0, saturation=1.0, brightness=0.8, kelvin=3500)\n\n# Create from RGB\nred = HSBK.from_rgb(255, 0, 0, kelvin=3500)\n\n# Convert to RGB\nr, g, b = Colors.BLUE.to_rgb()\nprint(f\"RGB: ({r}, {g}, {b})\")\n</code></pre>"},{"location":"api/colors/#color-components","title":"Color Components","text":"<pre><code>from lifx import HSBK\n\ncolor = HSBK(hue=240.0, saturation=1.0, brightness=0.5, kelvin=3500)\n\n# Hue: 0-360 degrees (0=red, 120=green, 240=blue)\nprint(f\"Hue: {color.hue}\u00b0\")\n\n# Saturation: 0.0-1.0 (0=white, 1=full color)\nprint(f\"Saturation: {color.saturation * 100}%\")\n\n# Brightness: 0.0-1.0 (0=off, 1=full brightness)\nprint(f\"Brightness: {color.brightness * 100}%\")\n\n# Kelvin: 1500-9000 (warm white to cool white)\nprint(f\"Temperature: {color.kelvin}K\")\n</code></pre>"},{"location":"api/colors/#color-manipulation","title":"Color Manipulation","text":"<pre><code>from lifx import HSBK, Light\n\n\nasync def cycle_hue(light: Light):\n    \"\"\"Cycle through the color spectrum\"\"\"\n    for hue in range(0, 360, 10):\n        color = HSBK(hue=float(hue), saturation=1.0, brightness=0.8, kelvin=3500)\n        await light.set_color(color, duration=0.1)\n</code></pre>"},{"location":"api/colors/#white-balance","title":"White Balance","text":"<pre><code>from lifx import HSBK\n\n# Warm white (sunset, candlelight)\nwarm = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=2500)\n\n# Neutral white (daylight)\nneutral = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=4000)\n\n# Cool white (overcast, shade)\ncool = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=6500)\n</code></pre>"},{"location":"api/colors/#available-color-presets","title":"Available Color Presets","text":"<p>The <code>Colors</code> class provides these preset colors:</p> <ul> <li><code>Colors.WHITE</code> - Pure white (3500K)</li> <li><code>Colors.RED</code> - Red</li> <li><code>Colors.ORANGE</code> - Orange</li> <li><code>Colors.YELLOW</code> - Yellow</li> <li><code>Colors.GREEN</code> - Green</li> <li><code>Colors.CYAN</code> - Cyan</li> <li><code>Colors.BLUE</code> - Blue</li> <li><code>Colors.PURPLE</code> - Purple</li> <li><code>Colors.PINK</code> - Pink</li> <li><code>Colors.WARM_WHITE</code> - Warm white (2500K)</li> <li><code>Colors.COOL_WHITE</code> - Cool white (6500K)</li> </ul>"},{"location":"api/colors/#color-conversion-notes","title":"Color Conversion Notes","text":""},{"location":"api/colors/#rgb-to-hsbk","title":"RGB to HSBK","text":"<p>When converting from RGB to HSBK, note that:</p> <ul> <li>RGB values are 0-255</li> <li>The Kelvin value must be specified (default: 3500K)</li> <li>Some RGB colors may not have exact HSBK equivalents</li> <li>Conversion uses standard HSV formulas with brightness mapping</li> </ul>"},{"location":"api/colors/#hsbk-to-rgb","title":"HSBK to RGB","text":"<p>When converting from HSBK to RGB:</p> <ul> <li>Returns tuple of (r, g, b) with values 0-255</li> <li>Kelvin temperature is not represented in RGB</li> <li>White colors (saturation=0) will be pure gray values</li> <li>Conversion is lossy - converting back may not yield the same HSBK</li> </ul>"},{"location":"api/devices/","title":"Device Classes","text":"<p>Device classes provide direct control over LIFX devices. All device classes support async context managers for automatic resource cleanup.</p>"},{"location":"api/devices/#state-and-info-classes","title":"State and Info Classes","text":"<p>Device state and information dataclasses returned by device methods.</p>"},{"location":"api/devices/#devicestate","title":"DeviceState","text":"<p>Base device state dataclass returned by <code>Device.state</code>.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState","title":"DeviceState  <code>dataclass</code>","text":"<pre><code>DeviceState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n)\n</code></pre> <p>Base device state.</p> ATTRIBUTE DESCRIPTION <code>model</code> <p>Friendly product name (e.g., \"LIFX A19\")</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p>Device label (user-assigned name)</p> <p> TYPE: <code>str</code> </p> <code>serial</code> <p>Device serial number (6 bytes)</p> <p> TYPE: <code>str</code> </p> <code>mac_address</code> <p>Device MAC address (formatted string)</p> <p> TYPE: <code>str</code> </p> <code>capabilities</code> <p>Device capabilities from product registry</p> <p> TYPE: <code>DeviceCapabilities</code> </p> <code>power</code> <p>Power level (0 = off, 65535 = on)</p> <p> TYPE: <code>int</code> </p> <code>host_firmware</code> <p>Host firmware version</p> <p> TYPE: <code>FirmwareInfo</code> </p> <code>wifi_firmware</code> <p>WiFi firmware version</p> <p> TYPE: <code>FirmwareInfo</code> </p> <code>location</code> <p>Location tuple (UUID bytes, label, updated_at)</p> <p> TYPE: <code>CollectionInfo</code> </p> <code>group</code> <p>Group tuple (UUID bytes, label, updated_at)</p> <p> TYPE: <code>CollectionInfo</code> </p> <code>last_updated</code> <p>Timestamp of last state refresh</p> <p> TYPE: <code>float</code> </p> METHOD DESCRIPTION <code>is_fresh</code> <p>Check if state is fresh (recently updated).</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.base.DeviceState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: dict[\n    str, str | int | float | dict[str, bool | int] | dict[str, str | int]\n]\n</code></pre> <p>Return DeviceState as a dictionary.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState.is_on","title":"is_on  <code>property</code>","text":"<pre><code>is_on: bool\n</code></pre> <p>Check if device is powered on.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState.location_name","title":"location_name  <code>property</code>","text":"<pre><code>location_name: str\n</code></pre> <p>Get location label.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState.group_name","title":"group_name  <code>property</code>","text":"<pre><code>group_name: str\n</code></pre> <p>Get group label.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState.age","title":"age  <code>property</code>","text":"<pre><code>age: float\n</code></pre> <p>Get age of state in seconds.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceState-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.base.DeviceState.is_fresh","title":"is_fresh","text":"<pre><code>is_fresh(max_age: float = 5.0) -&gt; bool\n</code></pre> <p>Check if state is fresh (recently updated).</p> PARAMETER DESCRIPTION <code>max_age</code> <p>Maximum age in seconds (default: 5.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>5.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if state age is less than max_age</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def is_fresh(self, max_age: float = 5.0) -&gt; bool:\n    \"\"\"Check if state is fresh (recently updated).\n\n    Args:\n        max_age: Maximum age in seconds (default: 5.0)\n\n    Returns:\n        True if state age is less than max_age\n    \"\"\"\n    return self.age &lt; max_age\n</code></pre>"},{"location":"api/devices/#deviceversion","title":"DeviceVersion","text":"<p>Device version information returned by <code>Device.get_version()</code>.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceVersion","title":"DeviceVersion  <code>dataclass</code>","text":"<pre><code>DeviceVersion(vendor: int, product: int)\n</code></pre> <p>Device version information.</p> ATTRIBUTE DESCRIPTION <code>vendor</code> <p>Vendor ID (typically 1 for LIFX)</p> <p> TYPE: <code>int</code> </p> <code>product</code> <p>Product ID (identifies specific device model)</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/devices/#deviceinfo","title":"DeviceInfo","text":"<p>Device runtime information returned by <code>Device.get_info()</code>.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceInfo","title":"DeviceInfo  <code>dataclass</code>","text":"<pre><code>DeviceInfo(time: int, uptime: int, downtime: int)\n</code></pre> <p>Device runtime information.</p> ATTRIBUTE DESCRIPTION <code>time</code> <p>Current device time (nanoseconds since epoch)</p> <p> TYPE: <code>int</code> </p> <code>uptime</code> <p>Time since last power on (nanoseconds)</p> <p> TYPE: <code>int</code> </p> <code>downtime</code> <p>Time device was powered off (nanoseconds)</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/devices/#wifiinfo","title":"WifiInfo","text":"<p>WiFi module information returned by <code>Device.get_wifi_info()</code>.</p>"},{"location":"api/devices/#lifx.devices.base.WifiInfo","title":"WifiInfo  <code>dataclass</code>","text":"<pre><code>WifiInfo(signal: float)\n</code></pre> <p>Device WiFi module information.</p> ATTRIBUTE DESCRIPTION <code>signal</code> <p>WiFi signal strength</p> <p> TYPE: <code>float</code> </p> <code>rssi</code> <p>WiFi RSSI</p> <p> TYPE: <code>int</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Calculate RSSI from signal.</p>"},{"location":"api/devices/#lifx.devices.base.WifiInfo-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.base.WifiInfo.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Calculate RSSI from signal.</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Calculate RSSI from signal.\"\"\"\n    self.rssi = int(floor(10 * log10(self.signal) + 0.5))\n</code></pre>"},{"location":"api/devices/#firmwareinfo","title":"FirmwareInfo","text":"<p>Firmware version information returned by <code>Device.get_host_firmware()</code> and <code>Device.get_wifi_firmware()</code>.</p>"},{"location":"api/devices/#lifx.devices.base.FirmwareInfo","title":"FirmwareInfo  <code>dataclass</code>","text":"<pre><code>FirmwareInfo(build: int, version_major: int, version_minor: int)\n</code></pre> <p>Device firmware version information.</p> ATTRIBUTE DESCRIPTION <code>build</code> <p>Firmware build timestamp</p> <p> TYPE: <code>int</code> </p> <code>version_major</code> <p>Major version number</p> <p> TYPE: <code>int</code> </p> <code>version_minor</code> <p>Minor version number</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/devices/#lifx.devices.base.FirmwareInfo-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.base.FirmwareInfo.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: dict[str, int]\n</code></pre> <p>Return firmware info as dict.</p>"},{"location":"api/devices/#collectioninfo","title":"CollectionInfo","text":"<p>Location and group collection information returned by <code>Device.get_location()</code> and <code>Device.get_group()</code>.</p>"},{"location":"api/devices/#lifx.devices.base.CollectionInfo","title":"CollectionInfo  <code>dataclass</code>","text":"<pre><code>CollectionInfo(uuid: str, label: str, updated_at: int)\n</code></pre> <p>Device location and group collection information.</p> ATTRIBUTE DESCRIPTION <code>uuid</code> <p>Collection UUID (16 hexadecimal characters)</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p>Collection label (up to 32 characters)</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Timestamp when group was last updated (nanoseconds)</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/devices/#lifx.devices.base.CollectionInfo-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.base.CollectionInfo.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: dict[str, str | int]\n</code></pre> <p>Return group info as dict.</p>"},{"location":"api/devices/#devicecapabilities","title":"DeviceCapabilities","text":"<p>Device capabilities from product registry, available via <code>Device.capabilities</code>.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceCapabilities","title":"DeviceCapabilities  <code>dataclass</code>","text":"<pre><code>DeviceCapabilities(\n    has_color: bool,\n    has_multizone: bool,\n    has_chain: bool,\n    has_matrix: bool,\n    has_infrared: bool,\n    has_hev: bool,\n    has_extended_multizone: bool,\n    kelvin_min: int | None,\n    kelvin_max: int | None,\n)\n</code></pre> <p>Device capabilities from product registry.</p> ATTRIBUTE DESCRIPTION <code>has_color</code> <p>Supports color control</p> <p> TYPE: <code>bool</code> </p> <code>has_multizone</code> <p>Supports multizone control (strips, beams)</p> <p> TYPE: <code>bool</code> </p> <code>has_chain</code> <p>Supports chaining (tiles)</p> <p> TYPE: <code>bool</code> </p> <code>has_matrix</code> <p>Supports 2D matrix control (tiles, candle, path)</p> <p> TYPE: <code>bool</code> </p> <code>has_infrared</code> <p>Supports infrared LED</p> <p> TYPE: <code>bool</code> </p> <code>has_hev</code> <p>Supports HEV (High Energy Visible) cleaning cycles</p> <p> TYPE: <code>bool</code> </p> <code>has_extended_multizone</code> <p>Supports extended multizone protocol</p> <p> TYPE: <code>bool</code> </p> <code>kelvin_min</code> <p>Minimum color temperature (Kelvin)</p> <p> TYPE: <code>int | None</code> </p> <code>kelvin_max</code> <p>Maximum color temperature (Kelvin)</p> <p> TYPE: <code>int | None</code> </p>"},{"location":"api/devices/#lifx.devices.base.DeviceCapabilities-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.base.DeviceCapabilities.has_variable_color_temp","title":"has_variable_color_temp  <code>property</code>","text":"<pre><code>has_variable_color_temp: bool\n</code></pre> <p>Check if device supports variable color temperature.</p>"},{"location":"api/devices/#lifx.devices.base.DeviceCapabilities.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: dict[str, bool | int]\n</code></pre> <p>Return DeviceCapabilities as a dict.</p>"},{"location":"api/devices/#base-device","title":"Base Device","text":"<p>The <code>Device</code> class provides common operations available on all LIFX devices.</p>"},{"location":"api/devices/#lifx.devices.base.Device","title":"Device","text":"<pre><code>Device(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n)\n</code></pre> <p>               Bases: <code>Generic[StateT]</code></p> <p>Base class for LIFX devices.</p> <p>This class provides common functionality for all LIFX devices: - Connection management - Basic device queries (label, power, version, info) - State caching for reduced network traffic</p> <p>Properties return cached values or None if never fetched. Use get_*() methods to fetch fresh data from the device.</p> Example <pre><code>device = Device(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with device:\n    # Get device label\n    label = await device.get_label()\n    print(f\"Device: {label}\")\n\n    # Use cached label value\n    if device.label is not None:\n        print(f\"Cached label: {device.label}\")\n\n    # Turn on device\n    await device.set_power(True)\n\n    # Get power state\n    is_on = await device.get_power()\n    if is_on is not None:\n        print(f\"Power: {'ON' if is_on else 'OFF'}\")\n</code></pre> PARAMETER DESCRIPTION <code>serial</code> <p>Device serial number as 12-digit hex string (e.g., \"d073d5123456\")</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>timeout</code> <p>Overall timeout for network requests in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>Maximum number of retry attempts for network requests</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any parameter is invalid</p> METHOD DESCRIPTION <code>from_ip</code> <p>Create and return an instance for the given IP address.</p> <code>connect</code> <p>Create and return a fully initialized device instance.</p> <code>get_mac_address</code> <p>Calculate and return the MAC address for this device.</p> <code>get_label</code> <p>Get device label/name.</p> <code>set_label</code> <p>Set device label/name.</p> <code>get_power</code> <p>Get device power state.</p> <code>set_power</code> <p>Set device power state.</p> <code>get_version</code> <p>Get device version information.</p> <code>get_info</code> <p>Get device runtime information.</p> <code>get_wifi_info</code> <p>Get device WiFi module information.</p> <code>get_host_firmware</code> <p>Get device host (WiFi module) firmware information.</p> <code>get_wifi_firmware</code> <p>Get device WiFi module firmware information.</p> <code>get_location</code> <p>Get device location information.</p> <code>set_location</code> <p>Set device location information.</p> <code>get_group</code> <p>Get device group information.</p> <code>set_group</code> <p>Set device group information.</p> <code>set_reboot</code> <p>Reboot the device.</p> <code>close</code> <p>Close device connection and cleanup resources.</p> <code>refresh_state</code> <p>Refresh device state from hardware.</p> ATTRIBUTE DESCRIPTION <code>capabilities</code> <p>Get device product capabilities.</p> <p> TYPE: <code>ProductInfo | None</code> </p> <code>state</code> <p>Get device state if available.</p> <p> TYPE: <code>StateT | None</code> </p> <code>label</code> <p>Get cached label if available.</p> <p> TYPE: <code>str | None</code> </p> <code>version</code> <p>Get cached version if available.</p> <p> TYPE: <code>DeviceVersion | None</code> </p> <code>host_firmware</code> <p>Get cached host firmware if available.</p> <p> TYPE: <code>FirmwareInfo | None</code> </p> <code>wifi_firmware</code> <p>Get cached wifi firmware if available.</p> <p> TYPE: <code>FirmwareInfo | None</code> </p> <code>location</code> <p>Get cached location name if available.</p> <p> TYPE: <code>str | None</code> </p> <code>group</code> <p>Get cached group name if available.</p> <p> TYPE: <code>str | None</code> </p> <code>model</code> <p>Get LIFX friendly model name if available.</p> <p> TYPE: <code>str | None</code> </p> <code>mac_address</code> <p>Get cached MAC address if available.</p> <p> TYPE: <code>str | None</code> </p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; None:\n    \"\"\"Initialize device.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., \"d073d5123456\")\n        ip: Device IP address\n        port: Device UDP port\n        timeout: Overall timeout for network requests in seconds\n        max_retries: Maximum number of retry attempts for network requests\n\n    Raises:\n        ValueError: If any parameter is invalid\n    \"\"\"\n    # Parse and validate serial number\n    try:\n        serial_obj = Serial.from_string(serial)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Invalid serial number: {e}\") from e\n\n    serial_bytes = serial_obj.value\n\n    # Validate serial number\n    # Check for all-zeros (invalid)\n    if serial_bytes == b\"\\x00\" * 6:\n        raise ValueError(\"Serial number cannot be all zeros\")  # pragma: no cover\n\n    # Check for all-ones/broadcast (invalid for unicast)\n    if serial_bytes == b\"\\xff\" * 6:\n        raise ValueError(  # pragma: no cover\n            \"Broadcast serial number not allowed for device connection\"\n        )\n\n    # Validate IP address\n    try:\n        addr = ipaddress.ip_address(ip)\n    except ValueError as e:  # pragma: no cover\n        raise ValueError(f\"Invalid IP address format: {e}\")\n\n    # Check for localhost\n    if addr.is_loopback:\n        # raise ValueError(\"Localhost IP address not allowed\")  # pragma: no cover\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"is_loopback\",\n                \"ip\": ip,\n            }\n        )\n\n    # Check for unspecified (0.0.0.0)\n    if addr.is_unspecified:\n        raise ValueError(\n            \"Unspecified IP address (0.0.0.0) not allowed\"\n        )  # pragma: no cover\n\n    # Warn for non-private IPs (LIFX should be on local network)\n    if not addr.is_private:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_private_ip\",\n                \"ip\": ip,\n            }\n        )\n\n    # LIFX uses IPv4 only (protocol limitation)\n    if addr.version != 4:\n        raise ValueError(\"Only IPv4 addresses are supported\")  # pragma: no cover\n\n    # Validate port\n    if not (1024 &lt;= port &lt;= 65535):\n        raise ValueError(\n            f\"Port must be between 1 and 65535, got {port}\"\n        )  # pragma: no cover\n\n    # Warn for non-standard ports\n    if port != LIFX_UDP_PORT:\n        _LOGGER.warning(\n            {\n                \"class\": \"Device\",\n                \"method\": \"__init__\",\n                \"action\": \"non_standard_port\",\n                \"port\": port,\n                \"default_port\": LIFX_UDP_PORT,\n            }\n        )\n\n    # Store normalized serial as 12-digit hex string\n    self.serial = serial_obj.to_string()\n    self.ip = ip\n    self.port = port\n    self._timeout = timeout\n    self._max_retries = max_retries\n\n    # Create lightweight connection handle - connection pooling is internal\n    self.connection = DeviceConnection(\n        serial=self.serial,\n        ip=self.ip,\n        port=self.port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    # State storage: Cached values from device\n    self._label: str | None = None\n    self._version: DeviceVersion | None = None\n    self._host_firmware: FirmwareInfo | None = None\n    self._wifi_firmware: FirmwareInfo | None = None\n    self._location: CollectionInfo | None = None\n    self._group: CollectionInfo | None = None\n    self._mac_address: str | None = None\n\n    # Product capabilities for device features (populated on first use)\n    self._capabilities: ProductInfo | None = None\n\n    # State management (populated by connect() factory or _initialize_state())\n    self._state: StateT | None = None\n    self._refresh_task: asyncio.Task[None] | None = None\n    self._refresh_lock = asyncio.Lock()\n    self._is_closed = False\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.base.Device.capabilities","title":"capabilities  <code>property</code>","text":"<pre><code>capabilities: ProductInfo | None\n</code></pre> <p>Get device product capabilities.</p> <p>Returns product information including supported features like: - color, infrared, multizone, extended_multizone - matrix (for tiles), chain, relays, buttons, hev - temperature_range</p> <p>Capabilities are automatically loaded when using device as context manager.</p> RETURNS DESCRIPTION <code>ProductInfo | None</code> <p>ProductInfo if capabilities have been loaded, None otherwise.</p> Example <pre><code>async with device:\n    if device.capabilities and device.capabilities.has_multizone:\n        print(\"Device supports multizone\")\n    if device.capabilities and device.capabilities.has_extended_multizone:\n        print(\"Device supports extended multizone\")\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.state","title":"state  <code>property</code>","text":"<pre><code>state: StateT | None\n</code></pre> <p>Get device state if available.</p> <p>State is populated by the connect() factory method or by calling _initialize_state() directly. Returns None if state has not been initialized.</p> RETURNS DESCRIPTION <code>StateT | None</code> <p>State with current device state, or None if not initialized</p>"},{"location":"api/devices/#lifx.devices.base.Device.label","title":"label  <code>property</code>","text":"<pre><code>label: str | None\n</code></pre> <p>Get cached label if available.</p> <p>Use get_label() to fetch from device.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Device label or None if never fetched.</p>"},{"location":"api/devices/#lifx.devices.base.Device.version","title":"version  <code>property</code>","text":"<pre><code>version: DeviceVersion | None\n</code></pre> <p>Get cached version if available.</p> <p>Use get_version() to fetch from device.</p> RETURNS DESCRIPTION <code>DeviceVersion | None</code> <p>Device version or None if never fetched.</p>"},{"location":"api/devices/#lifx.devices.base.Device.host_firmware","title":"host_firmware  <code>property</code>","text":"<pre><code>host_firmware: FirmwareInfo | None\n</code></pre> <p>Get cached host firmware if available.</p> <p>Use get_host_firmware() to fetch from device.</p> RETURNS DESCRIPTION <code>FirmwareInfo | None</code> <p>Firmware info or None if never fetched.</p>"},{"location":"api/devices/#lifx.devices.base.Device.wifi_firmware","title":"wifi_firmware  <code>property</code>","text":"<pre><code>wifi_firmware: FirmwareInfo | None\n</code></pre> <p>Get cached wifi firmware if available.</p> <p>Use get_wifi_firmware() to fetch from device.</p> RETURNS DESCRIPTION <code>FirmwareInfo | None</code> <p>Firmware info or None if never fetched.</p>"},{"location":"api/devices/#lifx.devices.base.Device.location","title":"location  <code>property</code>","text":"<pre><code>location: str | None\n</code></pre> <p>Get cached location name if available.</p> <p>Use get_location() to fetch from device.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Location name or None if never fetched.</p>"},{"location":"api/devices/#lifx.devices.base.Device.group","title":"group  <code>property</code>","text":"<pre><code>group: str | None\n</code></pre> <p>Get cached group name if available.</p> <p>Use get_group() to fetch from device.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Group name or None if never fetched.</p>"},{"location":"api/devices/#lifx.devices.base.Device.model","title":"model  <code>property</code>","text":"<pre><code>model: str | None\n</code></pre> <p>Get LIFX friendly model name if available.</p> RETURNS DESCRIPTION <code>str | None</code> <p>Model string from product registry.</p>"},{"location":"api/devices/#lifx.devices.base.Device.mac_address","title":"mac_address  <code>property</code>","text":"<pre><code>mac_address: str | None\n</code></pre> <p>Get cached MAC address if available.</p> <p>Use get_host_firmware() to calculate MAC address from device firmware.</p> RETURNS DESCRIPTION <code>str | None</code> <p>MAC address in colon-separated format (e.g., \"d0:73:d5:01:02:03\"),</p> <code>str | None</code> <p>or None if not yet calculated.</p>"},{"location":"api/devices/#lifx.devices.base.Device-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.base.Device.from_ip","title":"from_ip  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_ip(\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    serial: str | None = None,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Self\n</code></pre> <p>Create and return an instance for the given IP address.</p> <p>This is a convenience class method for connecting to a known device by IP address. The returned instance can be used as a context manager.</p> PARAMETER DESCRIPTION <code>ip</code> <p>IP address of the device</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Port number (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>serial</code> <p>Serial number as 12-digit hex string</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Request timeout for this device instance</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Device instance ready to use with async context manager</p> Example <pre><code>async with await Device.from_ip(ip=\"192.168.1.100\") as device:\n    label = await device.get_label()\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>@classmethod\nasync def from_ip(\n    cls,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    serial: str | None = None,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Self:\n    \"\"\"Create and return an instance for the given IP address.\n\n    This is a convenience class method for connecting to a known device\n    by IP address. The returned instance can be used as a context manager.\n\n    Args:\n        ip: IP address of the device\n        port: Port number (default LIFX_UDP_PORT)\n        serial: Serial number as 12-digit hex string\n        timeout: Request timeout for this device instance\n\n    Returns:\n        Device instance ready to use with async context manager\n\n    Example:\n        ```python\n        async with await Device.from_ip(ip=\"192.168.1.100\") as device:\n            label = await device.get_label()\n        ```\n    \"\"\"\n    if serial is None:\n        temp_conn = DeviceConnection(\n            serial=\"000000000000\",\n            ip=ip,\n            port=port,\n            timeout=timeout,\n            max_retries=max_retries,\n        )\n        try:\n            response = await temp_conn.request(\n                packets.Device.GetService(), timeout=timeout\n            )\n            if response and isinstance(response, packets.Device.StateService):\n                if temp_conn.serial and temp_conn.serial != \"000000000000\":\n                    return cls(\n                        serial=temp_conn.serial,\n                        ip=ip,\n                        port=port,\n                        timeout=timeout,\n                        max_retries=max_retries,\n                    )\n        finally:\n            # Always close the temporary connection to prevent resource leaks\n            await temp_conn.close()\n    else:\n        return cls(\n            serial=serial,\n            ip=ip,\n            port=port,\n            timeout=timeout,\n            max_retries=max_retries,\n        )\n\n    raise LifxDeviceNotFoundError()\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.connect","title":"connect  <code>async</code> <code>classmethod</code>","text":"<pre><code>connect(\n    ip: str,\n    serial: str | None = None,\n    port: int = LIFX_UDP_PORT,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; (\n    Light\n    | HevLight\n    | InfraredLight\n    | MultiZoneLight\n    | MatrixLight\n    | CeilingLight\n)\n</code></pre> <p>Create and return a fully initialized device instance.</p> <p>This factory method creates the appropriate device type (Light, etc) based on the device's capabilities and initializes its state. The returned device MUST be used with an async context manager.</p> <p>The returned device subclass has guaranteed initialized state - the state property will never be None for devices created via this method.</p> PARAMETER DESCRIPTION <code>ip</code> <p>IP address of the device</p> <p> TYPE: <code>str</code> </p> <code>serial</code> <p>Optional serial number (12-digit hex, with or without colons).     If None, queries device to get serial.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>port</code> <p>Port number (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>timeout</code> <p>Request timeout for this device instance</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>Maximum number of retry attempts</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> RETURNS DESCRIPTION <code>Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight | CeilingLight</code> <p>Fully initialized device instance (Light, MultiZoneLight, MatrixLight, etc.)</p> <code>Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight | CeilingLight</code> <p>with complete state loaded and guaranteed non-None state property.</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device cannot be found or contacted</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>ValueError</code> <p>If serial format is invalid</p> Example <pre><code># Connect by IP (serial auto-detected)\ndevice = await Device.connect(ip=\"192.168.1.100\")\nasync with device:\n    # device.state is guaranteed to be initialized\n    print(f\"{device.state.model}: {device.state.label}\")\n    if device.state.is_on:\n        print(\"Device is on\")\n\n# Connect with known serial\ndevice = await Device.connect(ip=\"192.168.1.100\", serial=\"d073d5123456\")\nasync with device:\n    await device.set_power(True)\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>@classmethod\nasync def connect(\n    cls,\n    ip: str,\n    serial: str | None = None,\n    port: int = LIFX_UDP_PORT,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight | CeilingLight:\n    \"\"\"Create and return a fully initialized device instance.\n\n    This factory method creates the appropriate device type (Light, etc)\n    based on the device's capabilities and initializes its state. The returned\n    device MUST be used with an async context manager.\n\n    The returned device subclass has guaranteed initialized state - the state\n    property will never be None for devices created via this method.\n\n    Args:\n        ip: IP address of the device\n        serial: Optional serial number (12-digit hex, with or without colons).\n                If None, queries device to get serial.\n        port: Port number (default LIFX_UDP_PORT)\n        timeout: Request timeout for this device instance\n        max_retries: Maximum number of retry attempts\n\n    Returns:\n        Fully initialized device instance (Light, MultiZoneLight, MatrixLight, etc.)\n        with complete state loaded and guaranteed non-None state property.\n\n    Raises:\n        LifxDeviceNotFoundError: If device cannot be found or contacted\n        LifxTimeoutError: If device does not respond\n        ValueError: If serial format is invalid\n\n    Example:\n        ```python\n        # Connect by IP (serial auto-detected)\n        device = await Device.connect(ip=\"192.168.1.100\")\n        async with device:\n            # device.state is guaranteed to be initialized\n            print(f\"{device.state.model}: {device.state.label}\")\n            if device.state.is_on:\n                print(\"Device is on\")\n\n        # Connect with known serial\n        device = await Device.connect(ip=\"192.168.1.100\", serial=\"d073d5123456\")\n        async with device:\n            await device.set_power(True)\n        ```\n    \"\"\"\n    # Step 1: Get serial if not provided\n    if serial is None:\n        temp_conn = DeviceConnection(\n            serial=\"000000000000\",\n            ip=ip,\n            port=port,\n            timeout=timeout,\n            max_retries=max_retries,\n        )\n        try:\n            response = await temp_conn.request(\n                packets.Device.GetService(), timeout=timeout\n            )\n            if response and isinstance(response, packets.Device.StateService):\n                if temp_conn.serial and temp_conn.serial != \"000000000000\":\n                    serial = temp_conn.serial\n                else:\n                    raise LifxDeviceNotFoundError(\n                        \"Could not determine device serial\"\n                    )\n            else:\n                raise LifxDeviceNotFoundError(\"No response from device\")\n        finally:\n            await temp_conn.close()\n\n    # Step 2: Normalize serial (accept with or without colons)\n    serial = serial.replace(\":\", \"\")\n\n    # Step 3: Create temporary device to get product info\n    temp_device = cls(\n        serial=serial,\n        ip=ip,\n        port=port,\n        timeout=timeout,\n        max_retries=max_retries,\n    )\n\n    try:\n        # Get version to determine product\n        version = await temp_device.get_version()\n        product_info = get_product(version.product)\n\n        if product_info is None:\n            raise LifxDeviceNotFoundError(f\"Unknown product ID: {version.product}\")\n\n        # Step 4: Determine correct device class based on capabilities\n        # Import device classes here to avoid circular imports\n        from typing import TYPE_CHECKING\n\n        if TYPE_CHECKING:\n            from lifx.devices.hev import HevLight\n            from lifx.devices.infrared import InfraredLight\n            from lifx.devices.light import Light\n            from lifx.devices.matrix import MatrixLight\n            from lifx.devices.multizone import MultiZoneLight\n\n        device_class: type[Device] = cls\n\n        # Check for ceiling products first (subset of matrix devices)\n        from lifx.products import is_ceiling_product\n\n        if is_ceiling_product(version.product):\n            from lifx.devices.ceiling import CeilingLight\n\n            device_class = CeilingLight\n        elif product_info.has_matrix:\n            from lifx.devices.matrix import MatrixLight\n\n            device_class = MatrixLight\n        elif product_info.has_multizone:\n            from lifx.devices.multizone import MultiZoneLight\n\n            device_class = MultiZoneLight\n        elif product_info.has_infrared:\n            from lifx.devices.infrared import InfraredLight\n\n            device_class = InfraredLight\n        elif product_info.has_hev:\n            from lifx.devices.hev import HevLight\n\n            device_class = HevLight\n        elif product_info.has_color:\n            from lifx.devices.light import Light\n\n            device_class = Light\n\n        # Step 5: Create instance of correct device class\n        device = device_class(\n            serial=serial,\n            ip=ip,\n            port=port,\n            timeout=timeout,\n            max_retries=max_retries,\n        )\n\n        # Type system note: device._state is guaranteed non-None after\n        # _initialize_state().\n        # Each subclass overrides _state to be non-optional\n        return device  # type: ignore[return-value]\n\n    finally:\n        # Clean up temporary device\n        await temp_device.connection.close()\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_mac_address","title":"get_mac_address  <code>async</code>","text":"<pre><code>get_mac_address() -&gt; str\n</code></pre> <p>Calculate and return the MAC address for this device.</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_mac_address(self) -&gt; str:\n    \"\"\"Calculate and return the MAC address for this device.\"\"\"\n    if self._mac_address is None:\n        firmware = (\n            self._host_firmware\n            if self._host_firmware is not None\n            else await self.get_host_firmware()\n        )\n        octets = [\n            int(self.serial[i : i + 2], 16) for i in range(0, len(self.serial), 2)\n        ]\n\n        if firmware.version_major == 3:\n            octets[5] = (octets[5] + 1) % 256\n\n        self._mac_address = \":\".join(f\"{octet:02x}\" for octet in octets)\n\n    return self._mac_address\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_label","title":"get_label  <code>async</code>","text":"<pre><code>get_label() -&gt; str\n</code></pre> <p>Get device label/name.</p> <p>Always fetches from device. Use the <code>label</code> property to access stored value.</p> RETURNS DESCRIPTION <code>str</code> <p>Device label as string (max 32 bytes UTF-8)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>label = await device.get_label()\nprint(f\"Device name: {label}\")\n\n# Or use cached value\nif device.label:\n    print(f\"Cached label: {device.label}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_label(self) -&gt; str:\n    \"\"\"Get device label/name.\n\n    Always fetches from device. Use the `label` property to access stored value.\n\n    Returns:\n        Device label as string (max 32 bytes UTF-8)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        label = await device.get_label()\n        print(f\"Device name: {label}\")\n\n        # Or use cached value\n        if device.label:\n            print(f\"Cached label: {device.label}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks and decodes label\n    state = await self.connection.request(packets.Device.GetLabel())\n    self._raise_if_unhandled(state)\n\n    # Store label\n    label_value = state.label\n    self._label = label_value\n    # Update state if it exists\n    if self._state is not None:\n        self._state.label = label_value\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_label\",\n            \"action\": \"query\",\n            \"reply\": {\"label\": label_value},\n        }\n    )\n    return label_value\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_label","title":"set_label  <code>async</code>","text":"<pre><code>set_label(label: str) -&gt; None\n</code></pre> <p>Set device label/name.</p> PARAMETER DESCRIPTION <code>label</code> <p>New device label (max 32 bytes UTF-8)</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If label is too long</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Set label\nawait device.set_label(\"Living Room Light\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_label(self, label: str) -&gt; None:\n    \"\"\"Set device label/name.\n\n    Args:\n        label: New device label (max 32 bytes UTF-8)\n\n    Raises:\n        ValueError: If label is too long\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Set label\n        await device.set_label(\"Living Room Light\")\n        ```\n    \"\"\"\n    # Encode and pad to 32 bytes\n    label_bytes = label.encode(\"utf-8\")\n    if len(label_bytes) &gt; 32:\n        raise ValueError(f\"Label too long: {len(label_bytes)} bytes (max 32)\")\n\n    # Pad with zeros\n    label_bytes = label_bytes.ljust(32, b\"\\x00\")\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Device.SetLabel(label=label_bytes),\n    )\n    self._raise_if_unhandled(result)\n\n    if result:\n        self._label = label\n\n        if self._state is not None:\n            self._state.label = label\n            await self._schedule_refresh()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_label\",\n            \"action\": \"change\",\n            \"values\": {\"label\": label},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_power","title":"get_power  <code>async</code>","text":"<pre><code>get_power() -&gt; int\n</code></pre> <p>Get device power state.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>int</code> <p>Power level as integer (0 for off, 65535 for on)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>level = await device.get_power()\nprint(f\"Power: {'ON' if level &gt; 0 else 'OFF'}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_power(self) -&gt; int:\n    \"\"\"Get device power state.\n\n    Always fetches from device.\n\n    Returns:\n        Power level as integer (0 for off, 65535 for on)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        level = await device.get_power()\n        print(f\"Power: {'ON' if level &gt; 0 else 'OFF'}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetPower())\n    self._raise_if_unhandled(state)\n\n    # Power level is uint16 (0 or 65535)\n    power_level = state.level\n    # Update state if it exists\n    if self._state is not None:\n        self._state.power = power_level\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_power\",\n            \"action\": \"query\",\n            \"reply\": {\"level\": power_level},\n        }\n    )\n    return power_level\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(level: bool | int) -&gt; None\n</code></pre> <p>Set device power state.</p> PARAMETER DESCRIPTION <code>level</code> <p>True/65535 to turn on, False/0 to turn off</p> <p> TYPE: <code>bool | int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If integer value is not 0 or 65535</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Turn on device with boolean\nawait device.set_power(True)\n\n# Turn on device with integer\nawait device.set_power(65535)\n\n# Turn off device\nawait device.set_power(False)\nawait device.set_power(0)\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_power(self, level: bool | int) -&gt; None:\n    \"\"\"Set device power state.\n\n    Args:\n        level: True/65535 to turn on, False/0 to turn off\n\n    Raises:\n        ValueError: If integer value is not 0 or 65535\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Turn on device with boolean\n        await device.set_power(True)\n\n        # Turn on device with integer\n        await device.set_power(65535)\n\n        # Turn off device\n        await device.set_power(False)\n        await device.set_power(0)\n        ```\n    \"\"\"\n    # Power level: 0 for off, 65535 for on\n    if isinstance(level, bool):\n        power_level = 65535 if level else 0\n    elif isinstance(level, int):\n        if level not in (0, 65535):\n            raise ValueError(f\"Power level must be 0 or 65535, got {level}\")\n        power_level = level\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Device.SetPower(level=power_level),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_power\",\n            \"action\": \"change\",\n            \"values\": {\"level\": power_level},\n        }\n    )\n\n    if result and self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_version","title":"get_version  <code>async</code>","text":"<pre><code>get_version() -&gt; DeviceVersion\n</code></pre> <p>Get device version information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>DeviceVersion</code> <p>DeviceVersion with vendor and product fields</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>version = await device.get_version()\nprint(f\"Vendor: {version.vendor}, Product: {version.product}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_version(self) -&gt; DeviceVersion:\n    \"\"\"Get device version information.\n\n    Always fetches from device.\n\n    Returns:\n        DeviceVersion with vendor and product fields\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        version = await device.get_version()\n        print(f\"Vendor: {version.vendor}, Product: {version.product}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetVersion())\n    self._raise_if_unhandled(state)\n\n    version = DeviceVersion(\n        vendor=state.vendor,\n        product=state.product,\n    )\n\n    self._version = version\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_version\",\n            \"action\": \"query\",\n            \"reply\": {\"vendor\": state.vendor, \"product\": state.product},\n        }\n    )\n    return version\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_info","title":"get_info  <code>async</code>","text":"<pre><code>get_info() -&gt; DeviceInfo\n</code></pre> <p>Get device runtime information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>DeviceInfo</code> <p>DeviceInfo with time, uptime, and downtime</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>info = await device.get_info()\nuptime_hours = info.uptime / 1e9 / 3600\nprint(f\"Uptime: {uptime_hours:.1f} hours\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_info(self) -&gt; DeviceInfo:\n    \"\"\"Get device runtime information.\n\n    Always fetches from device.\n\n    Returns:\n        DeviceInfo with time, uptime, and downtime\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        info = await device.get_info()\n        uptime_hours = info.uptime / 1e9 / 3600\n        print(f\"Uptime: {uptime_hours:.1f} hours\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetInfo())  # type: ignore\n    self._raise_if_unhandled(state)\n\n    info = DeviceInfo(time=state.time, uptime=state.uptime, downtime=state.downtime)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_info\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"time\": state.time,\n                \"uptime\": state.uptime,\n                \"downtime\": state.downtime,\n            },\n        }\n    )\n    return info\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_wifi_info","title":"get_wifi_info  <code>async</code>","text":"<pre><code>get_wifi_info() -&gt; WifiInfo\n</code></pre> <p>Get device WiFi module information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>WifiInfo</code> <p>WifiInfo with signal strength and RSSI</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>wifi_info = await device.get_wifi_info()\nprint(f\"WiFi signal: {wifi_info.signal}\")\nprint(f\"WiFi RSSI: {wifi_info.rssi}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_wifi_info(self) -&gt; WifiInfo:\n    \"\"\"Get device WiFi module information.\n\n    Always fetches from device.\n\n    Returns:\n        WifiInfo with signal strength and RSSI\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        wifi_info = await device.get_wifi_info()\n        print(f\"WiFi signal: {wifi_info.signal}\")\n        print(f\"WiFi RSSI: {wifi_info.rssi}\")\n        ```\n    \"\"\"\n    # Request WiFi info from device\n    state = await self.connection.request(packets.Device.GetWifiInfo())\n    self._raise_if_unhandled(state)\n\n    # Extract WiFi info from response\n    wifi_info = WifiInfo(signal=state.signal)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_wifi_info\",\n            \"action\": \"query\",\n            \"reply\": {\"signal\": state.signal},\n        }\n    )\n    return wifi_info\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_host_firmware","title":"get_host_firmware  <code>async</code>","text":"<pre><code>get_host_firmware() -&gt; FirmwareInfo\n</code></pre> <p>Get device host (WiFi module) firmware information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>FirmwareInfo</code> <p>FirmwareInfo with build timestamp and version</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>firmware = await device.get_host_firmware()\nprint(f\"Firmware: v{firmware.version_major}.{firmware.version_minor}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_host_firmware(self) -&gt; FirmwareInfo:\n    \"\"\"Get device host (WiFi module) firmware information.\n\n    Always fetches from device.\n\n    Returns:\n        FirmwareInfo with build timestamp and version\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        firmware = await device.get_host_firmware()\n        print(f\"Firmware: v{firmware.version_major}.{firmware.version_minor}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetHostFirmware())  # type: ignore\n    self._raise_if_unhandled(state)\n\n    firmware = FirmwareInfo(\n        build=state.build,\n        version_major=state.version_major,\n        version_minor=state.version_minor,\n    )\n\n    self._host_firmware = firmware\n\n    # Calculate MAC address now that we have firmware info\n    if self.mac_address is None:\n        await self.get_mac_address()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_host_firmware\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"build\": state.build,\n                \"version_major\": state.version_major,\n                \"version_minor\": state.version_minor,\n            },\n        }\n    )\n    return firmware\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_wifi_firmware","title":"get_wifi_firmware  <code>async</code>","text":"<pre><code>get_wifi_firmware() -&gt; FirmwareInfo\n</code></pre> <p>Get device WiFi module firmware information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>FirmwareInfo</code> <p>FirmwareInfo with build timestamp and version</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>wifi_fw = await device.get_wifi_firmware()\nprint(f\"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_wifi_firmware(self) -&gt; FirmwareInfo:\n    \"\"\"Get device WiFi module firmware information.\n\n    Always fetches from device.\n\n    Returns:\n        FirmwareInfo with build timestamp and version\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        wifi_fw = await device.get_wifi_firmware()\n        print(f\"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetWifiFirmware())  # type: ignore\n    self._raise_if_unhandled(state)\n\n    firmware = FirmwareInfo(\n        build=state.build,\n        version_major=state.version_major,\n        version_minor=state.version_minor,\n    )\n\n    self._wifi_firmware = firmware\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_wifi_firmware\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"build\": state.build,\n                \"version_major\": state.version_major,\n                \"version_minor\": state.version_minor,\n            },\n        }\n    )\n    return firmware\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_location","title":"get_location  <code>async</code>","text":"<pre><code>get_location() -&gt; CollectionInfo\n</code></pre> <p>Get device location information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>CollectionInfo</code> <p>CollectionInfo with location UUID, label, and updated timestamp</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>location = await device.get_location()\nprint(f\"Location: {location.label}\")\nprint(f\"Location ID: {location.uuid}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_location(self) -&gt; CollectionInfo:\n    \"\"\"Get device location information.\n\n    Always fetches from device.\n\n    Returns:\n        CollectionInfo with location UUID, label, and updated timestamp\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        location = await device.get_location()\n        print(f\"Location: {location.label}\")\n        print(f\"Location ID: {location.uuid}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetLocation())  # type: ignore\n    self._raise_if_unhandled(state)\n\n    location = CollectionInfo(\n        uuid=state.location.hex(),\n        label=state.label,\n        updated_at=state.updated_at,\n    )\n\n    self._location = location\n    if self._state is not None:\n        self._state.location = location\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_location\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"location\": state.location.hex(),\n                \"label\": state.label,\n                \"updated_at\": state.updated_at,\n            },\n        }\n    )\n    return location\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_location","title":"set_location  <code>async</code>","text":"<pre><code>set_location(\n    label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT\n) -&gt; None\n</code></pre> <p>Set device location information.</p> <p>Automatically discovers devices on the network to check if any device already has the target location label. If found, reuses that existing UUID to ensure devices with the same label share the same location UUID. If not found, generates a new UUID for this label.</p> PARAMETER DESCRIPTION <code>label</code> <p>Location label (max 32 characters)</p> <p> TYPE: <code>str</code> </p> <code>discover_timeout</code> <p>Timeout for device discovery in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>ValueError</code> <p>If label is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Set device location\nawait device.set_location(\"Living Room\")\n\n# If another device already has \"Kitchen\" location, this device will\n# join that existing location UUID\nawait device.set_location(\"Kitchen\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_location(\n    self, label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT\n) -&gt; None:\n    \"\"\"Set device location information.\n\n    Automatically discovers devices on the network to check if any device already\n    has the target location label. If found, reuses that existing UUID to ensure\n    devices with the same label share the same location UUID. If not found,\n    generates a new UUID for this label.\n\n    Args:\n        label: Location label (max 32 characters)\n        discover_timeout: Timeout for device discovery in seconds\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        ValueError: If label is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Set device location\n        await device.set_location(\"Living Room\")\n\n        # If another device already has \"Kitchen\" location, this device will\n        # join that existing location UUID\n        await device.set_location(\"Kitchen\")\n        ```\n    \"\"\"\n    # Validate label\n    if not label:\n        raise ValueError(\"Label cannot be empty\")\n    if len(label) &gt; 32:\n        raise ValueError(f\"Label must be max 32 characters, got {len(label)}\")\n\n    # Import here to avoid circular dependency\n    from lifx.network.discovery import discover_devices\n\n    # Discover all devices to check for existing label\n    location_uuid_to_use: bytes | None = None\n\n    try:\n        # Check each device for the target label\n        async for disc in discover_devices(\n            timeout=discover_timeout,\n            device_timeout=self._timeout,\n            max_retries=self._max_retries,\n        ):\n            temp_conn = DeviceConnection(\n                serial=disc.serial,\n                ip=disc.ip,\n                port=disc.port,\n                timeout=self._timeout,\n                max_retries=self._max_retries,\n            )\n\n            try:\n                # Get location info using new request() API\n                state_packet = await temp_conn.request(packets.Device.GetLocation())  # type: ignore\n\n                # Check if this device has the target label\n                if (\n                    state_packet.label == label\n                    and state_packet.location is not None\n                    and isinstance(state_packet.location, bytes)\n                ):\n                    location_uuid_to_use = state_packet.location\n                    assert location_uuid_to_use is not None\n                    # Type narrowing: we know location_uuid_to_use is not None here\n                    _LOGGER.debug(\n                        {\n                            \"action\": \"device.set_location\",\n                            \"location_found\": True,\n                            \"label\": label,\n                            \"uuid\": location_uuid_to_use.hex(),\n                        }\n                    )\n                    break\n\n            except Exception as e:\n                _LOGGER.debug(\n                    {\n                        \"action\": \"device.set_location\",\n                        \"discovery_query_failed\": True,\n                        \"reason\": str(e),\n                    }\n                )\n                continue\n\n            finally:\n                # Always close the temporary connection to prevent resource leaks\n                await temp_conn.close()\n\n    except Exception as e:\n        _LOGGER.warning(\n            {\n                \"warning\": \"Discovery failed, will generate new UUID\",\n                \"reason\": str(e),\n            }\n        )\n\n    # If no existing location with target label found, generate new UUID\n    if location_uuid_to_use is None:\n        location_uuid = uuid.uuid5(LIFX_LOCATION_NAMESPACE, label)\n        location_uuid_to_use = location_uuid.bytes\n\n    # Encode label for protocol\n    label_bytes = label.encode(\"utf-8\")[:32].ljust(32, b\"\\x00\")\n\n    # Always use current time as updated_at timestamp\n    updated_at = int(time.time() * 1e9)\n\n    # Update this device\n    result = await self.connection.request(\n        packets.Device.SetLocation(\n            location=location_uuid_to_use, label=label_bytes, updated_at=updated_at\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    if result:\n        self._location = CollectionInfo(\n            uuid=location_uuid_to_use.hex(), label=label, updated_at=updated_at\n        )\n\n    if result and self._state is not None:\n        self._state.location.uuid = location_uuid_to_use.hex()\n        self._state.location.label = label\n        self._state.location.updated_at = updated_at\n        await self._schedule_refresh()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_location\",\n            \"action\": \"change\",\n            \"values\": {\n                \"location\": location_uuid_to_use.hex(),\n                \"label\": label,\n                \"updated_at\": updated_at,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.get_group","title":"get_group  <code>async</code>","text":"<pre><code>get_group() -&gt; CollectionInfo\n</code></pre> <p>Get device group information.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>CollectionInfo</code> <p>CollectionInfo with group UUID, label, and updated timestamp</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>group = await device.get_group()\nprint(f\"Group: {group.label}\")\nprint(f\"Group ID: {group.uuid}\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def get_group(self) -&gt; CollectionInfo:\n    \"\"\"Get device group information.\n\n    Always fetches from device.\n\n    Returns:\n        CollectionInfo with group UUID, label, and updated timestamp\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        group = await device.get_group()\n        print(f\"Group: {group.label}\")\n        print(f\"Group ID: {group.uuid}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Device.GetGroup())  # type: ignore\n    self._raise_if_unhandled(state)\n\n    group = CollectionInfo(\n        uuid=state.group.hex(),\n        label=state.label,\n        updated_at=state.updated_at,\n    )\n\n    self._group = group\n    if self._state is not None:\n        self._state.group = group\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_group\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"uuid\": state.group.hex(),\n                \"label\": state.label,\n                \"updated_at\": state.updated_at,\n            },\n        }\n    )\n    return group\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_group","title":"set_group  <code>async</code>","text":"<pre><code>set_group(label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT) -&gt; None\n</code></pre> <p>Set device group information.</p> <p>Automatically discovers devices on the network to check if any device already has the target group label. If found, reuses that existing UUID to ensure devices with the same label share the same group UUID. If not found, generates a new UUID for this label.</p> PARAMETER DESCRIPTION <code>label</code> <p>Group label (max 32 characters)</p> <p> TYPE: <code>str</code> </p> <code>discover_timeout</code> <p>Timeout for device discovery in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>ValueError</code> <p>If label is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Set device group\nawait device.set_group(\"Bedroom Lights\")\n\n# If another device already has \"Upstairs\" group, this device will\n# join that existing group UUID\nawait device.set_group(\"Upstairs\")\n</code></pre> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_group(\n    self, label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT\n) -&gt; None:\n    \"\"\"Set device group information.\n\n    Automatically discovers devices on the network to check if any device already\n    has the target group label. If found, reuses that existing UUID to ensure\n    devices with the same label share the same group UUID. If not found,\n    generates a new UUID for this label.\n\n    Args:\n        label: Group label (max 32 characters)\n        discover_timeout: Timeout for device discovery in seconds\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        ValueError: If label is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Set device group\n        await device.set_group(\"Bedroom Lights\")\n\n        # If another device already has \"Upstairs\" group, this device will\n        # join that existing group UUID\n        await device.set_group(\"Upstairs\")\n        ```\n    \"\"\"\n    # Validate label\n    if not label:\n        raise ValueError(\"Label cannot be empty\")\n    if len(label) &gt; 32:\n        raise ValueError(f\"Label must be max 32 characters, got {len(label)}\")\n\n    # Import here to avoid circular dependency\n    from lifx.network.discovery import discover_devices\n\n    # Discover all devices to check for existing label\n    group_uuid_to_use: bytes | None = None\n\n    try:\n        # Check each device for the target label\n        async for disc in discover_devices(\n            timeout=discover_timeout,\n            device_timeout=self._timeout,\n            max_retries=self._max_retries,\n        ):\n            temp_conn = DeviceConnection(\n                serial=disc.serial,\n                ip=disc.ip,\n                port=disc.port,\n                timeout=self._timeout,\n                max_retries=self._max_retries,\n            )\n\n            try:\n                # Get group info using new request() API\n                state_packet = await temp_conn.request(packets.Device.GetGroup())  # type: ignore\n\n                # Check if this device has the target label\n                if (\n                    state_packet.label == label\n                    and state_packet.group is not None\n                    and isinstance(state_packet.group, bytes)\n                ):\n                    group_uuid_to_use = state_packet.group\n                    assert group_uuid_to_use is not None\n                    # Type narrowing: we know group_uuid_to_use is not None here\n                    _LOGGER.debug(\n                        {\n                            \"action\": \"device.set_group\",\n                            \"group_found\": True,\n                            \"label\": label,\n                            \"uuid\": group_uuid_to_use.hex(),\n                        }\n                    )\n                    break\n\n            except Exception as e:\n                _LOGGER.debug(\n                    {\n                        \"action\": \"device.set_group\",\n                        \"discovery_query_failed\": True,\n                        \"reason\": str(e),\n                    }\n                )\n                continue\n\n            finally:\n                # Always close the temporary connection to prevent resource leaks\n                await temp_conn.close()\n\n    except Exception as e:\n        _LOGGER.warning(\n            {\n                \"warning\": \"Discovery failed, will generate new UUID\",\n                \"reason\": str(e),\n            }\n        )\n\n    # If no existing group with target label found, generate new UUID\n    if group_uuid_to_use is None:\n        group_uuid = uuid.uuid5(LIFX_GROUP_NAMESPACE, label)\n        group_uuid_to_use = group_uuid.bytes\n\n    # Encode label for protocol\n    label_bytes = label.encode(\"utf-8\")[:32].ljust(32, b\"\\x00\")\n\n    # Always use current time as updated_at timestamp\n    updated_at = int(time.time() * 1e9)\n\n    # Update this device\n    result = await self.connection.request(\n        packets.Device.SetGroup(\n            group=group_uuid_to_use, label=label_bytes, updated_at=updated_at\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    if result:\n        self._group = CollectionInfo(\n            uuid=group_uuid_to_use.hex(), label=label, updated_at=updated_at\n        )\n\n    if result and self._state is not None:\n        self._state.location.uuid = group_uuid_to_use.hex()\n        self._state.location.label = label\n        self._state.location.updated_at = updated_at\n        await self._schedule_refresh()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_group\",\n            \"action\": \"change\",\n            \"values\": {\n                \"group\": group_uuid_to_use.hex(),\n                \"label\": label,\n                \"updated_at\": updated_at,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.set_reboot","title":"set_reboot  <code>async</code>","text":"<pre><code>set_reboot() -&gt; None\n</code></pre> <p>Reboot the device.</p> <p>This sends a reboot command to the device. The device will disconnect and restart. You should disconnect from the device after calling this method.</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>async with device:\n    await device.set_reboot()\n    # Device will reboot, connection will be lost\n</code></pre> Note <p>After rebooting, you may need to wait 10-30 seconds before the device comes back online and is discoverable again.</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def set_reboot(self) -&gt; None:\n    \"\"\"Reboot the device.\n\n    This sends a reboot command to the device. The device will disconnect\n    and restart. You should disconnect from the device after calling this method.\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        async with device:\n            await device.set_reboot()\n            # Device will reboot, connection will be lost\n        ```\n\n    Note:\n        After rebooting, you may need to wait 10-30 seconds before the device\n        comes back online and is discoverable again.\n    \"\"\"\n    # Send reboot request\n    result = await self.connection.request(\n        packets.Device.SetReboot(),\n    )\n    self._raise_if_unhandled(result)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_reboot\",\n            \"action\": \"change\",\n            \"values\": {},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close device connection and cleanup resources.</p> <p>Cancels any pending refresh tasks and closes the network connection. Called automatically when exiting the async context manager.</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close device connection and cleanup resources.\n\n    Cancels any pending refresh tasks and closes the network connection.\n    Called automatically when exiting the async context manager.\n    \"\"\"\n    self._is_closed = True\n    if self._refresh_task and not self._refresh_task.done():\n        self._refresh_task.cancel()\n        try:\n            await self._refresh_task\n        except asyncio.CancelledError:\n            pass\n    await self.connection.close()\n</code></pre>"},{"location":"api/devices/#lifx.devices.base.Device.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh device state from hardware.</p> <p>Fetches current state from device and updates the state instance. Base implementation fetches label, power, and updates timestamp. Subclasses override to add device-specific state updates.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/base.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh device state from hardware.\n\n    Fetches current state from device and updates the state instance.\n    Base implementation fetches label, power, and updates timestamp.\n    Subclasses override to add device-specific state updates.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    if not self._state:\n        await self._initialize_state()\n        return\n</code></pre>"},{"location":"api/devices/#light","title":"Light","text":"<p>The <code>Light</code> class provides color control and effects for standard LIFX lights.</p>"},{"location":"api/devices/#lifx.devices.light.Light","title":"Light","text":"<pre><code>Light(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Device[LightState]</code></p> <p>LIFX light device with color control.</p> <p>Extends the base Device class with light-specific functionality: - Color control (HSBK) - Brightness control - Color temperature control - Waveform effects</p> Example <pre><code>light = Light(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Set color\n    await light.set_color(HSBK.from_rgb(255, 0, 0))\n\n    # Set brightness\n    await light.set_brightness(0.5)\n\n    # Set temperature\n    await light.set_temperature(3500)\n</code></pre> <p>Using the simplified connect method (without knowing the serial): <pre><code>async with await Light.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_color(HSBK.from_rgb(255, 0, 0))\n</code></pre></p> METHOD DESCRIPTION <code>get_color</code> <p>Get current light color, power, and label.</p> <code>set_color</code> <p>Set light color.</p> <code>set_brightness</code> <p>Set light brightness only, preserving hue, saturation, and temperature.</p> <code>set_kelvin</code> <p>Set light color temperature, preserving brightness. Saturation is</p> <code>set_hue</code> <p>Set light hue only, preserving saturation, brightness, and temperature.</p> <code>set_saturation</code> <p>Set light saturation only, preserving hue, brightness, and temperature.</p> <code>get_power</code> <p>Get light power state (specific to light, not device).</p> <code>get_ambient_light_level</code> <p>Get ambient light level from device sensor.</p> <code>set_power</code> <p>Set light power state (specific to light, not device).</p> <code>set_waveform</code> <p>Apply a waveform effect to the light.</p> <code>set_waveform_optional</code> <p>Apply a waveform effect with selective color component control.</p> <code>pulse</code> <p>Pulse the light to a specific color.</p> <code>breathe</code> <p>Make the light breathe to a specific color.</p> <code>apply_theme</code> <p>Apply a theme to this light.</p> <code>refresh_state</code> <p>Refresh light state from hardware.</p> ATTRIBUTE DESCRIPTION <code>state</code> <p>Get light state (guaranteed to be initialized when using Device.connect()).</p> <p> TYPE: <code>LightState</code> </p> <code>min_kelvin</code> <p>Get the minimum supported kelvin value if available.</p> <p> TYPE: <code>int | None</code> </p> <code>max_kelvin</code> <p>Get the maximum supported kelvin value if available.</p> <p> TYPE: <code>int | None</code> </p> Source code in <code>src/lifx/devices/light.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Initialize Light with additional state attributes.\"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.light.Light.state","title":"state  <code>property</code>","text":"<pre><code>state: LightState\n</code></pre> <p>Get light state (guaranteed to be initialized when using Device.connect()).</p> RETURNS DESCRIPTION <code>LightState</code> <p>LightState with current light state</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If accessed before state initialization</p>"},{"location":"api/devices/#lifx.devices.light.Light.min_kelvin","title":"min_kelvin  <code>property</code>","text":"<pre><code>min_kelvin: int | None\n</code></pre> <p>Get the minimum supported kelvin value if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Minimum kelvin value from product registry.</p>"},{"location":"api/devices/#lifx.devices.light.Light.max_kelvin","title":"max_kelvin  <code>property</code>","text":"<pre><code>max_kelvin: int | None\n</code></pre> <p>Get the maximum supported kelvin value if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Maximum kelvin value from product registry.</p>"},{"location":"api/devices/#lifx.devices.light.Light-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.light.Light.get_color","title":"get_color  <code>async</code>","text":"<pre><code>get_color() -&gt; tuple[HSBK, int, str]\n</code></pre> <p>Get current light color, power, and label.</p> <p>Always fetches from device. Use the <code>color</code> property to access stored value.</p> <p>Returns a tuple containing: - color: HSBK color - power: Power level as integer (0 for off, 65535 for on) - label: Device label/name</p> RETURNS DESCRIPTION <code>tuple[HSBK, int, str]</code> <p>Tuple of (color, power, label)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>color, power, label = await light.get_color()\nprint(f\"{label}: Hue: {color.hue}\u00b0, Power: {'ON' if power &gt; 0 else 'OFF'}\")\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def get_color(self) -&gt; tuple[HSBK, int, str]:\n    \"\"\"Get current light color, power, and label.\n\n    Always fetches from device. Use the `color` property to access stored value.\n\n    Returns a tuple containing:\n    - color: HSBK color\n    - power: Power level as integer (0 for off, 65535 for on)\n    - label: Device label/name\n\n    Returns:\n        Tuple of (color, power, label)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        color, power, label = await light.get_color()\n        print(f\"{label}: Hue: {color.hue}\u00b0, Power: {'ON' if power &gt; 0 else 'OFF'}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response and decodes labels\n    state = await self.connection.request(packets.Light.GetColor())\n    self._raise_if_unhandled(state)\n\n    # Convert from protocol HSBK to user-friendly HSBK\n    color = HSBK.from_protocol(state.color)\n    power = state.power\n    label = state.label\n\n    # Store label from StateColor response\n    self._label = label  # Already decoded to string\n\n    # Update state if it exists (including all subclasses)\n    if self._state is not None:\n        # Update base fields available on all device states\n        self._state.power = power\n        self._state.label = label\n\n        if hasattr(self._state, \"color\"):\n            self._state.color = color\n\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_color\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"hue\": state.color.hue,\n                \"saturation\": state.color.saturation,\n                \"brightness\": state.color.brightness,\n                \"kelvin\": state.color.kelvin,\n                \"power\": state.power,\n                \"label\": state.label,\n            },\n        }\n    )\n\n    return color, power, label\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_color","title":"set_color  <code>async</code>","text":"<pre><code>set_color(color: HSBK, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light color.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Set to red instantly\nawait light.set_color(HSBK.from_rgb(255, 0, 0))\n\n# Fade to blue over 2 seconds\nawait light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_color(\n    self,\n    color: HSBK,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Set light color.\n\n    Args:\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Set to red instantly\n        await light.set_color(HSBK.from_rgb(255, 0, 0))\n\n        # Fade to blue over 2 seconds\n        await light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)\n        ```\n    \"\"\"\n    # Convert to protocol HSBK\n    protocol_color = color.to_protocol()\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Light.SetColor(\n            color=protocol_color,\n            duration=duration_ms,\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Light\",\n            \"method\": \"set_color\",\n            \"action\": \"change\",\n            \"values\": {\n                \"hue\": protocol_color.hue,\n                \"saturation\": protocol_color.saturation,\n                \"brightness\": protocol_color.brightness,\n                \"kelvin\": protocol_color.kelvin,\n                \"duration\": duration_ms,\n            },\n        }\n    )\n\n    # Update state on acknowledgement\n    if result and self._state is not None:\n        self._state.color = color\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_brightness","title":"set_brightness  <code>async</code>","text":"<pre><code>set_brightness(brightness: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light brightness only, preserving hue, saturation, and temperature.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>Brightness level (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If brightness is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to 50% brightness\nawait light.set_brightness(0.5)\n\n# Fade to full brightness over 1 second\nawait light.set_brightness(1.0, duration=1.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_brightness(self, brightness: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light brightness only, preserving hue, saturation, and temperature.\n\n    Args:\n        brightness: Brightness level (0.0-1.0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If brightness is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to 50% brightness\n        await light.set_brightness(0.5)\n\n        # Fade to full brightness over 1 second\n        await light.set_brightness(1.0, duration=1.0)\n        ```\n    \"\"\"\n    if not (MIN_BRIGHTNESS &lt;= brightness &lt;= MAX_BRIGHTNESS):\n        raise ValueError(\n            f\"Brightness must be between {MIN_BRIGHTNESS} \"\n            f\"and {MAX_BRIGHTNESS}, got {brightness}\"\n        )\n\n    # Use set_waveform_optional with HALF_SINE waveform to set brightness\n    # without needing to query current color values. Convert duration to seconds.\n    color = HSBK(hue=0, saturation=0, brightness=brightness, kelvin=3500)\n\n    await self.set_waveform_optional(\n        color=color,\n        period=max(duration, 0.001),\n        cycles=1,\n        waveform=LightWaveform.HALF_SINE,\n        transient=False,\n        set_hue=False,\n        set_saturation=False,\n        set_brightness=True,\n        set_kelvin=False,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_kelvin","title":"set_kelvin  <code>async</code>","text":"<pre><code>set_kelvin(kelvin: int, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light color temperature, preserving brightness. Saturation is    automatically set to 0 to switch the light to color temperature mode.</p> PARAMETER DESCRIPTION <code>kelvin</code> <p>Color temperature in Kelvin (1500-9000)</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If kelvin is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to warm white\nawait light.set_kelvin(2500)\n\n# Fade to cool white over 2 seconds\nawait light.set_kelvin(6500, duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_kelvin(self, kelvin: int, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light color temperature, preserving brightness. Saturation is\n       automatically set to 0 to switch the light to color temperature mode.\n\n    Args:\n        kelvin: Color temperature in Kelvin (1500-9000)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If kelvin is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to warm white\n        await light.set_kelvin(2500)\n\n        # Fade to cool white over 2 seconds\n        await light.set_kelvin(6500, duration=2.0)\n        ```\n    \"\"\"\n    if not (MIN_KELVIN &lt;= kelvin &lt;= MAX_KELVIN):\n        raise ValueError(\n            f\"Kelvin must be between {MIN_KELVIN} and {MAX_KELVIN}, got {kelvin}\"\n        )\n\n    # Use set_waveform_optional with HALF_SINE waveform to set kelvin\n    # and saturation without needing to query current color values\n    color = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=kelvin)\n\n    await self.set_waveform_optional(\n        color=color,\n        period=max(duration, 0.001),\n        cycles=1,\n        waveform=LightWaveform.HALF_SINE,\n        transient=False,\n        set_hue=False,\n        set_saturation=True,\n        set_brightness=False,\n        set_kelvin=True,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_hue","title":"set_hue  <code>async</code>","text":"<pre><code>set_hue(hue: int, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light hue only, preserving saturation, brightness, and temperature.</p> PARAMETER DESCRIPTION <code>hue</code> <p>Hue in degrees (0-360)</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If hue is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to red (0 degrees)\nawait light.set_hue(0)\n\n# Cycle through rainbow\nfor hue in range(0, 360, 10):\n    await light.set_hue(hue, duration=0.5)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_hue(self, hue: int, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light hue only, preserving saturation, brightness, and temperature.\n\n    Args:\n        hue: Hue in degrees (0-360)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If hue is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to red (0 degrees)\n        await light.set_hue(0)\n\n        # Cycle through rainbow\n        for hue in range(0, 360, 10):\n            await light.set_hue(hue, duration=0.5)\n        ```\n    \"\"\"\n    if not (MIN_HUE &lt;= hue &lt;= MAX_HUE):\n        raise ValueError(f\"Hue must be between {MIN_HUE} and {MAX_HUE}, got {hue}\")\n\n    # Use set_waveform_optional with HALF_SINE waveform to set hue\n    # without needing to query current color values\n    color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)\n\n    await self.set_waveform_optional(\n        color=color,\n        period=max(duration, 0.001),\n        cycles=1,\n        waveform=LightWaveform.HALF_SINE,\n        transient=False,\n        set_hue=True,\n        set_saturation=False,\n        set_brightness=False,\n        set_kelvin=False,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_saturation","title":"set_saturation  <code>async</code>","text":"<pre><code>set_saturation(saturation: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light saturation only, preserving hue, brightness, and temperature.</p> PARAMETER DESCRIPTION <code>saturation</code> <p>Saturation level (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If saturation is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> Example <pre><code># Set to fully saturated\nawait light.set_saturation(1.0)\n\n# Fade to white (no saturation) over 2 seconds\nawait light.set_saturation(0.0, duration=2.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_saturation(self, saturation: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light saturation only, preserving hue, brightness, and temperature.\n\n    Args:\n        saturation: Saturation level (0.0-1.0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If saturation is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n\n    Example:\n        ```python\n        # Set to fully saturated\n        await light.set_saturation(1.0)\n\n        # Fade to white (no saturation) over 2 seconds\n        await light.set_saturation(0.0, duration=2.0)\n        ```\n    \"\"\"\n    if not (MIN_SATURATION &lt;= saturation &lt;= MAX_SATURATION):\n        raise ValueError(\n            f\"Saturation must be between {MIN_SATURATION} \"\n            f\"and {MAX_SATURATION}, got {saturation}\"\n        )\n\n    # Use set_waveform_optional with HALF_SINE waveform to set saturation\n    # without needing to query current color values\n    color = HSBK(hue=0, saturation=saturation, brightness=1.0, kelvin=3500)\n\n    await self.set_waveform_optional(\n        color=color,\n        period=max(duration, 0.001),\n        cycles=1,\n        waveform=LightWaveform.HALF_SINE,\n        transient=False,\n        set_hue=False,\n        set_saturation=True,\n        set_brightness=False,\n        set_kelvin=False,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.get_power","title":"get_power  <code>async</code>","text":"<pre><code>get_power() -&gt; int\n</code></pre> <p>Get light power state (specific to light, not device).</p> <p>Always fetches from device.</p> <p>This overrides Device.get_power() as it queries the light-specific power state (packet type 116/118) instead of device power (packet type 20/22).</p> RETURNS DESCRIPTION <code>int</code> <p>Power level as integer (0 for off, 65535 for on)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>level = await light.get_power()\nprint(f\"Light power: {'ON' if level &gt; 0 else 'OFF'}\")\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def get_power(self) -&gt; int:\n    \"\"\"Get light power state (specific to light, not device).\n\n    Always fetches from device.\n\n    This overrides Device.get_power() as it queries the light-specific\n    power state (packet type 116/118) instead of device power (packet type 20/22).\n\n    Returns:\n        Power level as integer (0 for off, 65535 for on)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        level = await light.get_power()\n        print(f\"Light power: {'ON' if level &gt; 0 else 'OFF'}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Light.GetPower())\n    self._raise_if_unhandled(state)\n\n    # Power level is uint16 (0 or 65535)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_power\",\n            \"action\": \"query\",\n            \"reply\": {\"level\": state.level},\n        }\n    )\n\n    return state.level\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.get_ambient_light_level","title":"get_ambient_light_level  <code>async</code>","text":"<pre><code>get_ambient_light_level() -&gt; float\n</code></pre> <p>Get ambient light level from device sensor.</p> <p>Always fetches from device (volatile property, not cached).</p> <p>This method queries the device's ambient light sensor to get the current lux reading. Devices without ambient light sensors will return 0.0.</p> RETURNS DESCRIPTION <code>float</code> <p>Ambient light level in lux (0.0 if device has no sensor)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>lux = await light.get_ambient_light_level()\nif lux &gt; 0:\n    print(f\"Ambient light: {lux} lux\")\nelse:\n    print(\"No ambient light sensor or completely dark\")\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def get_ambient_light_level(self) -&gt; float:\n    \"\"\"Get ambient light level from device sensor.\n\n    Always fetches from device (volatile property, not cached).\n\n    This method queries the device's ambient light sensor to get the current\n    lux reading. Devices without ambient light sensors will return 0.0.\n\n    Returns:\n        Ambient light level in lux (0.0 if device has no sensor)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        lux = await light.get_ambient_light_level()\n        if lux &gt; 0:\n            print(f\"Ambient light: {lux} lux\")\n        else:\n            print(\"No ambient light sensor or completely dark\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.Sensor.GetAmbientLight())\n    self._raise_if_unhandled(state)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Light\",\n            \"method\": \"get_ambient_light_level\",\n            \"action\": \"query\",\n            \"reply\": {\"lux\": state.lux},\n        }\n    )\n\n    return state.lux\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(level: bool | int, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light power state (specific to light, not device).</p> <p>This overrides Device.set_power() as it uses the light-specific power packet (type 117) which supports transition duration.</p> PARAMETER DESCRIPTION <code>level</code> <p>True/65535 to turn on, False/0 to turn off</p> <p> TYPE: <code>bool | int</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If integer value is not 0 or 65535</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Turn on instantly with boolean\nawait light.set_power(True)\n\n# Turn on with integer\nawait light.set_power(65535)\n\n# Fade off over 3 seconds\nawait light.set_power(False, duration=3.0)\nawait light.set_power(0, duration=3.0)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_power(self, level: bool | int, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light power state (specific to light, not device).\n\n    This overrides Device.set_power() as it uses the light-specific\n    power packet (type 117) which supports transition duration.\n\n    Args:\n        level: True/65535 to turn on, False/0 to turn off\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If integer value is not 0 or 65535\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Turn on instantly with boolean\n        await light.set_power(True)\n\n        # Turn on with integer\n        await light.set_power(65535)\n\n        # Fade off over 3 seconds\n        await light.set_power(False, duration=3.0)\n        await light.set_power(0, duration=3.0)\n        ```\n    \"\"\"\n    # Power level: 0 for off, 65535 for on\n    if isinstance(level, bool):\n        power_level = 65535 if level else 0\n    elif isinstance(level, int):\n        if level not in (0, 65535):\n            raise ValueError(f\"Power level must be 0 or 65535, got {level}\")\n        power_level = level\n    else:\n        raise TypeError(f\"Expected bool or int, got {type(level).__name__}\")\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Light.SetPower(level=power_level, duration=duration_ms),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Light\",\n            \"method\": \"set_power\",\n            \"action\": \"change\",\n            \"values\": {\"level\": power_level, \"duration\": duration_ms},\n        }\n    )\n\n    # Update state on acknowledgement\n    if result and self._state is not None:\n        self._state.power = power_level\n\n    # Schedule refresh to validate state\n    if self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_waveform","title":"set_waveform  <code>async</code>","text":"<pre><code>set_waveform(\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n) -&gt; None\n</code></pre> <p>Apply a waveform effect to the light.</p> <p>Waveforms create repeating color transitions. Useful for effects like pulsing, breathing, or blinking.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color for the waveform</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one cycle in seconds</p> <p> TYPE: <code>float</code> </p> <code>cycles</code> <p>Number of cycles</p> <p> TYPE: <code>float</code> </p> <code>waveform</code> <p>Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)</p> <p> TYPE: <code>LightWaveform</code> </p> <code>transient</code> <p>If True, return to original color after effect (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>skew_ratio</code> <p>Waveform skew (0.0-1.0, default 0.5 for symmetric)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If parameters are out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>from lifx.protocol.protocol_types import LightWaveform\n\n# Pulse red 5 times\nawait light.set_waveform(\n    color=HSBK.from_rgb(255, 0, 0),\n    period=1.0,\n    cycles=5,\n    waveform=LightWaveform.SINE,\n)\n\n# Breathe white once\nawait light.set_waveform(\n    color=HSBK(0, 0, 1.0, 3500),\n    period=2.0,\n    cycles=1,\n    waveform=LightWaveform.SINE,\n    transient=False,\n)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_waveform(\n    self,\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n) -&gt; None:\n    \"\"\"Apply a waveform effect to the light.\n\n    Waveforms create repeating color transitions. Useful for effects like\n    pulsing, breathing, or blinking.\n\n    Args:\n        color: Target color for the waveform\n        period: Period of one cycle in seconds\n        cycles: Number of cycles\n        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)\n        transient: If True, return to original color after effect (default True)\n        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)\n\n    Raises:\n        ValueError: If parameters are out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        from lifx.protocol.protocol_types import LightWaveform\n\n        # Pulse red 5 times\n        await light.set_waveform(\n            color=HSBK.from_rgb(255, 0, 0),\n            period=1.0,\n            cycles=5,\n            waveform=LightWaveform.SINE,\n        )\n\n        # Breathe white once\n        await light.set_waveform(\n            color=HSBK(0, 0, 1.0, 3500),\n            period=2.0,\n            cycles=1,\n            waveform=LightWaveform.SINE,\n            transient=False,\n        )\n        ```\n    \"\"\"\n    if period &lt;= 0:\n        raise ValueError(f\"Period must be positive, got {period}\")\n    if cycles &lt; 1:\n        raise ValueError(f\"Cycles must be 1 or higher, got {cycles}\")\n    if not (0.0 &lt;= skew_ratio &lt;= 1.0):\n        raise ValueError(\n            f\"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}\"\n        )\n\n    # Convert to protocol values\n    protocol_color = color.to_protocol()\n    period_ms = int(period * 1000)\n    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range\n\n    # Send request\n    result = await self.connection.request(\n        packets.Light.SetWaveform(\n            transient=bool(transient),\n            color=protocol_color,\n            period=period_ms,\n            cycles=cycles,\n            skew_ratio=skew_ratio_i16,\n            waveform=waveform,\n        ),\n    )\n    self._raise_if_unhandled(result)\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_waveform\",\n            \"action\": \"change\",\n            \"values\": {\n                \"transient\": transient,\n                \"hue\": protocol_color.hue,\n                \"saturation\": protocol_color.saturation,\n                \"brightness\": protocol_color.brightness,\n                \"kelvin\": protocol_color.kelvin,\n                \"period\": period_ms,\n                \"cycles\": cycles,\n                \"skew_ratio\": skew_ratio_i16,\n                \"waveform\": waveform.value,\n            },\n        }\n    )\n\n    # Schedule refresh to update state\n    if self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.set_waveform_optional","title":"set_waveform_optional  <code>async</code>","text":"<pre><code>set_waveform_optional(\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n    set_hue: bool = True,\n    set_saturation: bool = True,\n    set_brightness: bool = True,\n    set_kelvin: bool = True,\n) -&gt; None\n</code></pre> <p>Apply a waveform effect with selective color component control.</p> <p>Similar to set_waveform() but allows fine-grained control over which color components (hue, saturation, brightness, kelvin) are affected by the waveform. This enables effects like pulsing brightness while keeping hue constant, or cycling hue while maintaining brightness.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color for the waveform</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one cycle in seconds</p> <p> TYPE: <code>float</code> </p> <code>cycles</code> <p>Number of cycles</p> <p> TYPE: <code>float</code> </p> <code>waveform</code> <p>Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)</p> <p> TYPE: <code>LightWaveform</code> </p> <code>transient</code> <p>If True, return to original color after effect (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>skew_ratio</code> <p>Waveform skew (0.0-1.0, default 0.5 for symmetric)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>set_hue</code> <p>Apply waveform to hue component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>set_saturation</code> <p>Apply waveform to saturation component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>set_brightness</code> <p>Apply waveform to brightness component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>set_kelvin</code> <p>Apply waveform to kelvin component (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If parameters are out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>from lifx.protocol.protocol_types import LightWaveform\n\n# Pulse brightness only, keeping hue/saturation constant\nawait light.set_waveform_optional(\n    color=HSBK(0, 1.0, 1.0, 3500),\n    period=1.0,\n    cycles=5,\n    waveform=LightWaveform.SINE,\n    set_hue=False,\n    set_saturation=False,\n    set_brightness=True,\n    set_kelvin=False,\n)\n\n# Cycle hue while maintaining brightness\nawait light.set_waveform_optional(\n    color=HSBK(180, 1.0, 1.0, 3500),\n    period=5.0,\n    cycles=0,  # Infinite\n    waveform=LightWaveform.SAW,\n    set_hue=True,\n    set_saturation=False,\n    set_brightness=False,\n    set_kelvin=False,\n)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def set_waveform_optional(\n    self,\n    color: HSBK,\n    period: float,\n    cycles: float,\n    waveform: LightWaveform,\n    transient: bool = True,\n    skew_ratio: float = 0.5,\n    set_hue: bool = True,\n    set_saturation: bool = True,\n    set_brightness: bool = True,\n    set_kelvin: bool = True,\n) -&gt; None:\n    \"\"\"Apply a waveform effect with selective color component control.\n\n    Similar to set_waveform() but allows fine-grained control over which\n    color components (hue, saturation, brightness, kelvin) are affected\n    by the waveform. This enables effects like pulsing brightness while\n    keeping hue constant, or cycling hue while maintaining brightness.\n\n    Args:\n        color: Target color for the waveform\n        period: Period of one cycle in seconds\n        cycles: Number of cycles\n        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)\n        transient: If True, return to original color after effect (default True)\n        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)\n        set_hue: Apply waveform to hue component (default True)\n        set_saturation: Apply waveform to saturation component (default True)\n        set_brightness: Apply waveform to brightness component (default True)\n        set_kelvin: Apply waveform to kelvin component (default True)\n\n    Raises:\n        ValueError: If parameters are out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        from lifx.protocol.protocol_types import LightWaveform\n\n        # Pulse brightness only, keeping hue/saturation constant\n        await light.set_waveform_optional(\n            color=HSBK(0, 1.0, 1.0, 3500),\n            period=1.0,\n            cycles=5,\n            waveform=LightWaveform.SINE,\n            set_hue=False,\n            set_saturation=False,\n            set_brightness=True,\n            set_kelvin=False,\n        )\n\n        # Cycle hue while maintaining brightness\n        await light.set_waveform_optional(\n            color=HSBK(180, 1.0, 1.0, 3500),\n            period=5.0,\n            cycles=0,  # Infinite\n            waveform=LightWaveform.SAW,\n            set_hue=True,\n            set_saturation=False,\n            set_brightness=False,\n            set_kelvin=False,\n        )\n        ```\n    \"\"\"\n    if period &lt;= 0:\n        raise ValueError(f\"Period must be positive, got {period}\")\n    if cycles &lt; 0:\n        raise ValueError(f\"Cycles must be non-negative, got {cycles}\")\n    if not (0.0 &lt;= skew_ratio &lt;= 1.0):\n        raise ValueError(\n            f\"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}\"\n        )\n\n    # Convert to protocol values\n    protocol_color = color.to_protocol()\n    period_ms = int(period * 1000)\n    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range\n\n    # Send request\n    result = await self.connection.request(\n        packets.Light.SetWaveformOptional(\n            transient=bool(transient),\n            color=protocol_color,\n            period=period_ms,\n            cycles=cycles,\n            skew_ratio=skew_ratio_i16,\n            waveform=waveform,\n            set_hue=set_hue,\n            set_saturation=set_saturation,\n            set_brightness=set_brightness,\n            set_kelvin=set_kelvin,\n        ),\n    )\n    self._raise_if_unhandled(result)\n    _LOGGER.debug(\n        {\n            \"class\": \"Light\",\n            \"method\": \"set_waveform_optional\",\n            \"action\": \"change\",\n            \"values\": {\n                \"transient\": transient,\n                \"hue\": protocol_color.hue,\n                \"saturation\": protocol_color.saturation,\n                \"brightness\": protocol_color.brightness,\n                \"kelvin\": protocol_color.kelvin,\n                \"period\": period_ms,\n                \"cycles\": cycles,\n                \"skew_ratio\": skew_ratio_i16,\n                \"waveform\": waveform.value,\n                \"set_hue\": set_hue,\n                \"set_saturation\": set_saturation,\n                \"set_brightness\": set_brightness,\n                \"set_kelvin\": set_kelvin,\n            },\n        }\n    )\n\n    # Update state on acknowledgement (only if non-transient)\n    if result and not transient and self._state is not None:\n        # Create a new color with only the specified components updated\n        current = self._state.color\n        new_color = HSBK(\n            hue=color.hue if set_hue else current.hue,\n            saturation=color.saturation if set_saturation else current.saturation,\n            brightness=color.brightness if set_brightness else current.brightness,\n            kelvin=color.kelvin if set_kelvin else current.kelvin,\n        )\n        self._state.color = new_color\n\n    # Schedule refresh to validate state\n    if self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.pulse","title":"pulse  <code>async</code>","text":"<pre><code>pulse(\n    color: HSBK, period: float = 1.0, cycles: float = 1, transient: bool = True\n) -&gt; None\n</code></pre> <p>Pulse the light to a specific color.</p> <p>Convenience method for creating a pulse effect using SINE waveform.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color to pulse to</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one pulse in seconds (default 1.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>cycles</code> <p>Number of pulses (default 1)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>transient</code> <p>If True, return to original color after effect (default True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Example <pre><code># Pulse red once\nawait light.pulse(HSBK.from_rgb(255, 0, 0))\n\n# Pulse blue 3 times, 2 seconds per pulse\nawait light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def pulse(\n    self,\n    color: HSBK,\n    period: float = 1.0,\n    cycles: float = 1,\n    transient: bool = True,\n) -&gt; None:\n    \"\"\"Pulse the light to a specific color.\n\n    Convenience method for creating a pulse effect using SINE waveform.\n\n    Args:\n        color: Target color to pulse to\n        period: Period of one pulse in seconds (default 1.0)\n        cycles: Number of pulses (default 1)\n        transient: If True, return to original color after effect (default True)\n\n    Example:\n        ```python\n        # Pulse red once\n        await light.pulse(HSBK.from_rgb(255, 0, 0))\n\n        # Pulse blue 3 times, 2 seconds per pulse\n        await light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)\n        ```\n    \"\"\"\n    await self.set_waveform(\n        color=color,\n        period=period,\n        cycles=cycles,\n        waveform=LightWaveform.PULSE,\n        transient=transient,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.breathe","title":"breathe  <code>async</code>","text":"<pre><code>breathe(color: HSBK, period: float = 2.0, cycles: float = 1) -&gt; None\n</code></pre> <p>Make the light breathe to a specific color.</p> <p>Convenience method for creating a breathing effect using SINE waveform.</p> PARAMETER DESCRIPTION <code>color</code> <p>Target color to breathe to</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one breath in seconds (default 2.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>cycles</code> <p>Number of breaths (default 1)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> Example <pre><code># Breathe white once\nawait light.breathe(HSBK(0, 0, 1.0, 3500))\n\n# Breathe purple 10 times\nawait light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def breathe(\n    self,\n    color: HSBK,\n    period: float = 2.0,\n    cycles: float = 1,\n) -&gt; None:\n    \"\"\"Make the light breathe to a specific color.\n\n    Convenience method for creating a breathing effect using SINE waveform.\n\n    Args:\n        color: Target color to breathe to\n        period: Period of one breath in seconds (default 2.0)\n        cycles: Number of breaths (default 1)\n\n    Example:\n        ```python\n        # Breathe white once\n        await light.breathe(HSBK(0, 0, 1.0, 3500))\n\n        # Breathe purple 10 times\n        await light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)\n        ```\n    \"\"\"\n    await self.set_waveform(\n        color=color,\n        period=period,\n        cycles=cycles,\n        waveform=LightWaveform.SINE,\n        transient=True,\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.apply_theme","title":"apply_theme  <code>async</code>","text":"<pre><code>apply_theme(\n    theme: Theme, power_on: bool = False, duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Apply a theme to this light.</p> <p>Selects a random color from the theme and applies it to the light.</p> PARAMETER DESCRIPTION <code>theme</code> <p>Theme to apply</p> <p> TYPE: <code>Theme</code> </p> <code>power_on</code> <p>Turn on the light</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>duration</code> <p>Transition duration in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>from lifx.theme import get_theme\n\ntheme = get_theme(\"evening\")\nawait light.apply_theme(theme, power_on=True, duration=0.5)\n</code></pre> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def apply_theme(\n    self,\n    theme: Theme,\n    power_on: bool = False,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Apply a theme to this light.\n\n    Selects a random color from the theme and applies it to the light.\n\n    Args:\n        theme: Theme to apply\n        power_on: Turn on the light\n        duration: Transition duration in seconds\n\n    Example:\n        ```python\n        from lifx.theme import get_theme\n\n        theme = get_theme(\"evening\")\n        await light.apply_theme(theme, power_on=True, duration=0.5)\n        ```\n    \"\"\"\n    if self.capabilities is None:\n        await self._ensure_capabilities()\n\n    if self.capabilities and not self.capabilities.has_color:\n        return\n\n    # Select a random color from theme\n    color = theme.random()\n\n    # Check if light is on\n    is_on = await self.get_power()\n\n    # Apply color to light\n    # If light is off and we're turning it on, set color immediately then fade on\n    if power_on and not is_on:\n        await self.set_color(color, duration=0)\n        await self.set_power(True, duration=duration)\n    else:\n        # Light is already on, or we're not turning it on - apply with duration\n        await self.set_color(color, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.light.Light.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh light state from hardware.</p> <p>Fetches color (which includes power and label) and updates state.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/light.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh light state from hardware.\n\n    Fetches color (which includes power and label) and updates state.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    import time\n\n    if self._state is None:\n        await self._initialize_state()\n        return\n\n    # GetColor returns color, power, and label in one request\n    color, power, label = await self.get_color()\n\n    self._state.color = color\n    self._state.power = power\n    self._state.label = label\n    self._state.last_updated = time.time()\n</code></pre>"},{"location":"api/devices/#lightstate","title":"LightState","text":"<p>Light device state dataclass returned by <code>Light.state</code>.</p>"},{"location":"api/devices/#lifx.devices.light.LightState","title":"LightState  <code>dataclass</code>","text":"<pre><code>LightState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n    color: HSBK,\n)\n</code></pre> <p>               Bases: <code>DeviceState</code></p> <p>Light device state with color control.</p> ATTRIBUTE DESCRIPTION <code>color</code> <p>Current HSBK color</p> <p> TYPE: <code>HSBK</code> </p>"},{"location":"api/devices/#lifx.devices.light.LightState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.light.LightState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return LightState as a dict.</p>"},{"location":"api/devices/#hev-light","title":"HEV Light","text":"<p>The <code>HevLight</code> class extends <code>Light</code> with anti-bacterial cleaning cycle control for LIFX HEV devices.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight","title":"HevLight","text":"<pre><code>HevLight(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX HEV light with anti-bacterial cleaning capabilities.</p> <p>Extends the Light class with HEV (High Energy Visible) cycle control. HEV uses UV-C light to sanitize surfaces and air with anti-bacterial properties.</p> Example <pre><code>light = HevLight(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Start a 2-hour cleaning cycle\n    await light.set_hev_cycle(enable=True, duration_seconds=7200)\n\n    # Check cycle status\n    state = await light.get_hev_cycle()\n    if state.is_running:\n        print(f\"Cleaning: {state.remaining_s}s remaining\")\n\n    # Configure defaults\n    await light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await HevLight.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_hev_cycle(enable=True, duration_seconds=3600)\n</code></pre></p> METHOD DESCRIPTION <code>get_hev_cycle</code> <p>Get current HEV cycle state.</p> <code>set_hev_cycle</code> <p>Start or stop a HEV cleaning cycle.</p> <code>get_hev_config</code> <p>Get HEV cycle configuration.</p> <code>set_hev_config</code> <p>Configure HEV cycle defaults.</p> <code>get_last_hev_result</code> <p>Get result of the last HEV cleaning cycle.</p> <code>refresh_state</code> <p>Refresh HEV light state from hardware.</p> ATTRIBUTE DESCRIPTION <code>state</code> <p>Get HEV light state (guaranteed when using Device.connect()).</p> <p> TYPE: <code>HevLightState</code> </p> <code>hev_config</code> <p>Get cached HEV configuration if available.</p> <p> TYPE: <code>HevConfig | None</code> </p> <code>hev_result</code> <p>Get cached last HEV cycle result if available.</p> <p> TYPE: <code>LightLastHevCycleResult | None</code> </p> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Initialize HevLight with additional state attributes.\"\"\"\n    super().__init__(*args, **kwargs)\n    # HEV-specific state storage\n    self._hev_config: HevConfig | None = None\n    self._hev_result: LightLastHevCycleResult | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.hev.HevLight.state","title":"state  <code>property</code>","text":"<pre><code>state: HevLightState\n</code></pre> <p>Get HEV light state (guaranteed when using Device.connect()).</p> RETURNS DESCRIPTION <code>HevLightState</code> <p>HevLightState with current HEV light state</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If accessed before state initialization</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight.hev_config","title":"hev_config  <code>property</code>","text":"<pre><code>hev_config: HevConfig | None\n</code></pre> <p>Get cached HEV configuration if available.</p> RETURNS DESCRIPTION <code>HevConfig | None</code> <p>Config or None if never fetched.</p> <code>HevConfig | None</code> <p>Use get_hev_config() to fetch from device.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight.hev_result","title":"hev_result  <code>property</code>","text":"<pre><code>hev_result: LightLastHevCycleResult | None\n</code></pre> <p>Get cached last HEV cycle result if available.</p> RETURNS DESCRIPTION <code>LightLastHevCycleResult | None</code> <p>Result or None if never fetched.</p> <code>LightLastHevCycleResult | None</code> <p>Use get_last_hev_result() to fetch from device.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.hev.HevLight.get_hev_cycle","title":"get_hev_cycle  <code>async</code>","text":"<pre><code>get_hev_cycle() -&gt; HevCycleState\n</code></pre> <p>Get current HEV cycle state.</p> <p>Always fetches from device. Use the <code>hev_cycle</code> property to access stored value.</p> RETURNS DESCRIPTION <code>HevCycleState</code> <p>HevCycleState with duration, remaining time, and last power state</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>state = await light.get_hev_cycle()\nif state.is_running:\n    print(f\"HEV cleaning in progress: {state.remaining_s}s left\")\nelse:\n    print(\"No active cleaning cycle\")\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def get_hev_cycle(self) -&gt; HevCycleState:\n    \"\"\"Get current HEV cycle state.\n\n    Always fetches from device. Use the `hev_cycle` property to access stored value.\n\n    Returns:\n        HevCycleState with duration, remaining time, and last power state\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        state = await light.get_hev_cycle()\n        if state.is_running:\n            print(f\"HEV cleaning in progress: {state.remaining_s}s left\")\n        else:\n            print(\"No active cleaning cycle\")\n        ```\n    \"\"\"\n    # Request HEV cycle state\n    state = await self.connection.request(packets.Light.GetHevCycle())\n    self._raise_if_unhandled(state)\n\n    # Create state object\n    cycle_state = HevCycleState(\n        duration_s=state.duration_s,\n        remaining_s=state.remaining_s,\n        last_power=state.last_power,\n    )\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"hev_cycle\"):\n        self._state.hev_cycle = cycle_state\n        self._state.last_updated = __import__(\"time\").time()\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"hev_cycle\"):\n        self._state.hev_cycle = cycle_state\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_hev_cycle\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"duration_s\": state.duration_s,\n                \"remaining_s\": state.remaining_s,\n                \"last_power\": state.last_power,\n            },\n        }\n    )\n\n    return cycle_state\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.set_hev_cycle","title":"set_hev_cycle  <code>async</code>","text":"<pre><code>set_hev_cycle(enable: bool, duration_seconds: int) -&gt; None\n</code></pre> <p>Start or stop a HEV cleaning cycle.</p> PARAMETER DESCRIPTION <code>enable</code> <p>True to start cycle, False to stop</p> <p> TYPE: <code>bool</code> </p> <code>duration_seconds</code> <p>Duration of the cleaning cycle in seconds</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If duration is negative</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Start a 1-hour cleaning cycle\nawait light.set_hev_cycle(enable=True, duration_seconds=3600)\n\n# Stop the current cycle\nawait light.set_hev_cycle(enable=False, duration_seconds=0)\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def set_hev_cycle(self, enable: bool, duration_seconds: int) -&gt; None:\n    \"\"\"Start or stop a HEV cleaning cycle.\n\n    Args:\n        enable: True to start cycle, False to stop\n        duration_seconds: Duration of the cleaning cycle in seconds\n\n    Raises:\n        ValueError: If duration is negative\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Start a 1-hour cleaning cycle\n        await light.set_hev_cycle(enable=True, duration_seconds=3600)\n\n        # Stop the current cycle\n        await light.set_hev_cycle(enable=False, duration_seconds=0)\n        ```\n    \"\"\"\n    if duration_seconds &lt; 0:\n        raise ValueError(f\"Duration must be non-negative, got {duration_seconds}\")\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Light.SetHevCycle(\n            enable=enable,\n            duration_s=duration_seconds,\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"HevLight\",\n            \"method\": \"set_hev_cycle\",\n            \"action\": \"change\",\n            \"values\": {\"enable\": enable, \"duration_s\": duration_seconds},\n        }\n    )\n\n    # Schedule debounced refresh to update HEV cycle state\n    # (No optimistic update - cycle state is complex)\n    if self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.get_hev_config","title":"get_hev_config  <code>async</code>","text":"<pre><code>get_hev_config() -&gt; HevConfig\n</code></pre> <p>Get HEV cycle configuration.</p> RETURNS DESCRIPTION <code>HevConfig</code> <p>HevConfig with indication and default duration settings</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>config = await light.get_hev_config()\nprint(f\"Default duration: {config.duration_s}s\")\nprint(f\"Visual indication: {config.indication}\")\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def get_hev_config(self) -&gt; HevConfig:\n    \"\"\"Get HEV cycle configuration.\n\n    Returns:\n        HevConfig with indication and default duration settings\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        config = await light.get_hev_config()\n        print(f\"Default duration: {config.duration_s}s\")\n        print(f\"Visual indication: {config.indication}\")\n        ```\n    \"\"\"\n    # Request HEV configuration\n    state = await self.connection.request(packets.Light.GetHevCycleConfiguration())\n    self._raise_if_unhandled(state)\n\n    # Create config object\n    config = HevConfig(\n        indication=state.indication,\n        duration_s=state.duration_s,\n    )\n\n    # Store cached state\n    self._hev_config = config\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"hev_config\"):\n        self._state.hev_config = config\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_hev_config\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"indication\": state.indication,\n                \"duration_s\": state.duration_s,\n            },\n        }\n    )\n\n    return config\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.set_hev_config","title":"set_hev_config  <code>async</code>","text":"<pre><code>set_hev_config(indication: bool, duration_seconds: int) -&gt; None\n</code></pre> <p>Configure HEV cycle defaults.</p> PARAMETER DESCRIPTION <code>indication</code> <p>Whether to show visual indication during cleaning</p> <p> TYPE: <code>bool</code> </p> <code>duration_seconds</code> <p>Default duration for cleaning cycles in seconds</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If duration is negative</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Configure 2-hour default with visual indication\nawait light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def set_hev_config(self, indication: bool, duration_seconds: int) -&gt; None:\n    \"\"\"Configure HEV cycle defaults.\n\n    Args:\n        indication: Whether to show visual indication during cleaning\n        duration_seconds: Default duration for cleaning cycles in seconds\n\n    Raises:\n        ValueError: If duration is negative\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Configure 2-hour default with visual indication\n        await light.set_hev_config(indication=True, duration_seconds=7200)\n        ```\n    \"\"\"\n    if duration_seconds &lt; 0:\n        raise ValueError(f\"Duration must be non-negative, got {duration_seconds}\")\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Light.SetHevCycleConfiguration(\n            indication=indication,\n            duration_s=duration_seconds,\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"HevLight\",\n            \"method\": \"set_hev_config\",\n            \"action\": \"change\",\n            \"values\": {\"indication\": indication, \"duration_s\": duration_seconds},\n        }\n    )\n\n    # Update cache and state on acknowledgement\n    if result:\n        hev_config = HevConfig(indication=indication, duration_s=duration_seconds)\n        self._hev_config = hev_config\n        if self._state is not None:\n            self._state.hev_config = hev_config\n\n    # Schedule refresh to validate state\n    if self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.get_last_hev_result","title":"get_last_hev_result  <code>async</code>","text":"<pre><code>get_last_hev_result() -&gt; LightLastHevCycleResult\n</code></pre> <p>Get result of the last HEV cleaning cycle.</p> RETURNS DESCRIPTION <code>LightLastHevCycleResult</code> <p>LightLastHevCycleResult enum value indicating success or interruption reason</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>result = await light.get_last_hev_result()\nif result == LightLastHevCycleResult.SUCCESS:\n    print(\"Last cleaning cycle completed successfully\")\nelif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:\n    print(\"Cycle was interrupted by network command\")\n</code></pre> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def get_last_hev_result(\n    self,\n) -&gt; LightLastHevCycleResult:\n    \"\"\"Get result of the last HEV cleaning cycle.\n\n    Returns:\n        LightLastHevCycleResult enum value indicating success or interruption reason\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        result = await light.get_last_hev_result()\n        if result == LightLastHevCycleResult.SUCCESS:\n            print(\"Last cleaning cycle completed successfully\")\n        elif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:\n            print(\"Cycle was interrupted by network command\")\n        ```\n    \"\"\"\n    # Request last HEV result\n    state = await self.connection.request(packets.Light.GetLastHevCycleResult())\n    self._raise_if_unhandled(state)\n\n    # Store cached state\n    result = state.result\n    self._hev_result = result\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"hev_result\"):\n        self._state.hev_result = result\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_last_hev_result\",\n            \"action\": \"query\",\n            \"reply\": {\"result\": result.value},\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.hev.HevLight.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh HEV light state from hardware.</p> <p>Fetches color, HEV cycle, config, and last result.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh HEV light state from hardware.\n\n    Fetches color, HEV cycle, config, and last result.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    await super().refresh_state()\n\n    # Fetch all HEV light state\n    async with asyncio.TaskGroup() as tg:\n        hev_cycle_task = tg.create_task(self.get_hev_cycle())\n        hev_result_task = tg.create_task(self.get_last_hev_result())\n\n    hev_cycle = hev_cycle_task.result()\n    hev_result = hev_result_task.result()\n\n    self._state.hev_cycle = hev_cycle\n    self._state.hev_result = hev_result\n</code></pre>"},{"location":"api/devices/#hevlightstate","title":"HevLightState","text":"<p>HEV light device state dataclass returned by <code>HevLight.state</code>.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLightState","title":"HevLightState  <code>dataclass</code>","text":"<pre><code>HevLightState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n    color: HSBK,\n    hev_cycle: HevCycleState,\n    hev_config: HevConfig,\n    hev_result: LightLastHevCycleResult,\n)\n</code></pre> <p>               Bases: <code>LightState</code></p> <p>HEV light device state with anti-bacterial capabilities.</p> ATTRIBUTE DESCRIPTION <code>hev_cycle</code> <p>Current HEV cycle state</p> <p> TYPE: <code>HevCycleState</code> </p> <code>hev_config</code> <p>Default HEV configuration</p> <p> TYPE: <code>HevConfig</code> </p> <code>hev_result</code> <p>Last HEV cycle result</p> <p> TYPE: <code>LightLastHevCycleResult</code> </p> METHOD DESCRIPTION <code>from_light_state</code> <p>Create HevLightState from LightState.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLightState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.hev.HevLightState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return HevLightState as dict.</p>"},{"location":"api/devices/#lifx.devices.hev.HevLightState-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.hev.HevLightState.from_light_state","title":"from_light_state  <code>classmethod</code>","text":"<pre><code>from_light_state(\n    light_state: LightState,\n    hev_cycle: HevCycleState,\n    hev_config: HevConfig,\n    hev_result: LightLastHevCycleResult,\n) -&gt; HevLightState\n</code></pre> <p>Create HevLightState from LightState.</p> Source code in <code>src/lifx/devices/hev.py</code> <pre><code>@classmethod\ndef from_light_state(\n    cls,\n    light_state: LightState,\n    hev_cycle: HevCycleState,\n    hev_config: HevConfig,\n    hev_result: LightLastHevCycleResult,\n) -&gt; HevLightState:\n    \"\"\"Create HevLightState from LightState.\"\"\"\n    return cls(\n        model=light_state.model,\n        label=light_state.label,\n        serial=light_state.serial,\n        mac_address=light_state.mac_address,\n        power=light_state.power,\n        capabilities=light_state.capabilities,\n        host_firmware=light_state.host_firmware,\n        wifi_firmware=light_state.wifi_firmware,\n        location=light_state.location,\n        group=light_state.group,\n        color=light_state.color,\n        hev_config=hev_config,\n        hev_cycle=hev_cycle,\n        hev_result=hev_result,\n        last_updated=time.time(),\n    )\n</code></pre>"},{"location":"api/devices/#infrared-light","title":"Infrared Light","text":"<p>The <code>InfraredLight</code> class extends <code>Light</code> with infrared LED control for night vision on LIFX A19 + Night Vision devices.</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight","title":"InfraredLight","text":"<pre><code>InfraredLight(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX infrared light with IR LED control.</p> <p>Extends the Light class with infrared brightness control. Infrared LEDs automatically activate in low-light conditions to provide illumination for night vision cameras.</p> Example <pre><code>light = InfraredLight(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Set infrared brightness to 50%\n    await light.set_infrared(0.5)\n\n    # Get current infrared brightness\n    brightness = await light.get_infrared()\n    print(f\"IR brightness: {brightness * 100}%\")\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await InfraredLight.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_infrared(0.8)\n</code></pre></p> METHOD DESCRIPTION <code>get_infrared</code> <p>Get current infrared brightness.</p> <code>set_infrared</code> <p>Set infrared brightness.</p> <code>refresh_state</code> <p>Refresh infrared light state from hardware.</p> ATTRIBUTE DESCRIPTION <code>state</code> <p>Get infrared light state (guaranteed when using Device.connect()).</p> <p> TYPE: <code>InfraredLightState</code> </p> <code>infrared</code> <p>Get cached infrared brightness if available.</p> <p> TYPE: <code>float | None</code> </p> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Initialize InfraredLight with additional state attributes.\"\"\"\n    super().__init__(*args, **kwargs)\n    # Infrared-specific state storage\n    self._infrared: float | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.state","title":"state  <code>property</code>","text":"<pre><code>state: InfraredLightState\n</code></pre> <p>Get infrared light state (guaranteed when using Device.connect()).</p> RETURNS DESCRIPTION <code>InfraredLightState</code> <p>InfraredLightState with current infrared light state</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If accessed before state initialization</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.infrared","title":"infrared  <code>property</code>","text":"<pre><code>infrared: float | None\n</code></pre> <p>Get cached infrared brightness if available.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Brightness (0.0-1.0) or None if never fetched.</p> <code>float | None</code> <p>Use get_infrared() to fetch from device.</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.get_infrared","title":"get_infrared  <code>async</code>","text":"<pre><code>get_infrared() -&gt; float\n</code></pre> <p>Get current infrared brightness.</p> RETURNS DESCRIPTION <code>float</code> <p>Infrared brightness (0.0-1.0)</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>brightness = await light.get_infrared()\nif brightness &gt; 0:\n    print(f\"IR LEDs active at {brightness * 100}%\")\n</code></pre> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>async def get_infrared(self) -&gt; float:\n    \"\"\"Get current infrared brightness.\n\n    Returns:\n        Infrared brightness (0.0-1.0)\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        brightness = await light.get_infrared()\n        if brightness &gt; 0:\n            print(f\"IR LEDs active at {brightness * 100}%\")\n        ```\n    \"\"\"\n    # Request infrared state\n    state = await self.connection.request(packets.Light.GetInfrared())\n    self._raise_if_unhandled(state)\n\n    # Convert from uint16 (0-65535) to float (0.0-1.0)\n    brightness = state.brightness / 65535.0\n\n    # Store cached state\n    self._infrared = brightness\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"infrared\"):\n        self._state.infrared = brightness\n        self._state.last_updated = __import__(\"time\").time()\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"infrared\"):\n        self._state.infrared = brightness\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_infrared\",\n            \"action\": \"query\",\n            \"reply\": {\"brightness\": state.brightness},\n        }\n    )\n\n    return brightness\n</code></pre>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.set_infrared","title":"set_infrared  <code>async</code>","text":"<pre><code>set_infrared(brightness: float) -&gt; None\n</code></pre> <p>Set infrared brightness.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>Infrared brightness (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If brightness is out of range</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Set to 75% infrared brightness\nawait light.set_infrared(0.75)\n\n# Turn off infrared\nawait light.set_infrared(0.0)\n</code></pre> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>async def set_infrared(self, brightness: float) -&gt; None:\n    \"\"\"Set infrared brightness.\n\n    Args:\n        brightness: Infrared brightness (0.0-1.0)\n\n    Raises:\n        ValueError: If brightness is out of range\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Set to 75% infrared brightness\n        await light.set_infrared(0.75)\n\n        # Turn off infrared\n        await light.set_infrared(0.0)\n        ```\n    \"\"\"\n    if not (0.0 &lt;= brightness &lt;= 1.0):\n        raise ValueError(\n            f\"Brightness must be between 0.0 and 1.0, got {brightness}\"\n        )\n\n    # Convert from float (0.0-1.0) to uint16 (0-65535)\n    brightness_u16 = max(0, min(65535, int(round(brightness * 65535))))\n\n    # Request automatically handles acknowledgement\n    result = await self.connection.request(\n        packets.Light.SetInfrared(brightness=brightness_u16),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"InfraredLight\",\n            \"method\": \"set_infrared\",\n            \"action\": \"change\",\n            \"values\": {\"brightness\": brightness_u16},\n        }\n    )\n\n    # Update cache and state on acknowledgement\n    if result:\n        self._infrared = brightness\n        if self._state is not None:\n            self._state.infrared = brightness\n\n    # Schedule refresh to validate state\n    if self._state is not None:\n        await self._schedule_refresh()\n</code></pre>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLight.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh infrared light state from hardware.</p> <p>Fetches color and infrared brightness.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh infrared light state from hardware.\n\n    Fetches color and infrared brightness.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    await super().refresh_state()\n\n    infrared = await self.get_infrared()\n    self._state.infrared = infrared\n</code></pre>"},{"location":"api/devices/#infraredlightstate","title":"InfraredLightState","text":"<p>Infrared light device state dataclass returned by <code>InfraredLight.state</code>.</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLightState","title":"InfraredLightState  <code>dataclass</code>","text":"<pre><code>InfraredLightState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n    color: HSBK,\n    infrared: float,\n)\n</code></pre> <p>               Bases: <code>LightState</code></p> <p>Infrared light device state with IR control.</p> ATTRIBUTE DESCRIPTION <code>infrared</code> <p>Infrared brightness (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> METHOD DESCRIPTION <code>from_light_state</code> <p>Create InfraredLightState from LightState.</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLightState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.infrared.InfraredLightState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return InfraredLightState as dict.</p>"},{"location":"api/devices/#lifx.devices.infrared.InfraredLightState-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.infrared.InfraredLightState.from_light_state","title":"from_light_state  <code>classmethod</code>","text":"<pre><code>from_light_state(\n    light_state: LightState, infrared: float\n) -&gt; InfraredLightState\n</code></pre> <p>Create InfraredLightState from LightState.</p> Source code in <code>src/lifx/devices/infrared.py</code> <pre><code>@classmethod\ndef from_light_state(\n    cls, light_state: LightState, infrared: float\n) -&gt; InfraredLightState:\n    \"\"\"Create InfraredLightState from LightState.\"\"\"\n    return cls(\n        model=light_state.model,\n        label=light_state.label,\n        serial=light_state.serial,\n        mac_address=light_state.mac_address,\n        power=light_state.power,\n        capabilities=light_state.capabilities,\n        host_firmware=light_state.host_firmware,\n        wifi_firmware=light_state.wifi_firmware,\n        location=light_state.location,\n        group=light_state.group,\n        color=light_state.color,\n        infrared=infrared,\n        last_updated=time.time(),\n    )\n</code></pre>"},{"location":"api/devices/#multizone-light","title":"MultiZone Light","text":"<p>The <code>MultiZoneLight</code> class controls LIFX strips and beams with multiple color zones.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight","title":"MultiZoneLight","text":"<pre><code>MultiZoneLight(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX MultiZone light device (strips, beams).</p> <p>Extends the Light class with zone-specific functionality: - Individual zone color control - Multi-zone effects (move, etc.) - Extended color zone support for efficient bulk updates</p> Example <pre><code>light = MultiZoneLight(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\nasync with light:\n    # Get number of zones\n    zone_count = await light.get_zone_count()\n    print(f\"Device has {zone_count} zones\")\n\n    # Set all zones to red\n    await light.set_color_zones(\n        start=0, end=zone_count - 1, color=HSBK.from_rgb(255, 0, 0)\n    )\n\n    # Get colors for first 5 zones\n    colors = await light.get_color_zones(0, 4)\n\n    # Apply a moving effect\n    await light.set_move_effect(speed=5.0, direction=\"forward\")\n</code></pre> <p>Using the simplified connect method: <pre><code>async with await MultiZoneLight.from_ip(ip=\"192.168.1.100\") as light:\n    await light.set_move_effect(speed=5.0, direction=\"forward\")\n</code></pre></p> METHOD DESCRIPTION <code>get_zone_count</code> <p>Get the number of zones in the device.</p> <code>get_color_zones</code> <p>Get colors for a range of zones using GetColorZones.</p> <code>get_extended_color_zones</code> <p>Get colors for a range of zones using GetExtendedColorZones.</p> <code>get_all_color_zones</code> <p>Get colors for all zones, automatically using the best method.</p> <code>set_color_zones</code> <p>Set color for a range of zones.</p> <code>set_extended_color_zones</code> <p>Set colors for multiple zones efficiently (up to 82 zones per call).</p> <code>get_effect</code> <p>Get current multizone effect.</p> <code>set_effect</code> <p>Set multizone effect.</p> <code>stop_effect</code> <p>Stop any running multizone effect.</p> <code>apply_theme</code> <p>Apply a theme across zones.</p> <code>refresh_state</code> <p>Refresh multizone light state from hardware.</p> ATTRIBUTE DESCRIPTION <code>state</code> <p>Get multizone light state (guaranteed when using Device.connect()).</p> <p> TYPE: <code>MultiZoneLightState</code> </p> <code>zone_count</code> <p>Get cached zone count if available.</p> <p> TYPE: <code>int | None</code> </p> <code>multizone_effect</code> <p>Get cached multizone effect if available.</p> <p> TYPE: <code>MultiZoneEffect | None | None</code> </p> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Initialize MultiZoneLight with additional state attributes.\"\"\"\n    super().__init__(*args, **kwargs)\n    # MultiZone-specific state storage\n    self._zone_count: int | None = None\n    self._multizone_effect: MultiZoneEffect | None | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.state","title":"state  <code>property</code>","text":"<pre><code>state: MultiZoneLightState\n</code></pre> <p>Get multizone light state (guaranteed when using Device.connect()).</p> RETURNS DESCRIPTION <code>MultiZoneLightState</code> <p>MultiZoneLightState with current multizone light state</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If accessed before state initialization</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.zone_count","title":"zone_count  <code>property</code>","text":"<pre><code>zone_count: int | None\n</code></pre> <p>Get cached zone count if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>Zone count or None if never fetched.</p> <code>int | None</code> <p>Use get_zone_count() to fetch from device.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.multizone_effect","title":"multizone_effect  <code>property</code>","text":"<pre><code>multizone_effect: MultiZoneEffect | None | None\n</code></pre> <p>Get cached multizone effect if available.</p> RETURNS DESCRIPTION <code>MultiZoneEffect | None | None</code> <p>Effect or None if never fetched.</p> <code>MultiZoneEffect | None | None</code> <p>Use get_effect() to fetch from device.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_zone_count","title":"get_zone_count  <code>async</code>","text":"<pre><code>get_zone_count() -&gt; int\n</code></pre> <p>Get the number of zones in the device.</p> <p>Always fetches from device. Use the <code>zone_count</code> property to access stored value.</p> RETURNS DESCRIPTION <code>int</code> <p>Number of zones</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>zone_count = await light.get_zone_count()\nprint(f\"Device has {zone_count} zones\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_zone_count(self) -&gt; int:\n    \"\"\"Get the number of zones in the device.\n\n    Always fetches from device.\n    Use the `zone_count` property to access stored value.\n\n    Returns:\n        Number of zones\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        zone_count = await light.get_zone_count()\n        print(f\"Device has {zone_count} zones\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    if self.capabilities and self.capabilities.has_extended_multizone:\n        state = await self.connection.request(\n            packets.MultiZone.GetExtendedColorZones()\n        )\n    else:\n        state = await self.connection.request(\n            packets.MultiZone.GetColorZones(start_index=0, end_index=0)\n        )\n    self._raise_if_unhandled(state)\n\n    count = state.count\n\n    self._zone_count = count\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_zone_count\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"count\": state.count,\n            },\n        }\n    )\n\n    return count\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_color_zones","title":"get_color_zones  <code>async</code>","text":"<pre><code>get_color_zones(start: int = 0, end: int = 255) -&gt; list[HSBK]\n</code></pre> <p>Get colors for a range of zones using GetColorZones.</p> <p>Always fetches from device. Use <code>zones</code> property to access stored values.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start zone index (inclusive, default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>end</code> <p>End zone index (inclusive, default 255)</p> <p> TYPE: <code>int</code> DEFAULT: <code>255</code> </p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors, one per zone</p> RAISES DESCRIPTION <code>ValueError</code> <p>If zone indices are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Get colors for all zones (default)\ncolors = await light.get_color_zones()\n\n# Get colors for first 10 zones\ncolors = await light.get_color_zones(0, 9)\nfor i, color in enumerate(colors):\n    print(f\"Zone {i}: {color}\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_color_zones(\n    self,\n    start: int = 0,\n    end: int = 255,\n) -&gt; list[HSBK]:\n    \"\"\"Get colors for a range of zones using GetColorZones.\n\n    Always fetches from device.\n    Use `zones` property to access stored values.\n\n    Args:\n        start: Start zone index (inclusive, default 0)\n        end: End zone index (inclusive, default 255)\n\n    Returns:\n        List of HSBK colors, one per zone\n\n    Raises:\n        ValueError: If zone indices are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Get colors for all zones (default)\n        colors = await light.get_color_zones()\n\n        # Get colors for first 10 zones\n        colors = await light.get_color_zones(0, 9)\n        for i, color in enumerate(colors):\n            print(f\"Zone {i}: {color}\")\n        ```\n    \"\"\"\n    if start &lt; 0 or end &lt; start:\n        raise ValueError(f\"Invalid zone range: {start}-{end}\")\n\n    # Ensure capabilities are loaded\n    if self.capabilities is None:\n        await self._ensure_capabilities()\n\n    zone_count = await self.get_zone_count()\n    end = min(zone_count - 1, end)\n\n    colors = []\n    current_start = start\n\n    while current_start &lt;= end:\n        current_end = min(current_start + 7, end)  # Max 8 zones per request\n\n        # Stream responses - break after first (single response per request)\n        async for state in self.connection.request_stream(\n            packets.MultiZone.GetColorZones(\n                start_index=current_start, end_index=current_end\n            )\n        ):\n            self._raise_if_unhandled(state)\n            # Extract colors from response (up to 8 colors)\n            zones_in_response = min(8, current_end - current_start + 1)\n            for i in range(zones_in_response):\n                if i &gt;= len(state.colors):\n                    break\n                protocol_hsbk = state.colors[i]\n                colors.append(HSBK.from_protocol(protocol_hsbk))\n            break  # Single response per request\n\n        current_start += 8\n\n    result = colors\n\n    # Update state if it exists and we fetched all zones\n    if self._state is not None and hasattr(self._state, \"zones\"):\n        if start == 0 and len(result) == zone_count:\n            self._state.zones = result\n            self._state.last_updated = __import__(\"time\").time()\n\n    # Update state if it exists and we fetched all zones\n    if self._state is not None and hasattr(self._state, \"zones\"):\n        if start == 0 and len(result) == zone_count:\n            self._state.zones = result\n            self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_color_zones\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"start\": start,\n                \"end\": end,\n                \"zone_count\": len(result),\n                \"colors\": [\n                    {\n                        \"hue\": c.hue,\n                        \"saturation\": c.saturation,\n                        \"brightness\": c.brightness,\n                        \"kelvin\": c.kelvin,\n                    }\n                    for c in result\n                ],\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_extended_color_zones","title":"get_extended_color_zones  <code>async</code>","text":"<pre><code>get_extended_color_zones(start: int = 0, end: int = 255) -&gt; list[HSBK]\n</code></pre> <p>Get colors for a range of zones using GetExtendedColorZones.</p> <p>Always fetches from device. Use <code>zones</code> property to access stored values.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start zone index (inclusive, default 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>end</code> <p>End zone index (inclusive, default 255)</p> <p> TYPE: <code>int</code> DEFAULT: <code>255</code> </p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors, one per zone</p> RAISES DESCRIPTION <code>ValueError</code> <p>If zone indices are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Get colors for all zones (default)\ncolors = await light.get_extended_color_zones()\n\n# Get colors for first 10 zones\ncolors = await light.get_extended_color_zones(0, 9)\nfor i, color in enumerate(colors):\n    print(f\"Zone {i}: {color}\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_extended_color_zones(\n    self, start: int = 0, end: int = 255\n) -&gt; list[HSBK]:\n    \"\"\"Get colors for a range of zones using GetExtendedColorZones.\n\n    Always fetches from device.\n    Use `zones` property to access stored values.\n\n    Args:\n        start: Start zone index (inclusive, default 0)\n        end: End zone index (inclusive, default 255)\n\n    Returns:\n        List of HSBK colors, one per zone\n\n    Raises:\n        ValueError: If zone indices are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Get colors for all zones (default)\n        colors = await light.get_extended_color_zones()\n\n        # Get colors for first 10 zones\n        colors = await light.get_extended_color_zones(0, 9)\n        for i, color in enumerate(colors):\n            print(f\"Zone {i}: {color}\")\n        ```\n    \"\"\"\n    if start &lt; 0 or end &lt; start:\n        raise ValueError(f\"Invalid zone range: {start}-{end}\")\n\n    zone_count = await self.get_zone_count()\n    end = min(zone_count - 1, end)\n\n    colors: list[HSBK] = []\n\n    # Stream all responses until timeout\n    async for packet in self.connection.request_stream(\n        packets.MultiZone.GetExtendedColorZones(),\n        timeout=2.0,  # Allow time for multiple responses\n    ):\n        self._raise_if_unhandled(packet)\n        # Only process valid colors based on colors_count\n        for i in range(packet.colors_count):\n            if i &gt;= len(packet.colors):\n                break\n            protocol_hsbk = packet.colors[i]\n            colors.append(HSBK.from_protocol(protocol_hsbk))\n\n        # Early exit if we have all zones\n        if len(colors) &gt;= zone_count:\n            break\n\n    # Return only the requested range to caller\n    result = colors[start : end + 1]\n\n    # Update state if it exists and we fetched all zones\n    if self._state is not None and hasattr(self._state, \"zones\"):\n        if start == 0 and len(result) == zone_count:\n            self._state.zones = result\n            self._state.last_updated = __import__(\"time\").time()\n\n    # Update state if it exists and we fetched all zones\n    if self._state is not None and hasattr(self._state, \"zones\"):\n        if start == 0 and len(result) == zone_count:\n            self._state.zones = result\n            self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_extended_color_zones\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"total_zones\": len(colors),\n                \"requested_start\": start,\n                \"requested_end\": end,\n                \"returned_count\": len(result),\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_all_color_zones","title":"get_all_color_zones  <code>async</code>","text":"<pre><code>get_all_color_zones() -&gt; list[HSBK]\n</code></pre> <p>Get colors for all zones, automatically using the best method.</p> <p>This method automatically chooses between get_extended_color_zones() and get_color_zones() based on device capabilities. Always returns all zones on the device.</p> <p>Always fetches from device.</p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors for all zones</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> Example <pre><code># Get all zones (automatically uses best method)\ncolors = await light.get_all_color_zones()\nprint(f\"Device has {len(colors)} zones\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_all_color_zones(self) -&gt; list[HSBK]:\n    \"\"\"Get colors for all zones, automatically using the best method.\n\n    This method automatically chooses between get_extended_color_zones()\n    and get_color_zones() based on device capabilities. Always returns\n    all zones on the device.\n\n    Always fetches from device.\n\n    Returns:\n        List of HSBK colors for all zones\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n\n    Example:\n        ```python\n        # Get all zones (automatically uses best method)\n        colors = await light.get_all_color_zones()\n        print(f\"Device has {len(colors)} zones\")\n        ```\n    \"\"\"\n    # Ensure capabilities are loaded\n    if self.capabilities is None:\n        await self._ensure_capabilities()\n\n    # Use extended multizone if available, otherwise fall back to standard\n    if self.capabilities and self.capabilities.has_extended_multizone:\n        return await self.get_extended_color_zones()\n    else:\n        return await self.get_color_zones()\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_color_zones","title":"set_color_zones  <code>async</code>","text":"<pre><code>set_color_zones(\n    start: int,\n    end: int,\n    color: HSBK,\n    duration: float = 0.0,\n    apply: MultiZoneApplicationRequest = APPLY,\n) -&gt; None\n</code></pre> <p>Set color for a range of zones.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>end</code> <p>End zone index (inclusive)</p> <p> TYPE: <code>int</code> </p> <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>apply</code> <p>Application mode (default APPLY)    - NO_APPLY: Don't apply immediately (use for batching)    - APPLY: Apply this change and any pending changes    - APPLY_ONLY: Apply only this change</p> <p> TYPE: <code>MultiZoneApplicationRequest</code> DEFAULT: <code>APPLY</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If zone indices are invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Set zones 0-9 to red\nawait light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))\n\n# Set with transition\nawait light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)\n\n# Batch updates\nawait light.set_color_zones(\n    0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY\n)\nawait light.set_color_zones(\n    5, 9, color2, apply=MultiZoneApplicationRequest.APPLY\n)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_color_zones(\n    self,\n    start: int,\n    end: int,\n    color: HSBK,\n    duration: float = 0.0,\n    apply: MultiZoneApplicationRequest = MultiZoneApplicationRequest.APPLY,\n) -&gt; None:\n    \"\"\"Set color for a range of zones.\n\n    Args:\n        start: Start zone index (inclusive)\n        end: End zone index (inclusive)\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n        apply: Application mode (default APPLY)\n               - NO_APPLY: Don't apply immediately (use for batching)\n               - APPLY: Apply this change and any pending changes\n               - APPLY_ONLY: Apply only this change\n\n    Raises:\n        ValueError: If zone indices are invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Set zones 0-9 to red\n        await light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))\n\n        # Set with transition\n        await light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)\n\n        # Batch updates\n        await light.set_color_zones(\n            0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY\n        )\n        await light.set_color_zones(\n            5, 9, color2, apply=MultiZoneApplicationRequest.APPLY\n        )\n        ```\n    \"\"\"\n    if start &lt; 0 or end &lt; start:\n        raise ValueError(\n            f\"Invalid zone range: {start}-{end}\"\n        )  # Convert to protocol HSBK\n    protocol_color = color.to_protocol()\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    # Send request\n    result = await self.connection.request(\n        packets.MultiZone.SetColorZones(\n            start_index=start,\n            end_index=end,\n            color=protocol_color,\n            duration=duration_ms,\n            apply=apply,\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_color_zones\",\n            \"action\": \"change\",\n            \"values\": {\n                \"start\": start,\n                \"end\": end,\n                \"color\": {\n                    \"hue\": color.hue,\n                    \"saturation\": color.saturation,\n                    \"brightness\": color.brightness,\n                    \"kelvin\": color.kelvin,\n                },\n                \"duration\": duration_ms,\n                \"apply\": apply.name,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_extended_color_zones","title":"set_extended_color_zones  <code>async</code>","text":"<pre><code>set_extended_color_zones(\n    zone_index: int,\n    colors: list[HSBK],\n    duration: float = 0.0,\n    apply: MultiZoneApplicationRequest = APPLY,\n    *,\n    fast: bool = False,\n) -&gt; None\n</code></pre> <p>Set colors for multiple zones efficiently (up to 82 zones per call).</p> <p>This is more efficient than set_color_zones when setting different colors for many zones at once.</p> PARAMETER DESCRIPTION <code>zone_index</code> <p>Starting zone index</p> <p> TYPE: <code>int</code> </p> <code>colors</code> <p>List of HSBK colors to set (max 82)</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>apply</code> <p>Application mode (default APPLY)</p> <p> TYPE: <code>MultiZoneApplicationRequest</code> DEFAULT: <code>APPLY</code> </p> <code>fast</code> <p>If True, send fire-and-forget without waiting for response.   Use for high-frequency animations (&gt;20 updates/second).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If colors list is too long or zone index is invalid</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond (only when fast=False)</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command (only when fast=False)</p> Example <pre><code># Create a rainbow effect across zones\ncolors = [\n    HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)\n    for i in range(10)\n]\nawait light.set_extended_color_zones(0, colors)\n\n# High-speed animation loop\nfor frame in animation_frames:\n    await light.set_extended_color_zones(0, frame, fast=True)\n    await asyncio.sleep(0.033)  # ~30 FPS\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_extended_color_zones(\n    self,\n    zone_index: int,\n    colors: list[HSBK],\n    duration: float = 0.0,\n    apply: ExtendedAppReq = ExtendedAppReq.APPLY,\n    *,\n    fast: bool = False,\n) -&gt; None:\n    \"\"\"Set colors for multiple zones efficiently (up to 82 zones per call).\n\n    This is more efficient than set_color_zones when setting different colors\n    for many zones at once.\n\n    Args:\n        zone_index: Starting zone index\n        colors: List of HSBK colors to set (max 82)\n        duration: Transition duration in seconds (default 0.0)\n        apply: Application mode (default APPLY)\n        fast: If True, send fire-and-forget without waiting for response.\n              Use for high-frequency animations (&gt;20 updates/second).\n\n    Raises:\n        ValueError: If colors list is too long or zone index is invalid\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond (only when fast=False)\n        LifxUnsupportedCommandError: If device doesn't support this command\n            (only when fast=False)\n\n    Example:\n        ```python\n        # Create a rainbow effect across zones\n        colors = [\n            HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)\n            for i in range(10)\n        ]\n        await light.set_extended_color_zones(0, colors)\n\n        # High-speed animation loop\n        for frame in animation_frames:\n            await light.set_extended_color_zones(0, frame, fast=True)\n            await asyncio.sleep(0.033)  # ~30 FPS\n        ```\n    \"\"\"\n    if zone_index &lt; 0:\n        raise ValueError(f\"Invalid zone index: {zone_index}\")\n    if len(colors) &gt; 82:\n        raise ValueError(f\"Too many colors: {len(colors)} (max 82 per request)\")\n    if len(colors) == 0:\n        raise ValueError(\"Colors list cannot be empty\")\n\n    # Convert to protocol HSBK\n    protocol_colors = [color.to_protocol() for color in colors]\n\n    # Pad to 82 colors if needed\n    while len(protocol_colors) &lt; 82:\n        protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())\n\n    # Convert duration to milliseconds\n    duration_ms = int(duration * 1000)\n\n    packet = packets.MultiZone.SetExtendedColorZones(\n        duration=duration_ms,\n        apply=apply,\n        index=zone_index,\n        colors_count=len(colors),\n        colors=protocol_colors,\n    )\n\n    if fast:\n        # Fire-and-forget: no ack, no response, no waiting\n        await self.connection.send_packet(\n            packet,\n            ack_required=False,\n            res_required=False,\n        )\n    else:\n        # Standard: wait for response and check for errors\n        result = await self.connection.request(packet)\n        self._raise_if_unhandled(result)\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_extended_color_zones\",\n            \"action\": \"change\",\n            \"values\": {\n                \"zone_index\": zone_index,\n                \"colors_count\": len(colors),\n                \"colors\": [\n                    {\n                        \"hue\": c.hue,\n                        \"saturation\": c.saturation,\n                        \"brightness\": c.brightness,\n                        \"kelvin\": c.kelvin,\n                    }\n                    for c in colors\n                ],\n                \"duration\": duration_ms,\n                \"apply\": apply.name,\n                \"fast\": fast,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.get_effect","title":"get_effect  <code>async</code>","text":"<pre><code>get_effect() -&gt; MultiZoneEffect\n</code></pre> <p>Get current multizone effect.</p> <p>Always fetches from device. Use the <code>multizone_effect</code> property to access stored value.</p> RETURNS DESCRIPTION <code>MultiZoneEffect</code> <p>MultiZoneEffect with either FirmwareEffect.OFF or FirmwareEffect.MOVE</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxProtocolError</code> <p>If response is invalid</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>from lifx.protocol.protocol_types import Direction, FirmwareEffect\n\neffect = await light.get_effect()\nif effect:\n    print(f\"Effect: {effect.effect_type.name}, Speed: {effect.speed}ms\")\n    if effect.effect_type == FirmwareEffect.MOVE:\n        print(f\"Direction: {effect.direction.name}\")\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def get_effect(self) -&gt; MultiZoneEffect:\n    \"\"\"Get current multizone effect.\n\n    Always fetches from device.\n    Use the `multizone_effect` property to access stored value.\n\n    Returns:\n        MultiZoneEffect with either FirmwareEffect.OFF or FirmwareEffect.MOVE\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxProtocolError: If response is invalid\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        from lifx.protocol.protocol_types import Direction, FirmwareEffect\n\n        effect = await light.get_effect()\n        if effect:\n            print(f\"Effect: {effect.effect_type.name}, Speed: {effect.speed}ms\")\n            if effect.effect_type == FirmwareEffect.MOVE:\n                print(f\"Direction: {effect.direction.name}\")\n        ```\n    \"\"\"\n    # Request automatically unpacks response\n    state = await self.connection.request(packets.MultiZone.GetEffect())\n    self._raise_if_unhandled(state)\n\n    settings = state.settings\n    effect_type = settings.effect_type\n\n    # Extract parameters from the settings parameter field\n    parameters = [\n        settings.parameter.parameter0,\n        settings.parameter.parameter1,\n        settings.parameter.parameter2,\n        settings.parameter.parameter3,\n        settings.parameter.parameter4,\n        settings.parameter.parameter5,\n        settings.parameter.parameter6,\n        settings.parameter.parameter7,\n    ]\n\n    result = MultiZoneEffect(\n        effect_type=effect_type,\n        speed=settings.speed,\n        duration=settings.duration,\n        parameters=parameters,\n    )\n\n    self._multizone_effect = result\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"effect\"):\n        self._state.effect = result.effect_type\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"get_effect\",\n            \"action\": \"query\",\n            \"reply\": {\n                \"effect_type\": effect_type.name,\n                \"speed\": settings.speed,\n                \"duration\": settings.duration,\n                \"parameters\": parameters,\n            },\n        }\n    )\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.set_effect","title":"set_effect  <code>async</code>","text":"<pre><code>set_effect(effect: MultiZoneEffect) -&gt; None\n</code></pre> <p>Set multizone effect.</p> PARAMETER DESCRIPTION <code>effect</code> <p>MultiZone effect configuration</p> <p> TYPE: <code>MultiZoneEffect</code> </p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code>from lifx.protocol.protocol_types import Direction, FirmwareEffect\n\n# Apply a move effect moving forward\neffect = MultiZoneEffect(\n    effect_type=FirmwareEffect.MOVE,\n    speed=5000,  # 5 seconds per cycle\n    duration=0,  # Infinite\n)\neffect.direction = Direction.FORWARD\nawait light.set_effect(effect)\n\n# Or use parameters directly\neffect = MultiZoneEffect(\n    effect_type=FirmwareEffect.MOVE,\n    speed=5000,\n    parameters=[0, int(Direction.REVERSED), 0, 0, 0, 0, 0, 0],\n)\nawait light.set_effect(effect)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def set_effect(\n    self,\n    effect: MultiZoneEffect,\n) -&gt; None:\n    \"\"\"Set multizone effect.\n\n    Args:\n        effect: MultiZone effect configuration\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        from lifx.protocol.protocol_types import Direction, FirmwareEffect\n\n        # Apply a move effect moving forward\n        effect = MultiZoneEffect(\n            effect_type=FirmwareEffect.MOVE,\n            speed=5000,  # 5 seconds per cycle\n            duration=0,  # Infinite\n        )\n        effect.direction = Direction.FORWARD\n        await light.set_effect(effect)\n\n        # Or use parameters directly\n        effect = MultiZoneEffect(\n            effect_type=FirmwareEffect.MOVE,\n            speed=5000,\n            parameters=[0, int(Direction.REVERSED), 0, 0, 0, 0, 0, 0],\n        )\n        await light.set_effect(effect)\n        ```\n    \"\"\"  # Ensure parameters list is 8 elements\n    parameters = effect.parameters or [0] * 8\n    if len(parameters) &lt; 8:\n        parameters.extend([0] * (8 - len(parameters)))\n    parameters = parameters[:8]\n\n    # Send request\n    result = await self.connection.request(\n        packets.MultiZone.SetEffect(\n            settings=MultiZoneEffectSettings(\n                instanceid=0,  # 0 for new effect\n                effect_type=effect.effect_type,\n                speed=effect.speed,\n                duration=effect.duration,\n                parameter=MultiZoneEffectParameter(\n                    parameter0=parameters[0],\n                    parameter1=parameters[1],\n                    parameter2=parameters[2],\n                    parameter3=parameters[3],\n                    parameter4=parameters[4],\n                    parameter5=parameters[5],\n                    parameter6=parameters[6],\n                    parameter7=parameters[7],\n                ),\n            ),\n        ),\n    )\n    self._raise_if_unhandled(result)\n\n    # Update cached state\n    cached_effect = effect if effect.effect_type != FirmwareEffect.OFF else None\n    self._multizone_effect = cached_effect\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"set_effect\",\n            \"action\": \"change\",\n            \"values\": {\n                \"effect_type\": effect.effect_type.name,\n                \"speed\": effect.speed,\n                \"duration\": effect.duration,\n                \"parameters\": parameters,\n            },\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.stop_effect","title":"stop_effect  <code>async</code>","text":"<pre><code>stop_effect() -&gt; None\n</code></pre> <p>Stop any running multizone effect.</p> Example <pre><code>await light.stop_effect()\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def stop_effect(self) -&gt; None:\n    \"\"\"Stop any running multizone effect.\n\n    Example:\n        ```python\n        await light.stop_effect()\n        ```\n    \"\"\"\n    await self.set_effect(\n        MultiZoneEffect(\n            effect_type=FirmwareEffect.OFF,\n            speed=0,\n            duration=0,\n        )\n    )\n\n    _LOGGER.debug(\n        {\n            \"class\": \"Device\",\n            \"method\": \"stop_effect\",\n            \"action\": \"change\",\n            \"values\": {},\n        }\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.apply_theme","title":"apply_theme  <code>async</code>","text":"<pre><code>apply_theme(\n    theme: Theme,\n    power_on: bool = False,\n    duration: float = 0,\n    strategy: str | None = None,\n) -&gt; None\n</code></pre> <p>Apply a theme across zones.</p> <p>Distributes theme colors evenly across the light's zones with smooth color blending between theme colors.</p> PARAMETER DESCRIPTION <code>theme</code> <p>Theme to apply</p> <p> TYPE: <code>Theme</code> </p> <code>power_on</code> <p>Turn on the light</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>duration</code> <p>Transition duration in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>strategy</code> <p>Color distribution strategy (not used yet, for future)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Example <pre><code>from lifx.theme import get_theme\n\ntheme = get_theme(\"evening\")\nawait strip.apply_theme(theme, power_on=True, duration=0.5)\n</code></pre> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def apply_theme(\n    self,\n    theme: Theme,\n    power_on: bool = False,\n    duration: float = 0,\n    strategy: str | None = None,\n) -&gt; None:\n    \"\"\"Apply a theme across zones.\n\n    Distributes theme colors evenly across the light's zones with smooth\n    color blending between theme colors.\n\n    Args:\n        theme: Theme to apply\n        power_on: Turn on the light\n        duration: Transition duration in seconds\n        strategy: Color distribution strategy (not used yet, for future)\n\n    Example:\n        ```python\n        from lifx.theme import get_theme\n\n        theme = get_theme(\"evening\")\n        await strip.apply_theme(theme, power_on=True, duration=0.5)\n        ```\n    \"\"\"\n    from lifx.theme.generators import MultiZoneGenerator\n\n    # Get number of zones\n    zone_count = await self.get_zone_count()\n\n    # Use proper multizone generator with blending\n    generator = MultiZoneGenerator()\n    colors = generator.get_theme_colors(theme, zone_count)\n\n    # Check if light is on\n    is_on = await self.get_power()\n\n    # Apply colors to zones using extended format for efficiency\n    # If light is off and we're turning it on, set colors immediately then fade on\n    if power_on and not is_on:\n        await self.set_extended_color_zones(0, colors, duration=0)\n        await self.set_power(True, duration=duration)\n    else:\n        # Light is already on, or we're not turning it on - apply with duration\n        await self.set_extended_color_zones(0, colors, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLight.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh multizone light state from hardware.</p> <p>Fetches color, zones, and effect.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh multizone light state from hardware.\n\n    Fetches color, zones, and effect.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    await super().refresh_state()\n\n    async with asyncio.TaskGroup() as tg:\n        zones_task = tg.create_task(self.get_all_color_zones())\n        effect_task = tg.create_task(self.get_effect())\n\n    zones = zones_task.result()\n    effect = effect_task.result()\n\n    self._state.zones = zones\n    self._state.effect = effect.effect_type\n</code></pre>"},{"location":"api/devices/#multizonelightstate","title":"MultiZoneLightState","text":"<p>MultiZone light device state dataclass returned by <code>MultiZoneLight.state</code>.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLightState","title":"MultiZoneLightState  <code>dataclass</code>","text":"<pre><code>MultiZoneLightState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n    color: HSBK,\n    zones: list[HSBK],\n    zone_count: int,\n    effect: FirmwareEffect,\n)\n</code></pre> <p>               Bases: <code>LightState</code></p> <p>MultiZone light device state with zone-based control.</p> ATTRIBUTE DESCRIPTION <code>zones</code> <p>List of HSBK colors for each zone</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>zone_count</code> <p>Total number of zones</p> <p> TYPE: <code>int</code> </p> <code>effect</code> <p>Current multizone effect configuration</p> <p> TYPE: <code>FirmwareEffect</code> </p> METHOD DESCRIPTION <code>from_light_state</code> <p>Create MatrixLightState from LightState.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLightState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLightState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return MultiZoneLightState as dict.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLightState-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneLightState.from_light_state","title":"from_light_state  <code>classmethod</code>","text":"<pre><code>from_light_state(\n    light_state: LightState, zones: list[HSBK], effect: FirmwareEffect\n) -&gt; MultiZoneLightState\n</code></pre> <p>Create MatrixLightState from LightState.</p> Source code in <code>src/lifx/devices/multizone.py</code> <pre><code>@classmethod\ndef from_light_state(\n    cls,\n    light_state: LightState,\n    zones: list[HSBK],\n    effect: FirmwareEffect,\n) -&gt; MultiZoneLightState:\n    \"\"\"Create MatrixLightState from LightState.\"\"\"\n    return cls(\n        model=light_state.model,\n        label=light_state.label,\n        serial=light_state.serial,\n        mac_address=light_state.mac_address,\n        power=light_state.power,\n        capabilities=light_state.capabilities,\n        host_firmware=light_state.host_firmware,\n        wifi_firmware=light_state.wifi_firmware,\n        location=light_state.location,\n        group=light_state.group,\n        color=light_state.color,\n        zones=zones,\n        zone_count=len(zones),\n        effect=effect,\n        last_updated=time.time(),\n    )\n</code></pre>"},{"location":"api/devices/#multizoneeffect","title":"MultiZoneEffect","text":"<p>Configuration dataclass for multizone effects (MOVE). Used with <code>MultiZoneLight.set_effect()</code> and returned by <code>MultiZoneLight.get_effect()</code>.</p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneEffect","title":"MultiZoneEffect  <code>dataclass</code>","text":"<pre><code>MultiZoneEffect(\n    effect_type: FirmwareEffect,\n    speed: int,\n    duration: int = 0,\n    parameters: list[int] | None = None,\n)\n</code></pre> <p>MultiZone effect configuration.</p> ATTRIBUTE DESCRIPTION <code>effect_type</code> <p>Type of effect (OFF, MOVE)</p> <p> TYPE: <code>FirmwareEffect</code> </p> <code>speed</code> <p>Effect speed in milliseconds</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Total effect duration (0 for infinite)</p> <p> TYPE: <code>int</code> </p> <code>parameters</code> <p>Effect-specific parameters (8 uint32 values)</p> <p> TYPE: <code>list[int] | None</code> </p>"},{"location":"api/devices/#lifx.devices.multizone.MultiZoneEffect-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.multizone.MultiZoneEffect.direction","title":"direction  <code>property</code> <code>writable</code>","text":"<pre><code>direction: Direction | None\n</code></pre> <p>Get direction for MOVE effect.</p> RETURNS DESCRIPTION <code>Direction | None</code> <p>Direction enum value if effect is MOVE, None otherwise</p>"},{"location":"api/devices/#matrix-light","title":"Matrix Light","text":"<p>The <code>MatrixLight</code> class controls LIFX matrix devices (tiles, candle, path) with 2D zone control.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight","title":"MatrixLight","text":"<pre><code>MatrixLight(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Light</code></p> <p>LIFX Matrix Light Device.</p> <p>MatrixLight devices have 2D arrays of controllable color zones arranged in tiles. Most MatrixLight devices (LIFX Candle, LIFX Path) have a single tile. The discontinued LIFX Tile product supported up to 5 tiles in a chain (has_chain).</p> <p>Zone Addressing: - Colors are applied row-by-row starting at top-left (0,0) - For tiles \u226464 zones: Single set64() call to frame buffer 0 - For tiles &gt;64 zones (e.g., 16x8 = 128 zones):   1. First set64(): rect=(0,0), 64 colors, frame buffer 1   2. Second set64(): rect=(0,4), 64 colors, frame buffer 1   3. copy_frame_buffer(): Copy buffer 1 \u2192 buffer 0</p> Example <p>async with await MatrixLight.from_ip(\"192.168.1.100\") as matrix: ...     # Get device chain info ...     chain = await matrix.get_device_chain() ...     print(f\"Device has {len(chain)} tile(s)\") ... ...     # Set colors on first tile (8x8 = 64 zones) ...     colors = [HSBK.from_rgb(255, 0, 0)] * 64 ...     await matrix.set64(tile_index=0, colors=colors, width=8)</p> <p>See :class:<code>Light</code> for parameter documentation.</p> METHOD DESCRIPTION <code>get_device_chain</code> <p>Get device chain details (list of Tile objects).</p> <code>set_user_position</code> <p>Position tiles in the chain (only for devices with has_chain capability).</p> <code>get64</code> <p>Get up to 64 zones of color state from a tile.</p> <code>get_all_tile_colors</code> <p>Get colors for all tiles in the chain.</p> <code>set64</code> <p>Set up to 64 zones of color on a tile.</p> <code>copy_frame_buffer</code> <p>Copy frame buffer (for tiles with &gt;64 zones).</p> <code>set_matrix_colors</code> <p>Convenience method to set all colors on a tile.</p> <code>get_effect</code> <p>Get current running matrix effect.</p> <code>set_effect</code> <p>Set matrix effect with configuration.</p> <code>apply_theme</code> <p>Apply a theme across matrix tiles using Canvas interpolation.</p> <code>refresh_state</code> <p>Refresh matrix light state from hardware.</p> ATTRIBUTE DESCRIPTION <code>state</code> <p>Get matrix light state (guaranteed when using Device.connect()).</p> <p> TYPE: <code>MatrixLightState</code> </p> <code>device_chain</code> <p>Get cached device chain.</p> <p> TYPE: <code>list[TileInfo] | None</code> </p> <code>tile_count</code> <p>Get number of tiles in the chain.</p> <p> TYPE: <code>int | None</code> </p> <code>tile_effect</code> <p>Get cached tile effect.</p> <p> TYPE: <code>MatrixEffect | None</code> </p> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Initialize MatrixLight device.\n\n    See :class:`Light` for parameter documentation.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    # Matrix specific properties\n    self._device_chain: list[TileInfo] | None = None\n    self._tile_effect: MatrixEffect | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.state","title":"state  <code>property</code>","text":"<pre><code>state: MatrixLightState\n</code></pre> <p>Get matrix light state (guaranteed when using Device.connect()).</p> RETURNS DESCRIPTION <code>MatrixLightState</code> <p>MatrixLightState with current matrix light state</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If accessed before state initialization</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.device_chain","title":"device_chain  <code>property</code>","text":"<pre><code>device_chain: list[TileInfo] | None\n</code></pre> <p>Get cached device chain.</p> <p>Returns None if not yet fetched. Use get_device_chain() to fetch.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.tile_count","title":"tile_count  <code>property</code>","text":"<pre><code>tile_count: int | None\n</code></pre> <p>Get number of tiles in the chain.</p> <p>Returns None if device chain not yet fetched.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.tile_effect","title":"tile_effect  <code>property</code>","text":"<pre><code>tile_effect: MatrixEffect | None\n</code></pre> <p>Get cached tile effect.</p> <p>Returns None if not yet fetched. Use get_tile_effect() to fetch.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.get_device_chain","title":"get_device_chain  <code>async</code>","text":"<pre><code>get_device_chain() -&gt; list[TileInfo]\n</code></pre> <p>Get device chain details (list of Tile objects).</p> <p>This method fetches the device chain information and caches it.</p> RETURNS DESCRIPTION <code>list[TileInfo]</code> <p>List of TileInfo objects describing each tile in the chain</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <p>chain = await matrix.get_device_chain() for tile in chain: ...     print(f\"Tile {tile.tile_index}: {tile.width}x{tile.height}\")</p> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def get_device_chain(self) -&gt; list[TileInfo]:\n    \"\"\"Get device chain details (list of Tile objects).\n\n    This method fetches the device chain information and caches it.\n\n    Returns:\n        List of TileInfo objects describing each tile in the chain\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        &gt;&gt;&gt; chain = await matrix.get_device_chain()\n        &gt;&gt;&gt; for tile in chain:\n        ...     print(f\"Tile {tile.tile_index}: {tile.width}x{tile.height}\")\n    \"\"\"\n    _LOGGER.debug(\"Getting device chain for %s\", self.label or self.serial)\n\n    response: packets.Tile.StateDeviceChain = await self.connection.request(\n        packets.Tile.GetDeviceChain()\n    )\n    self._raise_if_unhandled(response)\n\n    # Parse tiles from response\n    tiles = []\n    for i, protocol_tile in enumerate(response.tile_devices):\n        # Stop at first zero-width tile (indicates end of chain)\n        if protocol_tile.width == 0:\n            break\n        tiles.append(TileInfo.from_protocol(i, protocol_tile))\n\n    self._device_chain = tiles\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"chain\"):\n        self._state.chain = tiles\n        self._state.tile_count = len(tiles)\n        self._state.last_updated = __import__(\"time\").time()\n\n    _LOGGER.debug(\"Device chain has %d tile(s)\", len(tiles))\n    return tiles\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_user_position","title":"set_user_position  <code>async</code>","text":"<pre><code>set_user_position(tile_index: int, user_x: float, user_y: float) -&gt; None\n</code></pre> <p>Position tiles in the chain (only for devices with has_chain capability).</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of the tile to position (0-based)</p> <p> TYPE: <code>int</code> </p> <code>user_x</code> <p>User-defined X position</p> <p> TYPE: <code>float</code> </p> <code>user_y</code> <p>User-defined Y position</p> <p> TYPE: <code>float</code> </p> Note <p>Only applicable for multi-tile devices (has_chain capability). Most MatrixLight devices have a single tile and don't need positioning.</p> Example Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def set_user_position(\n    self, tile_index: int, user_x: float, user_y: float\n) -&gt; None:\n    \"\"\"Position tiles in the chain (only for devices with has_chain capability).\n\n    Args:\n        tile_index: Index of the tile to position (0-based)\n        user_x: User-defined X position\n        user_y: User-defined Y position\n\n    Note:\n        Only applicable for multi-tile devices (has_chain capability).\n        Most MatrixLight devices have a single tile and don't need positioning.\n\n    Example:\n        &gt;&gt;&gt; # Position second tile at coordinates (1.0, 0.0)\n        &gt;&gt;&gt; await matrix.set_user_position(tile_index=1, user_x=1.0, user_y=0.0)\n    \"\"\"\n    _LOGGER.debug(\n        \"Setting tile %d position to (%f, %f) for %s\",\n        tile_index,\n        user_x,\n        user_y,\n        self.label or self.serial,\n    )\n\n    await self.connection.send_packet(\n        packets.Tile.SetUserPosition(\n            tile_index=tile_index,\n            user_x=user_x,\n            user_y=user_y,\n        )\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_user_position--position-second-tile-at-coordinates-10-00","title":"Position second tile at coordinates (1.0, 0.0)","text":"<p>await matrix.set_user_position(tile_index=1, user_x=1.0, user_y=0.0)</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.get64","title":"get64  <code>async</code>","text":"<pre><code>get64(\n    tile_index: int = 0,\n    length: int = 1,\n    x: int = 0,\n    y: int = 0,\n    width: int | None = None,\n) -&gt; list[HSBK]\n</code></pre> <p>Get up to 64 zones of color state from a tile.</p> <p>For devices with \u226464 zones, returns all zones. For devices with &gt;64 zones, returns up to 64 zones due to protocol limitations.</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of the tile (0-based). Defaults to 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>length</code> <p>Number of tiles to query (usually 1). Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>x</code> <p>X coordinate of the rectangle (0-based). Defaults to 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>y</code> <p>Y coordinate of the rectangle (0-based). Defaults to 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>width</code> <p>Width of the rectangle in zones. Defaults to tile width.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors for the requested zones. For tiles with \u226464 zones,</p> <code>list[HSBK]</code> <p>returns the actual zone count (e.g., 64 for 8x8, 16 for 4x4). For tiles</p> <code>list[HSBK]</code> <p>with &gt;64 zones (e.g., 128 for 16x8 Ceiling), returns 64 (protocol limit).</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def get64(\n    self,\n    tile_index: int = 0,\n    length: int = 1,\n    x: int = 0,\n    y: int = 0,\n    width: int | None = None,\n) -&gt; list[HSBK]:\n    \"\"\"Get up to 64 zones of color state from a tile.\n\n    For devices with \u226464 zones, returns all zones. For devices with &gt;64 zones,\n    returns up to 64 zones due to protocol limitations.\n\n    Args:\n        tile_index: Index of the tile (0-based). Defaults to 0.\n        length: Number of tiles to query (usually 1). Defaults to 1.\n        x: X coordinate of the rectangle (0-based). Defaults to 0.\n        y: Y coordinate of the rectangle (0-based). Defaults to 0.\n        width: Width of the rectangle in zones. Defaults to tile width.\n\n    Returns:\n        List of HSBK colors for the requested zones. For tiles with \u226464 zones,\n        returns the actual zone count (e.g., 64 for 8x8, 16 for 4x4). For tiles\n        with &gt;64 zones (e.g., 128 for 16x8 Ceiling), returns 64 (protocol limit).\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        &gt;&gt;&gt; # Get all colors from first tile (no parameters needed)\n        &gt;&gt;&gt; colors = await matrix.get64()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Get colors from specific region\n        &gt;&gt;&gt; colors = await matrix.get64(y=4)  # Start at row 4\n    \"\"\"\n    # Validate parameters\n    if x &lt; 0:\n        raise ValueError(f\"x coordinate must be non-negative, got {x}\")\n    if y &lt; 0:\n        raise ValueError(f\"y coordinate must be non-negative, got {y}\")\n    if width is not None and width &lt;= 0:\n        raise ValueError(f\"width must be positive, got {width}\")\n\n    if self._device_chain is None:\n        device_chain = await self.get_device_chain()\n    else:\n        device_chain = self._device_chain\n\n    if width is None:\n        width = device_chain[0].width\n\n    _LOGGER.debug(\n        \"Getting 64 zones from tile %d (x=%d, y=%d, width=%d) for %s\",\n        tile_index,\n        x,\n        y,\n        width,\n        self.label or self.serial,\n    )\n\n    response: packets.Tile.State64 = await self.connection.request(\n        packets.Tile.Get64(\n            tile_index=tile_index,\n            length=length,\n            rect=TileBufferRect(fb_index=0, x=x, y=y, width=width),\n        )\n    )\n    self._raise_if_unhandled(response)\n\n    max_colors = device_chain[0].width * device_chain[0].height\n\n    # Convert protocol colors to HSBK\n    result = [\n        HSBK.from_protocol(proto_color)\n        for proto_color in response.colors[:max_colors]\n    ]\n\n    # Update state if it exists and we fetched all colors from tile 0\n    if self._state is not None and hasattr(self._state, \"tile_colors\"):\n        if tile_index == 0 and x == 0 and y == 0 and len(result) == max_colors:\n            self._state.tile_colors = result\n            self._state.last_updated = __import__(\"time\").time()\n\n    return result\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.get64--get-all-colors-from-first-tile-no-parameters-needed","title":"Get all colors from first tile (no parameters needed)","text":"<p>colors = await matrix.get64()</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.get64--get-colors-from-specific-region","title":"Get colors from specific region","text":"<p>colors = await matrix.get64(y=4)  # Start at row 4</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.get_all_tile_colors","title":"get_all_tile_colors  <code>async</code>","text":"<pre><code>get_all_tile_colors() -&gt; list[list[HSBK]]\n</code></pre> <p>Get colors for all tiles in the chain.</p> <p>Fetches colors from each tile in the device chain and returns them as a list of color lists (one per tile). This is the matrix equivalent of MultiZoneLight's get_all_color_zones().</p> <p>For tiles with &gt;64 zones (e.g., 16x8 Ceiling with 128 zones), makes multiple Get64 requests to fetch all colors.</p> <p>Always fetches from device. Tiles are queried sequentially to avoid overwhelming the device with concurrent requests.</p> RETURNS DESCRIPTION <code>list[list[HSBK]]</code> <p>List of color lists, one per tile. Each inner list contains</p> <code>list[list[HSBK]]</code> <p>all colors for that tile (64 for 8x8 tiles, 128 for 16x8 Ceiling).</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Get colors for all tiles\nall_colors = await matrix.get_all_tile_colors()\nprint(f\"Device has {len(all_colors)} tiles\")\nfor i, tile_colors in enumerate(all_colors):\n    print(f\"Tile {i}: {len(tile_colors)} colors\")\n\n# Flatten to single list if needed\nflat_colors = [c for tile in all_colors for c in tile]\n</code></pre> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def get_all_tile_colors(self) -&gt; list[list[HSBK]]:\n    \"\"\"Get colors for all tiles in the chain.\n\n    Fetches colors from each tile in the device chain and returns them\n    as a list of color lists (one per tile). This is the matrix equivalent\n    of MultiZoneLight's get_all_color_zones().\n\n    For tiles with &gt;64 zones (e.g., 16x8 Ceiling with 128 zones), makes\n    multiple Get64 requests to fetch all colors.\n\n    Always fetches from device. Tiles are queried sequentially to avoid\n    overwhelming the device with concurrent requests.\n\n    Returns:\n        List of color lists, one per tile. Each inner list contains\n        all colors for that tile (64 for 8x8 tiles, 128 for 16x8 Ceiling).\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Get colors for all tiles\n        all_colors = await matrix.get_all_tile_colors()\n        print(f\"Device has {len(all_colors)} tiles\")\n        for i, tile_colors in enumerate(all_colors):\n            print(f\"Tile {i}: {len(tile_colors)} colors\")\n\n        # Flatten to single list if needed\n        flat_colors = [c for tile in all_colors for c in tile]\n        ```\n    \"\"\"\n    # Get device chain (use cached if available)\n    if self._device_chain is None:\n        device_chain = await self.get_device_chain()\n    else:\n        device_chain = self._device_chain\n\n    # Fetch colors from each tile sequentially\n    all_colors: list[list[HSBK]] = []\n    for tile in device_chain:\n        tile_zone_count = tile.width * tile.height\n\n        if tile_zone_count &lt;= 64:\n            # Single request for tiles with \u226464 zones\n            tile_colors = await self.get64(tile_index=tile.tile_index)\n            all_colors.append(tile_colors)\n        else:\n            # Multiple requests for tiles with &gt;64 zones (e.g., 16x8 Ceiling)\n            # Split into multiple 64-zone requests by row\n            tile_colors = []\n            rows_per_request = 64 // tile.width  # e.g., 64/16 = 4 rows\n\n            for y_offset in range(0, tile.height, rows_per_request):\n                chunk = await self.get64(\n                    tile_index=tile.tile_index,\n                    x=0,\n                    y=y_offset,\n                    width=tile.width,\n                )\n                tile_colors.extend(chunk)\n\n            all_colors.append(tile_colors)\n\n    # Update state if it exists (flatten for state storage)\n    if self._state is not None and hasattr(self._state, \"tile_colors\"):\n        flat_colors = [c for tile_colors in all_colors for c in tile_colors]\n        self._state.tile_colors = flat_colors\n        self._state.last_updated = time.time()\n\n    return all_colors\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set64","title":"set64  <code>async</code>","text":"<pre><code>set64(\n    tile_index: int,\n    length: int,\n    x: int,\n    y: int,\n    width: int,\n    duration: int,\n    colors: list[HSBK],\n    fb_index: int = 0,\n) -&gt; None\n</code></pre> <p>Set up to 64 zones of color on a tile.</p> <p>Colors are applied row-by-row starting at position (x, y). For tiles &gt;64 zones, use multiple set64() calls with copy_frame_buffer().</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of the tile (0-based)</p> <p> TYPE: <code>int</code> </p> <code>length</code> <p>Number of tiles to update (usually 1)</p> <p> TYPE: <code>int</code> </p> <code>x</code> <p>X coordinate of the rectangle (0-based)</p> <p> TYPE: <code>int</code> </p> <code>y</code> <p>Y coordinate of the rectangle (0-based)</p> <p> TYPE: <code>int</code> </p> <code>width</code> <p>Width of the rectangle in zones</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Transition duration in milliseconds</p> <p> TYPE: <code>int</code> </p> <code>colors</code> <p>List of HSBK colors (up to 64)</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>fb_index</code> <p>Frame buffer index (0 for display, 1 for temp buffer)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Example Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def set64(\n    self,\n    tile_index: int,\n    length: int,\n    x: int,\n    y: int,\n    width: int,\n    duration: int,\n    colors: list[HSBK],\n    fb_index: int = 0,\n) -&gt; None:\n    \"\"\"Set up to 64 zones of color on a tile.\n\n    Colors are applied row-by-row starting at position (x, y).\n    For tiles &gt;64 zones, use multiple set64() calls with copy_frame_buffer().\n\n    Args:\n        tile_index: Index of the tile (0-based)\n        length: Number of tiles to update (usually 1)\n        x: X coordinate of the rectangle (0-based)\n        y: Y coordinate of the rectangle (0-based)\n        width: Width of the rectangle in zones\n        duration: Transition duration in milliseconds\n        colors: List of HSBK colors (up to 64)\n        fb_index: Frame buffer index (0 for display, 1 for temp buffer)\n\n    Example:\n        &gt;&gt;&gt; # Set 8x8 tile to red\n        &gt;&gt;&gt; colors = [HSBK.from_rgb(255, 0, 0)] * 64\n        &gt;&gt;&gt; await matrix.set64(\n        ...     tile_index=0, length=1, x=0, y=0, width=8, duration=0, colors=colors\n        ... )\n    \"\"\"\n    # Validate parameters\n    if x &lt; 0:\n        raise ValueError(f\"x coordinate must be non-negative, got {x}\")\n    if y &lt; 0:\n        raise ValueError(f\"y coordinate must be non-negative, got {y}\")\n    if width &lt;= 0:\n        raise ValueError(f\"width must be positive, got {width}\")\n\n    _LOGGER.debug(\n        \"Setting 64 zones on tile %d (x=%d, y=%d, width=%d, fb=%d, \"\n        \"duration=%d) for %s\",\n        tile_index,\n        x,\n        y,\n        width,\n        fb_index,\n        duration,\n        self.label or self.serial,\n    )\n\n    # Convert HSBK colors to protocol format\n    proto_colors = []\n    for color in colors:\n        proto_colors.append(\n            LightHsbk(\n                hue=int(color.hue / 360 * 65535),\n                saturation=int(color.saturation * 65535),\n                brightness=int(color.brightness * 65535),\n                kelvin=color.kelvin,\n            )\n        )\n\n    # Pad to 64 colors if needed\n    while len(proto_colors) &lt; 64:\n        proto_colors.append(LightHsbk(0, 0, 0, 3500))\n\n    await self.connection.send_packet(\n        packets.Tile.Set64(\n            tile_index=tile_index,\n            length=length,\n            rect=TileBufferRect(fb_index=fb_index, x=x, y=y, width=width),\n            duration=duration,\n            colors=proto_colors,\n        )\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set64--set-8x8-tile-to-red","title":"Set 8x8 tile to red","text":"<p>colors = [HSBK.from_rgb(255, 0, 0)] * 64 await matrix.set64( ...     tile_index=0, length=1, x=0, y=0, width=8, duration=0, colors=colors ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.copy_frame_buffer","title":"copy_frame_buffer  <code>async</code>","text":"<pre><code>copy_frame_buffer(\n    tile_index: int,\n    source_fb: int = 1,\n    target_fb: int = 0,\n    duration: float = 0.0,\n    length: int = 1,\n) -&gt; None\n</code></pre> <p>Copy frame buffer (for tiles with &gt;64 zones).</p> <p>This is used for tiles with more than 64 zones. After setting colors in the temporary buffer (fb=1), copy to the display buffer (fb=0).</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of the tile (0-based)</p> <p> TYPE: <code>int</code> </p> <code>source_fb</code> <p>Source frame buffer index (usually 1)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>target_fb</code> <p>Target frame buffer index (usually 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>duration</code> <p>time in seconds to transition if target_fb is 0</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>length</code> <p>Number of tiles to update starting from tile_index (default 1)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Example Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def copy_frame_buffer(\n    self,\n    tile_index: int,\n    source_fb: int = 1,\n    target_fb: int = 0,\n    duration: float = 0.0,\n    length: int = 1,\n) -&gt; None:\n    \"\"\"Copy frame buffer (for tiles with &gt;64 zones).\n\n    This is used for tiles with more than 64 zones. After setting colors\n    in the temporary buffer (fb=1), copy to the display buffer (fb=0).\n\n    Args:\n        tile_index: Index of the tile (0-based)\n        source_fb: Source frame buffer index (usually 1)\n        target_fb: Target frame buffer index (usually 0)\n        duration: time in seconds to transition if target_fb is 0\n        length: Number of tiles to update starting from tile_index (default 1)\n\n    Example:\n        &gt;&gt;&gt; # For 16x8 tile (128 zones):\n        &gt;&gt;&gt; # 1. Set first 64 zones to buffer 1\n        &gt;&gt;&gt; await matrix.set64(\n        ...     tile_index=0,\n        ...     length=1,\n        ...     x=0,\n        ...     y=0,\n        ...     width=16,\n        ...     duration=0,\n        ...     colors=colors[:64],\n        ...     fb_index=1,\n        ... )\n        &gt;&gt;&gt; # 2. Set second 64 zones to buffer 1\n        &gt;&gt;&gt; await matrix.set64(\n        ...     tile_index=0,\n        ...     length=1,\n        ...     x=0,\n        ...     y=4,\n        ...     width=16,\n        ...     duration=0,\n        ...     colors=colors[64:],\n        ...     fb_index=1,\n        ... )\n        &gt;&gt;&gt; # 3. Copy buffer 1 to buffer 0 (display)\n        &gt;&gt;&gt; await matrix.copy_frame_buffer(\n        ...     tile_index=0, source_fb=1, target_fb=0, duration=2.0\n        ... )\n\n        &gt;&gt;&gt; # For a chain of 5 tiles, update all simultaneously:\n        &gt;&gt;&gt; await matrix.copy_frame_buffer(\n        ...     tile_index=0, source_fb=1, target_fb=0, length=5\n        ... )\n    \"\"\"\n    _LOGGER.debug(\n        \"Copying frame buffer %d -&gt; %d for tile %d (length=%d) on %s\",\n        source_fb,\n        target_fb,\n        tile_index,\n        length,\n        self.label or self.serial,\n    )\n\n    # Get tile dimensions for the copy operation\n    if self._device_chain is None:\n        await self.get_device_chain()\n\n    if self._device_chain is None or tile_index &gt;= len(self._device_chain):\n        raise ValueError(f\"Invalid tile_index {tile_index}\")\n\n    tile = self._device_chain[tile_index]\n    duration_ms = round(duration * 1000 if duration else 0)\n\n    await self.connection.send_packet(\n        packets.Tile.CopyFrameBuffer(\n            tile_index=tile_index,\n            length=length,\n            src_fb_index=source_fb,\n            dst_fb_index=target_fb,\n            src_x=0,\n            src_y=0,\n            dst_x=0,\n            dst_y=0,\n            width=tile.width,\n            height=tile.height,\n            duration=duration_ms,\n        )\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.copy_frame_buffer--for-16x8-tile-128-zones","title":"For 16x8 tile (128 zones):","text":""},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.copy_frame_buffer--1-set-first-64-zones-to-buffer-1","title":"1. Set first 64 zones to buffer 1","text":"<p>await matrix.set64( ...     tile_index=0, ...     length=1, ...     x=0, ...     y=0, ...     width=16, ...     duration=0, ...     colors=colors[:64], ...     fb_index=1, ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.copy_frame_buffer--2-set-second-64-zones-to-buffer-1","title":"2. Set second 64 zones to buffer 1","text":"<p>await matrix.set64( ...     tile_index=0, ...     length=1, ...     x=0, ...     y=4, ...     width=16, ...     duration=0, ...     colors=colors[64:], ...     fb_index=1, ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.copy_frame_buffer--3-copy-buffer-1-to-buffer-0-display","title":"3. Copy buffer 1 to buffer 0 (display)","text":"<p>await matrix.copy_frame_buffer( ...     tile_index=0, source_fb=1, target_fb=0, duration=2.0 ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.copy_frame_buffer--for-a-chain-of-5-tiles-update-all-simultaneously","title":"For a chain of 5 tiles, update all simultaneously:","text":"<p>await matrix.copy_frame_buffer( ...     tile_index=0, source_fb=1, target_fb=0, length=5 ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_matrix_colors","title":"set_matrix_colors  <code>async</code>","text":"<pre><code>set_matrix_colors(\n    tile_index: int, colors: list[HSBK], duration: int = 0\n) -&gt; None\n</code></pre> <p>Convenience method to set all colors on a tile.</p> <p>If all colors are the same, uses SetColor() packet which sets all zones across all tiles. Otherwise, automatically handles tiles with &gt;64 zones using frame buffer strategy.</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of the tile (0-based)</p> <p> TYPE: <code>int</code> </p> <code>colors</code> <p>List of HSBK colors (length must match tile total_zones)</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>duration</code> <p>Transition duration in milliseconds</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Example Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def set_matrix_colors(\n    self, tile_index: int, colors: list[HSBK], duration: int = 0\n) -&gt; None:\n    \"\"\"Convenience method to set all colors on a tile.\n\n    If all colors are the same, uses SetColor() packet which sets all zones\n    across all tiles. Otherwise, automatically handles tiles with &gt;64 zones\n    using frame buffer strategy.\n\n    Args:\n        tile_index: Index of the tile (0-based)\n        colors: List of HSBK colors (length must match tile total_zones)\n        duration: Transition duration in milliseconds\n\n    Example:\n        &gt;&gt;&gt; # Set entire tile to solid red (uses SetColor packet)\n        &gt;&gt;&gt; colors = [HSBK.from_rgb(255, 0, 0)] * 64\n        &gt;&gt;&gt; await matrix.set_matrix_colors(tile_index=0, colors=colors)\n\n        &gt;&gt;&gt; # Set 8x8 tile to gradient (uses set64 with zones)\n        &gt;&gt;&gt; colors = [HSBK(i * 360 / 64, 1.0, 1.0, 3500) for i in range(64)]\n        &gt;&gt;&gt; await matrix.set_matrix_colors(tile_index=0, colors=colors)\n    \"\"\"\n    # Get device chain to determine tile dimensions\n    if self._device_chain is None:\n        await self.get_device_chain()\n\n    if not self._device_chain or tile_index &gt;= len(self._device_chain):\n        raise ValueError(f\"Invalid tile_index: {tile_index}\")\n\n    tile = self._device_chain[tile_index]\n\n    if len(colors) != tile.total_zones:\n        raise ValueError(\n            f\"Color count mismatch: expected {tile.total_zones}, got {len(colors)}\"\n        )\n\n    # Check if all colors are the same\n    first_color = colors[0]\n    all_same = all(\n        c.hue == first_color.hue\n        and c.saturation == first_color.saturation\n        and c.brightness == first_color.brightness\n        and c.kelvin == first_color.kelvin\n        for c in colors\n    )\n\n    if all_same:\n        # All zones same color - use SetColor packet (much faster!)\n        _LOGGER.debug(\n            \"All zones same color, using SetColor packet for tile %d\",\n            tile_index,\n        )\n        await self.set_color(first_color, duration=duration / 1000.0)\n        return\n\n    if tile.requires_frame_buffer:\n        # Tile has &gt;64 zones, use frame buffer strategy\n        _LOGGER.debug(\n            \"Using frame buffer strategy for tile %d (%dx%d = %d zones)\",\n            tile_index,\n            tile.width,\n            tile.height,\n            tile.total_zones,\n        )\n\n        # Calculate rows per batch (64 zones / width)\n        rows_per_batch = 64 // tile.width\n        total_batches = (tile.height + rows_per_batch - 1) // rows_per_batch\n\n        for batch in range(total_batches):\n            start_row = batch * rows_per_batch\n            end_row = min(start_row + rows_per_batch, tile.height)\n\n            # Extract colors for this batch\n            start_idx = start_row * tile.width\n            end_idx = end_row * tile.width\n            batch_colors = colors[start_idx:end_idx]\n\n            # Set colors to frame buffer 1\n            await self.set64(\n                tile_index=tile_index,\n                length=1,\n                x=0,\n                y=start_row,\n                width=tile.width,\n                duration=duration if batch == total_batches - 1 else 0,\n                colors=batch_colors,\n                fb_index=1,\n            )\n\n        # Copy frame buffer 1 to 0 (display)\n        await self.copy_frame_buffer(\n            tile_index=tile_index, source_fb=1, target_fb=0\n        )\n    else:\n        # Tile has \u226464 zones, single set64() call\n        await self.set64(\n            tile_index=tile_index,\n            length=1,\n            x=0,\n            y=0,\n            width=tile.width,\n            duration=duration,\n            colors=colors,\n        )\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_matrix_colors--set-entire-tile-to-solid-red-uses-setcolor-packet","title":"Set entire tile to solid red (uses SetColor packet)","text":"<p>colors = [HSBK.from_rgb(255, 0, 0)] * 64 await matrix.set_matrix_colors(tile_index=0, colors=colors)</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_matrix_colors--set-8x8-tile-to-gradient-uses-set64-with-zones","title":"Set 8x8 tile to gradient (uses set64 with zones)","text":"<p>colors = [HSBK(i * 360 / 64, 1.0, 1.0, 3500) for i in range(64)] await matrix.set_matrix_colors(tile_index=0, colors=colors)</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.get_effect","title":"get_effect  <code>async</code>","text":"<pre><code>get_effect() -&gt; MatrixEffect\n</code></pre> <p>Get current running matrix effect.</p> RETURNS DESCRIPTION <code>MatrixEffect</code> <p>MatrixEffect describing the current effect state</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <p>effect = await matrix.get_effect() print(f\"Effect type: {effect.effect_type}\")</p> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def get_effect(self) -&gt; MatrixEffect:\n    \"\"\"Get current running matrix effect.\n\n    Returns:\n        MatrixEffect describing the current effect state\n\n    Raises:\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        &gt;&gt;&gt; effect = await matrix.get_effect()\n        &gt;&gt;&gt; print(f\"Effect type: {effect.effect_type}\")\n    \"\"\"\n    _LOGGER.debug(\"Getting matrix effect for %s\", self.label or self.serial)\n\n    response: packets.Tile.StateEffect = await self.connection.request(\n        packets.Tile.GetEffect()\n    )\n    self._raise_if_unhandled(response)\n\n    # Convert protocol effect to MatrixEffect\n    palette = [\n        HSBK.from_protocol(proto_color)\n        for proto_color in response.settings.palette[\n            : response.settings.palette_count\n        ]\n    ]\n\n    effect = MatrixEffect(\n        effect_type=response.settings.effect_type,\n        speed=response.settings.speed,\n        duration=response.settings.duration,\n        palette=palette if palette else None,\n        sky_type=response.settings.parameter.sky_type,\n        cloud_saturation_min=response.settings.parameter.cloud_saturation_min,\n        cloud_saturation_max=response.settings.parameter.cloud_saturation_max,\n    )\n\n    self._tile_effect = effect\n\n    # Update state if it exists\n    if self._state is not None and hasattr(self._state, \"effect\"):\n        self._state.effect = effect.effect_type\n        self._state.last_updated = __import__(\"time\").time()\n\n    return effect\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_effect","title":"set_effect  <code>async</code>","text":"<pre><code>set_effect(\n    effect_type: FirmwareEffect,\n    speed: float = 3.0,\n    duration: int = 0,\n    palette: list[HSBK] | None = None,\n    sky_type: TileEffectSkyType = SUNRISE,\n    cloud_saturation_min: int = 0,\n    cloud_saturation_max: int = 0,\n) -&gt; None\n</code></pre> <p>Set matrix effect with configuration.</p> PARAMETER DESCRIPTION <code>effect_type</code> <p>Type of effect (OFF, MORPH, FLAME, SKY)</p> <p> TYPE: <code>FirmwareEffect</code> </p> <code>speed</code> <p>Effect speed in seconds (default: 3)</p> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> <code>duration</code> <p>Total effect duration in nanoseconds (0 for infinite)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>palette</code> <p>Color palette for the effect (max 16 colors, None for no palette)</p> <p> TYPE: <code>list[HSBK] | None</code> DEFAULT: <code>None</code> </p> <code>sky_type</code> <p>Sky effect type (SUNRISE, SUNSET, CLOUDS)</p> <p> TYPE: <code>TileEffectSkyType</code> DEFAULT: <code>SUNRISE</code> </p> <code>cloud_saturation_min</code> <p>Minimum cloud saturation (0-255, for CLOUDS)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>cloud_saturation_max</code> <p>Maximum cloud saturation (0-255, for CLOUDS)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Example Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def set_effect(\n    self,\n    effect_type: FirmwareEffect,\n    speed: float = 3.0,\n    duration: int = 0,\n    palette: list[HSBK] | None = None,\n    sky_type: TileEffectSkyType = TileEffectSkyType.SUNRISE,\n    cloud_saturation_min: int = 0,\n    cloud_saturation_max: int = 0,\n) -&gt; None:\n    \"\"\"Set matrix effect with configuration.\n\n    Args:\n        effect_type: Type of effect (OFF, MORPH, FLAME, SKY)\n        speed: Effect speed in seconds (default: 3)\n        duration: Total effect duration in nanoseconds (0 for infinite)\n        palette: Color palette for the effect (max 16 colors, None for no palette)\n        sky_type: Sky effect type (SUNRISE, SUNSET, CLOUDS)\n        cloud_saturation_min: Minimum cloud saturation (0-255, for CLOUDS)\n        cloud_saturation_max: Maximum cloud saturation (0-255, for CLOUDS)\n\n    Example:\n        &gt;&gt;&gt; # Set MORPH effect with rainbow palette\n        &gt;&gt;&gt; rainbow = [\n        ...     HSBK(0, 1.0, 1.0, 3500),  # Red\n        ...     HSBK(60, 1.0, 1.0, 3500),  # Yellow\n        ...     HSBK(120, 1.0, 1.0, 3500),  # Green\n        ...     HSBK(240, 1.0, 1.0, 3500),  # Blue\n        ... ]\n        &gt;&gt;&gt; await matrix.set_effect(\n        ...     effect_type=FirmwareEffect.MORPH,\n        ...     speed=5.0,\n        ...     palette=rainbow,\n        ... )\n\n        &gt;&gt;&gt; # Set effect without a palette\n        &gt;&gt;&gt; await matrix.set_effect(\n        ...     effect_type=FirmwareEffect.FLAME,\n        ...     speed=3.0,\n        ... )\n    \"\"\"\n    _LOGGER.debug(\n        \"Setting matrix effect %s (speed=%d) for %s\",\n        effect_type,\n        speed,\n        self.label or self.serial,\n    )\n    speed_ms = round(speed * 1000) if speed else 3000\n\n    # Create and validate MatrixEffect\n    effect = MatrixEffect(\n        effect_type=effect_type,\n        speed=speed_ms,\n        duration=duration,\n        palette=palette,\n        sky_type=sky_type,\n        cloud_saturation_min=cloud_saturation_min,\n        cloud_saturation_max=cloud_saturation_max,\n    )\n\n    # Convert to protocol format\n    proto_palette = []\n    palette_count = 0\n\n    if effect.palette is not None:\n        palette_count = len(effect.palette)\n        for color in effect.palette:\n            proto_palette.append(\n                LightHsbk(\n                    hue=int(color.hue / 360 * 65535),\n                    saturation=int(color.saturation * 65535),\n                    brightness=int(color.brightness * 65535),\n                    kelvin=color.kelvin,\n                )\n            )\n\n    # Pad palette to 16 colors (protocol requirement)\n    while len(proto_palette) &lt; 16:\n        proto_palette.append(LightHsbk(0, 0, 0, 3500))\n\n    settings = TileEffectSettings(\n        instanceid=0,\n        effect_type=effect.effect_type,\n        speed=effect.speed,\n        duration=effect.duration,\n        parameter=TileEffectParameter(\n            sky_type=effect.sky_type,\n            cloud_saturation_min=effect.cloud_saturation_min,\n            cloud_saturation_max=effect.cloud_saturation_max,\n        ),\n        palette_count=palette_count,\n        palette=proto_palette,\n    )\n\n    await self.connection.send_packet(packets.Tile.SetEffect(settings=settings))\n    self._tile_effect = effect\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_effect--set-morph-effect-with-rainbow-palette","title":"Set MORPH effect with rainbow palette","text":"<p>rainbow = [ ...     HSBK(0, 1.0, 1.0, 3500),  # Red ...     HSBK(60, 1.0, 1.0, 3500),  # Yellow ...     HSBK(120, 1.0, 1.0, 3500),  # Green ...     HSBK(240, 1.0, 1.0, 3500),  # Blue ... ] await matrix.set_effect( ...     effect_type=FirmwareEffect.MORPH, ...     speed=5.0, ...     palette=rainbow, ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.set_effect--set-effect-without-a-palette","title":"Set effect without a palette","text":"<p>await matrix.set_effect( ...     effect_type=FirmwareEffect.FLAME, ...     speed=3.0, ... )</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.apply_theme","title":"apply_theme  <code>async</code>","text":"<pre><code>apply_theme(\n    theme: Theme, power_on: bool = False, duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Apply a theme across matrix tiles using Canvas interpolation.</p> <p>Distributes theme colors across the tile matrix with smooth color blending using the Canvas API for visually pleasing transitions.</p> PARAMETER DESCRIPTION <code>theme</code> <p>Theme to apply</p> <p> TYPE: <code>Theme</code> </p> <code>power_on</code> <p>Turn on the light</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>duration</code> <p>Transition duration in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>from lifx.theme import get_theme\n\ntheme = get_theme(\"evening\")\nawait matrix.apply_theme(theme, power_on=True, duration=0.5)\n</code></pre> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def apply_theme(\n    self,\n    theme: Theme,\n    power_on: bool = False,\n    duration: float = 0.0,\n) -&gt; None:\n    \"\"\"Apply a theme across matrix tiles using Canvas interpolation.\n\n    Distributes theme colors across the tile matrix with smooth color blending\n    using the Canvas API for visually pleasing transitions.\n\n    Args:\n        theme: Theme to apply\n        power_on: Turn on the light\n        duration: Transition duration in seconds\n\n    Example:\n        ```python\n        from lifx.theme import get_theme\n\n        theme = get_theme(\"evening\")\n        await matrix.apply_theme(theme, power_on=True, duration=0.5)\n        ```\n    \"\"\"\n    from lifx.theme.canvas import Canvas\n\n    # Get device chain\n    tiles = await self.get_device_chain()\n\n    if not tiles:\n        return\n\n    # Create canvas and populate with theme colors\n    canvas = Canvas()\n    for tile in tiles:\n        canvas.add_points_for_tile((int(tile.user_x), int(tile.user_y)), theme)\n\n    # Shuffle and blur ONCE after all points are added\n    # (Previously these were inside the loop, causing earlier tiles' points\n    # to be shuffled/blurred multiple times, displacing them from their\n    # intended positions and losing theme color variety)\n    canvas.shuffle_points()\n    canvas.blur_by_distance()\n\n    # Create tile canvas and fill in gaps for smooth interpolation\n    tile_canvas = Canvas()\n    for tile in tiles:\n        tile_canvas.fill_in_points(\n            canvas,\n            int(tile.user_x),\n            int(tile.user_y),\n            tile.width,\n            tile.height,\n        )\n\n    # Final blur for smooth gradients\n    tile_canvas.blur()\n\n    # Check if light is on\n    is_on = await self.get_power()\n\n    # Apply colors to each tile\n    for tile in tiles:\n        # Extract tile colors from canvas as 1D list\n        tile_coords = (int(tile.user_x), int(tile.user_y))\n        colors = tile_canvas.points_for_tile(\n            tile_coords, width=tile.width, height=tile.height\n        )\n\n        # Apply with appropriate timing\n        if power_on and not is_on:\n            await self.set_matrix_colors(tile.tile_index, colors, duration=0)\n        else:\n            await self.set_matrix_colors(\n                tile.tile_index, colors, duration=int(duration * 1000)\n            )\n\n    # Turn on light if requested and currently off\n    if power_on and not is_on:\n        await self.set_power(True, duration=duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLight.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh matrix light state from hardware.</p> <p>Fetches color, tiles, tile colors for all tiles, and effect.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh matrix light state from hardware.\n\n    Fetches color, tiles, tile colors for all tiles, and effect.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    await super().refresh_state()\n\n    # Fetch all matrix light state sequentially to avoid overwhelming device\n    all_tile_colors = await self.get_all_tile_colors()\n    effect = await self.get_effect()\n\n    # Flatten tile colors for state storage\n    self._state.tile_colors = [c for tile in all_tile_colors for c in tile]\n    self._state.effect = effect.effect_type\n</code></pre>"},{"location":"api/devices/#matrixlightstate","title":"MatrixLightState","text":"<p>Matrix light device state dataclass returned by <code>MatrixLight.state</code>.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLightState","title":"MatrixLightState  <code>dataclass</code>","text":"<pre><code>MatrixLightState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n    color: HSBK,\n    chain: list[TileInfo],\n    tile_orientations: dict[int, str],\n    tile_colors: list[HSBK],\n    tile_count: int,\n    effect: FirmwareEffect,\n)\n</code></pre> <p>               Bases: <code>LightState</code></p> <p>Matrix light device state with tile-based control.</p> ATTRIBUTE DESCRIPTION <code>tiles</code> <p>List of tile information for each tile in the chain</p> <p> </p> <code>tile_colors</code> <p>List of HSBK colors for all pixels across all tiles</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>tile_count</code> <p>Total number of tiles in chain</p> <p> TYPE: <code>int</code> </p> <code>effect</code> <p>Current matrix effect configuration</p> <p> TYPE: <code>FirmwareEffect</code> </p> METHOD DESCRIPTION <code>from_light_state</code> <p>Create MatrixLightState from LightState.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLightState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.matrix.MatrixLightState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return MatrixLightState as dict.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixLightState-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.matrix.MatrixLightState.from_light_state","title":"from_light_state  <code>classmethod</code>","text":"<pre><code>from_light_state(\n    light_state: LightState,\n    chain: list[TileInfo],\n    tile_orientations: dict[int, str],\n    tile_colors: list[HSBK],\n    effect: FirmwareEffect,\n) -&gt; MatrixLightState\n</code></pre> <p>Create MatrixLightState from LightState.</p> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>@classmethod\ndef from_light_state(\n    cls,\n    light_state: LightState,\n    chain: list[TileInfo],\n    tile_orientations: dict[int, str],\n    tile_colors: list[HSBK],\n    effect: FirmwareEffect,\n) -&gt; MatrixLightState:\n    \"\"\"Create MatrixLightState from LightState.\"\"\"\n    return cls(\n        model=light_state.model,\n        label=light_state.label,\n        serial=light_state.serial,\n        mac_address=light_state.mac_address,\n        power=light_state.power,\n        capabilities=light_state.capabilities,\n        host_firmware=light_state.host_firmware,\n        wifi_firmware=light_state.wifi_firmware,\n        location=light_state.location,\n        group=light_state.group,\n        color=light_state.color,\n        chain=chain,\n        tile_orientations=tile_orientations,\n        tile_colors=tile_colors,\n        tile_count=len(chain),\n        effect=effect,\n        last_updated=time.time(),\n    )\n</code></pre>"},{"location":"api/devices/#tileinfo","title":"TileInfo","text":"<p>Information dataclass for a single tile in the device chain. Returned as part of <code>MatrixLightState.chain</code>.</p>"},{"location":"api/devices/#lifx.devices.matrix.TileInfo","title":"TileInfo  <code>dataclass</code>","text":"<pre><code>TileInfo(\n    tile_index: int,\n    accel_meas_x: int,\n    accel_meas_y: int,\n    accel_meas_z: int,\n    user_x: float,\n    user_y: float,\n    width: int,\n    height: int,\n    supported_frame_buffers: int,\n    device_version_vendor: int,\n    device_version_product: int,\n    device_version_version: int,\n    firmware_build: int,\n    firmware_version_minor: int,\n    firmware_version_major: int,\n)\n</code></pre> <p>Information about a single tile in the device chain.</p> ATTRIBUTE DESCRIPTION <code>tile_index</code> <p>Index of this tile in the chain (0-based)</p> <p> TYPE: <code>int</code> </p> <code>accel_meas_x</code> <p>Accelerometer measurement X</p> <p> TYPE: <code>int</code> </p> <code>accel_meas_y</code> <p>Accelerometer measurement Y</p> <p> TYPE: <code>int</code> </p> <code>accel_meas_z</code> <p>Accelerometer measurement Z</p> <p> TYPE: <code>int</code> </p> <code>user_x</code> <p>User-defined X position</p> <p> TYPE: <code>float</code> </p> <code>user_y</code> <p>User-defined Y position</p> <p> TYPE: <code>float</code> </p> <code>width</code> <p>Tile width in zones</p> <p> TYPE: <code>int</code> </p> <code>height</code> <p>Tile height in zones</p> <p> TYPE: <code>int</code> </p> <code>supported_frame_buffers</code> <p>frame buffer count</p> <p> TYPE: <code>int</code> </p> <code>device_version_vendor</code> <p>Device vendor ID</p> <p> TYPE: <code>int</code> </p> <code>device_version_product</code> <p>Device product ID</p> <p> TYPE: <code>int</code> </p> <code>device_version_version</code> <p>Device version</p> <p> TYPE: <code>int</code> </p> <code>firmware_build</code> <p>Firmware build timestamp</p> <p> TYPE: <code>int</code> </p> <code>firmware_version_minor</code> <p>Firmware minor version</p> <p> TYPE: <code>int</code> </p> <code>firmware_version_major</code> <p>Firmware major version</p> <p> TYPE: <code>int</code> </p> METHOD DESCRIPTION <code>from_protocol</code> <p>Create TileInfo from protocol TileStateDevice.</p>"},{"location":"api/devices/#lifx.devices.matrix.TileInfo-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.matrix.TileInfo.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return TileInfo as dictionary.</p>"},{"location":"api/devices/#lifx.devices.matrix.TileInfo.total_zones","title":"total_zones  <code>property</code>","text":"<pre><code>total_zones: int\n</code></pre> <p>Get total number of zones on this tile.</p>"},{"location":"api/devices/#lifx.devices.matrix.TileInfo.requires_frame_buffer","title":"requires_frame_buffer  <code>property</code>","text":"<pre><code>requires_frame_buffer: bool\n</code></pre> <p>Check if tile has more than 64 zones (requires frame buffer strategy).</p>"},{"location":"api/devices/#lifx.devices.matrix.TileInfo.nearest_orientation","title":"nearest_orientation  <code>property</code>","text":"<pre><code>nearest_orientation: str\n</code></pre> <p>Determine the orientation of the tile from accelerometer data.</p>"},{"location":"api/devices/#lifx.devices.matrix.TileInfo-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.matrix.TileInfo.from_protocol","title":"from_protocol  <code>classmethod</code>","text":"<pre><code>from_protocol(tile_index: int, protocol_tile: TileStateDevice) -&gt; TileInfo\n</code></pre> <p>Create TileInfo from protocol TileStateDevice.</p> PARAMETER DESCRIPTION <code>tile_index</code> <p>Index of this tile in the chain (0-based)</p> <p> TYPE: <code>int</code> </p> <code>protocol_tile</code> <p>Protocol TileStateDevice object</p> <p> TYPE: <code>TileStateDevice</code> </p> RETURNS DESCRIPTION <code>TileInfo</code> <p>TileInfo instance</p> Source code in <code>src/lifx/devices/matrix.py</code> <pre><code>@classmethod\ndef from_protocol(\n    cls, tile_index: int, protocol_tile: LifxProtocolTileDevice\n) -&gt; TileInfo:\n    \"\"\"Create TileInfo from protocol TileStateDevice.\n\n    Args:\n        tile_index: Index of this tile in the chain (0-based)\n        protocol_tile: Protocol TileStateDevice object\n\n    Returns:\n        TileInfo instance\n    \"\"\"\n    return cls(\n        tile_index=tile_index,\n        accel_meas_x=protocol_tile.accel_meas.x,\n        accel_meas_y=protocol_tile.accel_meas.y,\n        accel_meas_z=protocol_tile.accel_meas.z,\n        user_x=protocol_tile.user_x,\n        user_y=protocol_tile.user_y,\n        width=protocol_tile.width,\n        height=protocol_tile.height,\n        supported_frame_buffers=protocol_tile.supported_frame_buffers,\n        device_version_vendor=protocol_tile.device_version.vendor,\n        device_version_product=protocol_tile.device_version.product,\n        device_version_version=0,  # Not available in TileStateDevice\n        firmware_build=protocol_tile.firmware.build,\n        firmware_version_minor=protocol_tile.firmware.version_minor,\n        firmware_version_major=protocol_tile.firmware.version_major,\n    )\n</code></pre>"},{"location":"api/devices/#matrixeffect","title":"MatrixEffect","text":"<p>Configuration dataclass for matrix effects (MORPH, FLAME, SKY). Used with <code>MatrixLight.set_effect()</code> and returned by <code>MatrixLight.get_effect()</code>.</p>"},{"location":"api/devices/#lifx.devices.matrix.MatrixEffect","title":"MatrixEffect  <code>dataclass</code>","text":"<pre><code>MatrixEffect(\n    effect_type: FirmwareEffect,\n    speed: int,\n    duration: int = 0,\n    palette: list[HSBK] | None = None,\n    sky_type: TileEffectSkyType = SUNRISE,\n    cloud_saturation_min: int = 0,\n    cloud_saturation_max: int = 0,\n)\n</code></pre> <p>Matrix effect configuration.</p> ATTRIBUTE DESCRIPTION <code>effect_type</code> <p>Type of effect (OFF, MORPH, FLAME, SKY)</p> <p> TYPE: <code>FirmwareEffect</code> </p> <code>speed</code> <p>Effect speed in milliseconds</p> <p> TYPE: <code>int</code> </p> <code>duration</code> <p>Total effect duration in nanoseconds (0 for infinite)</p> <p> TYPE: <code>int</code> </p> <code>palette</code> <p>Color palette for the effect (max 16 colors)</p> <p> TYPE: <code>list[HSBK] | None</code> </p> <code>sky_type</code> <p>Sky effect type (SUNRISE, SUNSET, CLOUDS)</p> <p> TYPE: <code>TileEffectSkyType</code> </p> <code>cloud_saturation_min</code> <p>Minimum cloud saturation (0-255, for CLOUDS sky type)</p> <p> TYPE: <code>int</code> </p> <code>cloud_saturation_max</code> <p>Maximum cloud saturation (0-255, for CLOUDS sky type)</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/devices/#ceiling-light","title":"Ceiling Light","text":"<p>The <code>CeilingLight</code> class extends <code>MatrixLight</code> with independent control over uplight and downlight components for LIFX Ceiling fixtures.</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight","title":"CeilingLight","text":"<pre><code>CeilingLight(\n    serial: str,\n    ip: str,\n    port: int = 56700,\n    timeout: float = 0.5,\n    max_retries: int = 3,\n    state_file: str | None = None,\n)\n</code></pre> <p>               Bases: <code>MatrixLight</code></p> <p>LIFX Ceiling Light with independent uplight and downlight control.</p> <p>CeilingLight extends MatrixLight to provide semantic control over uplight and downlight components while maintaining full backward compatibility with the MatrixLight API.</p> <p>The uplight component is the last zone in the matrix, and the downlight component consists of all other zones.</p> Example <pre><code>from lifx.devices import CeilingLight\nfrom lifx.color import HSBK\n\nasync with await CeilingLight.from_ip(\"192.168.1.100\") as ceiling:\n    # Independent component control\n    await ceiling.set_downlight_colors(HSBK(hue=0, sat=0, bri=1.0, kelvin=3500))\n    await ceiling.set_uplight_color(HSBK(hue=30, sat=0.2, bri=0.3, kelvin=2700))\n\n    # Turn components on/off\n    await ceiling.turn_downlight_on()\n    await ceiling.turn_uplight_off()\n\n    # Check component state\n    if ceiling.uplight_is_on:\n        print(\"Uplight is on\")\n</code></pre> PARAMETER DESCRIPTION <code>serial</code> <p>Device serial number</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port (default: 56700)</p> <p> TYPE: <code>int</code> DEFAULT: <code>56700</code> </p> <code>timeout</code> <p>Overall timeout for network requests in seconds (default: 0.5)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>max_retries</code> <p>Maximum number of retry attempts for network requests (default: 3)</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>state_file</code> <p>Optional path to JSON file for state persistence</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>LifxError</code> <p>If device is not a supported Ceiling product</p> METHOD DESCRIPTION <code>refresh_state</code> <p>Refresh ceiling light state from hardware.</p> <code>from_ip</code> <p>Create CeilingLight from IP address.</p> <code>get_uplight_color</code> <p>Get current uplight component color from device.</p> <code>get_downlight_colors</code> <p>Get current downlight component colors from device.</p> <code>set_uplight_color</code> <p>Set uplight component color.</p> <code>set_downlight_colors</code> <p>Set downlight component colors.</p> <code>turn_uplight_on</code> <p>Turn uplight component on.</p> <code>turn_uplight_off</code> <p>Turn uplight component off.</p> <code>turn_downlight_on</code> <p>Turn downlight component on.</p> <code>set_power</code> <p>Set light power state, capturing component colors before turning off.</p> <code>turn_downlight_off</code> <p>Turn downlight component off.</p> ATTRIBUTE DESCRIPTION <code>state</code> <p>Get Ceiling light state.</p> <p> TYPE: <code>CeilingLightState</code> </p> <code>uplight_zone</code> <p>Zone index of the uplight component.</p> <p> TYPE: <code>int</code> </p> <code>downlight_zones</code> <p>Slice representing the downlight component zones.</p> <p> TYPE: <code>slice</code> </p> <code>uplight_is_on</code> <p>True if uplight component is currently on.</p> <p> TYPE: <code>bool</code> </p> <code>downlight_is_on</code> <p>True if downlight component is currently on.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = 56700,  # LIFX_UDP_PORT\n    timeout: float = 0.5,  # DEFAULT_REQUEST_TIMEOUT\n    max_retries: int = 3,  # DEFAULT_MAX_RETRIES\n    state_file: str | None = None,\n):\n    \"\"\"Initialize CeilingLight.\n\n    Args:\n        serial: Device serial number\n        ip: Device IP address\n        port: Device UDP port (default: 56700)\n        timeout: Overall timeout for network requests in seconds\n            (default: 0.5)\n        max_retries: Maximum number of retry attempts for network requests\n            (default: 3)\n        state_file: Optional path to JSON file for state persistence\n\n    Raises:\n        LifxError: If device is not a supported Ceiling product\n    \"\"\"\n    super().__init__(serial, ip, port, timeout, max_retries)\n    self._state_file = state_file\n    self._stored_uplight_state: HSBK | None = None\n    self._stored_downlight_state: list[HSBK] | None = None\n    self._last_uplight_color: HSBK | None = None\n    self._last_downlight_colors: list[HSBK] | None = None\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.state","title":"state  <code>property</code>","text":"<pre><code>state: CeilingLightState\n</code></pre> <p>Get Ceiling light state.</p> RETURNS DESCRIPTION <code>CeilingLightState</code> <p>CeilingLightState with current state information.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If accessed before state initialization.</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.uplight_zone","title":"uplight_zone  <code>property</code>","text":"<pre><code>uplight_zone: int\n</code></pre> <p>Zone index of the uplight component.</p> RETURNS DESCRIPTION <code>int</code> <p>Zone index (63 for standard Ceiling, 127 for Capsule)</p> RAISES DESCRIPTION <code>LifxError</code> <p>If device version is not available or not a Ceiling product</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.downlight_zones","title":"downlight_zones  <code>property</code>","text":"<pre><code>downlight_zones: slice\n</code></pre> <p>Slice representing the downlight component zones.</p> RETURNS DESCRIPTION <code>slice</code> <p>Slice object (slice(0, 63) for standard, slice(0, 127) for Capsule)</p> RAISES DESCRIPTION <code>LifxError</code> <p>If device version is not available or not a Ceiling product</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.uplight_is_on","title":"uplight_is_on  <code>property</code>","text":"<pre><code>uplight_is_on: bool\n</code></pre> <p>True if uplight component is currently on.</p> <p>Calculated as: power_level &gt; 0 AND uplight brightness &gt; 0</p> Note <p>Requires recent data from device. Call get_uplight_color() or get_power() to refresh cached values before checking this property.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if uplight component is on, False otherwise</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.downlight_is_on","title":"downlight_is_on  <code>property</code>","text":"<pre><code>downlight_is_on: bool\n</code></pre> <p>True if downlight component is currently on.</p> <p>Calculated as: power_level &gt; 0 AND NOT all downlight zones have brightness == 0</p> Note <p>Requires recent data from device. Call get_downlight_colors() or get_power() to refresh cached values before checking this property.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if downlight component is on, False otherwise</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.refresh_state","title":"refresh_state  <code>async</code>","text":"<pre><code>refresh_state() -&gt; None\n</code></pre> <p>Refresh ceiling light state from hardware.</p> <p>Fetches color, tiles, tile colors, effect, and ceiling component state.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If state has not been initialized</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxDeviceNotFoundError</code> <p>If device cannot be reached</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def refresh_state(self) -&gt; None:\n    \"\"\"Refresh ceiling light state from hardware.\n\n    Fetches color, tiles, tile colors, effect, and ceiling component state.\n\n    Raises:\n        RuntimeError: If state has not been initialized\n        LifxTimeoutError: If device does not respond\n        LifxDeviceNotFoundError: If device cannot be reached\n    \"\"\"\n    await super().refresh_state()\n\n    # Get ceiling component colors\n    uplight_color = await self.get_uplight_color()\n    downlight_colors = await self.get_downlight_colors()\n\n    # Update ceiling-specific state fields\n    state = cast(CeilingLightState, self._state)\n    state.uplight_color = uplight_color\n    state.downlight_colors = downlight_colors\n    state.uplight_is_on = bool(\n        self.state.power &gt; 0 and uplight_color.brightness &gt; 0\n    )\n    state.downlight_is_on = bool(\n        self.state.power &gt; 0 and any(c.brightness &gt; 0 for c in downlight_colors)\n    )\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.from_ip","title":"from_ip  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_ip(\n    ip: str,\n    port: int = 56700,\n    serial: str | None = None,\n    timeout: float = 0.5,\n    max_retries: int = 3,\n    *,\n    state_file: str | None = None,\n) -&gt; CeilingLight\n</code></pre> <p>Create CeilingLight from IP address.</p> PARAMETER DESCRIPTION <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Port number (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>56700</code> </p> <code>serial</code> <p>Serial number as 12-digit hex string</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Request timeout for this device instance</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>max_retries</code> <p>Maximum number of retries for requests</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>state_file</code> <p>Optional path to JSON file for state persistence</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CeilingLight</code> <p>CeilingLight instance</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>Device not found at IP</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> <code>LifxError</code> <p>Device is not a supported Ceiling product</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>@classmethod\nasync def from_ip(\n    cls,\n    ip: str,\n    port: int = 56700,  # LIFX_UDP_PORT\n    serial: str | None = None,\n    timeout: float = 0.5,  # DEFAULT_REQUEST_TIMEOUT\n    max_retries: int = 3,  # DEFAULT_MAX_RETRIES\n    *,\n    state_file: str | None = None,\n) -&gt; CeilingLight:\n    \"\"\"Create CeilingLight from IP address.\n\n    Args:\n        ip: Device IP address\n        port: Port number (default LIFX_UDP_PORT)\n        serial: Serial number as 12-digit hex string\n        timeout: Request timeout for this device instance\n        max_retries: Maximum number of retries for requests\n        state_file: Optional path to JSON file for state persistence\n\n    Returns:\n        CeilingLight instance\n\n    Raises:\n        LifxDeviceNotFoundError: Device not found at IP\n        LifxTimeoutError: Device did not respond\n        LifxError: Device is not a supported Ceiling product\n    \"\"\"\n    # Use parent class factory method\n    device = await super().from_ip(ip, port, serial, timeout, max_retries)\n    # Type cast to CeilingLight and set state_file\n    ceiling = CeilingLight(device.serial, device.ip)\n    ceiling._state_file = state_file\n    ceiling.connection = device.connection\n    return ceiling\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.get_uplight_color","title":"get_uplight_color  <code>async</code>","text":"<pre><code>get_uplight_color() -&gt; HSBK\n</code></pre> <p>Get current uplight component color from device.</p> RETURNS DESCRIPTION <code>HSBK</code> <p>HSBK color of uplight zone</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>Device did not respond</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def get_uplight_color(self) -&gt; HSBK:\n    \"\"\"Get current uplight component color from device.\n\n    Returns:\n        HSBK color of uplight zone\n\n    Raises:\n        LifxTimeoutError: Device did not respond\n    \"\"\"\n    # Get all colors from tile\n    all_colors = await self.get_all_tile_colors()\n    tile_colors = all_colors[0]  # First tile\n\n    # Extract uplight zone\n    uplight_color = tile_colors[self.uplight_zone]\n\n    # Cache for is_on property\n    self._last_uplight_color = uplight_color\n\n    return uplight_color\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.get_downlight_colors","title":"get_downlight_colors  <code>async</code>","text":"<pre><code>get_downlight_colors() -&gt; list[HSBK]\n</code></pre> <p>Get current downlight component colors from device.</p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors for each downlight zone (63 or 127 zones)</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>Device did not respond</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def get_downlight_colors(self) -&gt; list[HSBK]:\n    \"\"\"Get current downlight component colors from device.\n\n    Returns:\n        List of HSBK colors for each downlight zone (63 or 127 zones)\n\n    Raises:\n        LifxTimeoutError: Device did not respond\n    \"\"\"\n    # Get all colors from tile\n    all_colors = await self.get_all_tile_colors()\n    tile_colors = all_colors[0]  # First tile\n\n    # Extract downlight zones\n    downlight_colors = tile_colors[self.downlight_zones]\n\n    # Cache for is_on property\n    self._last_downlight_colors = downlight_colors\n\n    return downlight_colors\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.set_uplight_color","title":"set_uplight_color  <code>async</code>","text":"<pre><code>set_uplight_color(color: HSBK, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set uplight component color.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If color.brightness == 0 (use turn_uplight_off instead)</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> Note <p>Also updates stored state for future restoration.</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def set_uplight_color(self, color: HSBK, duration: float = 0.0) -&gt; None:\n    \"\"\"Set uplight component color.\n\n    Args:\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If color.brightness == 0 (use turn_uplight_off instead)\n        LifxTimeoutError: Device did not respond\n\n    Note:\n        Also updates stored state for future restoration.\n    \"\"\"\n    if color.brightness == 0:\n        raise ValueError(\n            \"Cannot set uplight color with brightness=0. \"\n            \"Use turn_uplight_off() instead.\"\n        )\n\n    # Get current colors for all zones\n    all_colors = await self.get_all_tile_colors()\n    tile_colors = all_colors[0]\n\n    # Update uplight zone\n    tile_colors[self.uplight_zone] = color\n\n    # Set all colors back (duration in milliseconds for set_matrix_colors)\n    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))\n\n    # Store state\n    self._stored_uplight_state = color\n    self._last_uplight_color = color\n\n    # Persist if enabled\n    if self._state_file:\n        self._save_state_to_file()\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.set_downlight_colors","title":"set_downlight_colors  <code>async</code>","text":"<pre><code>set_downlight_colors(colors: HSBK | list[HSBK], duration: float = 0.0) -&gt; None\n</code></pre> <p>Set downlight component colors.</p> PARAMETER DESCRIPTION <code>colors</code> <p>Either: - Single HSBK: sets all downlight zones to same color - List[HSBK]: sets each zone individually (must match zone count)</p> <p> TYPE: <code>HSBK | list[HSBK]</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any color.brightness == 0 (use turn_downlight_off instead)</p> <code>ValueError</code> <p>If list length doesn't match downlight zone count</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> Note <p>Also updates stored state for future restoration.</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def set_downlight_colors(\n    self, colors: HSBK | list[HSBK], duration: float = 0.0\n) -&gt; None:\n    \"\"\"Set downlight component colors.\n\n    Args:\n        colors: Either:\n            - Single HSBK: sets all downlight zones to same color\n            - List[HSBK]: sets each zone individually (must match zone count)\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If any color.brightness == 0 (use turn_downlight_off instead)\n        ValueError: If list length doesn't match downlight zone count\n        LifxTimeoutError: Device did not respond\n\n    Note:\n        Also updates stored state for future restoration.\n    \"\"\"\n    # Validate and normalize colors\n    if isinstance(colors, HSBK):\n        if colors.brightness == 0:\n            raise ValueError(\n                \"Cannot set downlight color with brightness=0. \"\n                \"Use turn_downlight_off() instead.\"\n            )\n        downlight_colors = [colors] * len(range(*self.downlight_zones.indices(256)))\n    else:\n        if all(c.brightness == 0 for c in colors):\n            raise ValueError(\n                \"Cannot set downlight colors with brightness=0. \"\n                \"Use turn_downlight_off() instead.\"\n            )\n\n        expected_count = len(range(*self.downlight_zones.indices(256)))\n        if len(colors) != expected_count:\n            raise ValueError(\n                f\"Expected {expected_count} colors for downlight, got {len(colors)}\"\n            )\n        downlight_colors = colors\n\n    # Get current colors for all zones\n    all_colors = await self.get_all_tile_colors()\n    tile_colors = all_colors[0]\n\n    # Update downlight zones\n    tile_colors[self.downlight_zones] = downlight_colors\n\n    # Set all colors back\n    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))\n\n    # Store state\n    self._stored_downlight_state = downlight_colors\n    self._last_downlight_colors = downlight_colors\n\n    # Persist if enabled\n    if self._state_file:\n        self._save_state_to_file()\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.turn_uplight_on","title":"turn_uplight_on  <code>async</code>","text":"<pre><code>turn_uplight_on(color: HSBK | None = None, duration: float = 0.0) -&gt; None\n</code></pre> <p>Turn uplight component on.</p> PARAMETER DESCRIPTION <code>color</code> <p>Optional HSBK color. If provided: - Uses this color immediately - Updates stored state If None, uses brightness determination logic</p> <p> TYPE: <code>HSBK | None</code> DEFAULT: <code>None</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If color.brightness == 0</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def turn_uplight_on(\n    self, color: HSBK | None = None, duration: float = 0.0\n) -&gt; None:\n    \"\"\"Turn uplight component on.\n\n    Args:\n        color: Optional HSBK color. If provided:\n            - Uses this color immediately\n            - Updates stored state\n            If None, uses brightness determination logic\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If color.brightness == 0\n        LifxTimeoutError: Device did not respond\n    \"\"\"\n    if color is not None:\n        if color.brightness == 0:\n            raise ValueError(\"Cannot turn on uplight with brightness=0\")\n        await self.set_uplight_color(color, duration)\n    else:\n        # Determine color using priority logic\n        determined_color = await self._determine_uplight_brightness()\n        await self.set_uplight_color(determined_color, duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.turn_uplight_off","title":"turn_uplight_off  <code>async</code>","text":"<pre><code>turn_uplight_off(color: HSBK | None = None, duration: float = 0.0) -&gt; None\n</code></pre> <p>Turn uplight component off.</p> PARAMETER DESCRIPTION <code>color</code> <p>Optional HSBK color to store for future turn_on. If provided, stores this color (with brightness=0 on the device). If None, stores current color from device before turning off.</p> <p> TYPE: <code>HSBK | None</code> DEFAULT: <code>None</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If color.brightness == 0</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> Note <p>Sets uplight zone brightness to 0 on device while preserving H, S, K.</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def turn_uplight_off(\n    self, color: HSBK | None = None, duration: float = 0.0\n) -&gt; None:\n    \"\"\"Turn uplight component off.\n\n    Args:\n        color: Optional HSBK color to store for future turn_on.\n            If provided, stores this color (with brightness=0 on the device).\n            If None, stores current color from device before turning off.\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If color.brightness == 0\n        LifxTimeoutError: Device did not respond\n\n    Note:\n        Sets uplight zone brightness to 0 on device while preserving H, S, K.\n    \"\"\"\n    if color is not None:\n        if color.brightness == 0:\n            raise ValueError(\n                \"Provided color cannot have brightness=0. \"\n                \"Omit the parameter to use current color.\"\n            )\n        # Store the provided color\n        self._stored_uplight_state = color\n    else:\n        # Get and store current color\n        current_color = await self.get_uplight_color()\n        self._stored_uplight_state = current_color\n\n    # Create color with brightness=0 for device\n    off_color = HSBK(\n        hue=self._stored_uplight_state.hue,\n        saturation=self._stored_uplight_state.saturation,\n        brightness=0.0,\n        kelvin=self._stored_uplight_state.kelvin,\n    )\n\n    # Get all colors and update uplight zone\n    all_colors = await self.get_all_tile_colors()\n    tile_colors = all_colors[0]\n    tile_colors[self.uplight_zone] = off_color\n    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))\n\n    # Update cache\n    self._last_uplight_color = off_color\n\n    # Persist if enabled\n    if self._state_file:\n        self._save_state_to_file()\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.turn_downlight_on","title":"turn_downlight_on  <code>async</code>","text":"<pre><code>turn_downlight_on(\n    colors: HSBK | list[HSBK] | None = None, duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Turn downlight component on.</p> PARAMETER DESCRIPTION <code>colors</code> <p>Optional colors. Can be: - None: uses brightness determination logic - Single HSBK: sets all downlight zones to same color - List[HSBK]: sets each zone individually (must match zone count) If provided, updates stored state.</p> <p> TYPE: <code>HSBK | list[HSBK] | None</code> DEFAULT: <code>None</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any color.brightness == 0</p> <code>ValueError</code> <p>If list length doesn't match downlight zone count</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def turn_downlight_on(\n    self, colors: HSBK | list[HSBK] | None = None, duration: float = 0.0\n) -&gt; None:\n    \"\"\"Turn downlight component on.\n\n    Args:\n        colors: Optional colors. Can be:\n            - None: uses brightness determination logic\n            - Single HSBK: sets all downlight zones to same color\n            - List[HSBK]: sets each zone individually (must match zone count)\n            If provided, updates stored state.\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If any color.brightness == 0\n        ValueError: If list length doesn't match downlight zone count\n        LifxTimeoutError: Device did not respond\n    \"\"\"\n    if colors is not None:\n        await self.set_downlight_colors(colors, duration)\n    else:\n        # Determine colors using priority logic\n        determined_colors = await self._determine_downlight_brightness()\n        await self.set_downlight_colors(determined_colors, duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(level: bool | int, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set light power state, capturing component colors before turning off.</p> <p>Overrides Light.set_power() to capture the current uplight and downlight colors before turning off the entire light. This allows subsequent calls to turn_uplight_on() or turn_downlight_on() to restore the colors that were active just before the light was turned off.</p> <p>The captured colors preserve hue, saturation, and kelvin values even if a component was already off (brightness=0). The brightness will be determined at turn-on time using the standard brightness inference logic.</p> PARAMETER DESCRIPTION <code>level</code> <p>True/65535 to turn on, False/0 to turn off</p> <p> TYPE: <code>bool | int</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If integer value is not 0 or 65535</p> <code>LifxDeviceNotFoundError</code> <p>If device is not connected</p> <code>LifxTimeoutError</code> <p>If device does not respond</p> <code>LifxUnsupportedCommandError</code> <p>If device doesn't support this command</p> Example <pre><code># Turn off entire ceiling light (captures colors for later)\nawait ceiling.set_power(False)\n\n# Later, turn on just the uplight with its previous color\nawait ceiling.turn_uplight_on()\n\n# Or turn on just the downlight with its previous colors\nawait ceiling.turn_downlight_on()\n</code></pre> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def set_power(self, level: bool | int, duration: float = 0.0) -&gt; None:\n    \"\"\"Set light power state, capturing component colors before turning off.\n\n    Overrides Light.set_power() to capture the current uplight and downlight\n    colors before turning off the entire light. This allows subsequent calls\n    to turn_uplight_on() or turn_downlight_on() to restore the colors that\n    were active just before the light was turned off.\n\n    The captured colors preserve hue, saturation, and kelvin values even if\n    a component was already off (brightness=0). The brightness will be\n    determined at turn-on time using the standard brightness inference logic.\n\n    Args:\n        level: True/65535 to turn on, False/0 to turn off\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If integer value is not 0 or 65535\n        LifxDeviceNotFoundError: If device is not connected\n        LifxTimeoutError: If device does not respond\n        LifxUnsupportedCommandError: If device doesn't support this command\n\n    Example:\n        ```python\n        # Turn off entire ceiling light (captures colors for later)\n        await ceiling.set_power(False)\n\n        # Later, turn on just the uplight with its previous color\n        await ceiling.turn_uplight_on()\n\n        # Or turn on just the downlight with its previous colors\n        await ceiling.turn_downlight_on()\n        ```\n    \"\"\"\n    # Determine if we're turning off\n    if isinstance(level, bool):\n        turning_off = not level\n    elif isinstance(level, int):\n        if level not in (0, 65535):\n            raise ValueError(f\"Power level must be 0 or 65535, got {level}\")\n        turning_off = level == 0\n    else:\n        raise TypeError(f\"Expected bool or int, got {type(level).__name__}\")\n\n    # If turning off, capture current colors for both components\n    if turning_off:\n        # Always capture colors - even if brightness is 0, the hue/sat/kelvin\n        # are still useful for turn_on. Brightness will be determined at\n        # turn-on time using the standard inference logic.\n        self._stored_uplight_state = await self.get_uplight_color()\n        self._stored_downlight_state = await self.get_downlight_colors()\n\n        # Persist if enabled\n        if self._state_file:\n            self._save_state_to_file()\n\n    # Call parent to perform actual power change\n    await super().set_power(level, duration)\n</code></pre>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLight.turn_downlight_off","title":"turn_downlight_off  <code>async</code>","text":"<pre><code>turn_downlight_off(\n    colors: HSBK | list[HSBK] | None = None, duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Turn downlight component off.</p> PARAMETER DESCRIPTION <code>colors</code> <p>Optional colors to store for future turn_on. Can be: - None: stores current colors from device - Single HSBK: stores this color for all zones - List[HSBK]: stores individual colors (must match zone count) If provided, stores these colors (with brightness=0 on device).</p> <p> TYPE: <code>HSBK | list[HSBK] | None</code> DEFAULT: <code>None</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any color.brightness == 0</p> <code>ValueError</code> <p>If list length doesn't match downlight zone count</p> <code>LifxTimeoutError</code> <p>Device did not respond</p> Note <p>Sets all downlight zone brightness to 0 on device while preserving H, S, K.</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>async def turn_downlight_off(\n    self, colors: HSBK | list[HSBK] | None = None, duration: float = 0.0\n) -&gt; None:\n    \"\"\"Turn downlight component off.\n\n    Args:\n        colors: Optional colors to store for future turn_on. Can be:\n            - None: stores current colors from device\n            - Single HSBK: stores this color for all zones\n            - List[HSBK]: stores individual colors (must match zone count)\n            If provided, stores these colors (with brightness=0 on device).\n        duration: Transition duration in seconds (default 0.0)\n\n    Raises:\n        ValueError: If any color.brightness == 0\n        ValueError: If list length doesn't match downlight zone count\n        LifxTimeoutError: Device did not respond\n\n    Note:\n        Sets all downlight zone brightness to 0 on device while preserving H, S, K.\n    \"\"\"\n    expected_count = len(range(*self.downlight_zones.indices(256)))\n\n    if colors is not None:\n        # Validate and normalize provided colors\n        if isinstance(colors, HSBK):\n            if colors.brightness == 0:\n                raise ValueError(\n                    \"Provided color cannot have brightness=0. \"\n                    \"Omit the parameter to use current colors.\"\n                )\n            colors_to_store = [colors] * expected_count\n        else:\n            if all(c.brightness == 0 for c in colors):\n                raise ValueError(\n                    \"Provided colors cannot have brightness=0. \"\n                    \"Omit the parameter to use current colors.\"\n                )\n            if len(colors) != expected_count:\n                raise ValueError(\n                    f\"Expected {expected_count} colors for downlight, \"\n                    f\"got {len(colors)}\"\n                )\n            colors_to_store = colors\n\n        self._stored_downlight_state = colors_to_store\n    else:\n        # Get and store current colors\n        current_colors = await self.get_downlight_colors()\n        self._stored_downlight_state = current_colors\n\n    # Create colors with brightness=0 for device\n    off_colors = [\n        HSBK(\n            hue=c.hue,\n            saturation=c.saturation,\n            brightness=0.0,\n            kelvin=c.kelvin,\n        )\n        for c in self._stored_downlight_state\n    ]\n\n    # Get all colors and update downlight zones\n    all_colors = await self.get_all_tile_colors()\n    tile_colors = all_colors[0]\n    tile_colors[self.downlight_zones] = off_colors\n    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))\n\n    # Update cache\n    self._last_downlight_colors = off_colors\n\n    # Persist if enabled\n    if self._state_file:\n        self._save_state_to_file()\n</code></pre>"},{"location":"api/devices/#ceilinglightstate","title":"CeilingLightState","text":"<p>The <code>CeilingLightState</code> dataclass extends <code>MatrixLightState</code> with ceiling-specific component information. It is returned by <code>CeilingLight.state</code> after connecting to a device.</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLightState","title":"CeilingLightState  <code>dataclass</code>","text":"<pre><code>CeilingLightState(\n    model: str,\n    label: str,\n    serial: str,\n    mac_address: str,\n    capabilities: DeviceCapabilities,\n    power: int,\n    host_firmware: FirmwareInfo,\n    wifi_firmware: FirmwareInfo,\n    location: CollectionInfo,\n    group: CollectionInfo,\n    last_updated: float,\n    color: HSBK,\n    chain: list[TileInfo],\n    tile_orientations: dict[int, str],\n    tile_colors: list[HSBK],\n    tile_count: int,\n    effect: FirmwareEffect,\n    uplight_color: HSBK,\n    downlight_colors: list[HSBK],\n    uplight_is_on: bool,\n    downlight_is_on: bool,\n    uplight_zone: int,\n    downlight_zones: slice,\n)\n</code></pre> <p>               Bases: <code>MatrixLightState</code></p> <p>Ceiling light device state with uplight/downlight component control.</p> <p>Extends MatrixLightState with ceiling-specific component information.</p> ATTRIBUTE DESCRIPTION <code>uplight_color</code> <p>Current HSBK color of the uplight component</p> <p> TYPE: <code>HSBK</code> </p> <code>downlight_colors</code> <p>List of HSBK colors for each downlight zone</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>uplight_is_on</code> <p>Whether uplight component is on (brightness &gt; 0)</p> <p> TYPE: <code>bool</code> </p> <code>downlight_is_on</code> <p>Whether downlight component is on (any zone brightness &gt; 0)</p> <p> TYPE: <code>bool</code> </p> <code>uplight_zone</code> <p>Zone index for the uplight component</p> <p> TYPE: <code>int</code> </p> <code>downlight_zones</code> <p>Slice representing downlight component zones</p> <p> TYPE: <code>slice</code> </p> METHOD DESCRIPTION <code>from_matrix_state</code> <p>Create CeilingLightState from MatrixLightState.</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLightState-attributes","title":"Attributes","text":""},{"location":"api/devices/#lifx.devices.ceiling.CeilingLightState.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: Any\n</code></pre> <p>Return CeilingLightState as dict.</p>"},{"location":"api/devices/#lifx.devices.ceiling.CeilingLightState-functions","title":"Functions","text":""},{"location":"api/devices/#lifx.devices.ceiling.CeilingLightState.from_matrix_state","title":"from_matrix_state  <code>classmethod</code>","text":"<pre><code>from_matrix_state(\n    matrix_state: MatrixLightState,\n    uplight_color: HSBK,\n    downlight_colors: list[HSBK],\n    uplight_zone: int,\n    downlight_zones: slice,\n) -&gt; CeilingLightState\n</code></pre> <p>Create CeilingLightState from MatrixLightState.</p> PARAMETER DESCRIPTION <code>matrix_state</code> <p>Base MatrixLightState to extend</p> <p> TYPE: <code>MatrixLightState</code> </p> <code>uplight_color</code> <p>Current uplight zone color</p> <p> TYPE: <code>HSBK</code> </p> <code>downlight_colors</code> <p>Current downlight zone colors</p> <p> TYPE: <code>list[HSBK]</code> </p> <code>uplight_zone</code> <p>Zone index for uplight component</p> <p> TYPE: <code>int</code> </p> <code>downlight_zones</code> <p>Slice representing downlight component zones</p> <p> TYPE: <code>slice</code> </p> RETURNS DESCRIPTION <code>CeilingLightState</code> <p>CeilingLightState with all matrix state plus ceiling components</p> Source code in <code>src/lifx/devices/ceiling.py</code> <pre><code>@classmethod\ndef from_matrix_state(\n    cls,\n    matrix_state: MatrixLightState,\n    uplight_color: HSBK,\n    downlight_colors: list[HSBK],\n    uplight_zone: int,\n    downlight_zones: slice,\n) -&gt; CeilingLightState:\n    \"\"\"Create CeilingLightState from MatrixLightState.\n\n    Args:\n        matrix_state: Base MatrixLightState to extend\n        uplight_color: Current uplight zone color\n        downlight_colors: Current downlight zone colors\n        uplight_zone: Zone index for uplight component\n        downlight_zones: Slice representing downlight component zones\n\n    Returns:\n        CeilingLightState with all matrix state plus ceiling components\n    \"\"\"\n    return cls(\n        model=matrix_state.model,\n        label=matrix_state.label,\n        serial=matrix_state.serial,\n        mac_address=matrix_state.mac_address,\n        power=matrix_state.power,\n        capabilities=matrix_state.capabilities,\n        host_firmware=matrix_state.host_firmware,\n        wifi_firmware=matrix_state.wifi_firmware,\n        location=matrix_state.location,\n        group=matrix_state.group,\n        color=matrix_state.color,\n        chain=matrix_state.chain,\n        tile_orientations=matrix_state.tile_orientations,\n        tile_colors=matrix_state.tile_colors,\n        tile_count=matrix_state.tile_count,\n        effect=matrix_state.effect,\n        uplight_color=uplight_color,\n        downlight_colors=downlight_colors,\n        uplight_is_on=uplight_color.brightness &gt; 0,\n        downlight_is_on=any(c.brightness &gt; 0 for c in downlight_colors),\n        uplight_zone=uplight_zone,\n        downlight_zones=downlight_zones,\n        last_updated=time.time(),\n    )\n</code></pre>"},{"location":"api/devices/#device-properties","title":"Device Properties","text":""},{"location":"api/devices/#mac-address","title":"MAC Address","text":"<p>The <code>mac_address</code> property provides the device's MAC address, calculated from the serial number and host firmware version. The calculation is performed automatically when the device is used as a context manager or when <code>get_host_firmware()</code> is called.</p> <p>Calculation Logic (based on host firmware major version):</p> <ul> <li>Version 2 or 4: MAC address matches the serial number</li> <li>Version 3: MAC address is the serial number with the least significant byte incremented by 1 (with wraparound from 0xFF to 0x00)</li> <li>Unknown versions: Defaults to the serial number</li> </ul> <p>The MAC address is returned in colon-separated lowercase hexadecimal format (e.g., <code>d0:73:d5:01:02:03</code>) to visually distinguish it from the serial number format.</p> <pre><code>from lifx import Device\n\nasync def main():\n    async with await Device.from_ip(\"192.168.1.100\") as device:\n        # MAC address is automatically calculated during setup\n        if device.mac_address:\n            print(f\"Serial: {device.serial}\")\n            print(f\"MAC:    {device.mac_address}\")\n\n        # Returns None before host_firmware is fetched\n        assert device.mac_address is not None\n</code></pre>"},{"location":"api/devices/#examples","title":"Examples","text":""},{"location":"api/devices/#basic-light-control","title":"Basic Light Control","text":"<pre><code>from lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Turn on and set color\n        await light.set_power(True)\n        await light.set_color(Colors.BLUE, duration=1.0)\n\n        # Get device info\n        label = await light.get_label()\n        print(f\"Controlling: {label}\")\n</code></pre>"},{"location":"api/devices/#light-effects","title":"Light Effects","text":"<pre><code>from lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Pulse effect\n        await light.pulse(Colors.RED, period=1.0, cycles=5)\n\n        # Breathe effect\n        await light.breathe(Colors.BLUE, period=2.0, cycles=3)\n</code></pre>"},{"location":"api/devices/#hev-light-control-anti-bacterial-cleaning","title":"HEV Light Control (Anti-Bacterial Cleaning)","text":"<pre><code>from lifx import HevLight\n\n\nasync def main():\n    async with await HevLight.from_ip(\"192.168.1.100\") as light:\n        # Start a 2-hour cleaning cycle\n        await light.set_hev_cycle(enable=True, duration_seconds=7200)\n\n        # Check cycle status\n        state = await light.get_hev_cycle()\n        if state.is_running:\n            print(f\"Cleaning: {state.remaining_s}s remaining\")\n\n        # Configure default settings\n        await light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre>"},{"location":"api/devices/#infrared-light-control-night-vision","title":"Infrared Light Control (Night Vision)","text":"<pre><code>from lifx import InfraredLight\n\n\nasync def main():\n    async with await InfraredLight.from_ip(\"192.168.1.100\") as light:\n        # Set infrared brightness to 50%\n        await light.set_infrared(0.5)\n\n        # Get current infrared brightness\n        brightness = await light.get_infrared()\n        print(f\"IR brightness: {brightness * 100}%\")\n</code></pre>"},{"location":"api/devices/#ambient-light-sensor","title":"Ambient Light Sensor","text":"<p>Light devices with ambient light sensors can measure the current ambient light level in lux:</p> <pre><code>from lifx import Light\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Ensure light is off for accurate reading\n        await light.set_power(False)\n\n        # Get ambient light level in lux\n        lux = await light.get_ambient_light_level()\n        if lux &gt; 0:\n            print(f\"Ambient light: {lux} lux\")\n        else:\n            print(\"No ambient light sensor or completely dark\")\n</code></pre> <p>Notes:</p> <ul> <li>Devices without ambient light sensors return 0.0 (not an error)</li> <li>For accurate readings, the light should be turned off (otherwise the light's own illumination interferes with the sensor)</li> <li>This is a volatile property - always fetched fresh from the device</li> <li>A reading of 0.0 could mean either no sensor or complete darkness</li> <li>Returns ambient light level in lux (higher values indicate brighter ambient light)</li> </ul>"},{"location":"api/devices/#multizone-control","title":"MultiZone Control","text":"<pre><code>from lifx import MultiZoneLight, Colors, FirmwareEffect, Direction\n\n\nasync def main():\n    async with await MultiZoneLight.from_ip(\"192.168.1.100\") as light:\n        # Get all zones - automatically uses best method\n        colors = await light.get_all_color_zones()\n        print(f\"Device has {len(colors)} zones\")\n\n        # Set a MOVE effect\n        await light.set_effect(\n            effect_type=FirmwareEffect.MOVE,\n            speed=5.0,  # seconds per cycle\n            direction=Direction.FORWARD,\n        )\n\n        # Get current effect\n        effect = await light.get_effect()\n        print(f\"Effect: {effect.effect_type.name}\")\n        if effect.effect_type == FirmwareEffect.MOVE:\n            print(f\"Direction: {effect.direction.name}\")\n\n        # Stop the effect\n        await light.set_effect(effect_type=FirmwareEffect.OFF)\n</code></pre>"},{"location":"api/devices/#tile-control","title":"Tile Control","text":"<pre><code>from lifx import MatrixLight, HSBK, FirmwareEffect\n\n\nasync def main():\n    async with await MatrixLight.from_ip(\"192.168.1.100\") as light:\n        # Set a gradient across the tile\n        colors = [\n            HSBK(hue=h, saturation=1.0, brightness=0.5, kelvin=3500)\n            for h in range(0, 360, 10)\n        ]\n        await light.set_tile_colors(colors)\n\n        # Set a tile effect (MORPH, FLAME, or SKY)\n        await light.set_effect(\n            effect_type=FirmwareEffect.FLAME,\n            speed=5.0,  # seconds per cycle\n        )\n\n        # Get current effect\n        effect = await light.get_effect()\n        print(f\"Tile effect: {effect.effect_type.name}\")\n\n        # Stop the effect\n        await light.set_effect(effect_type=FirmwareEffect.OFF)\n</code></pre>"},{"location":"api/devices/#ceiling-light-control","title":"Ceiling Light Control","text":"<pre><code>from lifx import CeilingLight, HSBK\n\n\nasync def main():\n    async with await CeilingLight.from_ip(\"192.168.1.100\") as ceiling:\n        # Set downlight to warm white\n        await ceiling.set_downlight_colors(\n            HSBK(hue=0, saturation=0, brightness=0.8, kelvin=3000)\n        )\n\n        # Set uplight to a dim ambient glow\n        await ceiling.set_uplight_color(\n            HSBK(hue=30, saturation=0.2, brightness=0.3, kelvin=2700)\n        )\n\n        # Turn uplight off (stores color for later restoration)\n        await ceiling.turn_uplight_off()\n\n        # Turn uplight back on (restores previous color)\n        await ceiling.turn_uplight_on()\n\n        # Check component state\n        if ceiling.downlight_is_on:\n            print(\"Downlight is currently on\")\n</code></pre> <p>For detailed CeilingLight usage, see the Ceiling Lights User Guide.</p>"},{"location":"api/effects/","title":"Effects Reference","text":"<p>This reference guide provides comprehensive documentation for all built-in effect classes in the Light Effects Framework.</p>"},{"location":"api/effects/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Conductor</li> <li>EffectPulse</li> <li>EffectColorloop</li> <li>LIFXEffect (Base Class)</li> </ul>"},{"location":"api/effects/#conductor","title":"Conductor","text":"<p>The <code>Conductor</code> class is the central orchestrator for managing light effects across multiple devices.</p>"},{"location":"api/effects/#class-definition","title":"Class Definition","text":"<pre><code>from lifx import Conductor\n\nconductor = Conductor()\n</code></pre>"},{"location":"api/effects/#methods","title":"Methods","text":""},{"location":"api/effects/#effectlight-light-lifxeffect-none","title":"<code>effect(light: Light) -&gt; LIFXEffect | None</code>","text":"<p>Return the effect currently running on a device, or None if idle.</p> <p>Parameters:</p> <ul> <li><code>light</code> (Light): The device to check</li> </ul> <p>Returns:</p> <ul> <li><code>LIFXEffect | None</code>: Currently running effect instance, or None</li> </ul> <p>Example:</p> <pre><code>current_effect = conductor.effect(light)\nif current_effect:\n    print(f\"Running: {type(current_effect).__name__}\")\nelse:\n    print(\"No effect running\")\n</code></pre>"},{"location":"api/effects/#starteffect-lifxeffect-participants-listlight-none","title":"<code>start(effect: LIFXEffect, participants: list[Light]) -&gt; None</code>","text":"<p>Start an effect on one or more lights.</p> <p>Captures current light state, powers on if needed, and launches the effect. State is automatically restored when effect completes or <code>stop()</code> is called.</p> <p>Parameters:</p> <ul> <li><code>effect</code> (LIFXEffect): The effect instance to execute</li> <li><code>participants</code> (list[Light]): List of Light instances to apply effect to</li> </ul> <p>Raises:</p> <ul> <li><code>LifxTimeoutError</code>: If light state capture times out</li> <li><code>LifxDeviceNotFoundError</code>: If light becomes unreachable</li> </ul> <p>Example:</p> <pre><code>effect = EffectPulse(mode='blink', cycles=5)\nawait conductor.start(effect, [light1, light2])\n</code></pre>"},{"location":"api/effects/#stoplights-listlight-none","title":"<code>stop(lights: list[Light]) -&gt; None</code>","text":"<p>Stop effects and restore light state.</p> <p>Halts any running effects on the specified lights and restores them to their pre-effect state (power, color, zones).</p> <p>Parameters:</p> <ul> <li><code>lights</code> (list[Light]): List of lights to stop</li> </ul> <p>Example:</p> <pre><code># Stop specific lights\nawait conductor.stop([light1, light2])\n\n# Stop all lights in a group\nawait conductor.stop(group.lights)\n</code></pre>"},{"location":"api/effects/#state-management","title":"State Management","text":"<p>The conductor automatically handles:</p> <ol> <li>State Capture: Power state, current color (HSBK), and multizone colors (if applicable)</li> <li>Power Management: Powers on devices if needed for effect visibility</li> <li>Effect Execution: Runs effect logic on all participants</li> <li>State Restoration: Restores all captured state after effect completes</li> </ol>"},{"location":"api/effects/#timing-considerations","title":"Timing Considerations","text":"<ul> <li>State capture: &lt;1 second per device (mostly network I/O)</li> <li>State restoration: 0.6-1.0 seconds per device (includes required 0.3s delays)</li> <li>All operations use concurrent execution for multiple devices</li> </ul>"},{"location":"api/effects/#effectpulse","title":"EffectPulse","text":"<p>Pulse/blink/breathe effects using LIFX waveform modes. Supports five distinct modes with configurable timing and colors.</p>"},{"location":"api/effects/#class-definition_1","title":"Class Definition","text":"<pre><code>from lifx import EffectPulse, HSBK\n\neffect = EffectPulse(\n    power_on=True,\n    mode='blink',\n    period=None,\n    cycles=None,\n    hsbk=None\n)\n</code></pre>"},{"location":"api/effects/#parameters","title":"Parameters","text":""},{"location":"api/effects/#power_on-bool-default-true","title":"<code>power_on</code> (bool, default: <code>True</code>)","text":"<p>Whether to power on devices during effect. If <code>True</code>, devices that are off will be powered on before the effect starts.</p>"},{"location":"api/effects/#mode-str-default-blink","title":"<code>mode</code> (str, default: <code>'blink'</code>)","text":"<p>Pulse mode to use. Must be one of:</p> <ul> <li><code>'blink'</code>: Standard on/off toggle</li> <li><code>'strobe'</code>: Rapid flashing</li> <li><code>'breathe'</code>: Smooth breathing effect</li> <li><code>'ping'</code>: Single pulse with asymmetric duty cycle</li> <li><code>'solid'</code>: Minimal brightness variation</li> </ul>"},{"location":"api/effects/#period-float-none-default-mode-dependent","title":"<code>period</code> (float | None, default: mode-dependent)","text":"<p>Effect period in seconds. If not specified, uses mode default:</p> <ul> <li><code>'strobe'</code>: 0.1 seconds</li> <li>All others: 1.0 second</li> </ul>"},{"location":"api/effects/#cycles-int-none-default-mode-dependent","title":"<code>cycles</code> (int | None, default: mode-dependent)","text":"<p>Number of cycles to execute. If not specified, uses mode default:</p> <ul> <li><code>'strobe'</code>: 10 cycles</li> <li>All others: 1 cycle</li> </ul>"},{"location":"api/effects/#hsbk-hsbk-none-default-none","title":"<code>hsbk</code> (HSBK | None, default: <code>None</code>)","text":"<p>Optional color override. If provided, this color is used instead of automatic color selection. If <code>None</code>, the effect intelligently selects colors based on mode and device capabilities.</p>"},{"location":"api/effects/#pulse-modes","title":"Pulse Modes","text":""},{"location":"api/effects/#blink-mode","title":"Blink Mode","text":"<p>Standard on/off toggle effect.</p> <p>Defaults:</p> <ul> <li>Period: 1.0 second</li> <li>Cycles: 1</li> <li>Waveform: PULSE</li> <li>Behavior: Toggles between current color and off</li> </ul> <p>Example:</p> <pre><code># Basic blink - 5 cycles\neffect = EffectPulse(mode='blink', cycles=5)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(6)  # 5 cycles * 1s + buffer\n</code></pre> <p>Best for: Notifications, alerts, attention-getting</p>"},{"location":"api/effects/#strobe-mode","title":"Strobe Mode","text":"<p>Rapid flashing effect.</p> <p>Defaults:</p> <ul> <li>Period: 0.1 second</li> <li>Cycles: 10</li> <li>Waveform: PULSE</li> <li>Behavior: Rapid flashing from dark (cold white)</li> </ul> <p>Example:</p> <pre><code># Rapid strobe - 20 flashes\neffect = EffectPulse(mode='strobe', cycles=20)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(3)  # 20 * 0.1s + buffer\n</code></pre> <p>Best for: Emergency notifications, dramatic effects</p> <p>Note: Strobe mode starts from dark (0 brightness, cold white) for maximum impact.</p>"},{"location":"api/effects/#breathe-mode","title":"Breathe Mode","text":"<p>Smooth, gentle breathing effect using SINE waveform.</p> <p>Defaults:</p> <ul> <li>Period: 1.0 second</li> <li>Cycles: 1</li> <li>Waveform: SINE (smooth)</li> <li>Behavior: Smooth fade in and out</li> </ul> <p>Example:</p> <pre><code># Slow breathing effect\neffect = EffectPulse(mode='breathe', period=2.0, cycles=5)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(11)  # 5 * 2s + buffer\n</code></pre> <p>Best for: Relaxation, meditation, ambient effects</p>"},{"location":"api/effects/#ping-mode","title":"Ping Mode","text":"<p>Single pulse with asymmetric duty cycle.</p> <p>Defaults:</p> <ul> <li>Period: 1.0 second</li> <li>Cycles: 1</li> <li>Waveform: PULSE</li> <li>Skew: 0.1 (10% on, 90% off)</li> <li>Behavior: Quick flash followed by longer off period</li> </ul> <p>Example:</p> <pre><code># Quick ping notification\nred = HSBK.from_rgb(255, 0, 0)\neffect = EffectPulse(mode='ping', color=red)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(2)\n</code></pre> <p>Best for: Quick notifications, heartbeat effects</p>"},{"location":"api/effects/#solid-mode","title":"Solid Mode","text":"<p>Minimal brightness variation, almost solid color.</p> <p>Defaults:</p> <ul> <li>Period: 1.0 second</li> <li>Cycles: 1</li> <li>Waveform: PULSE</li> <li>Skew: 0.0 (minimum variation)</li> <li>Behavior: Very subtle brightness change</li> </ul> <p>Example:</p> <pre><code># Subtle solid pulse\ngreen = HSBK.from_rgb(0, 255, 0)\neffect = EffectPulse(mode='solid', period=3.0, cycles=2, color=green)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(7)\n</code></pre> <p>Best for: Subtle ambient effects, status indicators</p>"},{"location":"api/effects/#color-selection","title":"Color Selection","text":""},{"location":"api/effects/#with-color-parameter","title":"With <code>color</code> Parameter","text":"<p>When you provide a <code>color</code> parameter, that exact color is used:</p> <pre><code># Always use red\nred = HSBK.from_rgb(255, 0, 0)\neffect = EffectPulse(mode='blink', color=red)\n</code></pre>"},{"location":"api/effects/#without-color-parameter-automatic","title":"Without <code>color</code> Parameter (Automatic)","text":"<p>The effect intelligently selects colors based on mode and device:</p> <ul> <li>Strobe mode: Starts from dark (cold white, 0 brightness)</li> <li>Other modes: Preserves current device color</li> <li>Color devices: Full HSBK color used</li> <li>Monochrome devices: Brightness toggled, kelvin preserved</li> </ul>"},{"location":"api/effects/#device-type-behavior","title":"Device Type Behavior","text":""},{"location":"api/effects/#color-lights","title":"Color Lights","text":"<p>All modes work as expected with full color support.</p>"},{"location":"api/effects/#multizone-lights","title":"Multizone Lights","text":"<p>Pulse effects apply to entire device, not individual zones. All zones pulse together.</p>"},{"location":"api/effects/#tile-devices","title":"Tile Devices","text":"<p>Pulse effects apply to all tiles uniformly.</p>"},{"location":"api/effects/#monochromewhite-lights","title":"Monochrome/White Lights","text":"<p>Effects adapt to brightness changes only:</p> <ul> <li>Color components are ignored</li> <li>Brightness is toggled or faded</li> <li>Kelvin temperature is preserved</li> </ul>"},{"location":"api/effects/#examples","title":"Examples","text":""},{"location":"api/effects/#custom-color-pulse","title":"Custom Color Pulse","text":"<pre><code>from lifx import HSBK\n\n# Purple breathe effect\npurple = HSBK.from_rgb(128, 0, 128)\neffect = EffectPulse(\n    mode='breathe',\n    period=2.0,\n    cycles=3,\n    hsbk=purple\n)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(7)\n</code></pre>"},{"location":"api/effects/#emergency-alert","title":"Emergency Alert","text":"<pre><code># Rapid red strobe\nred = HSBK.from_rgb(255, 0, 0)\neffect = EffectPulse(\n    mode='strobe',\n    period=0.1,\n    cycles=30,\n    hsbk=red\n)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(4)\n</code></pre>"},{"location":"api/effects/#meditation-breathing","title":"Meditation Breathing","text":"<pre><code># Slow blue breathing\nblue = HSBK.from_rgb(0, 50, 200)\neffect = EffectPulse(\n    mode='breathe',\n    period=4.0,  # 4 second cycle\n    cycles=10,\n    hsbk=blue\n)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(42)  # 10 * 4s + buffer\n</code></pre>"},{"location":"api/effects/#performance-notes","title":"Performance Notes","text":"<ul> <li>Effect starts within 100ms</li> <li>Duration is precisely <code>period * cycles</code></li> <li>State restoration adds 0.6-1.0 seconds after completion</li> <li>Multiple devices execute concurrently</li> </ul>"},{"location":"api/effects/#effectcolorloop","title":"EffectColorloop","text":"<p>Continuous color rotation effect cycling through the hue spectrum. Runs indefinitely until manually stopped.</p>"},{"location":"api/effects/#class-definition_2","title":"Class Definition","text":"<pre><code>from lifx import EffectColorloop\n\neffect = EffectColorloop(\n    power_on=True,\n    period=60,\n    change=20,\n    spread=30,\n    brightness=None,\n    saturation_min=0.8,\n    saturation_max=1.0,\n    transition=None\n)\n</code></pre>"},{"location":"api/effects/#parameters_1","title":"Parameters","text":""},{"location":"api/effects/#power_on-bool-default-true_1","title":"<code>power_on</code> (bool, default: <code>True</code>)","text":"<p>Whether to power on devices if they're off.</p>"},{"location":"api/effects/#period-float-default-60","title":"<code>period</code> (float, default: <code>60</code>)","text":"<p>Seconds per full 360-degree hue cycle. Lower values = faster color changes.</p> <p>Range: Must be positive</p> <p>Examples:</p> <ul> <li><code>period=60</code>: One full rainbow per minute (slow)</li> <li><code>period=30</code>: Two full rainbows per minute (medium)</li> <li><code>period=15</code>: Four full rainbows per minute (fast)</li> </ul>"},{"location":"api/effects/#change-float-default-20","title":"<code>change</code> (float, default: <code>20</code>)","text":"<p>Hue degrees to shift per iteration. Larger values = larger color jumps.</p> <p>Range: 0-360 degrees</p> <p>Examples:</p> <ul> <li><code>change=10</code>: Small, smooth color transitions</li> <li><code>change=20</code>: Medium color steps (default)</li> <li><code>change=45</code>: Large, dramatic color jumps</li> </ul> <p>Calculation: iterations_per_cycle = 360 / change</p>"},{"location":"api/effects/#spread-float-default-30","title":"<code>spread</code> (float, default: <code>30</code>)","text":"<p>Hue degrees spread across devices. Creates rainbow effect across multiple lights.</p> <p>Range: 0-360 degrees</p> <p>Examples:</p> <ul> <li><code>spread=0</code>: All lights same color</li> <li><code>spread=30</code>: Slight color variation (default)</li> <li><code>spread=60</code>: Rainbow spread across devices</li> <li><code>spread=120</code>: Wide spectrum spread</li> </ul>"},{"location":"api/effects/#brightness-float-none-default-none","title":"<code>brightness</code> (float | None, default: <code>None</code>)","text":"<p>Fixed brightness level. If <code>None</code>, preserves current brightness for each device.</p> <p>Range: 0.0-1.0</p> <p>Examples:</p> <ul> <li><code>brightness=None</code>: Keeps original brightness (default)</li> <li><code>brightness=0.5</code>: Locks to 50% brightness</li> <li><code>brightness=1.0</code>: Full brightness</li> </ul>"},{"location":"api/effects/#saturation_min-float-default-08","title":"<code>saturation_min</code> (float, default: <code>0.8</code>)","text":"<p>Minimum saturation for random saturation selection.</p> <p>Range: 0.0-1.0</p> <p>Must be \u2264 <code>saturation_max</code></p>"},{"location":"api/effects/#saturation_max-float-default-10","title":"<code>saturation_max</code> (float, default: <code>1.0</code>)","text":"<p>Maximum saturation for random saturation selection.</p> <p>Range: 0.0-1.0</p> <p>Must be \u2265 <code>saturation_min</code></p> <p>Note: Each iteration randomly selects saturation within this range.</p>"},{"location":"api/effects/#transition-float-none-default-none","title":"<code>transition</code> (float | None, default: <code>None</code>)","text":"<p>Color transition time in seconds. If <code>None</code>, uses random transition time per device.</p> <p>Range: Non-negative</p> <p>Examples:</p> <ul> <li><code>transition=None</code>: Random transitions (0 to 2x iteration period)</li> <li><code>transition=0.5</code>: Quick 0.5-second transitions</li> <li><code>transition=2.0</code>: Slow 2-second transitions</li> </ul>"},{"location":"api/effects/#behavior","title":"Behavior","text":""},{"location":"api/effects/#continuous-operation","title":"Continuous Operation","text":"<p>ColorLoop effects run indefinitely until explicitly stopped:</p> <pre><code>effect = EffectColorloop(period=30)\nawait conductor.start(effect, lights)\n\n# Runs forever until you call:\nawait conductor.stop(lights)\n</code></pre>"},{"location":"api/effects/#random-elements","title":"Random Elements","text":"<p>For visual variety, ColorLoop randomizes:</p> <ol> <li>Initial direction: Forward or backward through hue spectrum</li> <li>Device order: Shuffled each cycle</li> <li>Saturation: Random value between saturation_min and saturation_max</li> <li>Transition time: Random if <code>transition=None</code></li> </ol>"},{"location":"api/effects/#hue-calculation","title":"Hue Calculation","text":"<p>For each device at each iteration:</p> <pre><code>new_hue = (base_hue + iteration_offset + device_spread_offset) % 360\n\n# Where:\n# - base_hue: Initial hue when effect started\n# - iteration_offset: iteration * change * direction\n# - device_spread_offset: device_index * spread\n</code></pre>"},{"location":"api/effects/#device-type-behavior_1","title":"Device Type Behavior","text":""},{"location":"api/effects/#color-lights_1","title":"Color Lights","text":"<p>Full color cycling with all parameters supported.</p>"},{"location":"api/effects/#multizone-lights_1","title":"Multizone Lights","text":"<p>Entire device cycles as one unit (all zones same color at each iteration).</p>"},{"location":"api/effects/#tile-devices_1","title":"Tile Devices","text":"<p>All tiles cycle together with same color.</p>"},{"location":"api/effects/#monochromewhite-lights_1","title":"Monochrome/White Lights","text":"<ul> <li>Hue changes are ignored (monochrome devices can't display colors)</li> <li>Brightness and saturation parameters are ignored</li> <li>Effect still runs but with no visible changes</li> <li>Recommendation: Don't use ColorLoop on monochrome devices</li> </ul>"},{"location":"api/effects/#examples_1","title":"Examples","text":""},{"location":"api/effects/#classic-rainbow","title":"Classic Rainbow","text":"<pre><code># Slow rainbow across multiple lights\neffect = EffectColorloop(\n    period=60,      # Full rainbow per minute\n    change=20,      # Smooth color steps\n    spread=60       # Spread colors across devices\n)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(120)  # Run for 2 minutes\nawait conductor.stop(lights)\n</code></pre>"},{"location":"api/effects/#fast-party-mode","title":"Fast Party Mode","text":"<pre><code># Fast, dramatic color changes\neffect = EffectColorloop(\n    period=15,          # Fast rotation\n    change=45,          # Large color jumps\n    spread=120,         # Wide spread\n    brightness=0.8,     # Fixed brightness\n    saturation_min=0.9, # High saturation only\n    transition=0.5      # Quick transitions\n)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(60)\nawait conductor.stop(lights)\n</code></pre>"},{"location":"api/effects/#ambient-pastels","title":"Ambient Pastels","text":"<pre><code># Subtle pastel color cycling\neffect = EffectColorloop(\n    period=90,          # Very slow\n    change=15,          # Small steps\n    spread=30,          # Slight variation\n    brightness=0.4,     # Dim\n    saturation_min=0.3, # Low saturation (pastels)\n    saturation_max=0.6,\n    transition=3.0      # Very slow transitions\n)\nawait conductor.start(effect, lights)\n# Let it run indefinitely\n</code></pre>"},{"location":"api/effects/#stopping-colorloop","title":"Stopping ColorLoop","text":"<p>Always explicitly stop ColorLoop effects:</p> <pre><code># Start effect\neffect = EffectColorloop(period=30)\nawait conductor.start(effect, lights)\n\n# Do other things...\nawait asyncio.sleep(60)\n\n# Must stop manually\nawait conductor.stop(lights)\n</code></pre> <p>The <code>conductor.stop()</code> call will:</p> <ol> <li>Signal the effect to stop</li> <li>Wait for current iteration to complete</li> <li>Restore all lights to pre-effect state (power, color, zones)</li> </ol>"},{"location":"api/effects/#prestate-inheritance","title":"Prestate Inheritance","text":"<p>ColorLoop effects support state inheritance optimization. If you start a ColorLoop while another ColorLoop is already running, the new effect inherits the existing prestate instead of resetting:</p> <pre><code># Start first colorloop\neffect1 = EffectColorloop(period=30, change=20)\nawait conductor.start(effect1, lights)\nawait asyncio.sleep(10)\n\n# Switch to different colorloop - no reset, seamless transition\neffect2 = EffectColorloop(period=20, change=30)\nawait conductor.start(effect2, lights)  # Inherits state, no flash\n</code></pre> <p>This prevents the lights from briefly returning to their original state between consecutive ColorLoop effects.</p>"},{"location":"api/effects/#performance-notes_1","title":"Performance Notes","text":"<ul> <li>Iteration period: <code>period / (360 / change)</code></li> <li>State capture: &lt;1 second per device</li> <li>Effect startup: &lt;100ms</li> <li>Multiple devices update concurrently</li> <li>No cycle limit - runs until stopped</li> </ul>"},{"location":"api/effects/#lifxeffect-base-class","title":"LIFXEffect (Base Class)","text":"<p>Abstract base class for all light effects. Subclass this to create custom effects.</p>"},{"location":"api/effects/#class-definition_3","title":"Class Definition","text":"<pre><code>from lifx import LIFXEffect\n\nclass MyEffect(LIFXEffect):\n    def __init__(self, power_on: bool = True):\n        super().__init__(power_on=power_on)\n\n    async def async_play(self) -&gt; None:\n        # Custom effect logic here\n        pass\n</code></pre>"},{"location":"api/effects/#attributes","title":"Attributes","text":""},{"location":"api/effects/#power_on-bool","title":"<code>power_on</code> (bool)","text":"<p>Whether to power on devices during effect.</p>"},{"location":"api/effects/#conductor-conductor-none","title":"<code>conductor</code> (Conductor | None)","text":"<p>Reference to the conductor managing this effect. Set automatically by conductor.</p>"},{"location":"api/effects/#participants-listlight","title":"<code>participants</code> (list[Light])","text":"<p>List of lights participating in the effect. Set automatically by conductor.</p>"},{"location":"api/effects/#methods_1","title":"Methods","text":""},{"location":"api/effects/#async_performparticipants-listlight-none","title":"<code>async_perform(participants: list[Light]) -&gt; None</code>","text":"<p>Perform common setup and play the effect. Called by conductor.</p> <p>Do not override this method. Override <code>async_play()</code> instead.</p>"},{"location":"api/effects/#async_play-none-abstract","title":"<code>async_play() -&gt; None</code> (abstract)","text":"<p>Play the effect logic. Override this in subclasses.</p> <p>This is where you implement your custom effect behavior.</p> <p>Example:</p> <pre><code>async def async_play(self) -&gt; None:\n    # Flash all lights 3 times\n    for _ in range(3):\n        await asyncio.gather(*[\n            light.set_brightness(1.0) for light in self.participants\n        ])\n        await asyncio.sleep(0.3)\n        await asyncio.gather(*[\n            light.set_brightness(0.0) for light in self.participants\n        ])\n        await asyncio.sleep(0.3)\n\n    # Restore via conductor\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre>"},{"location":"api/effects/#from_poweroff_hsbklight-light-hsbk","title":"<code>from_poweroff_hsbk(light: Light) -&gt; HSBK</code>","text":"<p>Return startup color when light is powered off.</p> <p>Override this to customize the color used when powering on a light.</p> <p>Default behavior: Returns random hue, full saturation, zero brightness, neutral white.</p> <p>Example:</p> <pre><code>async def from_poweroff_hsbk(self, light: Light) -&gt; HSBK:\n    # Always start with red\n    return HSBK.from_rgb(255, 0, 0, kelvin=KELVIN_NEUTRAL)\n</code></pre>"},{"location":"api/effects/#inherit_prestateother-lifxeffect-bool","title":"<code>inherit_prestate(other: LIFXEffect) -&gt; bool</code>","text":"<p>Whether this effect can skip device state restoration.</p> <p>Override this if your effect can run without resetting when following certain other effects.</p> <p>Default behavior: Returns <code>False</code> (always reset)</p> <p>Example:</p> <pre><code>def inherit_prestate(self, other: LIFXEffect) -&gt; bool:\n    # Can inherit from same effect type\n    return type(self) == type(other)\n</code></pre>"},{"location":"api/effects/#creating-custom-effects","title":"Creating Custom Effects","text":"<p>See the Custom Effects Guide for detailed instructions on creating your own effects.</p>"},{"location":"api/effects/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic usage and common patterns</li> <li>Custom Effects - Creating your own effects</li> <li>Architecture - How the system works</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>lifx-async defines a hierarchy of exceptions for different error conditions. All exceptions inherit from <code>LifxError</code>.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>LifxError (base exception)\n\u251c\u2500\u2500 LifxConnectionError\n\u251c\u2500\u2500 LifxTimeoutError\n\u251c\u2500\u2500 LifxDeviceNotFoundError\n\u251c\u2500\u2500 LifxProtocolError\n\u251c\u2500\u2500 LifxNetworkError\n\u2514\u2500\u2500 LifxUnsupportedCommandError\n</code></pre>"},{"location":"api/exceptions/#base-exception","title":"Base Exception","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxError","title":"LifxError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all lifx-async errors.</p>"},{"location":"api/exceptions/#connection-exceptions","title":"Connection Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxConnectionError","title":"LifxConnectionError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when there's a connection error.</p>"},{"location":"api/exceptions/#lifx.exceptions.LifxTimeoutError","title":"LifxTimeoutError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when an operation times out.</p>"},{"location":"api/exceptions/#lifx.exceptions.LifxDeviceNotFoundError","title":"LifxDeviceNotFoundError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when a device cannot be found or reached.</p>"},{"location":"api/exceptions/#protocol-exceptions","title":"Protocol Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxProtocolError","title":"LifxProtocolError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when there's an error with protocol parsing or validation.</p>"},{"location":"api/exceptions/#network-exceptions","title":"Network Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxNetworkError","title":"LifxNetworkError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when there's a network-level error.</p>"},{"location":"api/exceptions/#command-exceptions","title":"Command Exceptions","text":""},{"location":"api/exceptions/#lifx.exceptions.LifxUnsupportedCommandError","title":"LifxUnsupportedCommandError","text":"<p>               Bases: <code>LifxError</code></p> <p>Raised when a device doesn't support the requested command.</p>"},{"location":"api/exceptions/#examples","title":"Examples","text":""},{"location":"api/exceptions/#basic-exception-handling","title":"Basic Exception Handling","text":"<pre><code>from lifx import discover, LifxError, LifxTimeoutError\n\n\nasync def main():\n    try:\n        async with discover(timeout=5.0) as group:\n            await group.set_color(Colors.BLUE)\n    except LifxTimeoutError:\n        print(\"Discovery timed out - no devices found\")\n    except LifxError as e:\n        print(f\"LIFX error: {e}\")\n</code></pre>"},{"location":"api/exceptions/#specific-exception-handling","title":"Specific Exception Handling","text":"<pre><code>from lifx import Light, LifxConnectionError, LifxUnsupportedCommandError\n\n\nasync def main():\n    try:\n        async with await Light.from_ip(\"192.168.1.100\") as light:\n            await light.set_color(Colors.BLUE)\n    except LifxConnectionError:\n        print(\"Failed to connect to device\")\n    except LifxUnsupportedCommandError as e:\n        print(f\"Device doesn't support this operation: {e}\")\n</code></pre>"},{"location":"api/exceptions/#catching-all-lifx-exceptions","title":"Catching All LIFX Exceptions","text":"<pre><code>from lifx import find_lights, LifxError\n\n\nasync def safe_control():\n    try:\n        async with find_lights() as lights:\n            for light in lights:\n                await light.set_brightness(0.8)\n    except LifxError as e:\n        # Catches all LIFX-specific exceptions\n        print(f\"LIFX operation failed: {e}\")\n        # Log, retry, or handle gracefully\n</code></pre>"},{"location":"api/exceptions/#timeout-handling","title":"Timeout Handling","text":"<pre><code>from lifx import DeviceConnection, LifxTimeoutError\nfrom lifx.protocol.packets import LightGet, LightState\n\n\nasync def main():\n    try:\n        async with DeviceConnection(serial, ip, timeout=2.0) as conn:\n            response = await conn.request_response(LightGet(), LightState)\n    except LifxTimeoutError:\n        print(\"Device did not respond in time\")\n        # Device may be offline or unreachable\n</code></pre>"},{"location":"api/exceptions/#protocol-error-handling","title":"Protocol Error Handling","text":"<pre><code>from lifx import Light, LifxProtocolError\n\n\nasync def main():\n    try:\n        async with await Light.from_ip(\"192.168.1.100\") as light:\n            await light.set_color(Colors.BLUE)\n    except LifxProtocolError:\n        print(\"Protocol-level error occurred\")\n</code></pre>"},{"location":"api/exceptions/#unsupported-command-handling","title":"Unsupported Command Handling","text":"<pre><code>from lifx import find_lights, LifxUnsupportedCommandError\n\n\nasync def main():\n    async with find_lights() as lights:\n        for light in lights:\n            try:\n                # Some devices may not support all features\n                await light.set_infrared(0.5)\n            except LifxUnsupportedCommandError:\n                print(f\"{light.label} doesn't support this command\")\n                continue\n</code></pre>"},{"location":"api/exceptions/#device-not-found-handling","title":"Device Not Found Handling","text":"<pre><code>from lifx import find_by_serial, LifxDeviceNotFoundError\n\n\nasync def main():\n    try:\n        device = await find_by_serial(\"d073d5123456\", timeout=3.0)\n        if device:\n            async with device:\n                await device.set_power(True)\n    except LifxDeviceNotFoundError:\n        print(\"Device not found on the network\")\n</code></pre>"},{"location":"api/exceptions/#best-practices","title":"Best Practices","text":""},{"location":"api/exceptions/#always-catch-specific-exceptions-first","title":"Always Catch Specific Exceptions First","text":"<pre><code># \u2705 Good - specific to general\ntry:\n    await light.set_color(Colors.BLUE)\nexcept LifxTimeoutError:\n    print(\"Timeout\")\nexcept LifxConnectionError:\n    print(\"Connection failed\")\nexcept LifxError:\n    print(\"Other LIFX error\")\n\n# \u274c Bad - general exception catches everything\ntry:\n    await light.set_color(Colors.BLUE)\nexcept LifxError:\n    print(\"Error\")  # Can't distinguish timeout from other errors\n</code></pre>"},{"location":"api/exceptions/#use-context-managers-for-cleanup","title":"Use Context Managers for Cleanup","text":"<pre><code># \u2705 Good - resources cleaned up even on exception\ntry:\n    async with await Light.from_ip(ip) as light:\n        await light.set_color(Colors.BLUE)\nexcept LifxError:\n    print(\"Error occurred but connection was closed properly\")\n\n# \u274c Bad - connection may leak on exception\nlight = Light(serial, ip)\nawait light.connect()\ntry:\n    await light.set_color(Colors.BLUE)\nexcept LifxError:\n    pass  # Connection not closed!\nfinally:\n    await light.disconnect()\n</code></pre>"},{"location":"api/exceptions/#log-exceptions-for-debugging","title":"Log Exceptions for Debugging","text":"<pre><code>import logging\nfrom lifx import discover, DeviceGroup, LifxError\n\nlogger = logging.getLogger(__name__)\n\n\nasync def main():\n    try:\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        await group.set_color(Colors.BLUE)\n    except LifxError as e:\n        logger.exception(\"Failed to control lights\")\n        # Logs full traceback for debugging\n</code></pre>"},{"location":"api/exceptions/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>from lifx import find_lights, LifxError\n\n\nasync def main():\n    async with find_lights() as lights:\n        for light in lights:\n            try:\n                await light.set_color(Colors.BLUE)\n            except LifxError as e:\n                # Continue with other lights even if one fails\n                print(f\"Failed to control {light.label}: {e}\")\n                continue\n</code></pre>"},{"location":"api/exceptions/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"api/exceptions/#device-not-responding","title":"Device Not Responding","text":"<pre><code># Usually raises: LifxTimeoutError\nasync with await Light.from_ip(\"192.168.1.100\", timeout=5.0) as light:\n    await light.set_color(Colors.BLUE)\n</code></pre> <p>Causes:</p> <ul> <li>Device is offline or unpowered</li> <li>Wrong IP address</li> <li>Network connectivity issues</li> <li>Firewall blocking UDP port 56700</li> </ul>"},{"location":"api/exceptions/#device-not-found-during-discovery","title":"Device Not Found During Discovery","text":"<pre><code># May raise: LifxTimeoutError or LifxDeviceNotFoundError\nasync with discover(timeout=3.0) as group:\n    if not group.devices:\n        print(\"No devices found\")\n</code></pre> <p>Causes:</p> <ul> <li>No LIFX devices on the network</li> <li>Devices on different subnet</li> <li>Discovery timeout too short</li> <li>Network doesn't allow broadcast packets</li> </ul>"},{"location":"api/exceptions/#connection-failed","title":"Connection Failed","text":"<pre><code># Raises: LifxConnectionError\nasync with DeviceConnection(serial, ip) as conn:\n    await conn.send_packet(packet)\n</code></pre> <p>Causes:</p> <ul> <li>Network unreachable</li> <li>Device offline</li> <li>Port blocked by firewall</li> <li>Invalid IP address</li> </ul>"},{"location":"api/exceptions/#unsupported-command","title":"Unsupported Command","text":"<pre><code># Raises: LifxUnsupportedCommandError\nasync with await Light.from_ip(ip) as light:\n    await light.set_color_zones(0, 5, Colors.RED)  # Not a multizone device\n</code></pre> <p>Causes:</p> <ul> <li>Attempting zone control on non-multizone device</li> <li>Using tile operations on non-tile device</li> <li>Feature not supported by firmware version</li> <li>Sending Light commands to non-light devices (e.g., switches)</li> </ul>"},{"location":"api/exceptions/#protocol-error","title":"Protocol Error","text":"<pre><code># Raises: LifxProtocolError\n</code></pre> <p>Causes:</p> <ul> <li>Invalid packet format received</li> <li>Protocol parsing failure</li> <li>Corrupted message data</li> <li>Unexpected packet type</li> </ul>"},{"location":"api/high-level/","title":"High-Level API","text":"<p>The high-level API provides simplified functions for common LIFX operations. These are the recommended entry points for most users.</p>"},{"location":"api/high-level/#discovery-functions","title":"Discovery Functions","text":""},{"location":"api/high-level/#lifx.api.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; AsyncGenerator[Device, None]\n</code></pre> <p>Discover LIFX devices and yield them as they are found.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Discovery timeout in seconds (default 3.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> <code>broadcast_address</code> <p>Broadcast address to use (default \"255.255.255.255\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> <code>device_timeout</code> <p>request timeout set on discovered devices</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>max retries per request set on discovered devices</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> <p>Yields:     Device instances as they are discovered</p> Example <pre><code># Process devices as they're discovered\nasync for device in discover():\n    print(f\"Found: {device.serial}\")\n    async with device:\n        await device.set_power(True)\n\n# Or collect all devices first\ndevices = []\nasync for device in discover():\n    devices.append(device)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def discover(\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; AsyncGenerator[Device, None]:\n    \"\"\"Discover LIFX devices and yield them as they are found.\n\n    Args:\n        timeout: Discovery timeout in seconds (default 3.0)\n        broadcast_address: Broadcast address to use (default \"255.255.255.255\")\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n        device_timeout: request timeout set on discovered devices\n        max_retries: max retries per request set on discovered devices\n    Yields:\n        Device instances as they are discovered\n\n    Example:\n        ```python\n        # Process devices as they're discovered\n        async for device in discover():\n            print(f\"Found: {device.serial}\")\n            async with device:\n                await device.set_power(True)\n\n        # Or collect all devices first\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        ```\n    \"\"\"\n    async for discovered in discover_devices(\n        timeout=timeout,\n        broadcast_address=broadcast_address,\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n        device_timeout=device_timeout,\n        max_retries=max_retries,\n    ):\n        device = await discovered.create_device()\n        if device is not None:\n            yield device\n</code></pre>"},{"location":"api/high-level/#lifx.api.find_by_serial","title":"find_by_serial  <code>async</code>","text":"<pre><code>find_by_serial(\n    serial: str,\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Device | None\n</code></pre> <p>Find a specific device by serial number.</p> PARAMETER DESCRIPTION <code>serial</code> <p>Serial number as hex string (with or without separators)</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Discovery timeout in seconds (default DISCOVERY_TIMEOUT)</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> <code>broadcast_address</code> <p>Broadcast address to use (default \"255.255.255.255\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> <code>device_timeout</code> <p>request timeout set on discovered device</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>max retries per request set on discovered device</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> RETURNS DESCRIPTION <code>Device | None</code> <p>Device instance if found, None otherwise</p> Example <pre><code># Find by serial number\ndevice = await find_by_serial(\"d073d5123456\")\nif device:\n    async with device:\n        await device.set_power(True)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def find_by_serial(\n    serial: str,\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Device | None:\n    \"\"\"Find a specific device by serial number.\n\n    Args:\n        serial: Serial number as hex string (with or without separators)\n        timeout: Discovery timeout in seconds (default DISCOVERY_TIMEOUT)\n        broadcast_address: Broadcast address to use (default \"255.255.255.255\")\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n        device_timeout: request timeout set on discovered device\n        max_retries: max retries per request set on discovered device\n\n    Returns:\n        Device instance if found, None otherwise\n\n    Example:\n        ```python\n        # Find by serial number\n        device = await find_by_serial(\"d073d5123456\")\n        if device:\n            async with device:\n                await device.set_power(True)\n        ```\n    \"\"\"\n    # Normalize serial to string format (12-digit hex, no separators)\n    serial_str = serial.replace(\":\", \"\").replace(\"-\", \"\").lower()\n\n    async for disc in discover_devices(\n        timeout=timeout,\n        broadcast_address=broadcast_address,\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n        device_timeout=device_timeout,\n        max_retries=max_retries,\n    ):\n        if disc.serial.lower() == serial_str:\n            # Detect device type and return appropriate class\n            return await disc.create_device()\n\n    return None\n</code></pre>"},{"location":"api/high-level/#lifx.api.find_by_label","title":"find_by_label  <code>async</code>","text":"<pre><code>find_by_label(\n    label: str,\n    exact_match: bool = False,\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; AsyncGenerator[Device]\n</code></pre> <p>Find LIFX devices by label (name).</p> <p>Uses a protocol trick by broadcasting GetLabel instead of GetService, which returns all device labels in StateLabel responses. This is more efficient than querying each device individually.</p> PARAMETER DESCRIPTION <code>label</code> <p>Device label to search for (case-insensitive)</p> <p> TYPE: <code>str</code> </p> <code>exact_match</code> <p>If True, match label exactly and yield at most one device;          if False, match substring and yield all matching devices          (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>Discovery timeout in seconds (default DISCOVERY_TIMEOUT)</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> <code>broadcast_address</code> <p>Broadcast address to use (default \"255.255.255.255\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> <code>device_timeout</code> <p>request timeout set on discovered device(s)</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>max retries per request set on discovered device(s)</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> YIELDS DESCRIPTION <code>AsyncGenerator[Device]</code> <p>Matching Device instance(s)</p> Example <pre><code># Find all devices with \"Living\" in the label\nasync for device in find_by_label(\"Living\"):\n    async with device:\n        await device.set_power(True)\n\n# Find device by exact label match (yields at most one)\nasync for device in find_by_label(\"Living Room\", exact_match=True):\n    async with device:\n        await device.set_power(True)\n    break  # exact_match yields at most one device\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def find_by_label(\n    label: str,\n    exact_match: bool = False,\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; AsyncGenerator[Device]:\n    \"\"\"Find LIFX devices by label (name).\n\n    Uses a protocol trick by broadcasting GetLabel instead of GetService,\n    which returns all device labels in StateLabel responses. This is more\n    efficient than querying each device individually.\n\n    Args:\n        label: Device label to search for (case-insensitive)\n        exact_match: If True, match label exactly and yield at most one device;\n                     if False, match substring and yield all matching devices\n                     (default False)\n        timeout: Discovery timeout in seconds (default DISCOVERY_TIMEOUT)\n        broadcast_address: Broadcast address to use (default \"255.255.255.255\")\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n        device_timeout: request timeout set on discovered device(s)\n        max_retries: max retries per request set on discovered device(s)\n\n    Yields:\n        Matching Device instance(s)\n\n    Example:\n        ```python\n        # Find all devices with \"Living\" in the label\n        async for device in find_by_label(\"Living\"):\n            async with device:\n                await device.set_power(True)\n\n        # Find device by exact label match (yields at most one)\n        async for device in find_by_label(\"Living Room\", exact_match=True):\n            async with device:\n                await device.set_power(True)\n            break  # exact_match yields at most one device\n        ```\n    \"\"\"\n    async for resp in _discover_with_packet(\n        packets.Device.GetLabel(),\n        timeout=timeout,\n        broadcast_address=broadcast_address,\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n    ):\n        device_label = resp.response_payload.get(\"label\", \"\")\n        matched = False\n\n        if exact_match:\n            # Exact match - return first match only\n            if device_label.lower() == label.lower():\n                matched = True\n        else:\n            # Substring match - return all matches\n            if label.lower() in device_label.lower():\n                matched = True\n\n        if matched:\n            # Create DiscoveredDevice from response\n            disc = DiscoveredDevice(\n                serial=resp.serial,\n                ip=resp.ip,\n                port=resp.port,\n                response_time=resp.response_time,\n                timeout=device_timeout,\n                max_retries=max_retries,\n            )\n\n            device = await disc.create_device()\n            if device is not None:\n                yield device\n</code></pre>"},{"location":"api/high-level/#lifx.api.find_by_ip","title":"find_by_ip  <code>async</code>","text":"<pre><code>find_by_ip(\n    ip: str,\n    timeout: float = DISCOVERY_TIMEOUT,\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Device | None\n</code></pre> <p>Find a LIFX device by IP address.</p> <p>Uses a targeted discovery by sending the broadcast to the specific IP address, which means only that device will respond (if it exists). This is more efficient than broadcasting to all devices and filtering.</p> PARAMETER DESCRIPTION <code>ip</code> <p>Target device IP address</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Discovery timeout in seconds (default DISCOVERY_TIMEOUT)</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> <code>port</code> <p>Port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> <code>device_timeout</code> <p>request timeout set on discovered device</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>max retries per request set on discovered device</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> RETURNS DESCRIPTION <code>Device | None</code> <p>Device instance if found, None otherwise</p> Example <pre><code># Find device at specific IP\ndevice = await find_by_ip(\"192.168.1.100\")\nif device:\n    async with device:\n        print(f\"Found: {device.label}\")\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def find_by_ip(\n    ip: str,\n    timeout: float = DISCOVERY_TIMEOUT,\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; Device | None:\n    \"\"\"Find a LIFX device by IP address.\n\n    Uses a targeted discovery by sending the broadcast to the specific IP address,\n    which means only that device will respond (if it exists). This is more efficient\n    than broadcasting to all devices and filtering.\n\n    Args:\n        ip: Target device IP address\n        timeout: Discovery timeout in seconds (default DISCOVERY_TIMEOUT)\n        port: Port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n        device_timeout: request timeout set on discovered device\n        max_retries: max retries per request set on discovered device\n\n    Returns:\n        Device instance if found, None otherwise\n\n    Example:\n        ```python\n        # Find device at specific IP\n        device = await find_by_ip(\"192.168.1.100\")\n        if device:\n            async with device:\n                print(f\"Found: {device.label}\")\n        ```\n    \"\"\"\n    # Use the target IP as the \"broadcast\" address - only that device will respond\n    async for discovered in discover_devices(\n        timeout=timeout,\n        broadcast_address=ip,  # Protocol trick: send directly to target IP\n        port=port,\n        max_response_time=max_response_time,\n        idle_timeout_multiplier=idle_timeout_multiplier,\n        device_timeout=device_timeout,\n        max_retries=max_retries,\n    ):\n        # Should only get one response (or none)\n        return await discovered.create_device()\n\n    return None\n</code></pre>"},{"location":"api/high-level/#device-group","title":"Device Group","text":""},{"location":"api/high-level/#lifx.api.DeviceGroup","title":"DeviceGroup","text":"<pre><code>DeviceGroup(\n    devices: Sequence[\n        Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight\n    ],\n)\n</code></pre> <p>A group of devices for batch operations.</p> <p>Provides convenient methods to control multiple devices simultaneously.</p> Example <pre><code># Collect devices from discovery\ndevices = []\nasync for device in discover():\n    devices.append(device)\n\n# Create group and perform batch operations\ngroup = DeviceGroup(devices)\nawait group.set_power(True)\nawait group.set_color(Colors.BLUE)\n</code></pre> PARAMETER DESCRIPTION <code>devices</code> <p>List of Device instances</p> <p> TYPE: <code>Sequence[Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight]</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter async context manager.</p> <code>__aexit__</code> <p>Exit async context manager and close all device connections.</p> <code>__iter__</code> <p>Iterate over devices in the group.</p> <code>__len__</code> <p>Get number of devices in the group.</p> <code>__getitem__</code> <p>Get device by index.</p> <code>set_power</code> <p>Set power state for all devices in the group.</p> <code>set_color</code> <p>Set color for all Light devices in the group.</p> <code>set_brightness</code> <p>Set brightness for all Light devices in the group.</p> <code>pulse</code> <p>Pulse effect for all Light devices.</p> <code>organize_by_location</code> <p>Organize devices by location label.</p> <code>organize_by_group</code> <p>Organize devices by group label.</p> <code>filter_by_location</code> <p>Filter devices to a specific location.</p> <code>filter_by_group</code> <p>Filter devices to a specific group.</p> <code>get_unassigned_devices</code> <p>Get devices without location or group assigned.</p> <code>apply_theme</code> <p>Apply a theme to all devices in the group.</p> <code>invalidate_metadata_cache</code> <p>Clear all cached location and group metadata.</p> ATTRIBUTE DESCRIPTION <code>devices</code> <p>Get all the devices in the group.</p> <p> TYPE: <code>Sequence[Device | HevLight | InfraredLight | Light | MultiZoneLight | MatrixLight]</code> </p> <code>lights</code> <p>Get all Light devices in the group.</p> <p> TYPE: <code>list[Light]</code> </p> <code>hev_lights</code> <p>Get the HEV lights in the group.</p> <p> TYPE: <code>list[HevLight]</code> </p> <code>infrared_lights</code> <p>Get the Infrared lights in the group.</p> <p> TYPE: <code>list[InfraredLight]</code> </p> <code>multizone_lights</code> <p>Get all MultiZone light devices in the group.</p> <p> TYPE: <code>list[MultiZoneLight]</code> </p> <code>matrix_lights</code> <p>Get all Matrix light devices in the group.</p> <p> TYPE: <code>list[MatrixLight]</code> </p> Source code in <code>src/lifx/api.py</code> <pre><code>def __init__(\n    self,\n    devices: Sequence[\n        Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight\n    ],\n) -&gt; None:\n    \"\"\"Initialize device group.\n\n    Args:\n        devices: List of Device instances\n    \"\"\"\n    self._devices = devices\n    self._lights = [light for light in devices if isinstance(light, Light)]\n    self._hev_lights = [light for light in devices if type(light) is HevLight]\n    self._infrared_lights = [\n        light for light in devices if type(light) is InfraredLight\n    ]\n    self._multizone_lights = [\n        light for light in devices if type(light) is MultiZoneLight\n    ]\n    self._matrix_lights = [light for light in devices if type(light) is MatrixLight]\n    self._locations_cache: dict[str, DeviceGroup] | None = None\n    self._groups_cache: dict[str, DeviceGroup] | None = None\n    self._location_metadata: dict[str, LocationGrouping] | None = None\n    self._group_metadata: dict[str, GroupGrouping] | None = None\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup-attributes","title":"Attributes","text":""},{"location":"api/high-level/#lifx.api.DeviceGroup.devices","title":"devices  <code>property</code>","text":"<pre><code>devices: Sequence[\n    Device | HevLight | InfraredLight | Light | MultiZoneLight | MatrixLight\n]\n</code></pre> <p>Get all the devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.lights","title":"lights  <code>property</code>","text":"<pre><code>lights: list[Light]\n</code></pre> <p>Get all Light devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.hev_lights","title":"hev_lights  <code>property</code>","text":"<pre><code>hev_lights: list[HevLight]\n</code></pre> <p>Get the HEV lights in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.infrared_lights","title":"infrared_lights  <code>property</code>","text":"<pre><code>infrared_lights: list[InfraredLight]\n</code></pre> <p>Get the Infrared lights in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.multizone_lights","title":"multizone_lights  <code>property</code>","text":"<pre><code>multizone_lights: list[MultiZoneLight]\n</code></pre> <p>Get all MultiZone light devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup.matrix_lights","title":"matrix_lights  <code>property</code>","text":"<pre><code>matrix_lights: list[MatrixLight]\n</code></pre> <p>Get all Matrix light devices in the group.</p>"},{"location":"api/high-level/#lifx.api.DeviceGroup-functions","title":"Functions","text":""},{"location":"api/high-level/#lifx.api.DeviceGroup.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; DeviceGroup\n</code></pre> <p>Enter async context manager.</p> Source code in <code>src/lifx/api.py</code> <pre><code>async def __aenter__(self) -&gt; DeviceGroup:\n    \"\"\"Enter async context manager.\"\"\"\n    return self\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit async context manager and close all device connections.</p> Source code in <code>src/lifx/api.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit async context manager and close all device connections.\"\"\"\n    for device in self._devices:\n        await device.connection.close()\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[\n    Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight\n]\n</code></pre> <p>Iterate over devices in the group.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def __iter__(\n    self,\n) -&gt; Iterator[\n    Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight\n]:\n    \"\"\"Iterate over devices in the group.\"\"\"\n    return iter(self._devices)\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get number of devices in the group.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get number of devices in the group.\"\"\"\n    return len(self._devices)\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    index: int,\n) -&gt; Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight\n</code></pre> <p>Get device by index.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def __getitem__(\n    self, index: int\n) -&gt; Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight:\n    \"\"\"Get device by index.\"\"\"\n    return self._devices[index]\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(on: bool, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set power state for all devices in the group.</p> PARAMETER DESCRIPTION <code>on</code> <p>True to turn on, False to turn off</p> <p> TYPE: <code>bool</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nawait group.set_power(True, duration=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def set_power(self, on: bool, duration: float = 0.0) -&gt; None:\n    \"\"\"Set power state for all devices in the group.\n\n    Args:\n        on: True to turn on, False to turn off\n        duration: Transition duration in seconds (default 0.0)\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        await group.set_power(True, duration=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.set_power(on, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.set_color","title":"set_color  <code>async</code>","text":"<pre><code>set_color(color: HSBK, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set color for all Light devices in the group.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to set</p> <p> TYPE: <code>HSBK</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nawait group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def set_color(self, color: HSBK, duration: float = 0.0) -&gt; None:\n    \"\"\"Set color for all Light devices in the group.\n\n    Args:\n        color: HSBK color to set\n        duration: Transition duration in seconds (default 0.0)\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.set_color(color, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.set_brightness","title":"set_brightness  <code>async</code>","text":"<pre><code>set_brightness(brightness: float, duration: float = 0.0) -&gt; None\n</code></pre> <p>Set brightness for all Light devices in the group.</p> PARAMETER DESCRIPTION <code>brightness</code> <p>Brightness level (0.0-1.0)</p> <p> TYPE: <code>float</code> </p> <code>duration</code> <p>Transition duration in seconds (default 0.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nawait group.set_brightness(0.5, duration=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def set_brightness(self, brightness: float, duration: float = 0.0) -&gt; None:\n    \"\"\"Set brightness for all Light devices in the group.\n\n    Args:\n        brightness: Brightness level (0.0-1.0)\n        duration: Transition duration in seconds (default 0.0)\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        await group.set_brightness(0.5, duration=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.set_brightness(brightness, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.pulse","title":"pulse  <code>async</code>","text":"<pre><code>pulse(color: HSBK, period: float = 1.0, cycles: float = 1.0) -&gt; None\n</code></pre> <p>Pulse effect for all Light devices.</p> PARAMETER DESCRIPTION <code>color</code> <p>Color to pulse to</p> <p> TYPE: <code>HSBK</code> </p> <code>period</code> <p>Period of one cycle in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>cycles</code> <p>Number of cycles</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nawait group.pulse(Colors.RED, period=1.0, cycles=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def pulse(\n    self, color: HSBK, period: float = 1.0, cycles: float = 1.0\n) -&gt; None:\n    \"\"\"Pulse effect for all Light devices.\n\n    Args:\n        color: Color to pulse to\n        period: Period of one cycle in seconds\n        cycles: Number of cycles\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        await group.pulse(Colors.RED, period=1.0, cycles=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for light in self.lights:\n            tg.create_task(light.pulse(color, period, cycles))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.organize_by_location","title":"organize_by_location  <code>async</code>","text":"<pre><code>organize_by_location(\n    include_unassigned: bool = False,\n) -&gt; dict[str, DeviceGroup]\n</code></pre> <p>Organize devices by location label.</p> <p>Fetches location metadata if not cached and groups devices by location label.</p> PARAMETER DESCRIPTION <code>include_unassigned</code> <p>Include \"Unassigned\" group</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, DeviceGroup]</code> <p>Dictionary mapping location labels to DeviceGroup instances</p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nby_location = await group.organize_by_location()\nkitchen = by_location[\"Kitchen\"]\nawait kitchen.set_color(Colors.BLUE)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def organize_by_location(\n    self, include_unassigned: bool = False\n) -&gt; dict[str, DeviceGroup]:\n    \"\"\"Organize devices by location label.\n\n    Fetches location metadata if not cached and groups devices by location label.\n\n    Args:\n        include_unassigned: Include \"Unassigned\" group\n\n    Returns:\n        Dictionary mapping location labels to DeviceGroup instances\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        by_location = await group.organize_by_location()\n        kitchen = by_location[\"Kitchen\"]\n        await kitchen.set_color(Colors.BLUE)\n        ```\n    \"\"\"\n    # Fetch metadata if not cached\n    if self._location_metadata is None:\n        await self._fetch_location_metadata()\n\n    # Build and cache groups\n    if self._locations_cache is None:\n        self._locations_cache = self._build_location_groups(include_unassigned)\n\n    return self._locations_cache\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.organize_by_group","title":"organize_by_group  <code>async</code>","text":"<pre><code>organize_by_group(include_unassigned: bool = False) -&gt; dict[str, DeviceGroup]\n</code></pre> <p>Organize devices by group label.</p> <p>Fetches group metadata if not cached and groups devices by group label.</p> PARAMETER DESCRIPTION <code>include_unassigned</code> <p>Include \"Unassigned\" group</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, DeviceGroup]</code> <p>Dictionary mapping group labels to DeviceGroup instances</p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nby_group = await group.organize_by_group()\nbedroom = by_group[\"Bedroom Lights\"]\nawait bedroom.set_power(False)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def organize_by_group(\n    self, include_unassigned: bool = False\n) -&gt; dict[str, DeviceGroup]:\n    \"\"\"Organize devices by group label.\n\n    Fetches group metadata if not cached and groups devices by group label.\n\n    Args:\n        include_unassigned: Include \"Unassigned\" group\n\n    Returns:\n        Dictionary mapping group labels to DeviceGroup instances\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        by_group = await group.organize_by_group()\n        bedroom = by_group[\"Bedroom Lights\"]\n        await bedroom.set_power(False)\n        ```\n    \"\"\"\n    # Fetch metadata if not cached\n    if self._group_metadata is None:\n        await self._fetch_group_metadata()\n\n    # Build and cache groups\n    if self._groups_cache is None:\n        self._groups_cache = self._build_group_groups(include_unassigned)\n\n    return self._groups_cache\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.filter_by_location","title":"filter_by_location  <code>async</code>","text":"<pre><code>filter_by_location(label: str, case_sensitive: bool = False) -&gt; DeviceGroup\n</code></pre> <p>Filter devices to a specific location.</p> PARAMETER DESCRIPTION <code>label</code> <p>Location label to filter by</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>If True, performs case-sensitive matching (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DeviceGroup</code> <p>DeviceGroup containing devices in the specified location</p> RAISES DESCRIPTION <code>KeyError</code> <p>If location label not found</p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nliving_room = await group.filter_by_location(\"Living Room\")\nawait living_room.set_brightness(0.7)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def filter_by_location(\n    self, label: str, case_sensitive: bool = False\n) -&gt; DeviceGroup:\n    \"\"\"Filter devices to a specific location.\n\n    Args:\n        label: Location label to filter by\n        case_sensitive: If True, performs case-sensitive matching (default False)\n\n    Returns:\n        DeviceGroup containing devices in the specified location\n\n    Raises:\n        KeyError: If location label not found\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        living_room = await group.filter_by_location(\"Living Room\")\n        await living_room.set_brightness(0.7)\n        ```\n    \"\"\"\n    locations = await self.organize_by_location(include_unassigned=False)\n\n    # Find matching label\n    if case_sensitive:\n        if label not in locations:\n            raise KeyError(f\"Location '{label}' not found\")\n        return locations[label]\n    else:\n        label_lower = label.lower()\n        for loc_label, device_group in locations.items():\n            if loc_label.lower() == label_lower:\n                return device_group\n        raise KeyError(f\"Location '{label}' not found\")\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.filter_by_group","title":"filter_by_group  <code>async</code>","text":"<pre><code>filter_by_group(label: str, case_sensitive: bool = False) -&gt; DeviceGroup\n</code></pre> <p>Filter devices to a specific group.</p> PARAMETER DESCRIPTION <code>label</code> <p>Group label to filter by</p> <p> TYPE: <code>str</code> </p> <code>case_sensitive</code> <p>If True, performs case-sensitive matching (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DeviceGroup</code> <p>DeviceGroup containing devices in the specified group</p> RAISES DESCRIPTION <code>KeyError</code> <p>If group label not found</p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nbedroom = await group.filter_by_group(\"Bedroom Lights\")\nawait bedroom.set_color(Colors.WARM_WHITE)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def filter_by_group(\n    self, label: str, case_sensitive: bool = False\n) -&gt; DeviceGroup:\n    \"\"\"Filter devices to a specific group.\n\n    Args:\n        label: Group label to filter by\n        case_sensitive: If True, performs case-sensitive matching (default False)\n\n    Returns:\n        DeviceGroup containing devices in the specified group\n\n    Raises:\n        KeyError: If group label not found\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        bedroom = await group.filter_by_group(\"Bedroom Lights\")\n        await bedroom.set_color(Colors.WARM_WHITE)\n        ```\n    \"\"\"\n    groups = await self.organize_by_group(include_unassigned=False)\n\n    # Find matching label\n    if case_sensitive:\n        if label not in groups:\n            raise KeyError(f\"Group '{label}' not found\")\n        return groups[label]\n    else:\n        label_lower = label.lower()\n        for grp_label, device_group in groups.items():\n            if grp_label.lower() == label_lower:\n                return device_group\n        raise KeyError(f\"Group '{label}' not found\")\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.get_unassigned_devices","title":"get_unassigned_devices","text":"<pre><code>get_unassigned_devices(\n    metadata_type: Literal[\"location\", \"group\"] = \"location\",\n) -&gt; list[Device]\n</code></pre> <p>Get devices without location or group assigned.</p> PARAMETER DESCRIPTION <code>metadata_type</code> <p>Type of metadata to check (\"location\" or \"group\")</p> <p> TYPE: <code>Literal['location', 'group']</code> DEFAULT: <code>'location'</code> </p> RETURNS DESCRIPTION <code>list[Device]</code> <p>List of devices without the specified metadata type</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If metadata hasn't been fetched yet</p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nawait group.organize_by_location()\nunassigned = group.get_unassigned_devices(metadata_type=\"location\")\nprint(f\"Found {len(unassigned)} devices without location\")\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>def get_unassigned_devices(\n    self, metadata_type: Literal[\"location\", \"group\"] = \"location\"\n) -&gt; list[Device]:\n    \"\"\"Get devices without location or group assigned.\n\n    Args:\n        metadata_type: Type of metadata to check (\"location\" or \"group\")\n\n    Returns:\n        List of devices without the specified metadata type\n\n    Raises:\n        RuntimeError: If metadata hasn't been fetched yet\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        await group.organize_by_location()\n        unassigned = group.get_unassigned_devices(metadata_type=\"location\")\n        print(f\"Found {len(unassigned)} devices without location\")\n        ```\n    \"\"\"\n    if metadata_type == \"location\":\n        if self._location_metadata is None:\n            raise RuntimeError(\n                \"Location metadata not fetched. Call organize_by_location() first.\"\n            )\n        return [d for d in self._devices if not self._has_location(d)]\n    else:\n        if self._group_metadata is None:\n            raise RuntimeError(\n                \"Group metadata not fetched. Call organize_by_group() first.\"\n            )\n        return [d for d in self._devices if not self._has_group(d)]\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.apply_theme","title":"apply_theme  <code>async</code>","text":"<pre><code>apply_theme(\n    theme: Theme, power_on: bool = False, duration: float = 0.0\n) -&gt; None\n</code></pre> <p>Apply a theme to all devices in the group.</p> <p>Each device applies the theme according to its capabilities: - Light: Selects random color from theme - MultiZoneLight: Distributes colors evenly across zones - MatrixLight: Uses interpolation for smooth gradients - Other devices: No action (themes only apply to color devices)</p> PARAMETER DESCRIPTION <code>theme</code> <p>Theme to apply</p> <p> TYPE: <code>Theme</code> </p> <code>power_on</code> <p>Turn on devices if True</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>duration</code> <p>Transition duration in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>from lifx.theme import get_theme\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\nevening = get_theme(\"evening\")\nawait group.apply_theme(evening, power_on=True, duration=1.0)\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>async def apply_theme(\n    self, theme: Theme, power_on: bool = False, duration: float = 0.0\n) -&gt; None:\n    \"\"\"Apply a theme to all devices in the group.\n\n    Each device applies the theme according to its capabilities:\n    - Light: Selects random color from theme\n    - MultiZoneLight: Distributes colors evenly across zones\n    - MatrixLight: Uses interpolation for smooth gradients\n    - Other devices: No action (themes only apply to color devices)\n\n    Args:\n        theme: Theme to apply\n        power_on: Turn on devices if True\n        duration: Transition duration in seconds\n\n    Example:\n        ```python\n        from lifx.theme import get_theme\n\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n        evening = get_theme(\"evening\")\n        await group.apply_theme(evening, power_on=True, duration=1.0)\n        ```\n    \"\"\"\n    async with asyncio.TaskGroup() as tg:\n        # Apply theme to all lights\n        for light in self.lights:\n            tg.create_task(light.apply_theme(theme, power_on, duration))\n\n        # Apply theme to all multizone lights\n        for multizone in self.multizone_lights:\n            tg.create_task(multizone.apply_theme(theme, power_on, duration))\n\n        # Apply theme to all matrix light devices\n        for matrix in self.matrix_lights:\n            tg.create_task(matrix.apply_theme(theme, power_on, duration))\n</code></pre>"},{"location":"api/high-level/#lifx.api.DeviceGroup.invalidate_metadata_cache","title":"invalidate_metadata_cache","text":"<pre><code>invalidate_metadata_cache() -&gt; None\n</code></pre> <p>Clear all cached location and group metadata.</p> <p>Use this if you've changed device locations/groups and want to re-fetch.</p> Example <pre><code>devices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\n# First organization\nby_location = await group.organize_by_location()\n\n# ... change device locations ...\n\n# Clear cache and re-organize\ngroup.invalidate_metadata_cache()\nby_location = await group.organize_by_location()\n</code></pre> Source code in <code>src/lifx/api.py</code> <pre><code>def invalidate_metadata_cache(self) -&gt; None:\n    \"\"\"Clear all cached location and group metadata.\n\n    Use this if you've changed device locations/groups and want to re-fetch.\n\n    Example:\n        ```python\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n\n        # First organization\n        by_location = await group.organize_by_location()\n\n        # ... change device locations ...\n\n        # Clear cache and re-organize\n        group.invalidate_metadata_cache()\n        by_location = await group.organize_by_location()\n        ```\n    \"\"\"\n    self._locations_cache = None\n    self._groups_cache = None\n    self._location_metadata = None\n    self._group_metadata = None\n</code></pre>"},{"location":"api/high-level/#organizational-groupings","title":"Organizational Groupings","text":"<p>Dataclasses for organizing devices by location or group. Returned by <code>DeviceGroup.organize_by_location()</code> and <code>DeviceGroup.organize_by_group()</code>.</p>"},{"location":"api/high-level/#locationgrouping","title":"LocationGrouping","text":"<p>Location-based device grouping returned by <code>DeviceGroup.organize_by_location()</code>.</p>"},{"location":"api/high-level/#lifx.api.LocationGrouping","title":"LocationGrouping  <code>dataclass</code>","text":"<pre><code>LocationGrouping(uuid: str, label: str, devices: list[Device], updated_at: int)\n</code></pre> <p>Organizational structure for location-based grouping.</p> METHOD DESCRIPTION <code>to_device_group</code> <p>Convert to DeviceGroup for batch operations.</p>"},{"location":"api/high-level/#lifx.api.LocationGrouping-functions","title":"Functions","text":""},{"location":"api/high-level/#lifx.api.LocationGrouping.to_device_group","title":"to_device_group","text":"<pre><code>to_device_group() -&gt; DeviceGroup\n</code></pre> <p>Convert to DeviceGroup for batch operations.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def to_device_group(self) -&gt; DeviceGroup:\n    \"\"\"Convert to DeviceGroup for batch operations.\"\"\"\n    return DeviceGroup(self.devices)\n</code></pre>"},{"location":"api/high-level/#groupgrouping","title":"GroupGrouping","text":"<p>Group-based device grouping returned by <code>DeviceGroup.organize_by_group()</code>.</p>"},{"location":"api/high-level/#lifx.api.GroupGrouping","title":"GroupGrouping  <code>dataclass</code>","text":"<pre><code>GroupGrouping(uuid: str, label: str, devices: list[Device], updated_at: int)\n</code></pre> <p>Organizational structure for group-based grouping.</p> METHOD DESCRIPTION <code>to_device_group</code> <p>Convert to DeviceGroup for batch operations.</p>"},{"location":"api/high-level/#lifx.api.GroupGrouping-functions","title":"Functions","text":""},{"location":"api/high-level/#lifx.api.GroupGrouping.to_device_group","title":"to_device_group","text":"<pre><code>to_device_group() -&gt; DeviceGroup\n</code></pre> <p>Convert to DeviceGroup for batch operations.</p> Source code in <code>src/lifx/api.py</code> <pre><code>def to_device_group(self) -&gt; DeviceGroup:\n    \"\"\"Convert to DeviceGroup for batch operations.\"\"\"\n    return DeviceGroup(self.devices)\n</code></pre>"},{"location":"api/high-level/#examples","title":"Examples","text":""},{"location":"api/high-level/#simple-discovery","title":"Simple Discovery","text":"<pre><code>from lifx import discover, DeviceGroup, Colors\n\n\nasync def main():\n    count: int = 0\n    async for device in discover():\n        count += 1\n        await device.set_power(True)\n        await device.set_color(Colors.BLUE)\n\n    print(f\"Found {count} devices\")\n</code></pre>"},{"location":"api/high-level/#find-by-serial-number","title":"Find by Serial Number","text":"<pre><code>from lifx import find_by_serial\n\n\nasync def main():\n    # Find specific device by serial number\n    device = await find_by_serial(\"d073d5123456\")\n    if device:\n        async with device:\n            await device.set_power(True)\n</code></pre>"},{"location":"api/high-level/#find-by-label","title":"Find by Label","text":"<pre><code>from lifx import find_by_label, Colors\n\n\nasync def main():\n    # Find all devices with \"Living\" in the label (substring match)\n    async for device in find_by_label(\"Living\"):  # May match \"Living Room\", \"Living Area\", etc.\n\n        await device.set_power(True)\n\n    # Find device with exact label match\n    async for device in find_by_label(\"Living Room\", exact_match=True):\n        await device.set_color(Colors.WARM_WHITE)\n        break  # exact_match returns at most one device\n</code></pre>"},{"location":"api/high-level/#find-by-ip-address","title":"Find by IP Address","text":"<pre><code>from lifx import find_by_ip\n\n\nasync def main():\n    # Find device at specific IP address\n    device = await find_by_ip(\"192.168.1.100\")\n    if device:\n        async with device:\n            await device.set_power(True)\n</code></pre>"},{"location":"api/network/","title":"Network Layer","text":"<p>The network layer provides low-level operations for communicating with LIFX devices over UDP.</p>"},{"location":"api/network/#discovery","title":"Discovery","text":"<p>Functions for discovering LIFX devices on the local network.</p>"},{"location":"api/network/#lifx.network.discovery.discover_devices","title":"discover_devices  <code>async</code>","text":"<pre><code>discover_devices(\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; AsyncGenerator[DiscoveredDevice, None]\n</code></pre> <p>Discover LIFX devices on the local network.</p> <p>Sends a broadcast DeviceGetService packet and yields devices as they respond. Implements DoS protection via timeout, source validation, and serial validation.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Discovery timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>DISCOVERY_TIMEOUT</code> </p> <code>broadcast_address</code> <p>Broadcast address to use</p> <p> TYPE: <code>str</code> DEFAULT: <code>'255.255.255.255'</code> </p> <code>port</code> <p>UDP port to use (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_response_time</code> <p>Max time to wait for responses</p> <p> TYPE: <code>float</code> DEFAULT: <code>MAX_RESPONSE_TIME</code> </p> <code>idle_timeout_multiplier</code> <p>Idle timeout multiplier</p> <p> TYPE: <code>float</code> DEFAULT: <code>IDLE_TIMEOUT_MULTIPLIER</code> </p> <code>device_timeout</code> <p>request timeout set on discovered devices</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> <code>max_retries</code> <p>max retries per request set on discovered devices</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> YIELDS DESCRIPTION <code>AsyncGenerator[DiscoveredDevice, None]</code> <p>DiscoveredDevice instances as they are discovered</p> <code>AsyncGenerator[DiscoveredDevice, None]</code> <p>(deduplicated by serial number)</p> Example <pre><code># Process devices as they're discovered\nasync for device in discover_devices(timeout=5.0):\n    print(f\"Found device: {device.serial} at {device.ip}:{device.port}\")\n\n# Or collect all devices first\ndevices = []\nasync for device in discover_devices():\n    devices.append(device)\n</code></pre> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>async def discover_devices(\n    timeout: float = DISCOVERY_TIMEOUT,\n    broadcast_address: str = \"255.255.255.255\",\n    port: int = LIFX_UDP_PORT,\n    max_response_time: float = MAX_RESPONSE_TIME,\n    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,\n    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n) -&gt; AsyncGenerator[DiscoveredDevice, None]:\n    \"\"\"Discover LIFX devices on the local network.\n\n    Sends a broadcast DeviceGetService packet and yields devices as they respond.\n    Implements DoS protection via timeout, source validation, and serial validation.\n\n    Args:\n        timeout: Discovery timeout in seconds\n        broadcast_address: Broadcast address to use\n        port: UDP port to use (default LIFX_UDP_PORT)\n        max_response_time: Max time to wait for responses\n        idle_timeout_multiplier: Idle timeout multiplier\n        device_timeout: request timeout set on discovered devices\n        max_retries: max retries per request set on discovered devices\n\n    Yields:\n        DiscoveredDevice instances as they are discovered\n        (deduplicated by serial number)\n\n    Example:\n        ```python\n        # Process devices as they're discovered\n        async for device in discover_devices(timeout=5.0):\n            print(f\"Found device: {device.serial} at {device.ip}:{device.port}\")\n\n        # Or collect all devices first\n        devices = []\n        async for device in discover_devices():\n            devices.append(device)\n        ```\n    \"\"\"\n    seen_serials: set[str] = set()\n    packet_count = 0\n    start_time = time.time()\n\n    # Create transport with broadcast enabled\n    async with UdpTransport(port=0, broadcast=True) as transport:\n        # Allocate unique source for this discovery session\n        discovery_source = secrets.randbelow(0xFFFFFFFF - 1) + 2\n\n        # Create discovery message\n        discovery_packet = DevicePackets.GetService()\n        message = create_message(\n            packet=discovery_packet,\n            source=discovery_source,\n            sequence=_DEFAULT_SEQUENCE_START,\n            target=b\"\\x00\" * 8,  # Broadcast\n            res_required=True,\n            ack_required=False,\n        )\n\n        # Send broadcast\n        request_time = time.time()\n        _LOGGER.debug(\n            {\n                \"class\": \"discover_devices\",\n                \"method\": \"discover\",\n                \"action\": \"broadcast_sent\",\n                \"broadcast_address\": broadcast_address,\n                \"port\": port,\n                \"max_timeout\": timeout,\n                \"request_time\": request_time,\n            }\n        )\n        await transport.send(message, (broadcast_address, port))\n\n        # Calculate idle timeout\n        idle_timeout = max_response_time * idle_timeout_multiplier\n        last_response_time = request_time\n\n        # Collect responses with dynamic timeout\n        while True:\n            # Calculate elapsed time since last response\n            elapsed_since_last = time.time() - last_response_time\n\n            # Stop if we've been idle too long\n            if elapsed_since_last &gt;= idle_timeout:\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"idle_timeout\",\n                        \"idle_time\": elapsed_since_last,\n                        \"idle_timeout\": idle_timeout,\n                    }\n                )\n                break\n\n            # Stop if we've exceeded the overall timeout\n            if time.time() - request_time &gt;= timeout:\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"overall_timeout\",\n                        \"elapsed\": time.time() - request_time,\n                        \"timeout\": timeout,\n                    }\n                )\n                break\n\n            # Calculate remaining timeout (use the shorter of idle or overall timeout)\n            remaining_idle = idle_timeout - elapsed_since_last\n            remaining_overall = timeout - (time.time() - request_time)\n            remaining = min(remaining_idle, remaining_overall)\n\n            # Try to receive a packet\n            try:\n                data, addr = await transport.receive(timeout=remaining)\n                response_timestamp = time.time()\n\n            except LifxTimeoutError:\n                # Timeout means no more responses within the idle period\n                _LOGGER.debug(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"no_responses\",\n                    }\n                )\n                break\n\n            # Increment packet counter for logging\n            packet_count += 1\n\n            try:\n                # Parse message\n                header, payload = parse_message(data)\n\n                # Validate source matches expected source\n                if header.source != discovery_source:\n                    _LOGGER.debug(\n                        {\n                            \"class\": \"discover_devices\",\n                            \"method\": \"discover\",\n                            \"action\": \"source_mismatch\",\n                            \"expected_source\": discovery_source,\n                            \"received_source\": header.source,\n                            \"source_ip\": addr[0],\n                        }\n                    )\n                    continue\n\n                # Check if this is a DeviceStateService response\n                if header.pkt_type != DevicePackets.StateService.PKT_TYPE:\n                    _LOGGER.debug(\n                        {\n                            \"class\": \"discover_devices\",\n                            \"method\": \"discover\",\n                            \"action\": \"unexpected_packet_type\",\n                            \"pkt_type\": header.pkt_type,\n                            \"expected_type\": DevicePackets.StateService.PKT_TYPE,\n                            \"source_ip\": addr[0],\n                        }\n                    )\n                    continue\n\n                # Validate serial is not multicast/broadcast\n                if header.target[0] &amp; 0x01 or header.target == b\"\\xff\" * 8:\n                    _LOGGER.warning(\n                        {\n                            \"warning\": \"Invalid serial number in discovery response\",\n                            \"serial\": header.target.hex(),\n                            \"source_ip\": addr[0],\n                        }\n                    )\n                    continue\n\n                # Parse service info\n                _service, device_port = _parse_device_state_service(payload)\n\n                # Calculate accurate response time from this specific response\n                response_time = response_timestamp - request_time\n\n                # Convert 8-byte protocol serial to string\n                device_serial = Serial.from_protocol(header.target).to_string()\n\n                # Deduplicate by serial number and yield new devices immediately\n                if device_serial not in seen_serials:\n                    seen_serials.add(device_serial)\n\n                    # Create device info\n                    device = DiscoveredDevice(\n                        serial=device_serial,\n                        ip=addr[0],\n                        port=device_port,\n                        response_time=response_time,\n                        timeout=device_timeout,\n                        max_retries=max_retries,\n                    )\n\n                    _LOGGER.debug(\n                        {\n                            \"class\": \"discover_devices\",\n                            \"method\": \"discover\",\n                            \"action\": \"device_found\",\n                            \"serial\": device.serial,\n                            \"ip\": device.ip,\n                            \"port\": device.port,\n                            \"response_time\": response_time,\n                        }\n                    )\n\n                    yield device\n\n                # Update last response time for idle timeout calculation\n                last_response_time = response_timestamp\n\n            except LifxProtocolError as e:\n                # Log malformed responses\n                _LOGGER.warning(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"malformed_response\",\n                        \"reason\": str(e),\n                        \"source_ip\": addr[0],\n                        \"packet_size\": len(data),\n                    },\n                    exc_info=True,\n                )\n                continue\n            except Exception as e:\n                # Log unexpected errors\n                _LOGGER.error(\n                    {\n                        \"class\": \"discover_devices\",\n                        \"method\": \"discover\",\n                        \"action\": \"unexpected_error\",\n                        \"error_details\": str(e),\n                        \"source_ip\": addr[0],\n                    },\n                    exc_info=True,\n                )\n                continue\n\n        _LOGGER.debug(\n            {\n                \"class\": \"discover_devices\",\n                \"method\": \"discover\",\n                \"action\": \"complete\",\n                \"devices_found\": len(seen_serials),\n                \"packets_processed\": packet_count,\n                \"elapsed\": time.time() - start_time,\n            }\n        )\n</code></pre>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice","title":"DiscoveredDevice  <code>dataclass</code>","text":"<pre><code>DiscoveredDevice(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n    first_seen: float = time(),\n    response_time: float = 0.0,\n)\n</code></pre> <p>Information about a discovered LIFX device.</p> ATTRIBUTE DESCRIPTION <code>serial</code> <p>Device serial number as 12-digit hex string (e.g., \"d073d5123456\")</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port</p> <p> TYPE: <code>int</code> </p> <code>first_seen</code> <p>Timestamp when device was first discovered</p> <p> TYPE: <code>float</code> </p> <code>response_time</code> <p>Response time in seconds</p> <p> TYPE: <code>float</code> </p> METHOD DESCRIPTION <code>create_device</code> <p>Create appropriate device instance based on product capabilities.</p> <code>__hash__</code> <p>Hash based on serial number for deduplication.</p> <code>__eq__</code> <p>Equality based on serial number.</p>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice.create_device","title":"create_device  <code>async</code>","text":"<pre><code>create_device() -&gt; Device | None\n</code></pre> <p>Create appropriate device instance based on product capabilities.</p> <p>Queries the device for its product ID and uses the product registry to instantiate the appropriate device class (Device, Light, HevLight, InfraredLight, MultiZoneLight, MatrixLight, or CeilingLight) based on the product capabilities.</p> <p>This is the single source of truth for device type detection and instantiation across the library.</p> RETURNS DESCRIPTION <code>Device | None</code> <p>Device instance of the appropriate type</p> RAISES DESCRIPTION <code>LifxDeviceNotFoundError</code> <p>If device doesn't respond</p> <code>LifxTimeoutError</code> <p>If device query times out</p> <code>LifxProtocolError</code> <p>If device returns invalid data</p> Example <pre><code>devices = await discover_devices()\nfor discovered in devices:\n    device = await discovered.create_device()\n    print(f\"Created {type(device).__name__}: {await device.get_label()}\")\n</code></pre> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>async def create_device(self) -&gt; Device | None:\n    \"\"\"Create appropriate device instance based on product capabilities.\n\n    Queries the device for its product ID and uses the product registry\n    to instantiate the appropriate device class (Device, Light, HevLight,\n    InfraredLight, MultiZoneLight, MatrixLight, or CeilingLight) based on\n    the product capabilities.\n\n    This is the single source of truth for device type detection and\n    instantiation across the library.\n\n    Returns:\n        Device instance of the appropriate type\n\n    Raises:\n        LifxDeviceNotFoundError: If device doesn't respond\n        LifxTimeoutError: If device query times out\n        LifxProtocolError: If device returns invalid data\n\n    Example:\n        ```python\n        devices = await discover_devices()\n        for discovered in devices:\n            device = await discovered.create_device()\n            print(f\"Created {type(device).__name__}: {await device.get_label()}\")\n        ```\n    \"\"\"\n    from lifx.devices.base import Device\n    from lifx.devices.ceiling import CeilingLight\n    from lifx.devices.hev import HevLight\n    from lifx.devices.infrared import InfraredLight\n    from lifx.devices.light import Light\n    from lifx.devices.matrix import MatrixLight\n    from lifx.devices.multizone import MultiZoneLight\n    from lifx.products import is_ceiling_product\n\n    kwargs = {\n        \"serial\": self.serial,\n        \"ip\": self.ip,\n        \"port\": self.port,\n        \"timeout\": self.timeout,\n        \"max_retries\": self.max_retries,\n    }\n\n    # Create temporary device to query version\n    temp_device = Device(**kwargs)\n\n    try:\n        await temp_device._ensure_capabilities()\n\n        if temp_device.capabilities:\n            # Check for Ceiling products first (before generic MatrixLight)\n            if temp_device.version and is_ceiling_product(\n                temp_device.version.product\n            ):\n                return CeilingLight(**kwargs)\n\n            if temp_device.capabilities.has_matrix:\n                return MatrixLight(**kwargs)\n            if temp_device.capabilities.has_multizone:\n                return MultiZoneLight(**kwargs)\n            if temp_device.capabilities.has_infrared:\n                return InfraredLight(**kwargs)\n            if temp_device.capabilities.has_hev:\n                return HevLight(**kwargs)\n            if temp_device.capabilities.has_relays or (\n                temp_device.capabilities.has_buttons\n                and not temp_device.capabilities.has_color\n            ):\n                return None\n\n            return Light(**kwargs)\n\n    except Exception:\n        return None\n\n    finally:\n        # Always close the temporary device connection to prevent resource leaks\n        await temp_device.connection.close()\n\n    return None\n</code></pre>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash based on serial number for deduplication.</p> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash based on serial number for deduplication.\"\"\"\n    return hash(self.serial)\n</code></pre>"},{"location":"api/network/#lifx.network.discovery.DiscoveredDevice.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Equality based on serial number.</p> Source code in <code>src/lifx/network/discovery.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Equality based on serial number.\"\"\"\n    if not isinstance(other, DiscoveredDevice):\n        return False\n    return self.serial == other.serial\n</code></pre>"},{"location":"api/network/#discoveryresponse","title":"DiscoveryResponse","text":"<p>Response dataclass from custom discovery broadcasts (using packets other than GetService).</p>"},{"location":"api/network/#lifx.network.discovery.DiscoveryResponse","title":"DiscoveryResponse  <code>dataclass</code>","text":"<pre><code>DiscoveryResponse(\n    serial: str,\n    ip: str,\n    port: int,\n    response_time: float,\n    response_payload: dict[str, Any],\n)\n</code></pre> <p>Response from a discovery broadcast using a custom packet.</p> ATTRIBUTE DESCRIPTION <code>serial</code> <p>Device serial number</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port</p> <p> TYPE: <code>int</code> </p> <code>response_time</code> <p>Response time in seconds</p> <p> TYPE: <code>float</code> </p> <code>response_payload</code> <p>Unpacked State packet fields as key/value dict</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/network/#udp-transport","title":"UDP Transport","text":"<p>Low-level UDP transport for sending and receiving LIFX protocol messages.</p>"},{"location":"api/network/#lifx.network.transport.UdpTransport","title":"UdpTransport","text":"<pre><code>UdpTransport(\n    ip_address: str = DEFAULT_IP_ADDRESS, port: int = 0, broadcast: bool = False\n)\n</code></pre> <p>UDP transport for sending and receiving LIFX packets.</p> <p>This class provides a simple interface for UDP communication with LIFX devices. It uses asyncio for async I/O operations.</p> PARAMETER DESCRIPTION <code>port</code> <p>Local port to bind to (0 for automatic assignment)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>broadcast</code> <p>Enable broadcast mode for device discovery</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> METHOD DESCRIPTION <code>open</code> <p>Open the UDP socket.</p> <code>send</code> <p>Send data to a specific address.</p> <code>receive</code> <p>Receive data from socket with size validation.</p> <code>receive_many</code> <p>Receive multiple packets within timeout period.</p> <code>close</code> <p>Close the UDP socket.</p> ATTRIBUTE DESCRIPTION <code>is_open</code> <p>Check if socket is open.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>def __init__(\n    self,\n    ip_address: str = DEFAULT_IP_ADDRESS,\n    port: int = 0,\n    broadcast: bool = False,\n) -&gt; None:\n    \"\"\"Initialize UDP transport.\n\n    Args:\n        port: Local port to bind to (0 for automatic assignment)\n        broadcast: Enable broadcast mode for device discovery\n    \"\"\"\n    self._ip_address = ip_address\n    self._port = port\n    self._broadcast = broadcast\n    self._protocol: _UdpProtocol | None = None\n    self._transport: DatagramTransport | None = None\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport-attributes","title":"Attributes","text":""},{"location":"api/network/#lifx.network.transport.UdpTransport.is_open","title":"is_open  <code>property</code>","text":"<pre><code>is_open: bool\n</code></pre> <p>Check if socket is open.</p>"},{"location":"api/network/#lifx.network.transport.UdpTransport-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.transport.UdpTransport.open","title":"open  <code>async</code>","text":"<pre><code>open() -&gt; None\n</code></pre> <p>Open the UDP socket.</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def open(self) -&gt; None:\n    \"\"\"Open the UDP socket.\"\"\"\n    if self._protocol is not None:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"already_open\",\n                \"ip_address\": self._ip_address,\n                \"port\": self._port,\n            }\n        )\n        return\n\n    try:\n        import socket as stdlib_socket\n\n        loop = asyncio.get_running_loop()\n\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"opening_socket\",\n                \"ip_address\": self._ip_address,\n                \"port\": self._port,\n                \"broadcast\": self._broadcast,\n            }\n        )\n\n        # Create protocol\n        protocol = _UdpProtocol()\n        self._protocol = protocol\n\n        # Create datagram endpoint\n        self._transport, _ = await loop.create_datagram_endpoint(\n            lambda: protocol,\n            local_addr=(self._ip_address, self._port),\n            reuse_port=bool(hasattr(stdlib_socket, \"SO_REUSEPORT\")),\n            family=stdlib_socket.AF_INET,\n        )\n\n        # Get actual port assigned\n        actual_port = self._transport.get_extra_info(\"sockname\")[1]\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"socket_opened\",\n                \"assigned_port\": actual_port,\n                \"broadcast\": self._broadcast,\n            }\n        )\n\n        # Enable broadcast if requested\n        if self._broadcast:\n            sock = self._transport.get_extra_info(\"socket\")\n            if sock:\n                sock.setsockopt(\n                    stdlib_socket.SOL_SOCKET,\n                    stdlib_socket.SO_BROADCAST,\n                    1,\n                )\n                _LOGGER.debug(\n                    {\n                        \"class\": \"UdpTransport\",\n                        \"method\": \"open\",\n                        \"action\": \"broadcast_enabled\",\n                    }\n                )\n\n    except OSError as e:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"open\",\n                \"action\": \"failed\",\n                \"ip_address\": self._ip_address,\n                \"port\": self._port,\n                \"reason\": str(e),\n            }\n        )\n        raise LifxNetworkError(f\"Failed to open UDP socket: {e}\") from e\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.send","title":"send  <code>async</code>","text":"<pre><code>send(data: bytes, address: tuple[str, int]) -&gt; None\n</code></pre> <p>Send data to a specific address.</p> PARAMETER DESCRIPTION <code>data</code> <p>Bytes to send</p> <p> TYPE: <code>bytes</code> </p> <code>address</code> <p>Tuple of (host, port)</p> <p> TYPE: <code>tuple[str, int]</code> </p> RAISES DESCRIPTION <code>NetworkError</code> <p>If socket is not open or send fails</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def send(self, data: bytes, address: tuple[str, int]) -&gt; None:\n    \"\"\"Send data to a specific address.\n\n    Args:\n        data: Bytes to send\n        address: Tuple of (host, port)\n\n    Raises:\n        NetworkError: If socket is not open or send fails\n    \"\"\"\n    if self._transport is None or self._protocol is None:\n        raise LifxNetworkError(\"Socket not open\")\n\n    try:\n        self._transport.sendto(data, address)\n    except OSError as e:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"send\",\n                \"action\": \"failed\",\n                \"destination\": address,\n                \"packet_size\": len(data),\n                \"reason\": str(e),\n            }\n        )\n        raise LifxNetworkError(f\"Failed to send data: {e}\") from e\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(timeout: float = 2.0) -&gt; tuple[bytes, tuple[str, int]]\n</code></pre> <p>Receive data from socket with size validation.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> RETURNS DESCRIPTION <code>tuple[bytes, tuple[str, int]]</code> <p>Tuple of (data, address) where address is (host, port)</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>If no data received within timeout</p> <code>NetworkError</code> <p>If socket is not open or receive fails</p> <code>ProtocolError</code> <p>If packet size is invalid</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def receive(self, timeout: float = 2.0) -&gt; tuple[bytes, tuple[str, int]]:\n    \"\"\"Receive data from socket with size validation.\n\n    Args:\n        timeout: Timeout in seconds\n\n    Returns:\n        Tuple of (data, address) where address is (host, port)\n\n    Raises:\n        LifxTimeoutError: If no data received within timeout\n        NetworkError: If socket is not open or receive fails\n        ProtocolError: If packet size is invalid\n    \"\"\"\n    if self._protocol is None:\n        raise LifxNetworkError(\"Socket not open\")\n\n    try:\n        async with asyncio.timeout(timeout):\n            data, addr = await self._protocol.queue.get()\n\n            # Validate packet size\n            if len(data) &gt; MAX_PACKET_SIZE:\n                from lifx.exceptions import LifxProtocolError\n\n                _LOGGER.error(\n                    {\n                        \"class\": \"UdpTransport\",\n                        \"method\": \"receive\",\n                        \"action\": \"packet_too_large\",\n                        \"packet_size\": len(data),\n                        \"max_size\": MAX_PACKET_SIZE,\n                    }\n                )\n                raise LifxProtocolError(\n                    f\"Packet too big: {len(data)} bytes &gt; {MAX_PACKET_SIZE} bytes\"\n                )\n\n            if len(data) &lt; MIN_PACKET_SIZE:\n                from lifx.exceptions import LifxProtocolError\n\n                _LOGGER.error(\n                    {\n                        \"class\": \"UdpTransport\",\n                        \"method\": \"receive\",\n                        \"action\": \"packet_too_small\",\n                        \"packet_size\": len(data),\n                        \"min_size\": MIN_PACKET_SIZE,\n                    }\n                )\n                raise LifxProtocolError(\n                    f\"Packet too small: {len(data)} bytes &lt; {MIN_PACKET_SIZE} bytes\"\n                )\n\n            return data, addr\n    except TimeoutError as e:\n        raise LifxTimeoutError(f\"No data received within {timeout}s\") from e\n    except OSError as e:\n        _LOGGER.error(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"receive\",\n                \"action\": \"failed\",\n                \"reason\": str(e),\n            }\n        )\n        raise LifxNetworkError(f\"Failed to receive data: {e}\") from e\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.receive_many","title":"receive_many  <code>async</code>","text":"<pre><code>receive_many(\n    timeout: float = 5.0, max_packets: int | None = None\n) -&gt; list[tuple[bytes, tuple[str, int]]]\n</code></pre> <p>Receive multiple packets within timeout period.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Total timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>5.0</code> </p> <code>max_packets</code> <p>Maximum number of packets to receive (None for unlimited)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[tuple[bytes, tuple[str, int]]]</code> <p>List of (data, address) tuples</p> RAISES DESCRIPTION <code>NetworkError</code> <p>If socket is not open</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def receive_many(\n    self, timeout: float = 5.0, max_packets: int | None = None\n) -&gt; list[tuple[bytes, tuple[str, int]]]:\n    \"\"\"Receive multiple packets within timeout period.\n\n    Args:\n        timeout: Total timeout in seconds\n        max_packets: Maximum number of packets to receive (None for unlimited)\n\n    Returns:\n        List of (data, address) tuples\n\n    Raises:\n        NetworkError: If socket is not open\n    \"\"\"\n    if self._protocol is None:\n        raise LifxNetworkError(\"Socket not open\")\n\n    packets: list[tuple[bytes, tuple[str, int]]] = []\n\n    try:\n        async with asyncio.timeout(timeout):\n            while True:\n                if max_packets is not None and len(packets) &gt;= max_packets:\n                    break\n\n                try:\n                    data, addr = await self._protocol.queue.get()\n\n                    # Validate packet size\n                    if len(data) &gt; MAX_PACKET_SIZE:\n                        # Drop oversized packet to prevent memory exhaustion DoS\n                        continue\n\n                    if len(data) &lt; MIN_PACKET_SIZE:\n                        # Drop undersized packet (header is 36 bytes)\n                        continue\n\n                    packets.append((data, addr))\n                except OSError:\n                    # Ignore individual receive errors\n                    break\n\n    except TimeoutError:\n        # Timeout is expected - return what we collected\n        pass\n\n    return packets\n</code></pre>"},{"location":"api/network/#lifx.network.transport.UdpTransport.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the UDP socket.</p> Source code in <code>src/lifx/network/transport.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the UDP socket.\"\"\"\n    if self._transport is not None:\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"close\",\n                \"action\": \"closing\",\n            }\n        )\n        self._transport.close()\n        self._transport = None\n        self._protocol = None\n        _LOGGER.debug(\n            {\n                \"class\": \"UdpTransport\",\n                \"method\": \"close\",\n                \"action\": \"closed\",\n            }\n        )\n</code></pre>"},{"location":"api/network/#examples","title":"Examples","text":""},{"location":"api/network/#device-discovery","title":"Device Discovery","text":"<pre><code>from lifx.network.discovery import discover_devices\n\n\nasync def main():\n    # Discover all devices on the network\n    devices = await discover_devices(timeout=3.0)\n\n    for device in devices:\n        print(f\"Found: {device.label} at {device.ip}\")\n        print(f\"  Serial: {device.serial}\")\n</code></pre>"},{"location":"api/network/#concurrency","title":"Concurrency","text":""},{"location":"api/network/#request-serialization-on-single-connection","title":"Request Serialization on Single Connection","text":"<p>Each <code>DeviceConnection</code> serializes requests using a lock to prevent response mixing:</p> <pre><code>import asyncio\nfrom lifx.network.connection import DeviceConnection\nfrom lifx.protocol.packets import Light, Device\n\n\nasync def main():\n    conn = DeviceConnection(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\n    # Sequential requests (serialized by internal lock)\n    state = await conn.request(Light.GetColor())\n    power = await conn.request(Light.GetPower())\n    label = await conn.request(Device.GetLabel())\n\n    # Connection automatically closes when done\n    await conn.close()\n</code></pre>"},{"location":"api/network/#concurrent-requests-on-different-devices","title":"Concurrent Requests on Different Devices","text":"<pre><code>import asyncio\nfrom lifx.network.connection import DeviceConnection\n\n\nasync def main():\n    conn1 = DeviceConnection(serial=\"d073d5000001\", ip=\"192.168.1.100\")\n    conn2 = DeviceConnection(serial=\"d073d5000002\", ip=\"192.168.1.101\")\n\n    # Fully parallel - different UDP sockets\n    result1, result2 = await asyncio.gather(\n        conn1.request(Light.GetColor()),\n        conn2.request(Light.GetColor())\n    )\n\n    # Clean up connections\n    await conn1.close()\n    await conn2.close()\n</code></pre>"},{"location":"api/network/#connection-management","title":"Connection Management","text":""},{"location":"api/network/#lifx.network.connection.DeviceConnection","title":"DeviceConnection","text":"<pre><code>DeviceConnection(\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n)\n</code></pre> <p>Connection to a LIFX device.</p> <p>This class manages the UDP transport and request/response lifecycle for a single device. Connections are opened lazily on first request and remain open until explicitly closed.</p> <p>Features: - Lazy connection opening (no context manager required) - Async generator-based request/response streaming - Retry logic with exponential backoff and jitter - Request serialization to prevent response mixing - Automatic sequence number management</p> Example <pre><code>conn = DeviceConnection(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n\n# Connection opens automatically on first request\nstate = await conn.request(packets.Light.GetColor())\n# state.label is already decoded to string\n# state.color is LightHsbk instance\n\n# Optionally close when done\nawait conn.close()\n</code></pre> <p>With context manager (recommended for cleanup):     <pre><code>async with DeviceConnection(...) as conn:\n    state = await conn.request(packets.Light.GetColor())\n# Connection automatically closed on exit\n</code></pre></p> <p>This is lightweight - doesn't actually create a connection. Connection is opened lazily on first request.</p> PARAMETER DESCRIPTION <code>serial</code> <p>Device serial number as 12-digit hex string (e.g., 'd073d5123456')</p> <p> TYPE: <code>str</code> </p> <code>ip</code> <p>Device IP address</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Device UDP port (default LIFX_UDP_PORT)</p> <p> TYPE: <code>int</code> DEFAULT: <code>LIFX_UDP_PORT</code> </p> <code>max_retries</code> <p>Maximum number of retry attempts (default: 8)</p> <p> TYPE: <code>int</code> DEFAULT: <code>DEFAULT_MAX_RETRIES</code> </p> <code>timeout</code> <p>Default timeout for requests in seconds (default: 8.0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_REQUEST_TIMEOUT</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter async context manager.</p> <code>__aexit__</code> <p>Exit async context manager and close connection.</p> <code>open</code> <p>Open connection to device.</p> <code>close</code> <p>Close connection to device.</p> <code>send_packet</code> <p>Send a packet to the device.</p> <code>receive_packet</code> <p>Receive a packet from the device.</p> <code>request_stream</code> <p>Send request and yield unpacked responses.</p> <code>request</code> <p>Send request and get single response (convenience wrapper).</p> ATTRIBUTE DESCRIPTION <code>is_open</code> <p>Check if connection is open.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>def __init__(\n    self,\n    serial: str,\n    ip: str,\n    port: int = LIFX_UDP_PORT,\n    max_retries: int = DEFAULT_MAX_RETRIES,\n    timeout: float = DEFAULT_REQUEST_TIMEOUT,\n) -&gt; None:\n    \"\"\"Initialize device connection.\n\n    This is lightweight - doesn't actually create a connection.\n    Connection is opened lazily on first request.\n\n    Args:\n        serial: Device serial number as 12-digit hex string (e.g., 'd073d5123456')\n        ip: Device IP address\n        port: Device UDP port (default LIFX_UDP_PORT)\n        max_retries: Maximum number of retry attempts (default: 8)\n        timeout: Default timeout for requests in seconds (default: 8.0)\n    \"\"\"\n    self.serial = serial\n    self.ip = ip\n    self.port = port\n    self.max_retries = max_retries\n    self.timeout = timeout\n\n    self._transport: UdpTransport | None = None\n    self._is_open = False\n    self._is_opening = False  # Flag to prevent concurrent open() calls\n\n    # Background receiver task infrastructure\n    # Key: (source, sequence, serial) \u2192 Queue of (header, payload) tuples\n    self._pending_requests: dict[\n        tuple[int, int, str], asyncio.Queue[tuple[LifxHeader, bytes]]\n    ] = {}\n    self._receiver_task: asyncio.Task[None] | None = None\n    self._receiver_shutdown: asyncio.Event | None = None\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection-attributes","title":"Attributes","text":""},{"location":"api/network/#lifx.network.connection.DeviceConnection.is_open","title":"is_open  <code>property</code>","text":"<pre><code>is_open: bool\n</code></pre> <p>Check if connection is open.</p>"},{"location":"api/network/#lifx.network.connection.DeviceConnection-functions","title":"Functions","text":""},{"location":"api/network/#lifx.network.connection.DeviceConnection.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter async context manager.</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter async context manager.\"\"\"\n    # Don't open connection here - it will open lazily on first request\n    return self\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: object,\n) -&gt; None\n</code></pre> <p>Exit async context manager and close connection.</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: object,\n) -&gt; None:\n    \"\"\"Exit async context manager and close connection.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.open","title":"open  <code>async</code>","text":"<pre><code>open() -&gt; None\n</code></pre> <p>Open connection to device.</p> <p>Opens the UDP transport for sending and receiving packets. Called automatically on first request if not already open.</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def open(self) -&gt; None:\n    \"\"\"Open connection to device.\n\n    Opens the UDP transport for sending and receiving packets.\n    Called automatically on first request if not already open.\n    \"\"\"\n    if self._is_open:\n        return\n\n    # Prevent concurrent open() calls\n    if self._is_opening:\n        # Another task is already opening, wait for it\n        while self._is_opening:\n            await asyncio.sleep(0.001)\n        return\n\n    self._is_opening = True\n    try:\n        # Double-check after setting flag\n        if self._is_open:  # pragma: no cover\n            return\n\n        # Create shutdown event for receiver task\n        self._receiver_shutdown = asyncio.Event()\n\n        # Open transport\n        self._transport = UdpTransport(port=0, broadcast=False)\n        await self._transport.open()\n        self._is_open = True\n\n        # Start background receiver task\n        self._receiver_task = asyncio.create_task(self._background_receiver())\n\n        _LOGGER.debug(\n            {\n                \"class\": \"DeviceConnection\",\n                \"method\": \"open\",\n                \"serial\": self.serial,\n                \"ip\": self.ip,\n                \"port\": self.port,\n            }\n        )\n    finally:\n        self._is_opening = False\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close connection to device.</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close connection to device.\"\"\"\n    if not self._is_open:\n        return\n\n    self._is_open = False\n\n    # Signal shutdown to receiver task\n    if self._receiver_shutdown:\n        self._receiver_shutdown.set()\n\n    # Wait for receiver to stop (with timeout)\n    if self._receiver_task:\n        try:\n            await asyncio.wait_for(\n                self._receiver_task, timeout=_RECEIVER_SHUTDOWN_TIMEOUT\n            )\n        except TimeoutError:\n            self._receiver_task.cancel()\n            try:\n                await self._receiver_task\n            except asyncio.CancelledError:\n                pass\n\n    # Cancel all pending request queues\n    for queue in self._pending_requests.values():\n        # Drain queue\n        while not queue.empty():\n            try:\n                queue.get_nowait()\n            except asyncio.QueueEmpty:\n                break\n    self._pending_requests.clear()\n\n    # Close transport\n    if self._transport is not None:\n        await self._transport.close()\n\n    _LOGGER.debug(\n        {\n            \"class\": \"DeviceConnection\",\n            \"method\": \"close\",\n            \"serial\": self.serial,\n            \"ip\": self.ip,\n        }\n    )\n    self._transport = None\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.send_packet","title":"send_packet  <code>async</code>","text":"<pre><code>send_packet(\n    packet: Any,\n    source: int | None = None,\n    sequence: int = 0,\n    ack_required: bool = False,\n    res_required: bool = False,\n) -&gt; None\n</code></pre> <p>Send a packet to the device.</p> PARAMETER DESCRIPTION <code>packet</code> <p>Packet dataclass instance</p> <p> TYPE: <code>Any</code> </p> <code>source</code> <p>Client source identifier (optional, allocated if None)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>sequence</code> <p>Sequence number (default: 0)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>ack_required</code> <p>Request acknowledgement</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>res_required</code> <p>Request response</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ConnectionError</code> <p>If connection is not open or send fails</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def send_packet(\n    self,\n    packet: Any,\n    source: int | None = None,\n    sequence: int = 0,\n    ack_required: bool = False,\n    res_required: bool = False,\n) -&gt; None:\n    \"\"\"Send a packet to the device.\n\n    Args:\n        packet: Packet dataclass instance\n        source: Client source identifier (optional, allocated if None)\n        sequence: Sequence number (default: 0)\n        ack_required: Request acknowledgement\n        res_required: Request response\n\n    Raises:\n        ConnectionError: If connection is not open or send fails\n    \"\"\"\n    if not self._is_open or self._transport is None:\n        raise LifxConnectionError(\"Connection not open\")\n\n    # Allocate source if not provided\n    if source is None:\n        source = self._allocate_source()\n\n    target = Serial.from_string(self.serial).to_protocol()\n    message = create_message(\n        packet=packet,\n        source=source,\n        sequence=sequence,\n        target=target,\n        ack_required=ack_required,\n        res_required=res_required,\n    )\n\n    # Send to device\n    await self._transport.send(message, (self.ip, self.port))\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.receive_packet","title":"receive_packet  <code>async</code>","text":"<pre><code>receive_packet(timeout: float = 0.5) -&gt; tuple[LifxHeader, bytes]\n</code></pre> <p>Receive a packet from the device.</p> Note <p>This method does not validate the source IP address. Validation is instead performed using the LIFX protocol's built-in target field (serial number) and sequence number matching in request_stream() and request_ack_stream(). This approach is more reliable in complex network configurations (NAT, multiple interfaces, bridges, etc.) while maintaining security through proper protocol-level validation.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> RETURNS DESCRIPTION <code>tuple[LifxHeader, bytes]</code> <p>Tuple of (header, payload)</p> RAISES DESCRIPTION <code>ConnectionError</code> <p>If connection is not open</p> <code>TimeoutError</code> <p>If no response within timeout</p> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def receive_packet(self, timeout: float = 0.5) -&gt; tuple[LifxHeader, bytes]:\n    \"\"\"Receive a packet from the device.\n\n    Note:\n        This method does not validate the source IP address. Validation is instead\n        performed using the LIFX protocol's built-in target field (serial number)\n        and sequence number matching in request_stream() and request_ack_stream().\n        This approach is more reliable in complex network configurations (NAT,\n        multiple interfaces, bridges, etc.) while maintaining security through\n        proper protocol-level validation.\n\n    Args:\n        timeout: Timeout in seconds\n\n    Returns:\n        Tuple of (header, payload)\n\n    Raises:\n        ConnectionError: If connection is not open\n        TimeoutError: If no response within timeout\n    \"\"\"\n    if not self._is_open or self._transport is None:\n        raise LifxConnectionError(\"Connection not open\")\n\n    # Receive message - source address not validated here\n    # Validation occurs via target field and sequence number matching\n    data, _addr = await self._transport.receive(timeout=timeout)\n\n    # Parse and return message\n    return parse_message(data)\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.request_stream","title":"request_stream  <code>async</code>","text":"<pre><code>request_stream(\n    packet: Any, timeout: float | None = None\n) -&gt; AsyncGenerator[Any, None]\n</code></pre> <p>Send request and yield unpacked responses.</p> <p>This is an async generator that handles the complete request/response cycle including packet type detection, response unpacking, and label decoding. Connection is opened automatically if not already open.</p> <p>Single response (most common):     async for response in conn.request_stream(GetLabel()):         process(response)         break  # Exit immediately</p> Multiple responses <p>async for state in conn.request_stream(GetColorZones()):     process(state)     # Continues until timeout</p> PARAMETER DESCRIPTION <code>packet</code> <p>Packet instance to send</p> <p> TYPE: <code>Any</code> </p> <code>timeout</code> <p>Request timeout in seconds</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncGenerator[Any, None]</code> <p>Unpacked response packet instances (including StateUnhandled if device</p> <code>AsyncGenerator[Any, None]</code> <p>doesn't support the command)</p> <code>AsyncGenerator[Any, None]</code> <p>For SET packets: yields True (acknowledgement) or False (StateUnhandled)</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>If request times out</p> <code>LifxProtocolError</code> <p>If response invalid</p> <code>LifxConnectionError</code> <p>If connection fails</p> Example <pre><code># GET request yields unpacked packets\nasync for state in conn.request_stream(packets.Light.GetColor()):\n    color = HSBK.from_protocol(state.color)\n    label = state.label  # Already decoded to string\n    break\n\n# SET request yields True (acknowledgement) or False (StateUnhandled)\nasync for result in conn.request_stream(\n    packets.Light.SetColor(color=hsbk, duration=1000)\n):\n    if result:\n        # Acknowledgement received\n        pass\n    else:\n        # Device doesn't support this command\n        pass\n    break\n\n# Multi-response GET - stream all responses\nasync for state in conn.request_stream(\n    packets.MultiZone.GetExtendedColorZones()\n):\n    # Process each zone state\n    pass\n</code></pre> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def request_stream(\n    self,\n    packet: Any,\n    timeout: float | None = None,\n) -&gt; AsyncGenerator[Any, None]:\n    \"\"\"Send request and yield unpacked responses.\n\n    This is an async generator that handles the complete request/response\n    cycle including packet type detection, response unpacking, and label\n    decoding. Connection is opened automatically if not already open.\n\n    Single response (most common):\n        async for response in conn.request_stream(GetLabel()):\n            process(response)\n            break  # Exit immediately\n\n    Multiple responses:\n        async for state in conn.request_stream(GetColorZones()):\n            process(state)\n            # Continues until timeout\n\n    Args:\n        packet: Packet instance to send\n        timeout: Request timeout in seconds\n\n    Yields:\n        Unpacked response packet instances (including StateUnhandled if device\n        doesn't support the command)\n        For SET packets: yields True (acknowledgement) or False (StateUnhandled)\n\n    Raises:\n        LifxTimeoutError: If request times out\n        LifxProtocolError: If response invalid\n        LifxConnectionError: If connection fails\n\n    Example:\n        ```python\n        # GET request yields unpacked packets\n        async for state in conn.request_stream(packets.Light.GetColor()):\n            color = HSBK.from_protocol(state.color)\n            label = state.label  # Already decoded to string\n            break\n\n        # SET request yields True (acknowledgement) or False (StateUnhandled)\n        async for result in conn.request_stream(\n            packets.Light.SetColor(color=hsbk, duration=1000)\n        ):\n            if result:\n                # Acknowledgement received\n                pass\n            else:\n                # Device doesn't support this command\n                pass\n            break\n\n        # Multi-response GET - stream all responses\n        async for state in conn.request_stream(\n            packets.MultiZone.GetExtendedColorZones()\n        ):\n            # Process each zone state\n            pass\n        ```\n    \"\"\"\n    # Ensure connection is open (lazy opening)\n    await self._ensure_open()\n\n    if timeout is None:\n        timeout = self.timeout\n\n    # Get packet metadata\n    packet_kind = getattr(packet, \"_packet_kind\", \"OTHER\")\n\n    if packet_kind == \"GET\":\n        # Use PACKET_REGISTRY to find the appropriate packet class\n        from lifx.protocol.packets import get_packet_class\n\n        # Stream responses and unpack each\n        async for header, payload in self._request_stream_impl(\n            packet, timeout=timeout\n        ):\n            packet_class = get_packet_class(header.pkt_type)\n            if packet_class is None:\n                raise LifxProtocolError(\n                    f\"Unknown packet type {header.pkt_type} in response\"\n                )\n\n            # Update unknown serial with value from response header\n            serial = Serial(value=header.target_serial).to_string()\n            if self.serial == \"000000000000\" and serial != self.serial:\n                self.serial = serial\n\n            # Unpack (labels are automatically decoded by Packet.unpack())\n            response_packet = packet_class.unpack(payload)\n\n            # Log the request/reply cycle\n            request_values = packet.as_dict\n            reply_values = response_packet.as_dict\n            _LOGGER.debug(\n                {\n                    \"class\": \"DeviceConnection\",\n                    \"method\": \"request_stream\",\n                    \"request\": {\n                        \"packet\": type(packet).__name__,\n                        \"values\": request_values,\n                    },\n                    \"reply\": {\n                        \"packet\": type(response_packet).__name__,\n                        \"values\": reply_values,\n                    },\n                    \"serial\": self.serial,\n                    \"ip\": self.ip,\n                }\n            )\n\n            yield response_packet\n\n    elif packet_kind == \"SET\":\n        # Request acknowledgement\n        async for ack_result in self._request_ack_stream_impl(\n            packet, timeout=timeout\n        ):\n            # Log the request/ack cycle\n            request_values = packet.as_dict\n            reply_packet = \"Acknowledgement\" if ack_result else \"StateUnhandled\"\n            _LOGGER.debug(\n                {\n                    \"class\": \"DeviceConnection\",\n                    \"method\": \"request_stream\",\n                    \"request\": {\n                        \"packet\": type(packet).__name__,\n                        \"values\": request_values,\n                    },\n                    \"reply\": {\n                        \"packet\": reply_packet,\n                        \"values\": {},\n                    },\n                    \"serial\": self.serial,\n                    \"ip\": self.ip,\n                }\n            )\n\n            yield ack_result\n            return\n\n    else:\n        # Handle special cases\n        if hasattr(packet, \"PKT_TYPE\"):\n            pkt_type = packet.PKT_TYPE\n            # EchoRequest/EchoResponse (58/59)\n            if pkt_type == 58:  # EchoRequest\n                from lifx.protocol.packets import Device\n\n                async for header, payload in self._request_stream_impl(\n                    packet, timeout=timeout\n                ):\n                    response_packet = Device.EchoResponse.unpack(payload)\n\n                    # Log the request/reply cycle\n                    request_values = packet.as_dict\n                    reply_values = response_packet.as_dict\n                    _LOGGER.debug(\n                        {\n                            \"class\": \"DeviceConnection\",\n                            \"method\": \"request_stream\",\n                            \"request\": {\n                                \"packet\": type(packet).__name__,\n                                \"values\": request_values,\n                            },\n                            \"reply\": {\n                                \"packet\": type(response_packet).__name__,\n                                \"values\": reply_values,\n                            },\n                            \"serial\": self.serial,\n                            \"ip\": self.ip,\n                        }\n                    )\n\n                    yield response_packet\n                    return\n            else:\n                raise LifxProtocolError(\n                    f\"Cannot auto-handle packet kind: {packet_kind}\"\n                )\n        else:\n            raise LifxProtocolError(\n                f\"Packet missing PKT_TYPE: {type(packet).__name__}\"\n            )\n</code></pre>"},{"location":"api/network/#lifx.network.connection.DeviceConnection.request","title":"request  <code>async</code>","text":"<pre><code>request(packet: Any, timeout: float | None = None) -&gt; Any\n</code></pre> <p>Send request and get single response (convenience wrapper).</p> <p>This is a convenience method that returns the first response from request_stream(). It's equivalent to:     await anext(conn.request_stream(packet))</p> <p>Most device operations use this method since they expect a single response. Connection is opened automatically if not already open.</p> PARAMETER DESCRIPTION <code>packet</code> <p>Packet instance to send</p> <p> TYPE: <code>Any</code> </p> <code>timeout</code> <p>Request timeout in seconds</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Single unpacked response packet (including StateUnhandled if device</p> <code>Any</code> <p>doesn't support the command)</p> <code>Any</code> <p>For SET packets: True (acknowledgement) or False (StateUnhandled)</p> RAISES DESCRIPTION <code>LifxTimeoutError</code> <p>If no response within timeout</p> <code>LifxProtocolError</code> <p>If response invalid</p> <code>LifxConnectionError</code> <p>If connection fails</p> Example <pre><code># GET request returns unpacked packet\nstate = await conn.request(packets.Light.GetColor())\ncolor = HSBK.from_protocol(state.color)\nlabel = state.label  # Already decoded to string\n\n# SET request returns True or False\nsuccess = await conn.request(\n    packets.Light.SetColor(color=hsbk, duration=1000)\n)\nif not success:\n    # Device doesn't support this command (returned StateUnhandled)\n    pass\n</code></pre> Source code in <code>src/lifx/network/connection.py</code> <pre><code>async def request(self, packet: Any, timeout: float | None = None) -&gt; Any:\n    \"\"\"Send request and get single response (convenience wrapper).\n\n    This is a convenience method that returns the first response from\n    request_stream(). It's equivalent to:\n        await anext(conn.request_stream(packet))\n\n    Most device operations use this method since they expect a single response.\n    Connection is opened automatically if not already open.\n\n    Args:\n        packet: Packet instance to send\n        timeout: Request timeout in seconds\n\n    Returns:\n        Single unpacked response packet (including StateUnhandled if device\n        doesn't support the command)\n        For SET packets: True (acknowledgement) or False (StateUnhandled)\n\n    Raises:\n        LifxTimeoutError: If no response within timeout\n        LifxProtocolError: If response invalid\n        LifxConnectionError: If connection fails\n\n    Example:\n        ```python\n        # GET request returns unpacked packet\n        state = await conn.request(packets.Light.GetColor())\n        color = HSBK.from_protocol(state.color)\n        label = state.label  # Already decoded to string\n\n        # SET request returns True or False\n        success = await conn.request(\n            packets.Light.SetColor(color=hsbk, duration=1000)\n        )\n        if not success:\n            # Device doesn't support this command (returned StateUnhandled)\n            pass\n        ```\n    \"\"\"\n    async for response in self.request_stream(packet, timeout):\n        return response\n    raise LifxTimeoutError(f\"No response from {self.ip}\")\n</code></pre>"},{"location":"api/network/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/network/#connection-lifecycle","title":"Connection Lifecycle","text":"<ul> <li>Connections open lazily on first request</li> <li>Each device owns its own connection (no shared pool)</li> <li>Connections close explicitly via <code>close()</code> or context manager exit</li> <li>Low memory overhead (one UDP socket per device)</li> </ul>"},{"location":"api/network/#response-handling","title":"Response Handling","text":"<ul> <li>Responses matched by sequence number</li> <li>Async generator-based streaming for efficient multi-response protocols</li> <li>Immediate exit for single-response requests (no wasted timeout)</li> <li>Retry logic with exponential backoff and jitter</li> </ul>"},{"location":"api/network/#rate-limiting","title":"Rate Limiting","text":"<p>The library intentionally does not implement rate limiting to keep the core library simple. Applications should implement their own rate limiting if needed. According to the LIFX protocol specification, devices can handle approximately 20 messages per second.</p>"},{"location":"api/protocol/","title":"Protocol Layer","text":"<p>The protocol layer contains auto-generated structures from the official LIFX protocol specification. These classes handle binary serialization and deserialization of LIFX messages.</p> <p>!!! warning \"Auto-Generated Code\" Files in the protocol layer are automatically generated from <code>protocol.yml</code>. Never edit these files directly. To update the protocol, download the latest <code>protocol.yml</code> from the LIFX public-protocol repository and run <code>uv run python -m lifx.protocol.generator</code>.</p>"},{"location":"api/protocol/#base-packet","title":"Base Packet","text":"<p>The base class for all protocol packets.</p>"},{"location":"api/protocol/#lifx.protocol.base.Packet","title":"Packet  <code>dataclass</code>","text":"<pre><code>Packet()\n</code></pre> <p>Base class for all LIFX protocol packets.</p> <p>Each packet subclass defines: - PKT_TYPE: ClassVar[int] - The packet type number - _fields: ClassVar[list[dict]] - Field metadata from protocol.yml - Actual field attributes as dataclass fields</p> METHOD DESCRIPTION <code>pack</code> <p>Pack packet to bytes using field metadata.</p> <code>unpack</code> <p>Unpack packet from bytes using field metadata.</p> ATTRIBUTE DESCRIPTION <code>as_dict</code> <p>Return packet as dictionary.</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/protocol/#lifx.protocol.base.Packet-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.protocol.base.Packet.as_dict","title":"as_dict  <code>property</code>","text":"<pre><code>as_dict: dict[str, Any]\n</code></pre> <p>Return packet as dictionary.</p>"},{"location":"api/protocol/#lifx.protocol.base.Packet-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.base.Packet.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack packet to bytes using field metadata.</p> RETURNS DESCRIPTION <code>bytes</code> <p>Packed bytes ready to send in a LIFX message payload</p> Source code in <code>src/lifx/protocol/base.py</code> <pre><code>def pack(self) -&gt; bytes:\n    \"\"\"Pack packet to bytes using field metadata.\n\n    Returns:\n        Packed bytes ready to send in a LIFX message payload\n    \"\"\"\n    from lifx.protocol import serializer\n\n    result = b\"\"\n\n    for field_item in self._fields:\n        # Handle reserved fields (no name)\n        if \"name\" not in field_item:\n            size_bytes = field_item.get(\"size_bytes\", 0)\n            result += serializer.pack_reserved(size_bytes)\n            continue\n\n        # Get field value from instance\n        field_name = self._protocol_to_python_name(field_item[\"name\"])\n        value = getattr(self, field_name)\n\n        # Pack based on type\n        field_type = field_item[\"type\"]\n        size_bytes = field_item.get(\"size_bytes\", 0)\n        result += self._pack_field_value(value, field_type, size_bytes)\n\n    return result\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.base.Packet.unpack","title":"unpack  <code>classmethod</code>","text":"<pre><code>unpack(data: bytes, offset: int = 0) -&gt; Packet\n</code></pre> <p>Unpack packet from bytes using field metadata.</p> PARAMETER DESCRIPTION <code>data</code> <p>Bytes to unpack from</p> <p> TYPE: <code>bytes</code> </p> <code>offset</code> <p>Offset in bytes to start unpacking</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>Packet</code> <p>Packet instance with label fields decoded to strings</p> Source code in <code>src/lifx/protocol/base.py</code> <pre><code>@classmethod\ndef unpack(cls, data: bytes, offset: int = 0) -&gt; Packet:\n    \"\"\"Unpack packet from bytes using field metadata.\n\n    Args:\n        data: Bytes to unpack from\n        offset: Offset in bytes to start unpacking\n\n    Returns:\n        Packet instance with label fields decoded to strings\n    \"\"\"\n    packet, _ = cls._unpack_internal(data, offset)\n\n    # Decode label fields from bytes to string in-place\n    # This ensures all State packets have human-readable labels\n    cls._decode_labels_inplace(packet)\n\n    # Log packet values after unpacking and decoding labels\n    packet_values = asdict(packet)\n    _LOGGER.debug(\n        {\n            \"class\": \"Packet\",\n            \"method\": \"unpack\",\n            \"packet_type\": type(packet).__name__,\n            \"values\": packet_values,\n        }\n    )\n\n    return packet\n</code></pre>"},{"location":"api/protocol/#protocol-header","title":"Protocol Header","text":"<p>The LIFX protocol header structure (36 bytes).</p>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader","title":"LifxHeader  <code>dataclass</code>","text":"<pre><code>LifxHeader(\n    size: int,\n    protocol: int,\n    source: int,\n    target: bytes,\n    tagged: bool,\n    ack_required: bool,\n    res_required: bool,\n    sequence: int,\n    pkt_type: int,\n)\n</code></pre> <p>LIFX protocol header (36 bytes).</p> ATTRIBUTE DESCRIPTION <code>size</code> <p>Total packet size in bytes (header + payload)</p> <p> TYPE: <code>int</code> </p> <code>protocol</code> <p>Protocol number (must be 1024)</p> <p> TYPE: <code>int</code> </p> <code>source</code> <p>Unique client identifier</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Device serial number (6 or 8 bytes, automatically padded to 8 bytes)     Note: This is the LIFX serial number, which is often but not always     the same as the device's MAC address.</p> <p> TYPE: <code>bytes</code> </p> <code>tagged</code> <p>True for broadcast discovery, False for targeted messages</p> <p> TYPE: <code>bool</code> </p> <code>ack_required</code> <p>Request acknowledgement from device</p> <p> TYPE: <code>bool</code> </p> <code>res_required</code> <p>Request response from device</p> <p> TYPE: <code>bool</code> </p> <code>sequence</code> <p>Sequence number for matching requests/responses</p> <p> TYPE: <code>int</code> </p> <code>pkt_type</code> <p>Packet type identifier</p> <p> TYPE: <code>int</code> </p> METHOD DESCRIPTION <code>__post_init__</code> <p>Validate header fields and auto-pad serial number if needed.</p> <code>create</code> <p>Create a new LIFX header.</p> <code>pack</code> <p>Pack header into 36 bytes.</p> <code>unpack</code> <p>Unpack header from bytes.</p> <code>__repr__</code> <p>String representation of header.</p>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.target_serial","title":"target_serial  <code>property</code>","text":"<pre><code>target_serial: bytes\n</code></pre> <p>Get the 6-byte serial number without padding.</p> RETURNS DESCRIPTION <code>bytes</code> <p>6-byte serial number</p>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate header fields and auto-pad serial number if needed.</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate header fields and auto-pad serial number if needed.\"\"\"\n    # Auto-pad serial number if 6 bytes\n    if len(self.target) == 6:\n        self.target = self.target + b\"\\x00\\x00\"\n    elif len(self.target) != 8:\n        raise ValueError(f\"Target must be 6 or 8 bytes, got {len(self.target)}\")\n\n    if self.protocol != self.PROTOCOL_NUMBER:\n        raise ValueError(\n            f\"Protocol must be {self.PROTOCOL_NUMBER}, got {self.protocol}\"\n        )\n    if self.sequence &gt; 255:\n        raise ValueError(f\"Sequence must be 0-255, got {self.sequence}\")\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    pkt_type: int,\n    source: int,\n    target: bytes = b\"\\x00\" * 6,\n    tagged: bool = False,\n    ack_required: bool = False,\n    res_required: bool = True,\n    sequence: int = 0,\n    payload_size: int = 0,\n) -&gt; LifxHeader\n</code></pre> <p>Create a new LIFX header.</p> PARAMETER DESCRIPTION <code>pkt_type</code> <p>Packet type identifier</p> <p> TYPE: <code>int</code> </p> <code>source</code> <p>Unique client identifier</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Device serial number (6 or 8 bytes, defaults to broadcast)</p> <p> TYPE: <code>bytes</code> DEFAULT: <code>b'\\x00' * 6</code> </p> <code>tagged</code> <p>True for broadcast, False for targeted</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>ack_required</code> <p>Request acknowledgement</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>res_required</code> <p>Request response</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sequence</code> <p>Sequence number for matching requests/responses</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>payload_size</code> <p>Size of packet payload in bytes</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>LifxHeader</code> <p>LifxHeader instance</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    pkt_type: int,\n    source: int,\n    target: bytes = b\"\\x00\" * 6,\n    tagged: bool = False,\n    ack_required: bool = False,\n    res_required: bool = True,\n    sequence: int = 0,\n    payload_size: int = 0,\n) -&gt; LifxHeader:\n    \"\"\"Create a new LIFX header.\n\n    Args:\n        pkt_type: Packet type identifier\n        source: Unique client identifier\n        target: Device serial number (6 or 8 bytes, defaults to broadcast)\n        tagged: True for broadcast, False for targeted\n        ack_required: Request acknowledgement\n        res_required: Request response\n        sequence: Sequence number for matching requests/responses\n        payload_size: Size of packet payload in bytes\n\n    Returns:\n        LifxHeader instance\n    \"\"\"\n    return cls(\n        size=cls.HEADER_SIZE + payload_size,\n        protocol=cls.PROTOCOL_NUMBER,\n        source=source,\n        target=target,  # __post_init__ will auto-pad if needed\n        tagged=tagged,\n        ack_required=ack_required,\n        res_required=res_required,\n        sequence=sequence,\n        pkt_type=pkt_type,\n    )\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack header into 36 bytes.</p> RETURNS DESCRIPTION <code>bytes</code> <p>Packed header bytes</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>def pack(self) -&gt; bytes:\n    \"\"\"Pack header into 36 bytes.\n\n    Returns:\n        Packed header bytes\n    \"\"\"\n    # Frame (8 bytes)\n    # Byte 0-1: size (uint16)\n    # Byte 2-3: origin + tagged + addressable + protocol bits\n    # Byte 4-7: source (uint32)\n\n    # Pack protocol field with flags\n    protocol_field = (\n        (self.ORIGIN &amp; 0b11) &lt;&lt; 14\n        | (int(self.tagged) &amp; 0b1) &lt;&lt; 13\n        | (self.ADDRESSABLE &amp; 0b1) &lt;&lt; 12\n        | (self.protocol &amp; 0xFFF)\n    )\n\n    frame = struct.pack(\"&lt;HHI\", self.size, protocol_field, self.source)\n\n    # Frame Address (16 bytes)\n    # Byte 0-7: target (uint64)\n    # Byte 8-13: reserved (6 bytes)\n    # Byte 14: res_required (bit 0) + ack_required (bit 1) + reserved (6 bits)\n    # Byte 15: sequence (uint8)\n\n    flags = (int(self.res_required) &amp; 0b1) | ((int(self.ack_required) &amp; 0b1) &lt;&lt; 1)\n\n    frame_addr = struct.pack(\n        \"&lt;Q6sBB\",\n        int.from_bytes(self.target, byteorder=\"little\"),\n        b\"\\x00\" * 6,  # reserved\n        flags,\n        self.sequence,\n    )\n\n    # Protocol Header (12 bytes)\n    # Byte 0-7: reserved (uint64)\n    # Byte 8-9: type (uint16)\n    # Byte 10-11: reserved (uint16)\n\n    protocol_header = struct.pack(\"&lt;QHH\", 0, self.pkt_type, 0)\n\n    return frame + frame_addr + protocol_header\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.unpack","title":"unpack  <code>classmethod</code>","text":"<pre><code>unpack(data: bytes) -&gt; LifxHeader\n</code></pre> <p>Unpack header from bytes.</p> PARAMETER DESCRIPTION <code>data</code> <p>Header bytes (at least 36 bytes)</p> <p> TYPE: <code>bytes</code> </p> RETURNS DESCRIPTION <code>LifxHeader</code> <p>LifxHeader instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If data is too short or invalid</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>@classmethod\ndef unpack(cls, data: bytes) -&gt; LifxHeader:\n    \"\"\"Unpack header from bytes.\n\n    Args:\n        data: Header bytes (at least 36 bytes)\n\n    Returns:\n        LifxHeader instance\n\n    Raises:\n        ValueError: If data is too short or invalid\n    \"\"\"\n    if len(data) &lt; cls.HEADER_SIZE:\n        raise ValueError(f\"Header data must be at least {cls.HEADER_SIZE} bytes\")\n\n    # Unpack Frame (8 bytes)\n    size, protocol_field, source = struct.unpack(\"&lt;HHI\", data[0:8])\n\n    # Extract protocol field components\n    origin = (protocol_field &gt;&gt; 14) &amp; 0b11\n    tagged = bool((protocol_field &gt;&gt; 13) &amp; 0b1)\n    addressable = bool((protocol_field &gt;&gt; 12) &amp; 0b1)\n    protocol = protocol_field &amp; 0xFFF\n\n    # Validate origin and addressable\n    if origin != cls.ORIGIN:\n        raise ValueError(f\"Invalid origin: {origin}\")\n    if not addressable:\n        raise ValueError(\"Addressable bit must be set\")\n\n    # Unpack Frame Address (16 bytes)\n    target_int, _reserved, flags, sequence = struct.unpack(\"&lt;Q6sBB\", data[8:24])\n    target = target_int.to_bytes(8, byteorder=\"little\")\n\n    res_required = bool(flags &amp; 0b1)\n    ack_required = bool((flags &gt;&gt; 1) &amp; 0b1)\n\n    # Unpack Protocol Header (12 bytes)\n    _reserved1, pkt_type, _reserved2 = struct.unpack(\"&lt;QHH\", data[24:36])\n\n    return cls(\n        size=size,\n        protocol=protocol,\n        source=source,\n        target=target,\n        tagged=tagged,\n        ack_required=ack_required,\n        res_required=res_required,\n        sequence=sequence,\n        pkt_type=pkt_type,\n    )\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.header.LifxHeader.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation of header.</p> Source code in <code>src/lifx/protocol/header.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of header.\"\"\"\n    target_serial_str = Serial(value=self.target_serial).to_string()\n    return (\n        f\"LifxHeader(type={self.pkt_type}, size={self.size}, \"\n        f\"source={self.source:#x}, target={target_serial_str}, \"\n        f\"seq={self.sequence}, tagged={self.tagged}, \"\n        f\"ack={self.ack_required}, res={self.res_required})\"\n    )\n</code></pre>"},{"location":"api/protocol/#serializer","title":"Serializer","text":"<p>Binary serialization and deserialization utilities.</p>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer","title":"FieldSerializer","text":"<pre><code>FieldSerializer(field_definitions: dict[str, dict[str, str]])\n</code></pre> <p>Serializer for structured fields with nested types.</p> PARAMETER DESCRIPTION <code>field_definitions</code> <p>Dict mapping field names to structure definitions</p> <p> TYPE: <code>dict[str, dict[str, str]]</code> </p> METHOD DESCRIPTION <code>pack_field</code> <p>Pack a structured field.</p> <code>unpack_field</code> <p>Unpack a structured field.</p> <code>get_field_size</code> <p>Get the size in bytes of a field structure.</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def __init__(self, field_definitions: dict[str, dict[str, str]]):\n    \"\"\"Initialize serializer with field definitions.\n\n    Args:\n        field_definitions: Dict mapping field names to structure definitions\n    \"\"\"\n    self.field_definitions = field_definitions\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer.pack_field","title":"pack_field","text":"<pre><code>pack_field(field_data: dict[str, Any], field_name: str) -&gt; bytes\n</code></pre> <p>Pack a structured field.</p> PARAMETER DESCRIPTION <code>field_data</code> <p>Dictionary of field values</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>field_name</code> <p>Name of the field structure (e.g., \"HSBK\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bytes</code> <p>Packed bytes</p> RAISES DESCRIPTION <code>ValueError</code> <p>If field_name is unknown</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def pack_field(self, field_data: dict[str, Any], field_name: str) -&gt; bytes:\n    \"\"\"Pack a structured field.\n\n    Args:\n        field_data: Dictionary of field values\n        field_name: Name of the field structure (e.g., \"HSBK\")\n\n    Returns:\n        Packed bytes\n\n    Raises:\n        ValueError: If field_name is unknown\n    \"\"\"\n    if field_name not in self.field_definitions:\n        raise ValueError(f\"Unknown field: {field_name}\")\n\n    field_def = self.field_definitions[field_name]\n    result = b\"\"\n\n    for attr_name, attr_type in field_def.items():\n        if attr_name not in field_data:\n            raise ValueError(f\"Missing attribute {attr_name} in {field_name}\")\n        result += pack_value(field_data[attr_name], attr_type)\n\n    return result\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer.unpack_field","title":"unpack_field","text":"<pre><code>unpack_field(\n    data: bytes, field_name: str, offset: int = 0\n) -&gt; tuple[dict[str, Any], int]\n</code></pre> <p>Unpack a structured field.</p> PARAMETER DESCRIPTION <code>data</code> <p>Bytes to unpack from</p> <p> TYPE: <code>bytes</code> </p> <code>field_name</code> <p>Name of the field structure</p> <p> TYPE: <code>str</code> </p> <code>offset</code> <p>Offset to start unpacking</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>tuple[dict[str, Any], int]</code> <p>Tuple of (field_dict, new_offset)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If field_name is unknown</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def unpack_field(\n    self, data: bytes, field_name: str, offset: int = 0\n) -&gt; tuple[dict[str, Any], int]:\n    \"\"\"Unpack a structured field.\n\n    Args:\n        data: Bytes to unpack from\n        field_name: Name of the field structure\n        offset: Offset to start unpacking\n\n    Returns:\n        Tuple of (field_dict, new_offset)\n\n    Raises:\n        ValueError: If field_name is unknown\n    \"\"\"\n    if field_name not in self.field_definitions:\n        raise ValueError(f\"Unknown field: {field_name}\")\n\n    field_def = self.field_definitions[field_name]\n    field_data: dict[str, Any] = {}\n    current_offset = offset\n\n    for attr_name, attr_type in field_def.items():\n        value, current_offset = unpack_value(data, attr_type, current_offset)\n        field_data[attr_name] = value\n\n    return field_data, current_offset\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.serializer.FieldSerializer.get_field_size","title":"get_field_size","text":"<pre><code>get_field_size(field_name: str) -&gt; int\n</code></pre> <p>Get the size in bytes of a field structure.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>Name of the field structure</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Size in bytes</p> RAISES DESCRIPTION <code>ValueError</code> <p>If field_name is unknown</p> Source code in <code>src/lifx/protocol/serializer.py</code> <pre><code>def get_field_size(self, field_name: str) -&gt; int:\n    \"\"\"Get the size in bytes of a field structure.\n\n    Args:\n        field_name: Name of the field structure\n\n    Returns:\n        Size in bytes\n\n    Raises:\n        ValueError: If field_name is unknown\n    \"\"\"\n    if field_name not in self.field_definitions:\n        raise ValueError(f\"Unknown field: {field_name}\")\n\n    field_def = self.field_definitions[field_name]\n    return sum(TYPE_SIZES[attr_type] for attr_type in field_def.values())\n</code></pre>"},{"location":"api/protocol/#protocol-types","title":"Protocol Types","text":"<p>Common protocol type definitions and enums.</p>"},{"location":"api/protocol/#hsbk-type","title":"HSBK Type","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk","title":"LightHsbk  <code>dataclass</code>","text":"<pre><code>LightHsbk(hue: int, saturation: int, brightness: int, kelvin: int)\n</code></pre> <p>Auto-generated field structure.</p> METHOD DESCRIPTION <code>pack</code> <p>Pack to bytes.</p> <code>unpack</code> <p>Unpack from bytes.</p>"},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk.pack","title":"pack","text":"<pre><code>pack() -&gt; bytes\n</code></pre> <p>Pack to bytes.</p> Source code in <code>src/lifx/protocol/protocol_types.py</code> <pre><code>def pack(self) -&gt; bytes:\n    \"\"\"Pack to bytes.\"\"\"\n    from lifx.protocol import serializer\n\n    result = b\"\"\n\n    # hue: uint16\n    result += serializer.pack_value(self.hue, \"uint16\")\n    # saturation: uint16\n    result += serializer.pack_value(self.saturation, \"uint16\")\n    # brightness: uint16\n    result += serializer.pack_value(self.brightness, \"uint16\")\n    # kelvin: uint16\n    result += serializer.pack_value(self.kelvin, \"uint16\")\n\n    return result\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.protocol_types.LightHsbk.unpack","title":"unpack  <code>classmethod</code>","text":"<pre><code>unpack(data: bytes, offset: int = 0) -&gt; tuple[LightHsbk, int]\n</code></pre> <p>Unpack from bytes.</p> Source code in <code>src/lifx/protocol/protocol_types.py</code> <pre><code>@classmethod\ndef unpack(cls, data: bytes, offset: int = 0) -&gt; tuple[LightHsbk, int]:\n    \"\"\"Unpack from bytes.\"\"\"\n    from lifx.protocol import serializer\n\n    current_offset = offset\n    # hue: uint16\n    hue, current_offset = serializer.unpack_value(data, \"uint16\", current_offset)\n    # saturation: uint16\n    saturation, current_offset = serializer.unpack_value(\n        data, \"uint16\", current_offset\n    )\n    # brightness: uint16\n    brightness, current_offset = serializer.unpack_value(\n        data, \"uint16\", current_offset\n    )\n    # kelvin: uint16\n    kelvin, current_offset = serializer.unpack_value(data, \"uint16\", current_offset)\n\n    return cls(\n        hue=hue, saturation=saturation, brightness=brightness, kelvin=kelvin\n    ), current_offset\n</code></pre>"},{"location":"api/protocol/#light-waveform","title":"Light Waveform","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.LightWaveform","title":"LightWaveform","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#device-service","title":"Device Service","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.DeviceService","title":"DeviceService","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#multizone-application-request","title":"MultiZone Application Request","text":""},{"location":"api/protocol/#lifx.protocol.protocol_types.MultiZoneApplicationRequest","title":"MultiZoneApplicationRequest","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#firmware-effect","title":"Firmware Effect","text":"<p>Unified enum for all firmware effects (multizone and matrix devices):</p>"},{"location":"api/protocol/#lifx.protocol.protocol_types.FirmwareEffect","title":"FirmwareEffect","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#direction","title":"Direction","text":"<p>Direction enum for MOVE effects:</p>"},{"location":"api/protocol/#lifx.protocol.protocol_types.Direction","title":"Direction","text":"<p>               Bases: <code>IntEnum</code></p> <p>Auto-generated enum.</p>"},{"location":"api/protocol/#packet-definitions","title":"Packet Definitions","text":"<p>The protocol layer includes packet definitions for all LIFX message types. Major categories include:</p>"},{"location":"api/protocol/#device-messages","title":"Device Messages","text":"<ul> <li><code>DeviceGetService</code> / <code>DeviceStateService</code> - Service discovery</li> <li><code>DeviceGetLabel</code> / <code>DeviceStateLabel</code> - Device labels</li> <li><code>DeviceGetPower</code> / <code>DeviceSetPower</code> / <code>DeviceStatePower</code> - Power control</li> <li><code>DeviceGetVersion</code> / <code>DeviceStateVersion</code> - Firmware version</li> <li><code>DeviceGetLocation</code> / <code>DeviceStateLocation</code> - Location groups</li> <li><code>DeviceGetGroup</code> / <code>DeviceStateGroup</code> - Device groups</li> <li><code>DeviceGetInfo</code> / <code>DeviceStateInfo</code> - Runtime info (uptime, downtime)</li> </ul>"},{"location":"api/protocol/#light-messages","title":"Light Messages","text":"<ul> <li><code>LightGet</code> / <code>LightState</code> - Get/set light state</li> <li><code>LightSetColor</code> - Set color with transition</li> <li><code>LightSetWaveform</code> - Waveform effects (pulse, breathe)</li> <li><code>LightGetPower</code> / <code>LightSetPower</code> / <code>LightStatePower</code> - Light power control</li> <li><code>LightGetInfrared</code> / <code>LightSetInfrared</code> / <code>LightStateInfrared</code> - Infrared control</li> </ul>"},{"location":"api/protocol/#multizone-messages","title":"MultiZone Messages","text":"<ul> <li><code>MultiZoneGetColorZones</code> / <code>MultiZoneStateZone</code> / <code>MultiZoneStateMultiZone</code> - Zone state</li> <li><code>MultiZoneSetColorZones</code> - Set zone colors</li> <li><code>MultiZoneGetMultiZoneEffect</code> / <code>MultiZoneSetMultiZoneEffect</code> - Zone effects</li> </ul>"},{"location":"api/protocol/#tile-messages","title":"Tile Messages","text":"<ul> <li><code>TileGetDeviceChain</code> / <code>TileStateDeviceChain</code> - Tile chain info</li> <li><code>TileGet64</code> / <code>TileState64</code> - Get tile state</li> <li><code>TileSet64</code> - Set tile colors</li> <li><code>TileGetTileEffect</code> / <code>TileSetTileEffect</code> - Tile effects</li> </ul>"},{"location":"api/protocol/#protocol-models","title":"Protocol Models","text":"<p>Protocol data models for working with LIFX serial numbers and HEV cycles.</p>"},{"location":"api/protocol/#serial","title":"Serial","text":"<p>Type-safe, immutable serial number handling:</p>"},{"location":"api/protocol/#lifx.protocol.models.Serial","title":"Serial  <code>dataclass</code>","text":"<pre><code>Serial(value: bytes)\n</code></pre> <p>LIFX device serial number.</p> <p>Encapsulates a device serial number with conversion methods for different formats. The LIFX serial number is often the same as the device's MAC address, but can differ (particularly the least significant byte may be off by one).</p> ATTRIBUTE DESCRIPTION <code>value</code> <p>Serial number as 6 bytes</p> <p> TYPE: <code>bytes</code> </p> Example <pre><code># Create from string\nserial = Serial.from_string(\"d073d5123456\")\n\n# Convert to protocol format (8 bytes with padding)\nprotocol_bytes = serial.to_protocol()\n\n# Convert to string\nserial_str = serial.to_string()  # \"d073d5123456\"\n\n# Create from protocol format\nserial2 = Serial.from_protocol(protocol_bytes)\n</code></pre> METHOD DESCRIPTION <code>__post_init__</code> <p>Validate serial number after initialization.</p> <code>from_string</code> <p>Create Serial from string format.</p> <code>from_protocol</code> <p>Create Serial from protocol format (8 bytes with padding).</p> <code>to_string</code> <p>Convert serial to 12-digit hex string format.</p> <code>to_protocol</code> <p>Convert serial to 8-byte protocol format with padding.</p> <code>__str__</code> <p>Return string representation.</p> <code>__repr__</code> <p>Return detailed representation.</p>"},{"location":"api/protocol/#lifx.protocol.models.Serial-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.models.Serial.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate serial number after initialization.</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate serial number after initialization.\"\"\"\n    self._validate_type(self.value)\n    self._validate_length(self.value)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(serial: str) -&gt; Serial\n</code></pre> <p>Create Serial from string format.</p> <p>Accepts 12-digit hex string (with or without separators).</p> PARAMETER DESCRIPTION <code>serial</code> <p>12-digit hex string (e.g., \"d073d5123456\" or \"d0:73:d5:12:34:56\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Serial</code> <p>Serial instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If serial number is invalid</p> <code>TypeError</code> <p>If serial is not a string</p> Example <p>Serial.from_string(\"d073d5123456\") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56') Serial.from_string(\"d0:73:d5:12:34:56\")  # Also accepts separators Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>@classmethod\ndef from_string(cls, serial: str) -&gt; Serial:\n    \"\"\"Create Serial from string format.\n\n    Accepts 12-digit hex string (with or without separators).\n\n    Args:\n        serial: 12-digit hex string (e.g., \"d073d5123456\" or \"d0:73:d5:12:34:56\")\n\n    Returns:\n        Serial instance\n\n    Raises:\n        ValueError: If serial number is invalid\n        TypeError: If serial is not a string\n\n    Example:\n        &gt;&gt;&gt; Serial.from_string(\"d073d5123456\")\n        Serial(value=b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56')\n        &gt;&gt;&gt; Serial.from_string(\"d0:73:d5:12:34:56\")  # Also accepts separators\n        Serial(value=b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56')\n    \"\"\"\n    cls._validate_string_type(serial)\n    serial_clean = cls._remove_separators(serial)\n    cls._validate_hex_length(serial_clean)\n    serial_bytes = cls._parse_hex(serial_clean)\n\n    return cls(value=serial_bytes)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.from_protocol","title":"from_protocol  <code>classmethod</code>","text":"<pre><code>from_protocol(padded_serial: bytes) -&gt; Serial\n</code></pre> <p>Create Serial from protocol format (8 bytes with padding).</p> <p>The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.</p> PARAMETER DESCRIPTION <code>padded_serial</code> <p>8-byte serial number from protocol</p> <p> TYPE: <code>bytes</code> </p> RETURNS DESCRIPTION <code>Serial</code> <p>Serial instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If padded serial is not 8 bytes</p> Example <p>Serial.from_protocol(b\"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00\") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>@classmethod\ndef from_protocol(cls, padded_serial: bytes) -&gt; Serial:\n    \"\"\"Create Serial from protocol format (8 bytes with padding).\n\n    The LIFX protocol uses 8 bytes for the target field, with the serial number\n    in the first 6 bytes and 2 bytes of padding (zeros) at the end.\n\n    Args:\n        padded_serial: 8-byte serial number from protocol\n\n    Returns:\n        Serial instance\n\n    Raises:\n        ValueError: If padded serial is not 8 bytes\n\n    Example:\n        &gt;&gt;&gt; Serial.from_protocol(b\"\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56\\\\x00\\\\x00\")\n        Serial(value=b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56')\n    \"\"\"\n    if len(padded_serial) != 8:\n        raise ValueError(\n            f\"Padded serial number must be 8 bytes, got {len(padded_serial)}\"\n        )\n\n    # Extract first 6 bytes\n    return cls(value=padded_serial[:6])\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Convert serial to 12-digit hex string format.</p> RETURNS DESCRIPTION <code>str</code> <p>Serial number string in format \"xxxxxxxxxxxx\" (12 hex digits, no separators)</p> Example <p>serial = Serial.from_string(\"d073d5123456\") serial.to_string() 'd073d5123456'</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"Convert serial to 12-digit hex string format.\n\n    Returns:\n        Serial number string in format \"xxxxxxxxxxxx\" (12 hex digits, no separators)\n\n    Example:\n        &gt;&gt;&gt; serial = Serial.from_string(\"d073d5123456\")\n        &gt;&gt;&gt; serial.to_string()\n        'd073d5123456'\n    \"\"\"\n    return self.value.hex()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.to_protocol","title":"to_protocol","text":"<pre><code>to_protocol() -&gt; bytes\n</code></pre> <p>Convert serial to 8-byte protocol format with padding.</p> <p>The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.</p> RETURNS DESCRIPTION <code>bytes</code> <p>8-byte serial number with padding (suitable for protocol)</p> Example <p>serial = Serial.from_string(\"d073d5123456\") serial.to_protocol() b'\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00'</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def to_protocol(self) -&gt; bytes:\n    \"\"\"Convert serial to 8-byte protocol format with padding.\n\n    The LIFX protocol uses 8 bytes for the target field, with the serial number\n    in the first 6 bytes and 2 bytes of padding (zeros) at the end.\n\n    Returns:\n        8-byte serial number with padding (suitable for protocol)\n\n    Example:\n        &gt;&gt;&gt; serial = Serial.from_string(\"d073d5123456\")\n        &gt;&gt;&gt; serial.to_protocol()\n        b'\\\\xd0\\\\x73\\\\xd5\\\\x12\\\\x34\\\\x56\\\\x00\\\\x00'\n    \"\"\"\n    return self.value + b\"\\x00\\x00\"\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.Serial.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return detailed representation.</p> Source code in <code>src/lifx/protocol/models.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return detailed representation.\"\"\"\n    return f\"Serial('{self.to_string()}')\"\n</code></pre>"},{"location":"api/protocol/#hev-cycle-state","title":"HEV Cycle State","text":"<p>HEV (High Energy Visible) cleaning cycle state:</p>"},{"location":"api/protocol/#lifx.protocol.models.HevCycleState","title":"HevCycleState  <code>dataclass</code>","text":"<pre><code>HevCycleState(duration_s: int, remaining_s: int, last_power: bool)\n</code></pre> <p>HEV cleaning cycle state.</p> <p>Represents the current state of a HEV (High Energy Visible) cleaning cycle, which uses anti-bacterial UV-C light to sanitize the environment.</p> ATTRIBUTE DESCRIPTION <code>duration_s</code> <p>Total duration of the cycle in seconds</p> <p> TYPE: <code>int</code> </p> <code>remaining_s</code> <p>Remaining time in the current cycle (0 if not running)</p> <p> TYPE: <code>int</code> </p> <code>last_power</code> <p>Whether the light was on during the last cycle</p> <p> TYPE: <code>bool</code> </p> Example <pre><code># Check if HEV cycle is running\nstate = await hev_light.get_hev_cycle()\nif state.remaining_s &gt; 0:\n    print(f\"Cleaning in progress: {state.remaining_s}s remaining\")\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.models.HevCycleState-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.protocol.models.HevCycleState.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Check if a HEV cycle is currently running.</p>"},{"location":"api/protocol/#hev-configuration","title":"HEV Configuration","text":"<p>HEV cycle configuration:</p>"},{"location":"api/protocol/#lifx.protocol.models.HevConfig","title":"HevConfig  <code>dataclass</code>","text":"<pre><code>HevConfig(indication: bool, duration_s: int)\n</code></pre> <p>HEV cycle configuration.</p> <p>Configuration settings for HEV cleaning cycles.</p> ATTRIBUTE DESCRIPTION <code>indication</code> <p>Whether to show visual indication during cleaning</p> <p> TYPE: <code>bool</code> </p> <code>duration_s</code> <p>Default duration for cleaning cycles in seconds</p> <p> TYPE: <code>int</code> </p> Example <pre><code># Configure HEV cycle with 2-hour duration and visual indication\nawait hev_light.set_hev_config(indication=True, duration_seconds=7200)\n</code></pre>"},{"location":"api/protocol/#code-generator","title":"Code Generator","text":"<p>The protocol generator reads <code>protocol.yml</code> and generates Python code.</p>"},{"location":"api/protocol/#lifx.protocol.generator","title":"generator","text":"<p>Code generator for LIFX protocol structures.</p> <p>Downloads the official protocol.yml from the LIFX GitHub repository and generates Python types and packet classes. The YAML is never stored locally, only parsed and converted into protocol classes.</p> CLASS DESCRIPTION <code>TypeRegistry</code> <p>Registry of all protocol types for validation.</p> FUNCTION DESCRIPTION <code>to_snake_case</code> <p>Convert PascalCase or camelCase to snake_case.</p> <code>apply_field_name_quirks</code> <p>Apply quirks to field names to avoid Python built-ins and reserved words.</p> <code>apply_extended_multizone_packet_quirks</code> <p>Apply quirks to extended multizone packet names to follow LIFX naming convention.</p> <code>apply_tile_effect_parameter_quirk</code> <p>Apply local quirk to fix TileEffectParameter structure.</p> <code>apply_tile_state_device_quirk</code> <p>Apply local quirk to add supported_frame_buffers field to TileStateDevice.</p> <code>apply_sensor_packet_quirks</code> <p>Add undocumented sensor packets for ambient light level reading.</p> <code>apply_firmware_effect_enum_quirk</code> <p>Merge MultiZoneEffectType and TileEffectType into FirmwareEffect enum.</p> <code>apply_multizone_application_request_quirk</code> <p>Suppress MultiZoneExtendedApplicationRequest enum.</p> <code>format_long_import</code> <p>Format a long import statement across multiple lines.</p> <code>format_long_list</code> <p>Format a long list across multiple lines.</p> <code>parse_field_type</code> <p>Parse a field type string.</p> <code>camel_to_snake_upper</code> <p>Convert CamelCase to UPPER_SNAKE_CASE.</p> <code>generate_enum_code</code> <p>Generate Python Enum definitions with shortened names.</p> <code>convert_type_to_python</code> <p>Convert a protocol field type to Python type annotation.</p> <code>generate_pack_method</code> <p>Generate pack() method code for a field structure or packet.</p> <code>generate_unpack_method</code> <p>Generate unpack() classmethod code for a field structure or packet.</p> <code>generate_field_code</code> <p>Generate Python dataclass definitions for field structures.</p> <code>generate_nested_packet_code</code> <p>Generate nested Python packet class definitions.</p> <code>generate_types_file</code> <p>Generate complete types.py file.</p> <code>generate_packets_file</code> <p>Generate complete packets.py file.</p> <code>download_protocol</code> <p>Download and parse protocol.yml from LIFX GitHub repository.</p> <code>validate_protocol_spec</code> <p>Validate protocol specification for missing type references.</p> <code>should_skip_button_relay</code> <p>Check if a name should be skipped (Button or Relay related).</p> <code>filter_button_relay_items</code> <p>Filter out Button and Relay items from a dictionary.</p> <code>filter_button_relay_packets</code> <p>Filter out button and relay category packets.</p> <code>extract_packets_as_fields</code> <p>Extract packets that are used as field types in other structures.</p> <code>main</code> <p>Main generator entry point.</p>"},{"location":"api/protocol/#lifx.protocol.generator-classes","title":"Classes","text":""},{"location":"api/protocol/#lifx.protocol.generator.TypeRegistry","title":"TypeRegistry","text":"<pre><code>TypeRegistry()\n</code></pre> <p>Registry of all protocol types for validation.</p> <p>Tracks all defined types (enums, fields, packets, unions) to validate that all type references in the protocol specification are valid.</p> METHOD DESCRIPTION <code>register_enum</code> <p>Register an enum type.</p> <code>register_field</code> <p>Register a field structure type.</p> <code>register_packet</code> <p>Register a packet type.</p> <code>register_union</code> <p>Register a union type.</p> <code>is_enum</code> <p>Check if a type is an enum.</p> <code>has_type</code> <p>Check if a type is defined.</p> <code>get_all_types</code> <p>Get all registered types.</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize empty type registry.\"\"\"\n    self._enums: set[str] = set()\n    self._fields: set[str] = set()\n    self._packets: set[str] = set()\n    self._unions: set[str] = set()\n    self._basic_types: set[str] = {\n        \"uint8\",\n        \"uint16\",\n        \"uint32\",\n        \"uint64\",\n        \"int8\",\n        \"int16\",\n        \"int32\",\n        \"int64\",\n        \"float32\",\n        \"bool\",\n        \"byte\",\n        \"reserved\",  # Special type for reserved fields\n    }\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.TypeRegistry-functions","title":"Functions","text":"register_enum \u00b6 <pre><code>register_enum(name: str) -&gt; None\n</code></pre> <p>Register an enum type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Enum type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_enum(self, name: str) -&gt; None:\n    \"\"\"Register an enum type.\n\n    Args:\n        name: Enum type name\n    \"\"\"\n    self._enums.add(name)\n</code></pre> <code></code> register_field \u00b6 <pre><code>register_field(name: str) -&gt; None\n</code></pre> <p>Register a field structure type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Field structure type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_field(self, name: str) -&gt; None:\n    \"\"\"Register a field structure type.\n\n    Args:\n        name: Field structure type name\n    \"\"\"\n    self._fields.add(name)\n</code></pre> <code></code> register_packet \u00b6 <pre><code>register_packet(name: str) -&gt; None\n</code></pre> <p>Register a packet type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Packet type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_packet(self, name: str) -&gt; None:\n    \"\"\"Register a packet type.\n\n    Args:\n        name: Packet type name\n    \"\"\"\n    self._packets.add(name)\n</code></pre> <code></code> register_union \u00b6 <pre><code>register_union(name: str) -&gt; None\n</code></pre> <p>Register a union type.</p> PARAMETER DESCRIPTION <code>name</code> <p>Union type name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def register_union(self, name: str) -&gt; None:\n    \"\"\"Register a union type.\n\n    Args:\n        name: Union type name\n    \"\"\"\n    self._unions.add(name)\n</code></pre> <code></code> is_enum \u00b6 <pre><code>is_enum(name: str) -&gt; bool\n</code></pre> <p>Check if a type is an enum.</p> PARAMETER DESCRIPTION <code>name</code> <p>Type name to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the type is an enum</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def is_enum(self, name: str) -&gt; bool:\n    \"\"\"Check if a type is an enum.\n\n    Args:\n        name: Type name to check\n\n    Returns:\n        True if the type is an enum\n    \"\"\"\n    return name in self._enums\n</code></pre> <code></code> has_type \u00b6 <pre><code>has_type(name: str) -&gt; bool\n</code></pre> <p>Check if a type is defined.</p> PARAMETER DESCRIPTION <code>name</code> <p>Type name to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the type is defined</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def has_type(self, name: str) -&gt; bool:\n    \"\"\"Check if a type is defined.\n\n    Args:\n        name: Type name to check\n\n    Returns:\n        True if the type is defined\n    \"\"\"\n    return (\n        name in self._enums\n        or name in self._fields\n        or name in self._packets\n        or name in self._unions\n        or name in self._basic_types\n    )\n</code></pre> <code></code> get_all_types \u00b6 <pre><code>get_all_types() -&gt; set[str]\n</code></pre> <p>Get all registered types.</p> RETURNS DESCRIPTION <code>set[str]</code> <p>Set of all type names</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def get_all_types(self) -&gt; set[str]:\n    \"\"\"Get all registered types.\n\n    Returns:\n        Set of all type names\n    \"\"\"\n    return (\n        self._enums\n        | self._fields\n        | self._packets\n        | self._unions\n        | self._basic_types\n    )\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.protocol.generator.to_snake_case","title":"to_snake_case","text":"<pre><code>to_snake_case(name: str) -&gt; str\n</code></pre> <p>Convert PascalCase or camelCase to snake_case.</p> PARAMETER DESCRIPTION <code>name</code> <p>PascalCase or camelCase string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>snake_case string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def to_snake_case(name: str) -&gt; str:\n    \"\"\"Convert PascalCase or camelCase to snake_case.\n\n    Args:\n        name: PascalCase or camelCase string\n\n    Returns:\n        snake_case string\n    \"\"\"\n    # Insert underscore before uppercase letters (except at start)\n    snake = re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", name)\n    return snake.lower()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_field_name_quirks","title":"apply_field_name_quirks","text":"<pre><code>apply_field_name_quirks(python_name: str) -&gt; str\n</code></pre> <p>Apply quirks to field names to avoid Python built-ins and reserved words.</p> PARAMETER DESCRIPTION <code>python_name</code> <p>The Python field name (usually from to_snake_case)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Quirk-adjusted field name</p> Quirks applied <ul> <li>\"type\" -&gt; \"effect_type\" (avoids Python built-in)</li> </ul> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_field_name_quirks(python_name: str) -&gt; str:\n    \"\"\"Apply quirks to field names to avoid Python built-ins and reserved words.\n\n    Args:\n        python_name: The Python field name (usually from to_snake_case)\n\n    Returns:\n        Quirk-adjusted field name\n\n    Quirks applied:\n        - \"type\" -&gt; \"effect_type\" (avoids Python built-in)\n    \"\"\"\n    if python_name == \"type\":\n        return \"effect_type\"\n    return python_name\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_extended_multizone_packet_quirks","title":"apply_extended_multizone_packet_quirks","text":"<pre><code>apply_extended_multizone_packet_quirks(\n    packet_name: str, category_class: str\n) -&gt; str\n</code></pre> <p>Apply quirks to extended multizone packet names to follow LIFX naming convention.</p> <p>In the LIFX protocol, extended multizone packets should follow the standard naming pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).</p> PARAMETER DESCRIPTION <code>packet_name</code> <p>Packet name (after category prefix removal)</p> <p> TYPE: <code>str</code> </p> <code>category_class</code> <p>Category class name (e.g., \"MultiZone\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Quirk-adjusted packet name</p> Quirks applied <ul> <li>\"ExtendedGetColorZones\" -&gt; \"GetExtendedColorZones\"</li> <li>\"ExtendedSetColorZones\" -&gt; \"SetExtendedColorZones\"</li> <li>\"ExtendedStateMultiZone\" -&gt; \"StateExtendedColorZones\"</li> </ul> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_extended_multizone_packet_quirks(\n    packet_name: str, category_class: str\n) -&gt; str:\n    \"\"\"Apply quirks to extended multizone packet names to follow LIFX naming convention.\n\n    In the LIFX protocol, extended multizone packets should follow the standard naming\n    pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).\n\n    Args:\n        packet_name: Packet name (after category prefix removal)\n        category_class: Category class name (e.g., \"MultiZone\")\n\n    Returns:\n        Quirk-adjusted packet name\n\n    Quirks applied:\n        - \"ExtendedGetColorZones\" -&gt; \"GetExtendedColorZones\"\n        - \"ExtendedSetColorZones\" -&gt; \"SetExtendedColorZones\"\n        - \"ExtendedStateMultiZone\" -&gt; \"StateExtendedColorZones\"\n    \"\"\"\n    if category_class == \"MultiZone\":\n        if packet_name == \"ExtendedGetColorZones\":\n            return \"GetExtendedColorZones\"\n        elif packet_name == \"ExtendedSetColorZones\":\n            return \"SetExtendedColorZones\"\n        elif packet_name == \"ExtendedStateMultiZone\":\n            return \"StateExtendedColorZones\"\n    return packet_name\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_tile_effect_parameter_quirk","title":"apply_tile_effect_parameter_quirk","text":"<pre><code>apply_tile_effect_parameter_quirk(fields: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Apply local quirk to fix TileEffectParameter structure.</p> <p>The upstream protocol.yml doesn't provide enough detail for TileEffectParameter. This quirk replaces it with the correct structure: - TileEffectSkyType (enum, uint8) - 3 reserved bytes - cloudSaturationMin (uint8) - 3 reserved bytes - cloudSaturationMax (uint8) - 23 reserved bytes Total: 32 bytes</p> PARAMETER DESCRIPTION <code>fields</code> <p>Dictionary of field definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary with TileEffectParameter quirk applied</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_tile_effect_parameter_quirk(\n    fields: dict[str, Any],\n) -&gt; dict[str, Any]:\n    \"\"\"Apply local quirk to fix TileEffectParameter structure.\n\n    The upstream protocol.yml doesn't provide enough detail for TileEffectParameter.\n    This quirk replaces it with the correct structure:\n    - TileEffectSkyType (enum, uint8)\n    - 3 reserved bytes\n    - cloudSaturationMin (uint8)\n    - 3 reserved bytes\n    - cloudSaturationMax (uint8)\n    - 23 reserved bytes\n    Total: 32 bytes\n\n    Args:\n        fields: Dictionary of field definitions\n\n    Returns:\n        Dictionary with TileEffectParameter quirk applied\n    \"\"\"\n    if \"TileEffectParameter\" in fields:\n        fields[\"TileEffectParameter\"] = {\n            \"size_bytes\": 32,\n            \"fields\": [\n                {\"name\": \"SkyType\", \"type\": \"&lt;TileEffectSkyType&gt;\"},\n                {\"size_bytes\": 3},\n                {\"name\": \"CloudSaturationMin\", \"type\": \"uint8\"},\n                {\"size_bytes\": 3},\n                {\"name\": \"CloudSaturationMax\", \"type\": \"uint8\"},\n                {\"size_bytes\": 23},\n            ],\n        }\n    return fields\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_tile_state_device_quirk","title":"apply_tile_state_device_quirk","text":"<pre><code>apply_tile_state_device_quirk(fields: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Apply local quirk to add supported_frame_buffers field to TileStateDevice.</p> <p>The upstream protocol.yml has a reserved field between height and device_version. This quirk replaces that reserved field with supported_frame_buffers (uint8).</p> PARAMETER DESCRIPTION <code>fields</code> <p>Dictionary of field definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary with TileStateDevice quirk applied</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_tile_state_device_quirk(\n    fields: dict[str, Any],\n) -&gt; dict[str, Any]:\n    \"\"\"Apply local quirk to add supported_frame_buffers field to TileStateDevice.\n\n    The upstream protocol.yml has a reserved field between height and device_version.\n    This quirk replaces that reserved field with supported_frame_buffers (uint8).\n\n    Args:\n        fields: Dictionary of field definitions\n\n    Returns:\n        Dictionary with TileStateDevice quirk applied\n    \"\"\"\n    if \"TileStateDevice\" in fields:\n        tile_def = fields[\"TileStateDevice\"]\n        if \"fields\" in tile_def:\n            # Find and replace the reserved field between height and device_version\n            fields_list = tile_def[\"fields\"]\n            for i, field in enumerate(fields_list):\n                # Look for height field\n                if field.get(\"name\") == \"Height\":\n                    # Check if next field is reserved (1 byte) and followed by DeviceVersion\n                    if (\n                        i + 1 &lt; len(fields_list)\n                        and i + 2 &lt; len(fields_list)\n                        and fields_list[i + 1].get(\"type\") == \"reserved\"\n                        and fields_list[i + 1].get(\"size_bytes\") == 1\n                        and fields_list[i + 2].get(\"name\") == \"DeviceVersion\"\n                    ):\n                        # Replace the reserved field with supported_frame_buffers\n                        fields_list[i + 1] = {\n                            \"name\": \"SupportedFrameBuffers\",\n                            \"type\": \"uint8\",\n                        }\n                        break\n\n    return fields\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_sensor_packet_quirks","title":"apply_sensor_packet_quirks","text":"<pre><code>apply_sensor_packet_quirks(packets: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Add undocumented sensor packets for ambient light level reading.</p> <p>These packets are not documented in the official protocol.yml but are supported by LIFX devices with ambient light sensors.</p> Quirks applied <ul> <li>SensorGetAmbientLight (401): Request packet with no parameters</li> <li>SensorStateAmbientLight (402): Response packet with lux field (float)</li> </ul> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary with sensor packet quirks applied</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_sensor_packet_quirks(packets: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Add undocumented sensor packets for ambient light level reading.\n\n    These packets are not documented in the official protocol.yml but are supported\n    by LIFX devices with ambient light sensors.\n\n    Quirks applied:\n        - SensorGetAmbientLight (401): Request packet with no parameters\n        - SensorStateAmbientLight (402): Response packet with lux field (float)\n\n    Args:\n        packets: Dictionary of packet definitions\n\n    Returns:\n        Dictionary with sensor packet quirks applied\n    \"\"\"\n    # Ensure sensor category exists\n    if \"sensor\" not in packets:\n        packets[\"sensor\"] = {}\n\n    # Add SensorGetAmbientLight (401) - request with no parameters\n    packets[\"sensor\"][\"SensorGetAmbientLight\"] = {\n        \"pkt_type\": 401,\n        \"fields\": [],\n    }\n\n    # Add SensorStateAmbientLight (402) - response with lux field\n    packets[\"sensor\"][\"SensorStateAmbientLight\"] = {\n        \"pkt_type\": 402,\n        \"fields\": [\n            {\"name\": \"Lux\", \"type\": \"float32\"},\n        ],\n    }\n\n    return packets\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_firmware_effect_enum_quirk","title":"apply_firmware_effect_enum_quirk","text":"<pre><code>apply_firmware_effect_enum_quirk(\n    enums: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any],\n) -&gt; tuple[dict[str, Any], dict[str, Any], dict[str, Any]]\n</code></pre> <p>Merge MultiZoneEffectType and TileEffectType into FirmwareEffect enum.</p> <p>Both MultiZone and Tile effects use the same firmware effect protocol values, so they should share a single enum. This quirk: - Creates FirmwareEffect enum combining values from both - Removes MultiZoneEffectType and TileEffectType - Updates MultiZoneEffectSettings and TileEffectSettings to use FirmwareEffect - Uses clean enum value names (OFF, MOVE, MORPH, FLAME, SKY, RESERVED_*) - Also adds DIRECTION enum for move effect parameter</p> PARAMETER DESCRIPTION <code>enums</code> <p>Dictionary of enum definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Dictionary of field definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Dictionary of compound field definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>tuple[dict[str, Any], dict[str, Any], dict[str, Any]]</code> <p>Tuple of (enums, fields, compound_fields) with FirmwareEffect enum quirk applied</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_firmware_effect_enum_quirk(\n    enums: dict[str, Any], fields: dict[str, Any], compound_fields: dict[str, Any]\n) -&gt; tuple[dict[str, Any], dict[str, Any], dict[str, Any]]:\n    \"\"\"Merge MultiZoneEffectType and TileEffectType into FirmwareEffect enum.\n\n    Both MultiZone and Tile effects use the same firmware effect protocol values,\n    so they should share a single enum. This quirk:\n    - Creates FirmwareEffect enum combining values from both\n    - Removes MultiZoneEffectType and TileEffectType\n    - Updates MultiZoneEffectSettings and TileEffectSettings to use FirmwareEffect\n    - Uses clean enum value names (OFF, MOVE, MORPH, FLAME, SKY, RESERVED_*)\n    - Also adds DIRECTION enum for move effect parameter\n\n    Args:\n        enums: Dictionary of enum definitions\n        fields: Dictionary of field definitions\n        compound_fields: Dictionary of compound field definitions\n\n    Returns:\n        Tuple of (enums, fields, compound_fields) with FirmwareEffect enum quirk applied\n    \"\"\"\n    # Create FirmwareEffect enum with clean names manually\n    # Based on protocol spec:\n    # MultiZone: OFF=0, MOVE=1, reserved=2, reserved=3\n    # Tile: OFF=0, reserved=1, MORPH=2, FLAME=3, reserved=4, SKY=5\n    # Note: Reserved values are intentionally omitted\n    firmware_effect_values = {\n        \"OFF\": 0,\n        \"MOVE\": 1,\n        \"MORPH\": 2,\n        \"FLAME\": 3,\n        \"SKY\": 5,\n    }\n\n    # Create FirmwareEffect enum\n    enums[\"FirmwareEffect\"] = firmware_effect_values\n\n    # Remove the old separate enums\n    enums.pop(\"MultiZoneEffectType\", None)\n    enums.pop(\"TileEffectType\", None)\n\n    # Update fields to use FirmwareEffect (check both fields and compound_fields)\n    for field_dict in [fields, compound_fields]:\n        if \"MultiZoneEffectSettings\" in field_dict:\n            for field in field_dict[\"MultiZoneEffectSettings\"].get(\"fields\", []):\n                if field.get(\"name\") == \"Type\":\n                    field[\"type\"] = \"&lt;FirmwareEffect&gt;\"\n\n        if \"TileEffectSettings\" in field_dict:\n            for field in field_dict[\"TileEffectSettings\"].get(\"fields\", []):\n                if field.get(\"name\") == \"Type\":\n                    field[\"type\"] = \"&lt;FirmwareEffect&gt;\"\n\n    # Add DIRECTION enum for move effect\n    enums[\"Direction\"] = {\n        \"REVERSED\": 0,\n        \"FORWARD\": 1,\n    }\n\n    return enums, fields, compound_fields\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.apply_multizone_application_request_quirk","title":"apply_multizone_application_request_quirk","text":"<pre><code>apply_multizone_application_request_quirk(\n    enums: dict[str, Any], packets: dict[str, Any]\n) -&gt; tuple[dict[str, Any], dict[str, Any]]\n</code></pre> <p>Suppress MultiZoneExtendedApplicationRequest enum.</p> <p>Both MultiZoneApplicationRequest and MultiZoneExtendedApplicationRequest have identical values (NO_APPLY=0, APPLY=1, APPLY_ONLY=2), so we suppress the extended version and use the standard one for both SetColorZones and SetExtendedColorZones packets.</p> PARAMETER DESCRIPTION <code>enums</code> <p>Dictionary of enum definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>packets</code> <p>Dictionary of packet definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Tuple of (enums, packets) with MultiZoneExtendedApplicationRequest removed</p> <code>dict[str, Any]</code> <p>and packets updated to use MultiZoneApplicationRequest</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def apply_multizone_application_request_quirk(\n    enums: dict[str, Any], packets: dict[str, Any]\n) -&gt; tuple[dict[str, Any], dict[str, Any]]:\n    \"\"\"Suppress MultiZoneExtendedApplicationRequest enum.\n\n    Both MultiZoneApplicationRequest and MultiZoneExtendedApplicationRequest have\n    identical values (NO_APPLY=0, APPLY=1, APPLY_ONLY=2), so we suppress the\n    extended version and use the standard one for both SetColorZones and\n    SetExtendedColorZones packets.\n\n    Args:\n        enums: Dictionary of enum definitions\n        packets: Dictionary of packet definitions\n\n    Returns:\n        Tuple of (enums, packets) with MultiZoneExtendedApplicationRequest removed\n        and packets updated to use MultiZoneApplicationRequest\n    \"\"\"\n    # Remove the duplicate enum\n    enums.pop(\"MultiZoneExtendedApplicationRequest\", None)\n\n    # Update packets in multi_zone category to use MultiZoneApplicationRequest\n    if \"multi_zone\" in packets:\n        for packet_name, packet_def in packets[\"multi_zone\"].items():\n            if \"fields\" in packet_def:\n                for field in packet_def[\"fields\"]:\n                    if (\n                        isinstance(field, dict)\n                        and field.get(\"type\") == \"&lt;MultiZoneExtendedApplicationRequest&gt;\"\n                    ):\n                        field[\"type\"] = \"&lt;MultiZoneApplicationRequest&gt;\"\n\n    return enums, packets\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.format_long_import","title":"format_long_import","text":"<pre><code>format_long_import(\n    items: list[str], prefix: str = \"from lifx.protocol.protocol_types import \"\n) -&gt; str\n</code></pre> <p>Format a long import statement across multiple lines.</p> PARAMETER DESCRIPTION <code>items</code> <p>List of import items (e.g., [\"Foo\", \"Bar as BazAlias\"])</p> <p> TYPE: <code>list[str]</code> </p> <code>prefix</code> <p>Import prefix</p> <p> TYPE: <code>str</code> DEFAULT: <code>'from lifx.protocol.protocol_types import '</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted import string with line breaks if needed</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def format_long_import(\n    items: list[str], prefix: str = \"from lifx.protocol.protocol_types import \"\n) -&gt; str:\n    \"\"\"Format a long import statement across multiple lines.\n\n    Args:\n        items: List of import items (e.g., [\"Foo\", \"Bar as BazAlias\"])\n        prefix: Import prefix\n\n    Returns:\n        Formatted import string with line breaks if needed\n    \"\"\"\n    if not items:\n        return \"\"\n\n    # Try single line first\n    single_line = prefix + \", \".join(items)\n    if len(single_line) &lt;= 120:\n        return single_line + \"\\n\"\n\n    # Multi-line format\n    lines = [prefix + \"(\"]\n    for i, item in enumerate(items):\n        if i &lt; len(items) - 1:\n            lines.append(f\"    {item},\")\n        else:\n            lines.append(f\"    {item},\")\n    lines.append(\")\")\n    return \"\\n\".join(lines) + \"\\n\"\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.format_long_list","title":"format_long_list","text":"<pre><code>format_long_list(\n    items: list[dict[str, Any]], max_line_length: int = 120\n) -&gt; str\n</code></pre> <p>Format a long list across multiple lines.</p> PARAMETER DESCRIPTION <code>items</code> <p>List of dict items to format</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>max_line_length</code> <p>Maximum line length before wrapping</p> <p> TYPE: <code>int</code> DEFAULT: <code>120</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted list string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def format_long_list(items: list[dict[str, Any]], max_line_length: int = 120) -&gt; str:\n    \"\"\"Format a long list across multiple lines.\n\n    Args:\n        items: List of dict items to format\n        max_line_length: Maximum line length before wrapping\n\n    Returns:\n        Formatted list string\n    \"\"\"\n    if not items:\n        return \"[]\"\n\n    # Try single line first\n    single_line = repr(items)\n    if len(single_line) &lt;= max_line_length:\n        return single_line\n\n    # Multi-line format with one item per line\n    lines = [\"[\"]\n    for i, item in enumerate(items):\n        item_str = repr(item)\n        if i &lt; len(items) - 1:\n            lines.append(f\"    {item_str},\")\n        else:\n            lines.append(f\"    {item_str},\")\n    lines.append(\"]\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.parse_field_type","title":"parse_field_type","text":"<pre><code>parse_field_type(field_type: str) -&gt; tuple[str, int | None, bool]\n</code></pre> <p>Parse a field type string.</p> PARAMETER DESCRIPTION <code>field_type</code> <p>Field type (e.g., 'uint16', '[32]uint8', '') <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Tuple of (base_type, array_count, is_nested)</p> <code>int | None</code> <ul> <li>base_type: The base type name</li> </ul> <code>bool</code> <ul> <li>array_count: Number of elements if array, None otherwise</li> </ul> <code>tuple[str, int | None, bool]</code> <ul> <li>is_nested: True if it's a nested structure () Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def parse_field_type(field_type: str) -&gt; tuple[str, int | None, bool]:\n    \"\"\"Parse a field type string.\n\n    Args:\n        field_type: Field type (e.g., 'uint16', '[32]uint8', '&lt;HSBK&gt;')\n\n    Returns:\n        Tuple of (base_type, array_count, is_nested)\n        - base_type: The base type name\n        - array_count: Number of elements if array, None otherwise\n        - is_nested: True if it's a nested structure (&lt;Type&gt;)\n    \"\"\"\n    # Check for array: [N]type\n    array_match = re.match(r\"\\[(\\d+)\\](.+)\", field_type)\n    if array_match:\n        count = int(array_match.group(1))\n        inner_type = array_match.group(2)\n        # Check if inner type is nested\n        if inner_type.startswith(\"&lt;\") and inner_type.endswith(\"&gt;\"):\n            return inner_type[1:-1], count, True\n        return inner_type, count, False\n\n    # Check for nested structure: &lt;Type&gt;\n    if field_type.startswith(\"&lt;\") and field_type.endswith(\"&gt;\"):\n        return field_type[1:-1], None, True\n\n    # Simple type\n    return field_type, None, False\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.camel_to_snake_upper","title":"camel_to_snake_upper","text":"<pre><code>camel_to_snake_upper(name: str) -&gt; str\n</code></pre> <p>Convert CamelCase to UPPER_SNAKE_CASE.</p> PARAMETER DESCRIPTION <code>name</code> <p>CamelCase string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>UPPER_SNAKE_CASE string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def camel_to_snake_upper(name: str) -&gt; str:\n    \"\"\"Convert CamelCase to UPPER_SNAKE_CASE.\n\n    Args:\n        name: CamelCase string\n\n    Returns:\n        UPPER_SNAKE_CASE string\n    \"\"\"\n    # Insert underscore before uppercase letters (except at start)\n    snake = re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", name)\n    return snake.upper()\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_enum_code","title":"generate_enum_code","text":"<pre><code>generate_enum_code(enums: dict[str, Any]) -&gt; str\n</code></pre> <p>Generate Python Enum definitions with shortened names.</p> PARAMETER DESCRIPTION <code>enums</code> <p>Dictionary of enum definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python code string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_enum_code(enums: dict[str, Any]) -&gt; str:\n    \"\"\"Generate Python Enum definitions with shortened names.\n\n    Args:\n        enums: Dictionary of enum definitions\n\n    Returns:\n        Python code string\n    \"\"\"\n    code: list[str] = []\n\n    for enum_name, enum_def in sorted(enums.items()):\n        code.append(f\"class {enum_name}(IntEnum):\")\n        code.append('    \"\"\"Auto-generated enum.\"\"\"')\n        code.append(\"\")\n\n        # Handle both old format (dict) and new format (list of dicts)\n        if isinstance(enum_def, dict) and \"values\" in enum_def:\n            # New format: {type: \"uint16\", values: [{name: \"X\", value: 1}, ...]}\n            values = enum_def[\"values\"]\n\n            # Check if all values share a common prefix (enum name)\n            expected_prefix = camel_to_snake_upper(enum_name) + \"_\"\n            non_reserved = [\n                item[\"name\"] for item in values if item[\"name\"].lower() != \"reserved\"\n            ]\n            has_common_prefix = non_reserved and all(\n                name.startswith(expected_prefix) for name in non_reserved\n            )\n\n            for item in sorted(values, key=lambda x: x[\"value\"]):\n                protocol_name = item[\"name\"]\n                member_value = item[\"value\"]\n\n                # Skip reserved fields entirely\n                if protocol_name.lower() == \"reserved\":\n                    continue\n\n                # Remove redundant prefix for cleaner Python names\n                if has_common_prefix and protocol_name.startswith(expected_prefix):\n                    member_name = protocol_name[len(expected_prefix) :]\n                else:\n                    member_name = protocol_name\n\n                code.append(f\"    {member_name} = {member_value}\")\n        else:\n            # Old format: {MEMBER: value, ...}\n            for member_name, member_value in sorted(\n                enum_def.items(), key=lambda x: x[1]\n            ):\n                code.append(f\"    {member_name} = {member_value}\")\n\n        code.append(\"\")\n        code.append(\"\")\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.convert_type_to_python","title":"convert_type_to_python","text":"<pre><code>convert_type_to_python(\n    field_type: str, type_aliases: dict[str, str] | None = None\n) -&gt; str\n</code></pre> <p>Convert a protocol field type to Python type annotation.</p> PARAMETER DESCRIPTION <code>field_type</code> <p>Protocol field type string</p> <p> TYPE: <code>str</code> </p> <code>type_aliases</code> <p>Optional dict for type name aliases</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python type annotation string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def convert_type_to_python(\n    field_type: str, type_aliases: dict[str, str] | None = None\n) -&gt; str:\n    \"\"\"Convert a protocol field type to Python type annotation.\n\n    Args:\n        field_type: Protocol field type string\n        type_aliases: Optional dict for type name aliases\n\n    Returns:\n        Python type annotation string\n    \"\"\"\n    if type_aliases is None:\n        type_aliases = {}\n\n    base_type, array_count, is_nested = parse_field_type(field_type)\n\n    if array_count:\n        if is_nested:\n            # Use alias if one exists\n            type_name = type_aliases.get(base_type, base_type)\n            return f\"list[{type_name}]\"\n        elif base_type in (\"uint8\", \"byte\"):\n            # Special case: byte arrays\n            return \"bytes\"\n        else:\n            return \"list[int]\"\n    elif is_nested:\n        # Use alias if one exists\n        return type_aliases.get(base_type, base_type)\n    elif base_type in (\"uint8\", \"uint16\", \"uint32\", \"uint64\"):\n        return \"int\"\n    elif base_type in (\"int8\", \"int16\", \"int32\", \"int64\"):\n        return \"int\"\n    elif base_type == \"float32\":\n        return \"float\"\n    elif base_type == \"bool\":\n        return \"bool\"\n    else:\n        return \"Any\"\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_pack_method","title":"generate_pack_method","text":"<pre><code>generate_pack_method(\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str\n</code></pre> <p>Generate pack() method code for a field structure or packet.</p> PARAMETER DESCRIPTION <code>fields_data</code> <p>List of field definitions</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>class_type</code> <p>Either \"field\" or \"packet\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'field'</code> </p> <code>enum_types</code> <p>Set of enum type names for detection</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python method code string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_pack_method(\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str:\n    \"\"\"Generate pack() method code for a field structure or packet.\n\n    Args:\n        fields_data: List of field definitions\n        class_type: Either \"field\" or \"packet\"\n        enum_types: Set of enum type names for detection\n\n    Returns:\n        Python method code string\n    \"\"\"\n    if enum_types is None:\n        enum_types = set()\n\n    code = []\n    code.append(\"    def pack(self) -&gt; bytes:\")\n    code.append('        \"\"\"Pack to bytes.\"\"\"')\n    code.append(\"        from lifx.protocol import serializer\")\n    code.append('        result = b\"\"')\n    code.append(\"\")\n\n    for field_item in fields_data:\n        # Handle reserved fields (no name)\n        if \"name\" not in field_item:\n            size_bytes = field_item.get(\"size_bytes\", 0)\n            code.append(f\"        # Reserved {size_bytes} bytes\")\n            code.append(f\"        result += serializer.pack_reserved({size_bytes})\")\n            continue\n\n        protocol_name = field_item[\"name\"]\n        field_type = field_item[\"type\"]\n        size_bytes = field_item.get(\"size_bytes\", 0)\n        python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n\n        base_type, array_count, is_nested = parse_field_type(field_type)\n\n        # Check if this is an enum (nested but in enum_types)\n        is_enum = is_nested and base_type in enum_types\n\n        # Handle different field types\n        if array_count:\n            if is_enum:\n                # Array of enums - pack as array of ints\n                code.append(f\"        # {python_name}: list[{base_type}] (enum array)\")\n                code.append(f\"        for item in self.{python_name}:\")\n                code.append(\n                    \"            result += serializer.pack_value(int(item), 'uint8')\"\n                )\n            elif is_nested:\n                # Array of nested structures\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(f\"        for item in self.{python_name}:\")\n                code.append(\"            result += item.pack()\")\n            elif base_type in (\"uint8\", \"byte\"):\n                # Byte array\n                code.append(f\"        # {python_name}: bytes ({size_bytes} bytes)\")\n                code.append(\n                    f\"        result += \"\n                    f\"serializer.pack_bytes(self.{python_name}, {size_bytes})\"\n                )\n            else:\n                # Array of primitives\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(\n                    f\"        result += \"\n                    f\"serializer.pack_array(self.{python_name}, '{base_type}', {array_count})\"\n                )\n        elif is_enum:\n            # Enum - pack as int\n            code.append(f\"        # {python_name}: {base_type} (enum)\")\n            code.append(\n                f\"        result += \"\n                f\"serializer.pack_value(int(self.{python_name}), 'uint8')\"\n            )\n        elif is_nested:\n            # Nested structure\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(f\"        result += self.{python_name}.pack()\")\n        else:\n            # Primitive type\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(\n                f\"        result += \"\n                f\"serializer.pack_value(self.{python_name}, '{base_type}')\"\n            )\n\n    code.append(\"\")\n    code.append(\"        return result\")\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_unpack_method","title":"generate_unpack_method","text":"<pre><code>generate_unpack_method(\n    class_name: str,\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str\n</code></pre> <p>Generate unpack() classmethod code for a field structure or packet.</p> PARAMETER DESCRIPTION <code>class_name</code> <p>Name of the class</p> <p> TYPE: <code>str</code> </p> <code>fields_data</code> <p>List of field definitions</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>class_type</code> <p>Either \"field\" or \"packet\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'field'</code> </p> <code>enum_types</code> <p>Set of enum type names for detection</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python method code string</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_unpack_method(\n    class_name: str,\n    fields_data: list[dict[str, Any]],\n    class_type: str = \"field\",\n    enum_types: set[str] | None = None,\n) -&gt; str:\n    \"\"\"Generate unpack() classmethod code for a field structure or packet.\n\n    Args:\n        class_name: Name of the class\n        fields_data: List of field definitions\n        class_type: Either \"field\" or \"packet\"\n        enum_types: Set of enum type names for detection\n\n    Returns:\n        Python method code string\n    \"\"\"\n    if enum_types is None:\n        enum_types = set()\n\n    code = []\n    code.append(\"    @classmethod\")\n    code.append(\n        f\"    def unpack(cls, data: bytes, offset: int = 0) -&gt; tuple[{class_name}, int]:\"\n    )\n    code.append('        \"\"\"Unpack from bytes.\"\"\"')\n    code.append(\"        from lifx.protocol import serializer\")\n    code.append(\"        current_offset = offset\")\n\n    # Store field values\n    field_vars = []\n\n    for field_item in fields_data:\n        # Handle reserved fields (no name)\n        if \"name\" not in field_item:\n            size_bytes = field_item.get(\"size_bytes\", 0)\n            code.append(f\"        # Skip reserved {size_bytes} bytes\")\n            code.append(f\"        current_offset += {size_bytes}\")\n            continue\n\n        protocol_name = field_item[\"name\"]\n        field_type = field_item[\"type\"]\n        size_bytes = field_item.get(\"size_bytes\", 0)\n        python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n        field_vars.append(python_name)\n\n        base_type, array_count, is_nested = parse_field_type(field_type)\n\n        # Check if this is an enum (nested but in enum_types)\n        is_enum = is_nested and base_type in enum_types\n\n        # Handle different field types\n        if array_count:\n            if is_enum:\n                # Array of enums\n                code.append(f\"        # {python_name}: list[{base_type}] (enum array)\")\n                code.append(f\"        {python_name} = []\")\n                code.append(f\"        for _ in range({array_count}):\")\n                code.append(\n                    \"            item_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)\"\n                )\n                code.append(f\"            {python_name}.append({base_type}(item_raw))\")\n            elif is_nested:\n                # Array of nested structures\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(f\"        {python_name} = []\")\n                code.append(f\"        for _ in range({array_count}):\")\n                code.append(\n                    f\"            item, current_offset = {base_type}.unpack(data, current_offset)\"\n                )\n                code.append(f\"            {python_name}.append(item)\")\n            elif base_type in (\"uint8\", \"byte\"):\n                # Byte array\n                code.append(f\"        # {python_name}: bytes ({size_bytes} bytes)\")\n                code.append(\n                    f\"        {python_name}, current_offset = serializer.unpack_bytes(\"\n                )\n                code.append(f\"            data, {size_bytes}, current_offset\")\n                code.append(\"        )\")\n            else:\n                # Array of primitives\n                code.append(f\"        # {python_name}: list[{base_type}]\")\n                code.append(\n                    f\"        {python_name}, current_offset = serializer.unpack_array(\"\n                )\n                code.append(\n                    f\"            data, '{base_type}', {array_count}, current_offset\"\n                )\n                code.append(\"        )\")\n        elif is_enum:\n            # Enum - unpack as int then convert\n            code.append(f\"        # {python_name}: {base_type} (enum)\")\n            code.append(\n                f\"        {python_name}_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)\"\n            )\n            code.append(f\"        {python_name} = {base_type}({python_name}_raw)\")\n        elif is_nested:\n            # Nested structure\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(\n                f\"        {python_name}, current_offset = {base_type}.unpack(data, current_offset)\"\n            )\n        else:\n            # Primitive type\n            code.append(f\"        # {python_name}: {base_type}\")\n            code.append(\n                f\"        {python_name}, current_offset = serializer.unpack_value(data, '{base_type}', current_offset)\"\n            )\n\n    code.append(\"\")\n    # Create instance - format long return statements\n    field_args = \", \".join([f\"{name}={name}\" for name in field_vars])\n    return_stmt = f\"        return cls({field_args}), current_offset\"\n\n    # If too long, break across multiple lines\n    if len(return_stmt) &gt; 120:\n        code.append(\"        return (\")\n        code.append(\"            cls(\")\n        for i, name in enumerate(field_vars):\n            if i &lt; len(field_vars) - 1:\n                code.append(f\"                {name}={name},\")\n            else:\n                code.append(f\"                {name}={name},\")\n        code.append(\"            ),\")\n        code.append(\"            current_offset,\")\n        code.append(\"        )\")\n    else:\n        code.append(return_stmt)\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_field_code","title":"generate_field_code","text":"<pre><code>generate_field_code(\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enum_types: set[str] | None = None,\n) -&gt; tuple[str, dict[str, dict[str, str]]]\n</code></pre> <p>Generate Python dataclass definitions for field structures.</p> PARAMETER DESCRIPTION <code>fields</code> <p>Dictionary of field definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Dictionary of compound field definitions</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>unions</code> <p>Dictionary of union definitions (treated as fields)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>packets_as_fields</code> <p>Dictionary of packets that are also used as field types</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>enum_types</code> <p>Set of enum type names</p> <p> TYPE: <code>set[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Tuple of (code string, field mappings dict)</p> <code>dict[str, dict[str, str]]</code> <p>Field mappings: {ClassName: {python_name: protocol_name}}</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_field_code(\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enum_types: set[str] | None = None,\n) -&gt; tuple[str, dict[str, dict[str, str]]]:\n    \"\"\"Generate Python dataclass definitions for field structures.\n\n    Args:\n        fields: Dictionary of field definitions\n        compound_fields: Dictionary of compound field definitions\n        unions: Dictionary of union definitions (treated as fields)\n        packets_as_fields: Dictionary of packets that are also used as field types\n        enum_types: Set of enum type names\n\n    Returns:\n        Tuple of (code string, field mappings dict)\n        Field mappings: {ClassName: {python_name: protocol_name}}\n    \"\"\"\n    if enum_types is None:\n        enum_types = set()\n\n    code = []\n    field_mappings: dict[str, dict[str, str]] = {}\n    all_fields = {**fields}\n    if compound_fields:\n        all_fields.update(compound_fields)\n    if unions:\n        all_fields.update(unions)\n    if packets_as_fields:\n        all_fields.update(packets_as_fields)\n\n    for field_name, field_def in sorted(all_fields.items()):\n        code.append(\"@dataclass\")\n        code.append(f\"class {field_name}:\")\n\n        # Check if this is a union (has comment indicating it's a union)\n        is_union = isinstance(field_def, dict) and \"comment\" in field_def\n        if is_union:\n            code.append(\n                f'    \"\"\"Auto-generated union structure. {field_def.get(\"comment\", \"\")}\"\"\"'\n            )\n        else:\n            code.append('    \"\"\"Auto-generated field structure.\"\"\"')\n        code.append(\"\")\n\n        field_map: dict[str, str] = {}\n        fields_data = []\n\n        # Handle both old format (dict) and new format (list of dicts)\n        if isinstance(field_def, dict) and \"fields\" in field_def:\n            # New format: {size_bytes: N, fields: [{name: \"X\", type: \"uint16\"}, ...]}\n            field_list = field_def[\"fields\"]\n\n            # For unions, treat as a raw bytes field (they overlay, so just store raw data)\n            if is_union:\n                size_bytes = field_def.get(\"size_bytes\", 16)\n                code.append(f\"    data: bytes  # Union of {size_bytes} bytes\")\n                field_map[\"data\"] = \"data\"\n                # For pack/unpack, use bytes field\n                fields_data = [\n                    {\n                        \"name\": \"data\",\n                        \"type\": f\"[{size_bytes}]byte\",\n                        \"size_bytes\": size_bytes,\n                    }\n                ]\n            else:\n                # Normal field structure - process all fields\n                fields_data = field_list  # Save for pack/unpack generation\n                for field_item in field_list:\n                    # Skip reserved fields without names (they won't be in dataclass)\n                    if \"name\" not in field_item:\n                        continue\n                    protocol_name = field_item[\"name\"]\n                    attr_type = field_item[\"type\"]\n                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n                    python_type = convert_type_to_python(attr_type)\n\n                    code.append(f\"    {python_name}: {python_type}\")\n                    field_map[python_name] = protocol_name\n        else:\n            # Old format: {attr_name: type, ...}\n            # Convert to new format for pack/unpack generation\n            for protocol_name, attr_type in field_def.items():\n                python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n                python_type = convert_type_to_python(attr_type)\n                code.append(f\"    {python_name}: {python_type}\")\n                field_map[python_name] = protocol_name\n                # Build fields_data for old format\n                fields_data.append({\"name\": protocol_name, \"type\": attr_type})\n\n        field_mappings[field_name] = field_map\n\n        # Add pack/unpack methods\n        if fields_data:\n            code.append(\"\")\n            code.append(generate_pack_method(fields_data, \"field\", enum_types))\n            code.append(\"\")\n            code.append(\n                generate_unpack_method(field_name, fields_data, \"field\", enum_types)\n            )\n\n        code.append(\"\")\n        code.append(\"\")\n\n    return \"\\n\".join(code), field_mappings\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_nested_packet_code","title":"generate_nested_packet_code","text":"<pre><code>generate_nested_packet_code(\n    packets: dict[str, Any], type_aliases: dict[str, str] | None = None\n) -&gt; str\n</code></pre> <p>Generate nested Python packet class definitions.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions (grouped by category)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>type_aliases</code> <p>Optional dict mapping type names to their aliases (for collision resolution)</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Python code string with nested packet classes</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_nested_packet_code(\n    packets: dict[str, Any], type_aliases: dict[str, str] | None = None\n) -&gt; str:\n    \"\"\"Generate nested Python packet class definitions.\n\n    Args:\n        packets: Dictionary of packet definitions (grouped by category)\n        type_aliases: Optional dict mapping type names to their aliases (for collision resolution)\n\n    Returns:\n        Python code string with nested packet classes\n    \"\"\"\n    if type_aliases is None:\n        type_aliases = {}\n\n    code = []\n\n    # Flatten packets if they're grouped by category\n    flat_packets: list[tuple[str, str, dict[str, Any]]] = []\n\n    # Check if packets are grouped by category (new format)\n    sample_key = next(iter(packets.keys())) if packets else None\n    if sample_key and isinstance(packets[sample_key], dict):\n        sample_value = packets[sample_key]\n        # Check if this is a category grouping (contains nested packet dicts)\n        if any(isinstance(v, dict) and \"pkt_type\" in v for v in sample_value.values()):\n            # New format: grouped by category\n            for category, category_packets in packets.items():\n                for packet_name, packet_def in category_packets.items():\n                    flat_packets.append((category, packet_name, packet_def))\n        else:\n            # Old format: flat packets with category field\n            for packet_name, packet_def in packets.items():\n                category = packet_def.get(\"category\", \"misc\")\n                flat_packets.append((category, packet_name, packet_def))\n\n    # Group by category\n    categories: dict[str, list[tuple[str, dict[str, Any]]]] = {}\n    for category, packet_name, packet_def in flat_packets:\n        if category not in categories:\n            categories[category] = []\n        categories[category].append((packet_name, packet_def))\n\n    # Build lookup table for request-to-response mapping\n    # Maps (category, short_name) -&gt; pkt_type\n    packet_lookup: dict[tuple[str, str], int] = {}\n    for category, packets_list in categories.items():\n        parts = category.split(\"_\")\n        category_class = \"\".join(part.capitalize() for part in parts)\n        for packet_name, packet_def in packets_list:\n            short_name = packet_name\n            if packet_name.lower().startswith(category_class.lower()):\n                short_name = packet_name[len(category_class) :]\n            if category_class == \"Light\":\n                if short_name == \"Get\":\n                    short_name = \"GetColor\"\n                elif short_name == \"State\":\n                    short_name = \"StateColor\"\n            short_name = apply_extended_multizone_packet_quirks(\n                short_name, category_class\n            )\n            packet_lookup[(category, short_name)] = packet_def[\"pkt_type\"]\n\n    # Generate category classes with nested packet classes\n    for category in sorted(categories.keys()):\n        # Generate category class\n        # Quirk: Convert category names to proper camel case (multi_zone -&gt; MultiZone)\n        # Split on underscores, capitalize each part, then join\n        parts = category.split(\"_\")\n        category_class = \"\".join(part.capitalize() for part in parts)\n        code.append(\"\")\n        code.append(f\"class {category_class}(Packet):\")\n        code.append(f'    \"\"\"{category_class} category packets.\"\"\"')\n        code.append(\"\")\n\n        # Generate nested packet classes\n        for packet_name, packet_def in sorted(categories[category]):\n            pkt_type = packet_def[\"pkt_type\"]\n            fields_data = packet_def.get(\"fields\", [])\n\n            # Remove category prefix from packet name (e.g., DeviceGetLabel -&gt; GetLabel)\n            # The packet name format is: CategoryActionTarget (e.g., DeviceGetLabel, LightSetColor)\n            # Use case-insensitive matching to handle multi_zone -&gt; Multizone -&gt; MultiZone\n            short_name = packet_name\n            if packet_name.lower().startswith(category_class.lower()):\n                short_name = packet_name[len(category_class) :]\n\n            # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor\n            # for better clarity (Set and SetColor are different packets)\n            if category_class == \"Light\":\n                if short_name == \"Get\":\n                    short_name = \"GetColor\"\n                elif short_name == \"State\":\n                    short_name = \"StateColor\"\n\n            # Quirk: Rename extended multizone packets to follow standard naming convention\n            short_name = apply_extended_multizone_packet_quirks(\n                short_name, category_class\n            )\n\n            code.append(\"    @dataclass\")\n            code.append(f\"    class {short_name}(Packet):\")\n            code.append(f'        \"\"\"Packet type {pkt_type}.\"\"\"')\n            code.append(\"\")\n            code.append(f\"        PKT_TYPE: ClassVar[int] = {pkt_type}\")\n\n            # Add STATE_TYPE for Get*/Request packets (expected response packet type)\n            state_pkt_type = None\n            if short_name.startswith(\"Get\"):\n                # Special case: GetColorZones \u2192 StateMultiZone (not StateColorZones)\n                if category_class == \"MultiZone\" and short_name == \"GetColorZones\":\n                    state_pkt_type = packet_lookup.get((category, \"StateMultiZone\"))\n                else:\n                    # Standard naming: GetXxx \u2192 StateXxx\n                    state_name = short_name.replace(\"Get\", \"State\", 1)\n                    state_pkt_type = packet_lookup.get((category, state_name))\n            elif short_name.endswith(\"Request\"):\n                # XxxRequest \u2192 XxxResponse\n                response_name = short_name.replace(\"Request\", \"Response\")\n                state_pkt_type = packet_lookup.get((category, response_name))\n\n            if state_pkt_type is not None:\n                code.append(f\"        STATE_TYPE: ClassVar[int] = {state_pkt_type}\")\n\n            # Format fields_data - split long lists across multiple lines\n            # Account for the prefix \"        _fields: ClassVar[list[dict[str, Any]]] = \" which is ~50 chars\n            fields_repr = format_long_list(fields_data, max_line_length=70)\n            if \"\\n\" in fields_repr:\n                # Multi-line format - indent properly\n                code.append(\"        _fields: ClassVar[list[dict[str, Any]]] = (\")\n                for line in fields_repr.split(\"\\n\"):\n                    if line.strip():\n                        code.append(f\"        {line}\")\n                code.append(\"        )\")\n            else:\n                code.append(\n                    f\"        _fields: ClassVar[list[dict[str, Any]]] = {fields_repr}\"\n                )\n\n            # Add packet metadata for smart request handling\n            # Classify packet by name pattern: Get*, Set*, State*, or OTHER\n            packet_kind = \"OTHER\"\n            if short_name.startswith(\"Get\"):\n                packet_kind = \"GET\"\n            elif short_name.startswith(\"Set\"):\n                packet_kind = \"SET\"\n            elif short_name.startswith(\"State\"):\n                packet_kind = \"STATE\"\n\n            # Quirk: CopyFrameBuffer is semantically a SET operation\n            # It modifies device state without returning data\n            if category_class == \"Tile\" and short_name == \"CopyFrameBuffer\":\n                packet_kind = \"SET\"\n\n            code.append(\"\")\n            code.append(\"        # Packet metadata for automatic handling\")\n            code.append(f\"        _packet_kind: ClassVar[str] = {repr(packet_kind)}\")\n\n            # Requires acknowledgement/response based on packet kind\n            # GET requests: ack_required=False, res_required=False (device responds anyway)\n            # SET requests: ack_required=True, res_required=False (need acknowledgement)\n            requires_ack = packet_kind == \"SET\"\n            requires_response = False\n            code.append(f\"        _requires_ack: ClassVar[bool] = {requires_ack}\")\n            code.append(\n                f\"        _requires_response: ClassVar[bool] = {requires_response}\"\n            )\n            code.append(\"\")\n\n            # Generate dataclass fields (only non-reserved)\n            has_fields = False\n            if isinstance(fields_data, list):\n                for field_item in fields_data:\n                    # Skip reserved fields\n                    if \"name\" not in field_item:\n                        continue\n                    protocol_name = field_item[\"name\"]\n                    field_type = field_item[\"type\"]\n                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))\n                    python_type = convert_type_to_python(field_type, type_aliases)\n                    code.append(f\"        {python_name}: {python_type}\")\n                    has_fields = True\n\n            if not has_fields:\n                code.append(\"        pass\")\n\n            code.append(\"\")\n\n        code.append(\"\")\n\n    return \"\\n\".join(code)\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_types_file","title":"generate_types_file","text":"<pre><code>generate_types_file(\n    enums: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Generate complete types.py file.</p> PARAMETER DESCRIPTION <code>enums</code> <p>Enum definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Field structure definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Compound field definitions</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>unions</code> <p>Union definitions</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>packets_as_fields</code> <p>Packets that are also used as field types</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Complete Python file content</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_types_file(\n    enums: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"Generate complete types.py file.\n\n    Args:\n        enums: Enum definitions\n        fields: Field structure definitions\n        compound_fields: Compound field definitions\n        unions: Union definitions\n        packets_as_fields: Packets that are also used as field types\n\n    Returns:\n        Complete Python file content\n    \"\"\"\n    header = '''\"\"\"Auto-generated LIFX protocol types.\n\nDO NOT EDIT THIS FILE MANUALLY.\nGenerated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml\nby protocol/generator.py\n\nUses Pythonic naming conventions (snake_case fields, shortened enums) while\nmaintaining compatibility with the official LIFX protocol through mappings.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom enum import IntEnum\n\n\n'''\n\n    code = header\n    code += generate_enum_code(enums)\n    code += \"\\n\"\n\n    # Extract enum names for pack/unpack generation\n    enum_names = set(enums.keys())\n\n    field_code, field_mappings = generate_field_code(\n        fields, compound_fields, unions, packets_as_fields, enum_names\n    )\n    code += field_code\n    code += \"\\n\"\n\n    # Add type aliases for common names\n    code += \"# Type aliases for convenience\\n\"\n    all_field_names = {\n        **fields,\n        **(compound_fields or {}),\n        **(unions or {}),\n        **(packets_as_fields or {}),\n    }\n    if \"TileStateDevice\" in all_field_names:\n        code += \"TileDevice = TileStateDevice  # Pythonic alias\\n\"\n    code += \"\\n\"\n\n    # Add field name mappings as module-level constant (formatted for readability)\n    code += \"# Field name mappings: Python name -&gt; Protocol name\\n\"\n    code += \"# Used by serializer to translate between conventions\\n\"\n    code += \"FIELD_MAPPINGS: dict[str, dict[str, str]] = {\\n\"\n    for class_name in sorted(field_mappings.keys()):\n        mappings = field_mappings[class_name]\n        # Format each class mapping - if too long, break it into multiple lines\n        mappings_str = repr(mappings)\n        line = f\"    {repr(class_name)}: {mappings_str},\"\n        if len(line) &gt; 120:\n            # Multi-line format\n            code += f\"    {repr(class_name)}: {{\\n\"\n            for py_name, proto_name in sorted(mappings.items()):\n                code += f\"        {repr(py_name)}: {repr(proto_name)},\\n\"\n            code += \"    },\\n\"\n        else:\n            code += line + \"\\n\"\n    code += \"}\\n\"\n    code += \"\\n\"\n\n    return code\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.generate_packets_file","title":"generate_packets_file","text":"<pre><code>generate_packets_file(\n    packets: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enums: dict[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Generate complete packets.py file.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Packet definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Field definitions (for imports)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>compound_fields</code> <p>Compound field definitions (for imports)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>unions</code> <p>Union definitions (for imports)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>packets_as_fields</code> <p>Packets that are also used as field types (for imports)</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>enums</code> <p>Enum definitions for detecting enum types</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Complete Python file content</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def generate_packets_file(\n    packets: dict[str, Any],\n    fields: dict[str, Any],\n    compound_fields: dict[str, Any] | None = None,\n    unions: dict[str, Any] | None = None,\n    packets_as_fields: dict[str, Any] | None = None,\n    enums: dict[str, Any] | None = None,\n) -&gt; str:\n    \"\"\"Generate complete packets.py file.\n\n    Args:\n        packets: Packet definitions\n        fields: Field definitions (for imports)\n        compound_fields: Compound field definitions (for imports)\n        unions: Union definitions (for imports)\n        packets_as_fields: Packets that are also used as field types (for imports)\n        enums: Enum definitions for detecting enum types\n\n    Returns:\n        Complete Python file content\n    \"\"\"\n    # Extract enum names for pack/unpack generation\n    enum_names = set(enums.keys()) if enums else set()\n\n    # Collect all field types and enum types used in packets\n    used_fields = set()\n    used_enums = set()\n    all_fields = {**fields}\n    if compound_fields:\n        all_fields.update(compound_fields)\n    if unions:\n        all_fields.update(unions)\n    if packets_as_fields:\n        all_fields.update(packets_as_fields)\n\n    # Flatten packets to scan for used field types\n    flat_packets: list[dict[str, Any]] = []\n    for value in packets.values():\n        if isinstance(value, dict):\n            # Check if this is a category grouping\n            if any(isinstance(v, dict) and \"pkt_type\" in v for v in value.values()):\n                # New format: grouped by category\n                for packet_def in value.values():\n                    flat_packets.append(packet_def)\n            elif \"pkt_type\" in value:\n                # Old format: direct packet\n                flat_packets.append(value)\n\n    for packet_def in flat_packets:\n        fields_data = packet_def.get(\"fields\", [])\n        # Handle both list and dict formats\n        if isinstance(fields_data, list):\n            for field_item in fields_data:\n                if \"type\" in field_item:\n                    field_type = field_item[\"type\"]\n                    base_type, _, is_nested = parse_field_type(field_type)\n                    if is_nested:\n                        if base_type in all_fields:\n                            used_fields.add(base_type)\n                        elif base_type in enum_names:\n                            used_enums.add(base_type)\n        elif isinstance(fields_data, dict):\n            for field_type in fields_data.values():\n                base_type, _, is_nested = parse_field_type(field_type)\n                if is_nested:\n                    if base_type in all_fields:\n                        used_fields.add(base_type)\n                    elif base_type in enum_names:\n                        used_enums.add(base_type)\n\n    # Generate imports with collision detection\n    imports = \"\"\n    all_imports = sorted(used_fields | used_enums)\n    if all_imports:\n        # Detect name collisions with packet category names\n        category_names = set()\n        for category in packets.keys():\n            if isinstance(packets[category], dict):\n                # Convert category name to class name (same as in generate_nested_packet_code)\n                parts = category.split(\"_\")\n                category_class = \"\".join(part.capitalize() for part in parts)\n                category_names.add(category_class)\n\n        # Generate import list with aliases for collisions\n        import_items = []\n        type_aliases = {}  # Map original name to aliased name\n        for name in all_imports:\n            if name in category_names:\n                # Use alias to avoid collision\n                aliased_name = f\"{name}Field\"\n                import_items.append(f\"{name} as {aliased_name}\")\n                type_aliases[name] = aliased_name\n            else:\n                import_items.append(name)\n\n        imports = format_long_import(import_items) + \"\\n\"\n    else:\n        type_aliases = {}\n        imports = \"\"\n\n    header = f'''\"\"\"Auto-generated LIFX protocol packets.\n\nDO NOT EDIT THIS FILE MANUALLY.\nGenerated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml\nby protocol/generator.py\n\nUses nested packet classes organized by category (Device, Light, etc.).\nEach packet inherits from base Packet class which provides generic pack/unpack.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Any, ClassVar\n\nfrom lifx.protocol.base import Packet\n{imports}\n'''\n\n    code = header\n    packet_code = generate_nested_packet_code(packets, type_aliases)\n    code += packet_code\n\n    # Generate packet registry for nested classes\n    code += \"\\n\\n\"\n    code += \"# Packet Registry - maps packet type to nested packet class\\n\"\n    code += \"PACKET_REGISTRY: dict[int, type[Packet]] = {\\n\"\n\n    # Build registry with nested class paths\n    registry_items = []\n    for category, value in packets.items():\n        if isinstance(value, dict):\n            # Check if this is a category grouping\n            if any(isinstance(v, dict) and \"pkt_type\" in v for v in value.values()):\n                # New format: grouped by category\n                # Quirk: Convert category names to proper camel case (multi_zone -&gt; MultiZone)\n                parts = category.split(\"_\")\n                category_class = \"\".join(part.capitalize() for part in parts)\n                for packet_name, packet_def in value.items():\n                    pkt_type = packet_def.get(\"pkt_type\")\n                    if pkt_type is not None:\n                        # Remove category prefix to get short name\n                        # Use case-insensitive matching to handle multi_zone -&gt; Multizone -&gt; MultiZone\n                        short_name = packet_name\n                        if packet_name.lower().startswith(category_class.lower()):\n                            short_name = packet_name[len(category_class) :]\n\n                        # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor\n                        if category_class == \"Light\":\n                            if short_name == \"Get\":\n                                short_name = \"GetColor\"\n                            elif short_name == \"State\":\n                                short_name = \"StateColor\"\n\n                        # Quirk: Rename extended multizone packets to follow standard naming convention\n                        short_name = apply_extended_multizone_packet_quirks(\n                            short_name, category_class\n                        )\n\n                        # Full path: Category.ShortName\n                        full_path = f\"{category_class}.{short_name}\"\n                        registry_items.append((pkt_type, full_path))\n\n    # Sort by packet type for readability\n    for pkt_type, full_path in sorted(registry_items):\n        code += f\"    {pkt_type}: {full_path},\\n\"\n\n    code += \"}\\n\"\n    code += \"\\n\\n\"\n    code += \"def get_packet_class(pkt_type: int) -&gt; type[Packet] | None:\\n\"\n    code += '    \"\"\"Get packet class for a given packet type.\\n'\n    code += \"\\n\"\n    code += \"    Args:\\n\"\n    code += \"        pkt_type: Packet type number\\n\"\n    code += \"\\n\"\n    code += \"    Returns:\\n\"\n    code += \"        Nested packet class, or None if unknown\\n\"\n    code += '    \"\"\"\\n'\n    code += \"    return PACKET_REGISTRY.get(pkt_type)\\n\"\n\n    return code\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.download_protocol","title":"download_protocol","text":"<pre><code>download_protocol() -&gt; dict[str, Any]\n</code></pre> <p>Download and parse protocol.yml from LIFX GitHub repository.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Parsed protocol dictionary</p> RAISES DESCRIPTION <code>URLError</code> <p>If download fails</p> <code>YAMLError</code> <p>If parsing fails</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def download_protocol() -&gt; dict[str, Any]:\n    \"\"\"Download and parse protocol.yml from LIFX GitHub repository.\n\n    Returns:\n        Parsed protocol dictionary\n\n    Raises:\n        URLError: If download fails\n        yaml.YAMLError: If parsing fails\n    \"\"\"\n    parsed_url = urlparse(PROTOCOL_URL)\n    if parsed_url.scheme == \"https\" and parsed_url.netloc.startswith(\n        \"raw.githubusercontent.com\"\n    ):\n        print(f\"Downloading protocol.yml from {PROTOCOL_URL}...\")\n        with urlopen(PROTOCOL_URL) as response:  # nosec B310\n            protocol_data = response.read()\n\n        print(\"Parsing protocol specification...\")\n        protocol = yaml.safe_load(protocol_data)\n        return protocol\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.validate_protocol_spec","title":"validate_protocol_spec","text":"<pre><code>validate_protocol_spec(protocol: dict[str, Any]) -&gt; list[str]\n</code></pre> <p>Validate protocol specification for missing type references.</p> PARAMETER DESCRIPTION <code>protocol</code> <p>Parsed protocol dictionary</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of error messages (empty if validation passes)</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def validate_protocol_spec(protocol: dict[str, Any]) -&gt; list[str]:\n    \"\"\"Validate protocol specification for missing type references.\n\n    Args:\n        protocol: Parsed protocol dictionary\n\n    Returns:\n        List of error messages (empty if validation passes)\n    \"\"\"\n    errors: list[str] = []\n    registry = TypeRegistry()\n\n    # Register all types\n    enums = protocol.get(\"enums\", {})\n    fields = protocol.get(\"fields\", {})\n    compound_fields = protocol.get(\"compound_fields\", {})\n    unions = protocol.get(\"unions\", {})\n    packets = protocol.get(\"packets\", {})\n\n    # Register enums\n    for enum_name in enums.keys():\n        registry.register_enum(enum_name)\n\n    # Register field structures\n    for field_name in fields.keys():\n        registry.register_field(field_name)\n\n    # Register compound fields\n    for field_name in compound_fields.keys():\n        registry.register_field(field_name)\n\n    # Register unions\n    for union_name in unions.keys():\n        registry.register_union(union_name)\n\n    # Register packets (flatten by category)\n    for category_packets in packets.values():\n        if isinstance(category_packets, dict):\n            for packet_name in category_packets.keys():\n                registry.register_packet(packet_name)\n\n    # Validate field type references\n    def validate_field_types(struct_name: str, struct_def: dict[str, Any]) -&gt; None:\n        \"\"\"Validate all field types in a structure.\"\"\"\n        if isinstance(struct_def, dict) and \"fields\" in struct_def:\n            for field_item in struct_def[\"fields\"]:\n                if \"type\" in field_item:\n                    field_type = field_item[\"type\"]\n                    field_name = field_item.get(\"name\", \"reserved\")\n                    base_type, _, _ = parse_field_type(field_type)\n\n                    # Check if type is defined\n                    if not registry.has_type(base_type):\n                        errors.append(\n                            f\"{struct_name}.{field_name}: Unknown type '{base_type}' in field type '{field_type}'\"\n                        )\n\n    # Validate fields\n    for field_name, field_def in fields.items():\n        validate_field_types(f\"fields.{field_name}\", field_def)\n\n    # Validate compound fields\n    for field_name, field_def in compound_fields.items():\n        validate_field_types(f\"compound_fields.{field_name}\", field_def)\n\n    # Validate unions\n    for union_name, union_def in unions.items():\n        validate_field_types(f\"unions.{union_name}\", union_def)\n\n    # Validate packets\n    for category, category_packets in packets.items():\n        if isinstance(category_packets, dict):\n            for packet_name, packet_def in category_packets.items():\n                if isinstance(packet_def, dict):\n                    validate_field_types(\n                        f\"packets.{category}.{packet_name}\", packet_def\n                    )\n\n    return errors\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.should_skip_button_relay","title":"should_skip_button_relay","text":"<pre><code>should_skip_button_relay(name: str) -&gt; bool\n</code></pre> <p>Check if a name should be skipped (Button or Relay related).</p> PARAMETER DESCRIPTION <code>name</code> <p>Type name to check (enum, field, union, packet, or category)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the name starts with Button or Relay, False otherwise</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def should_skip_button_relay(name: str) -&gt; bool:\n    \"\"\"Check if a name should be skipped (Button or Relay related).\n\n    Args:\n        name: Type name to check (enum, field, union, packet, or category)\n\n    Returns:\n        True if the name starts with Button or Relay, False otherwise\n    \"\"\"\n    return name.startswith(\"Button\") or name.startswith(\"Relay\")\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.filter_button_relay_items","title":"filter_button_relay_items","text":"<pre><code>filter_button_relay_items(items: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Filter out Button and Relay items from a dictionary.</p> PARAMETER DESCRIPTION <code>items</code> <p>Dictionary of items to filter</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Filtered dictionary without Button/Relay items</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def filter_button_relay_items(items: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Filter out Button and Relay items from a dictionary.\n\n    Args:\n        items: Dictionary of items to filter\n\n    Returns:\n        Filtered dictionary without Button/Relay items\n    \"\"\"\n    return {\n        name: value\n        for name, value in items.items()\n        if not should_skip_button_relay(name)\n    }\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.filter_button_relay_packets","title":"filter_button_relay_packets","text":"<pre><code>filter_button_relay_packets(packets: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Filter out button and relay category packets.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions (grouped by category)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Filtered dictionary without button/relay categories</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def filter_button_relay_packets(packets: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Filter out button and relay category packets.\n\n    Args:\n        packets: Dictionary of packet definitions (grouped by category)\n\n    Returns:\n        Filtered dictionary without button/relay categories\n    \"\"\"\n    return {\n        category: category_packets\n        for category, category_packets in packets.items()\n        if category not in (\"button\", \"relay\")\n    }\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.extract_packets_as_fields","title":"extract_packets_as_fields","text":"<pre><code>extract_packets_as_fields(\n    packets: dict[str, Any], fields: dict[str, Any]\n) -&gt; dict[str, Any]\n</code></pre> <p>Extract packets that are used as field types in other structures.</p> PARAMETER DESCRIPTION <code>packets</code> <p>Dictionary of packet definitions</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>fields</code> <p>Dictionary of field definitions to scan</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary of packet definitions that are referenced as field types</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def extract_packets_as_fields(\n    packets: dict[str, Any], fields: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Extract packets that are used as field types in other structures.\n\n    Args:\n        packets: Dictionary of packet definitions\n        fields: Dictionary of field definitions to scan\n\n    Returns:\n        Dictionary of packet definitions that are referenced as field types\n    \"\"\"\n    packets_as_fields = {}\n\n    # Flatten packets first\n    flat_packets = {}\n    for category, category_packets in packets.items():\n        if isinstance(category_packets, dict):\n            for packet_name, packet_def in category_packets.items():\n                if isinstance(packet_def, dict) and \"pkt_type\" in packet_def:\n                    flat_packets[packet_name] = packet_def\n\n    # Scan all fields for references to packet types\n    all_structures = {**fields}\n\n    for struct_def in all_structures.values():\n        if isinstance(struct_def, dict) and \"fields\" in struct_def:\n            for field_item in struct_def[\"fields\"]:\n                if \"type\" in field_item:\n                    field_type = field_item[\"type\"]\n                    base_type, _, is_nested = parse_field_type(field_type)\n\n                    # Check if this references a packet\n                    if is_nested and base_type in flat_packets:\n                        packets_as_fields[base_type] = flat_packets[base_type]\n\n    return packets_as_fields\n</code></pre>"},{"location":"api/protocol/#lifx.protocol.generator.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Main generator entry point.</p> Source code in <code>src/lifx/protocol/generator.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Main generator entry point.\"\"\"\n    try:\n        # Download and parse protocol from GitHub\n        protocol = download_protocol()\n    except Exception as e:\n        print(f\"Error: Failed to download protocol.yml: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Extract sections\n    enums = protocol.get(\"enums\", {})\n    fields = protocol.get(\"fields\", {})\n    compound_fields = protocol.get(\"compound_fields\", {})\n    unions = protocol.get(\"unions\", {})\n    packets = protocol.get(\"packets\", {})\n\n    # Filter out Button and Relay items (not relevant for light control)\n    print(\"Filtering out Button and Relay items...\")\n    enums = filter_button_relay_items(enums)\n    fields = filter_button_relay_items(fields)\n    compound_fields = filter_button_relay_items(compound_fields)\n    unions = filter_button_relay_items(unions)\n    packets = filter_button_relay_packets(packets)\n\n    # Apply local quirks to fix protocol issues\n    print(\"Applying local protocol quirks...\")\n    enums, fields, compound_fields = apply_firmware_effect_enum_quirk(\n        enums, fields, compound_fields\n    )\n    enums, packets = apply_multizone_application_request_quirk(enums, packets)\n    fields = apply_tile_effect_parameter_quirk(fields)\n    fields = apply_tile_state_device_quirk(fields)\n    packets = apply_sensor_packet_quirks(packets)\n\n    # Rebuild protocol dict with filtered items for validation\n    filtered_protocol = {\n        **protocol,\n        \"enums\": enums,\n        \"fields\": fields,\n        \"compound_fields\": compound_fields,\n        \"unions\": unions,\n        \"packets\": packets,\n    }\n\n    # Validate filtered protocol specification\n    print(\"Validating protocol specification...\")\n    validation_errors = validate_protocol_spec(filtered_protocol)\n    if validation_errors:\n        print(\"Validation failed with the following errors:\", file=sys.stderr)\n        for error in validation_errors:\n            print(f\"  - {error}\", file=sys.stderr)\n        sys.exit(1)\n    print(\"Validation passed!\")\n\n    # Extract packets that are used as field types (e.g., DeviceStateVersion)\n    packets_as_fields = extract_packets_as_fields(packets, fields)\n\n    print(f\"Found {len(unions)} unions\")\n    print(\n        f\"Found {len(packets_as_fields)} packets used as field types: {list(packets_as_fields.keys())}\"\n    )\n\n    # Determine output directory\n    project_root = Path(__file__).parent.parent.parent.parent\n    protocol_dir = project_root / \"src\" / \"lifx\" / \"protocol\"\n\n    # Generate protocol_types.py (avoid conflict with Python's types module)\n    types_code = generate_types_file(\n        enums, fields, compound_fields, unions, packets_as_fields\n    )\n    types_file = protocol_dir / \"protocol_types.py\"\n    with open(types_file, \"w\") as f:\n        f.write(types_code)\n    print(f\"Generated {types_file}\")\n\n    # Generate packets.py\n    packets_code = generate_packets_file(\n        packets, fields, compound_fields, unions, packets_as_fields, enums\n    )\n    packets_file = protocol_dir / \"packets.py\"\n    with open(packets_file, \"w\") as f:\n        f.write(packets_code)\n    print(f\"Generated {packets_file}\")\n</code></pre>"},{"location":"api/protocol/#examples","title":"Examples","text":""},{"location":"api/protocol/#working-with-serial-numbers","title":"Working with Serial Numbers","text":"<p>The <code>Serial</code> dataclass provides type-safe, immutable serial number handling:</p> <pre><code>from lifx.protocol.models import Serial\n\n# Create from string (accepts hex with or without separators)\nserial = Serial.from_string(\"d073d5123456\")\nserial = Serial.from_string(\"d0:73:d5:12:34:56\")  # Also works\n\n# Convert between formats\nprotocol_bytes = serial.to_protocol()  # 8 bytes with padding\nserial_string = serial.to_string()     # \"d073d5123456\"\nserial_bytes = serial.value            # 6 bytes (immutable/frozen)\n\n# Create from protocol format (8 bytes)\nserial = Serial.from_protocol(b\"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00\")\nprint(serial)  # \"d073d5123456\"\n\n# String representations\nprint(str(serial))   # \"d073d5123456\"\nprint(repr(serial))  # \"Serial('d073d5123456')\"\n</code></pre>"},{"location":"api/protocol/#using-protocol-packets-directly","title":"Using Protocol Packets Directly","text":"<pre><code>from lifx.network.connection import DeviceConnection\nfrom lifx.protocol.packets import LightSetColor, LightGet, LightState\nfrom lifx.protocol.protocol_types import LightHsbk\nfrom lifx.protocol.models import Serial\n\n\nasync def main():\n    serial = Serial.from_string(\"d073d5123456\")\n\n    async with DeviceConnection(serial.to_string(), \"192.168.1.100\") as conn:\n        # Create a packet\n        packet = LightSetColor(\n            reserved=0,\n            color=LightHsbk(\n                hue=240 * 182, saturation=65535, brightness=32768, kelvin=3500\n            ),\n            duration=1000,  # milliseconds\n        )\n\n        # Send without waiting for response\n        await conn.send_packet(packet)\n\n        # Request with response\n        response = await conn.request_response(LightGet(), LightState)\n        print(f\"Hue: {response.color.hue / 182}\u00b0\")\n</code></pre>"},{"location":"api/protocol/#binary-serialization","title":"Binary Serialization","text":"<pre><code>from lifx.protocol.packets import DeviceSetLabel\nfrom lifx.protocol.serializer import Serializer\n\n# Create packet\npacket = DeviceSetLabel(label=b\"Kitchen Light\\0\" + b\"\\0\" * 19)\n\n# Serialize to bytes\ndata = packet.pack()\nprint(f\"Packet size: {len(data)} bytes\")\n\n# Deserialize from bytes\nunpacked = DeviceSetLabel.unpack(data)\nprint(f\"Label: {unpacked.label.decode('utf-8').rstrip('\\0')}\")\n</code></pre>"},{"location":"api/protocol/#protocol-header_1","title":"Protocol Header","text":"<pre><code>from lifx.protocol.header import LifxHeader\nfrom lifx.protocol.models import Serial\n\n# Create header with Serial\nserial = Serial.from_string(\"d073d5123456\")\nheader = LifxHeader(\n    size=36,\n    protocol=1024,\n    addressable=True,\n    tagged=False,\n    origin=0,\n    source=0x12345678,\n    target=serial.to_protocol(),  # 8 bytes with padding\n    reserved1=b\"\\x00\" * 6,\n    ack_required=False,\n    res_required=True,\n    sequence=42,\n    reserved2=0,\n    pkt_type=101,  # LightGet\n    reserved3=0,\n)\n\n# Serialize\ndata = header.pack()\nprint(f\"Header: {data.hex()}\")\n\n# Deserialize\nunpacked_header = LifxHeader.unpack(data)\nprint(f\"Packet type: {unpacked_header.pkt_type}\")\nprint(f\"Target serial: {Serial.from_protocol(unpacked_header.target)}\")\n</code></pre>"},{"location":"api/protocol/#protocol-constants","title":"Protocol Constants","text":""},{"location":"api/protocol/#message-types","title":"Message Types","text":"<p>Each packet class has a <code>PKT_TYPE</code> constant defining its protocol message type:</p> <pre><code>from lifx.protocol.packets import LightSetColor, LightGet, DeviceGetLabel\n\nprint(f\"LightSetColor type: {LightSetColor.PKT_TYPE}\")  # 102\nprint(f\"LightGet type: {LightGet.PKT_TYPE}\")  # 101\nprint(f\"DeviceGetLabel type: {DeviceGetLabel.PKT_TYPE}\")  # 23\n</code></pre>"},{"location":"api/protocol/#waveform-types","title":"Waveform Types","text":"<pre><code>from lifx.protocol.protocol_types import LightWaveform\n\n# Available waveforms\nLightWaveform.SAW\nLightWaveform.SINE\nLightWaveform.HALF_SINE\nLightWaveform.TRIANGLE\nLightWaveform.PULSE\n</code></pre>"},{"location":"api/protocol/#firmware-effects","title":"Firmware Effects","text":"<pre><code>from lifx.protocol.protocol_types import FirmwareEffect, Direction\n\n# Available firmware effects (for multizone and matrix devices)\nFirmwareEffect.OFF\nFirmwareEffect.MOVE       # MultiZone only\nFirmwareEffect.MORPH      # Tile/Matrix only\nFirmwareEffect.FLAME      # Tile/Matrix only\nFirmwareEffect.SKY        # Tile/Matrix only\n\n# Direction for MOVE effects\nDirection.FORWARD   # Move forward through zones\nDirection.REVERSED  # Move backward through zones\n</code></pre>"},{"location":"api/protocol/#product-registry","title":"Product Registry","text":"<p>The product registry provides automatic device type detection and capability information:</p>"},{"location":"api/protocol/#lifx.products.ProductInfo","title":"ProductInfo  <code>dataclass</code>","text":"<pre><code>ProductInfo(\n    pid: int,\n    name: str,\n    vendor: int,\n    capabilities: int,\n    temperature_range: TemperatureRange | None,\n    min_ext_mz_firmware: int | None,\n)\n</code></pre> <p>Information about a LIFX product.</p> ATTRIBUTE DESCRIPTION <code>pid</code> <p>Product ID</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>Product name</p> <p> TYPE: <code>str</code> </p> <code>vendor</code> <p>Vendor ID (always 1 for LIFX)</p> <p> TYPE: <code>int</code> </p> <code>capabilities</code> <p>Bitfield of ProductCapability flags</p> <p> TYPE: <code>int</code> </p> <code>temperature_range</code> <p>Min/max color temperature in Kelvin</p> <p> TYPE: <code>TemperatureRange | None</code> </p> <code>min_ext_mz_firmware</code> <p>Minimum firmware version for extended multizone</p> <p> TYPE: <code>int | None</code> </p> METHOD DESCRIPTION <code>has_capability</code> <p>Check if product has a specific capability.</p> <code>supports_extended_multizone</code> <p>Check if extended multizone is supported for given firmware version.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo-attributes","title":"Attributes","text":""},{"location":"api/protocol/#lifx.products.ProductInfo.has_color","title":"has_color  <code>property</code>","text":"<pre><code>has_color: bool\n</code></pre> <p>Check if product supports color.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_infrared","title":"has_infrared  <code>property</code>","text":"<pre><code>has_infrared: bool\n</code></pre> <p>Check if product supports infrared.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_multizone","title":"has_multizone  <code>property</code>","text":"<pre><code>has_multizone: bool\n</code></pre> <p>Check if product supports multizone.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_chain","title":"has_chain  <code>property</code>","text":"<pre><code>has_chain: bool\n</code></pre> <p>Check if product supports chaining.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_matrix","title":"has_matrix  <code>property</code>","text":"<pre><code>has_matrix: bool\n</code></pre> <p>Check if product supports matrix (2D grid).</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_relays","title":"has_relays  <code>property</code>","text":"<pre><code>has_relays: bool\n</code></pre> <p>Check if product has relays.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_buttons","title":"has_buttons  <code>property</code>","text":"<pre><code>has_buttons: bool\n</code></pre> <p>Check if product has buttons.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_hev","title":"has_hev  <code>property</code>","text":"<pre><code>has_hev: bool\n</code></pre> <p>Check if product supports HEV.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo.has_extended_multizone","title":"has_extended_multizone  <code>property</code>","text":"<pre><code>has_extended_multizone: bool\n</code></pre> <p>Check if product supports extended multizone.</p>"},{"location":"api/protocol/#lifx.products.ProductInfo-functions","title":"Functions","text":""},{"location":"api/protocol/#lifx.products.ProductInfo.has_capability","title":"has_capability","text":"<pre><code>has_capability(capability: ProductCapability) -&gt; bool\n</code></pre> <p>Check if product has a specific capability.</p> PARAMETER DESCRIPTION <code>capability</code> <p>Capability to check</p> <p> TYPE: <code>ProductCapability</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if product has the capability</p> Source code in <code>src/lifx/products/registry.py</code> <pre><code>def has_capability(self, capability: ProductCapability) -&gt; bool:\n    \"\"\"Check if product has a specific capability.\n\n    Args:\n        capability: Capability to check\n\n    Returns:\n        True if product has the capability\n    \"\"\"\n    return bool(self.capabilities &amp; capability)\n</code></pre>"},{"location":"api/protocol/#lifx.products.ProductInfo.supports_extended_multizone","title":"supports_extended_multizone","text":"<pre><code>supports_extended_multizone(firmware_version: int | None = None) -&gt; bool\n</code></pre> <p>Check if extended multizone is supported for given firmware version.</p> PARAMETER DESCRIPTION <code>firmware_version</code> <p>Firmware version to check (optional)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if extended multizone is supported</p> Source code in <code>src/lifx/products/registry.py</code> <pre><code>def supports_extended_multizone(self, firmware_version: int | None = None) -&gt; bool:\n    \"\"\"Check if extended multizone is supported for given firmware version.\n\n    Args:\n        firmware_version: Firmware version to check (optional)\n\n    Returns:\n        True if extended multizone is supported\n    \"\"\"\n    if not self.has_extended_multizone:\n        return False\n    if self.min_ext_mz_firmware is None:\n        return True\n    if firmware_version is None:\n        return True\n    return firmware_version &gt;= self.min_ext_mz_firmware\n</code></pre>"},{"location":"api/protocol/#lifx.products.ProductCapability","title":"ProductCapability","text":"<p>               Bases: <code>IntEnum</code></p> <p>Product capability flags.</p>"},{"location":"api/protocol/#using-the-product-registry","title":"Using the Product Registry","text":"<pre><code>from lifx.products import get_product, get_device_class_name\n\n# Get product info by product ID\nproduct_info = get_product(product_id=27)\n\n# Get appropriate device class name\nclass_name = get_device_class_name(product_id=27)  # Returns \"Light\", \"MultiZoneLight\", etc.\n</code></pre>"},{"location":"api/protocol/#protocol-updates","title":"Protocol Updates","text":"<p>To update to the latest LIFX protocol:</p> <ol> <li>Download the latest <code>protocol.yml</code> from the    LIFX public-protocol repository</li> <li>Save it to the project root</li> <li>Run the generator: <code>uv run python -m lifx.protocol.generator</code></li> <li>Review the generated code changes</li> <li>Run tests: <code>uv run pytest</code></li> </ol> <p>The generator will automatically:</p> <ul> <li>Parse the YAML specification</li> <li>Generate Python dataclasses for all packet types</li> <li>Create enums for protocol constants</li> <li>Add serialization/deserialization methods</li> <li>Filter out Button/Relay messages (out of scope)</li> </ul>"},{"location":"api/themes/","title":"Themes API Reference","text":"<p>The theme system provides professionally-curated color palettes for coordinated lighting across LIFX devices.</p>"},{"location":"api/themes/#theme-class","title":"Theme Class","text":"<p>The <code>Theme</code> class represents a collection of HSBK colors forming a coordinated palette.</p>"},{"location":"api/themes/#lifx.theme.Theme","title":"Theme","text":"<pre><code>Theme(colors: list[HSBK] | None = None)\n</code></pre> <p>A collection of colors representing a theme or color palette.</p> <p>Themes can be applied to LIFX devices to coordinate colors across multiple lights. Supports both single-zone and multi-zone devices.</p> ATTRIBUTE DESCRIPTION <code>colors</code> <p>List of HSBK colors in the theme</p> <p> TYPE: <code>list[HSBK]</code> </p> Example <pre><code># Create a theme with specific colors\ntheme = Theme(\n    [\n        HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500),  # Red\n        HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500),  # Green\n        HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500),  # Blue\n    ]\n)\n\n# Access colors\nfor color in theme:\n    print(f\"Color: {color.hue}\u00b0\")\n\n# Get a specific color\nfirst_color = theme[0]\n\n# Add more colors\ntheme.add_color(HSBK(hue=180, saturation=1.0, brightness=1.0, kelvin=3500))\n</code></pre> PARAMETER DESCRIPTION <code>colors</code> <p>List of HSBK colors (defaults to white if None or empty)</p> <p> TYPE: <code>list[HSBK] | None</code> DEFAULT: <code>None</code> </p> Example <pre><code># Create from list of colors\ntheme = Theme([color1, color2, color3])\n\n# Create with default white color\ntheme = Theme()\n</code></pre> METHOD DESCRIPTION <code>add_color</code> <p>Add a color to the theme.</p> <code>random</code> <p>Get a random color from the theme.</p> <code>shuffled</code> <p>Get a new theme with colors in random order.</p> <code>get_next_bounds_checked</code> <p>Get the next color after index or the last color if at end.</p> <code>ensure_color</code> <p>Ensure the theme has at least one color.</p> <code>__len__</code> <p>Get the number of colors in the theme.</p> <code>__iter__</code> <p>Iterate over colors in the theme.</p> <code>__getitem__</code> <p>Get a color by index.</p> <code>__contains__</code> <p>Check if a color is in the theme.</p> <code>__repr__</code> <p>Return a string representation of the theme.</p> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def __init__(self, colors: list[HSBK] | None = None) -&gt; None:\n    \"\"\"Create a new theme with the given colors.\n\n    Args:\n        colors: List of HSBK colors (defaults to white if None or empty)\n\n    Example:\n        ```python\n        # Create from list of colors\n        theme = Theme([color1, color2, color3])\n\n        # Create with default white color\n        theme = Theme()\n        ```\n    \"\"\"\n    if colors and len(colors) &gt; 0:\n        self.colors: list[HSBK] = colors\n    else:\n        # Default to white if no colors provided\n        self.colors = [Colors.WHITE_NEUTRAL]\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme-functions","title":"Functions","text":""},{"location":"api/themes/#lifx.theme.Theme.add_color","title":"add_color","text":"<pre><code>add_color(color: HSBK) -&gt; None\n</code></pre> <p>Add a color to the theme.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to add</p> <p> TYPE: <code>HSBK</code> </p> Example <pre><code>theme = Theme()\ntheme.add_color(HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500))\n</code></pre> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def add_color(self, color: HSBK) -&gt; None:\n    \"\"\"Add a color to the theme.\n\n    Args:\n        color: HSBK color to add\n\n    Example:\n        ```python\n        theme = Theme()\n        theme.add_color(HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500))\n        ```\n    \"\"\"\n    self.colors.append(color)\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.random","title":"random","text":"<pre><code>random() -&gt; HSBK\n</code></pre> <p>Get a random color from the theme.</p> RETURNS DESCRIPTION <code>HSBK</code> <p>A random HSBK color from the theme</p> Example <pre><code>theme = Theme([red, green, blue])\ncolor = theme.random()\n</code></pre> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def random(self) -&gt; HSBK:\n    \"\"\"Get a random color from the theme.\n\n    Returns:\n        A random HSBK color from the theme\n\n    Example:\n        ```python\n        theme = Theme([red, green, blue])\n        color = theme.random()\n        ```\n    \"\"\"\n    return random.choice(self.colors)  # nosec\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.shuffled","title":"shuffled","text":"<pre><code>shuffled() -&gt; Theme\n</code></pre> <p>Get a new theme with colors in random order.</p> RETURNS DESCRIPTION <code>Theme</code> <p>New Theme instance with shuffled colors</p> Example <pre><code>theme = Theme([color1, color2, color3])\nshuffled_theme = theme.shuffled()\n</code></pre> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def shuffled(self) -&gt; Theme:\n    \"\"\"Get a new theme with colors in random order.\n\n    Returns:\n        New Theme instance with shuffled colors\n\n    Example:\n        ```python\n        theme = Theme([color1, color2, color3])\n        shuffled_theme = theme.shuffled()\n        ```\n    \"\"\"\n    shuffled_colors = self.colors.copy()\n    random.shuffle(shuffled_colors)\n    return Theme(shuffled_colors)\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.get_next_bounds_checked","title":"get_next_bounds_checked","text":"<pre><code>get_next_bounds_checked(index: int) -&gt; HSBK\n</code></pre> <p>Get the next color after index or the last color if at end.</p> PARAMETER DESCRIPTION <code>index</code> <p>Index of current color</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>Next HSBK color or the last color if index is at the end</p> Example <pre><code>theme = Theme([red, green, blue])\ncolor = theme.get_next_bounds_checked(0)  # green\ncolor = theme.get_next_bounds_checked(2)  # blue (last color)\n</code></pre> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def get_next_bounds_checked(self, index: int) -&gt; HSBK:\n    \"\"\"Get the next color after index or the last color if at end.\n\n    Args:\n        index: Index of current color\n\n    Returns:\n        Next HSBK color or the last color if index is at the end\n\n    Example:\n        ```python\n        theme = Theme([red, green, blue])\n        color = theme.get_next_bounds_checked(0)  # green\n        color = theme.get_next_bounds_checked(2)  # blue (last color)\n        ```\n    \"\"\"\n    if index + 1 &lt; len(self.colors):\n        return self.colors[index + 1]\n    return self.colors[-1]\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.ensure_color","title":"ensure_color","text":"<pre><code>ensure_color() -&gt; None\n</code></pre> <p>Ensure the theme has at least one color.</p> <p>If the theme is empty, adds a default white color.</p> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def ensure_color(self) -&gt; None:\n    \"\"\"Ensure the theme has at least one color.\n\n    If the theme is empty, adds a default white color.\n    \"\"\"\n    if not self.colors:\n        self.colors.append(\n            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500)\n        )  # pragma: no cover\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Get the number of colors in the theme.</p> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get the number of colors in the theme.\"\"\"\n    return len(self.colors)\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[HSBK]\n</code></pre> <p>Iterate over colors in the theme.</p> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def __iter__(self) -&gt; Iterator[HSBK]:\n    \"\"\"Iterate over colors in the theme.\"\"\"\n    return iter(self.colors)\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: int) -&gt; HSBK\n</code></pre> <p>Get a color by index.</p> PARAMETER DESCRIPTION <code>index</code> <p>Index of the color (0-based)</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>HSBK</code> <p>HSBK color at the given index</p> RAISES DESCRIPTION <code>IndexError</code> <p>If index is out of range</p> Example <pre><code>theme = Theme([red, green, blue])\ncolor = theme[1]  # green\n</code></pre> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def __getitem__(self, index: int) -&gt; HSBK:\n    \"\"\"Get a color by index.\n\n    Args:\n        index: Index of the color (0-based)\n\n    Returns:\n        HSBK color at the given index\n\n    Raises:\n        IndexError: If index is out of range\n\n    Example:\n        ```python\n        theme = Theme([red, green, blue])\n        color = theme[1]  # green\n        ```\n    \"\"\"\n    return self.colors[index]\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.__contains__","title":"__contains__","text":"<pre><code>__contains__(color: HSBK) -&gt; bool\n</code></pre> <p>Check if a color is in the theme.</p> PARAMETER DESCRIPTION <code>color</code> <p>HSBK color to check</p> <p> TYPE: <code>HSBK</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if color is in theme (by value comparison)</p> Example <pre><code>theme = Theme([red, green, blue])\nif red in theme:\n    print(\"Red is in the theme\")\n</code></pre> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def __contains__(self, color: HSBK) -&gt; bool:\n    \"\"\"Check if a color is in the theme.\n\n    Args:\n        color: HSBK color to check\n\n    Returns:\n        True if color is in theme (by value comparison)\n\n    Example:\n        ```python\n        theme = Theme([red, green, blue])\n        if red in theme:\n            print(\"Red is in the theme\")\n        ```\n    \"\"\"\n    return any(\n        c.hue == color.hue\n        and c.saturation == color.saturation\n        and c.brightness == color.brightness\n        and c.kelvin == color.kelvin\n        for c in self.colors\n    )\n</code></pre>"},{"location":"api/themes/#lifx.theme.Theme.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the theme.</p> Source code in <code>src/lifx/theme/theme.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the theme.\"\"\"\n    color_count = len(self.colors)\n    return f\"Theme({color_count} colors)\"\n</code></pre>"},{"location":"api/themes/#themelibrary-class","title":"ThemeLibrary Class","text":"<p>The <code>ThemeLibrary</code> provides access to 42 official LIFX app themes organized into 6 categories.</p>"},{"location":"api/themes/#lifx.theme.ThemeLibrary","title":"ThemeLibrary","text":"<p>Collection of built-in color themes for LIFX devices.</p> <p>Provides access to 60+ professionally designed themes organized by mood, season, occasion, and time of day.</p> Example <pre><code># Get a specific theme\nevening_theme = ThemeLibrary.get(\"evening\")\n\n# List all available themes\nall_themes = ThemeLibrary.list()\n\n# Get themes by category\nseasonal = ThemeLibrary.get_by_category(\"seasonal\")\n\n# Apply to a light\nawait light.apply_theme(evening_theme, power_on=True)\n</code></pre> METHOD DESCRIPTION <code>get</code> <p>Get a theme by name.</p> <code>list</code> <p>List all available theme names.</p> <code>get_by_category</code> <p>Get all themes in a category.</p>"},{"location":"api/themes/#lifx.theme.ThemeLibrary-functions","title":"Functions","text":""},{"location":"api/themes/#lifx.theme.ThemeLibrary.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(name: str) -&gt; Theme\n</code></pre> <p>Get a theme by name.</p> PARAMETER DESCRIPTION <code>name</code> <p>Theme name (case-insensitive)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Theme</code> <p>Theme object</p> RAISES DESCRIPTION <code>KeyError</code> <p>If theme name is not found</p> Example <pre><code>from lifx.theme import ThemeLibrary\n\nevening_theme = ThemeLibrary.get(\"evening\")\nawait light.apply_theme(evening_theme, power_on=True)\n</code></pre> Source code in <code>src/lifx/theme/library.py</code> <pre><code>@classmethod\ndef get(cls, name: str) -&gt; Theme:\n    \"\"\"Get a theme by name.\n\n    Args:\n        name: Theme name (case-insensitive)\n\n    Returns:\n        Theme object\n\n    Raises:\n        KeyError: If theme name is not found\n\n    Example:\n        ```python\n        from lifx.theme import ThemeLibrary\n\n        evening_theme = ThemeLibrary.get(\"evening\")\n        await light.apply_theme(evening_theme, power_on=True)\n        ```\n    \"\"\"\n    normalized_name = name.lower()\n    if normalized_name not in cls._THEMES:\n        available = \", \".join(sorted(cls._THEMES.keys()))\n        raise KeyError(f\"Theme '{name}' not found. Available themes: {available}\")\n    return Theme(cls._THEMES[normalized_name])\n</code></pre>"},{"location":"api/themes/#lifx.theme.ThemeLibrary.list","title":"list  <code>classmethod</code>","text":"<pre><code>list() -&gt; list[str]\n</code></pre> <p>List all available theme names.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>Sorted list of theme names</p> Example <pre><code>from lifx.theme import ThemeLibrary\n\nall_themes = ThemeLibrary.list()\nfor theme_name in all_themes:\n    print(f\"- {theme_name}\")\n</code></pre> Source code in <code>src/lifx/theme/library.py</code> <pre><code>@classmethod\ndef list(cls) -&gt; list[str]:\n    \"\"\"List all available theme names.\n\n    Returns:\n        Sorted list of theme names\n\n    Example:\n        ```python\n        from lifx.theme import ThemeLibrary\n\n        all_themes = ThemeLibrary.list()\n        for theme_name in all_themes:\n            print(f\"- {theme_name}\")\n        ```\n    \"\"\"\n    return sorted(cls._THEMES.keys())\n</code></pre>"},{"location":"api/themes/#lifx.theme.ThemeLibrary.get_by_category","title":"get_by_category  <code>classmethod</code>","text":"<pre><code>get_by_category(category: str) -&gt; dict[str, Theme]\n</code></pre> <p>Get all themes in a category.</p> PARAMETER DESCRIPTION <code>category</code> <p>Category name (seasonal, mood, holiday, time, etc.)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, Theme]</code> <p>Dictionary of Theme objects in the category</p> RAISES DESCRIPTION <code>ValueError</code> <p>If category is not recognized</p> Source code in <code>src/lifx/theme/library.py</code> <pre><code>@classmethod\ndef get_by_category(cls, category: str) -&gt; dict[str, Theme]:\n    \"\"\"Get all themes in a category.\n\n    Args:\n        category: Category name (seasonal, mood, holiday, time, etc.)\n\n    Returns:\n        Dictionary of Theme objects in the category\n\n    Raises:\n        ValueError: If category is not recognized\n    \"\"\"\n    category_lower = category.lower()\n\n    categories = {\n        \"seasonal\": [\n            \"spring\",\n            \"autumn\",\n            \"winter\",\n        ],\n        \"holiday\": [\n            \"christmas\",\n            \"halloween\",\n            \"hanukkah\",\n            \"kwanzaa\",\n            \"shamrock\",\n            \"thanksgiving\",\n            \"calaveras\",\n            \"pumpkin\",\n            \"santa\",\n            \"holly\",\n            \"independence\",\n            \"proud\",\n        ],\n        \"mood\": [\n            \"peaceful\",\n            \"serene\",\n            \"relaxing\",\n            \"mellow\",\n            \"gentle\",\n            \"soothing\",\n            \"blissful\",\n            \"cheerful\",\n            \"romantic\",\n            \"romance\",\n            \"love\",\n            \"energizing\",\n            \"exciting\",\n            \"epic\",\n            \"intense\",\n            \"powerful\",\n            \"dramatic\",\n            \"warming\",\n        ],\n        \"ambient\": [\n            \"dream\",\n            \"fantasy\",\n            \"spacey\",\n            \"stardust\",\n            \"zombie\",\n            \"party\",\n        ],\n        \"functional\": [\n            \"focusing\",\n            \"evening\",\n            \"bias_lighting\",\n        ],\n        \"atmosphere\": [\n            \"hygge\",\n            \"tranquil\",\n            \"sports\",\n        ],\n    }\n\n    if category_lower not in categories:\n        available = \", \".join(sorted(categories.keys()))\n        raise ValueError(\n            f\"Category '{category}' not recognized. \"\n            f\"Available categories: {available}\"\n        )\n\n    return {\n        name: cls.get(name)\n        for name in categories[category_lower]\n        if name in cls._THEMES\n    }\n</code></pre>"},{"location":"api/themes/#canvas-class","title":"Canvas Class","text":"<p>The <code>Canvas</code> class provides 2D sparse grid functionality for tile device color interpolation.</p>"},{"location":"api/themes/#lifx.theme.Canvas","title":"Canvas","text":"<pre><code>Canvas()\n</code></pre> <p>A Canvas is a collection of points with methods for interacting with those points</p> <p>The points are stored as (i, j) in a dictionary. The value for each point is an HSBK color.</p> METHOD DESCRIPTION <code>add_points_for_tile</code> <p>Create points on the canvas around where a tile is.</p> <code>surrounding_colors</code> <p>Return the colors that surround this (i, j) point.</p> <code>has_neighbour</code> <p>Return whether there are any points around this (i, j) position.</p> <code>shuffle_points</code> <p>Take all the points and move them around a random amount.</p> <code>blur</code> <p>For each point, find the average colour of that point plus all surrounding</p> <code>blur_by_distance</code> <p>Similar to blur but will find the 8 closest points as opposed to the 8</p> <code>points_for_tile</code> <p>Return a list of HSBK values for this tile.</p> <code>fill_in_points</code> <p>Fill in the gaps on this canvas by blurring the points on the provided canvas</p> <code>closest_points</code> <p>Return [(distance, color), ...] for the closest consider amount of</p> <code>__iter__</code> <p>Yield ((i, j), color) pairs for all our points.</p> <code>__getitem__</code> <p>Return the color at point where point is (i, j).</p> <code>__setitem__</code> <p>Set the color at point where point is (i, j).</p> <code>__contains__</code> <p>Return whether this point has a color where point is (i, j).</p> <code>__repr__</code> <p>Return string representation.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the canvas.\"\"\"\n    self.points: dict[tuple[int, int], HSBK] = {}\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas-functions","title":"Functions","text":""},{"location":"api/themes/#lifx.theme.Canvas.add_points_for_tile","title":"add_points_for_tile","text":"<pre><code>add_points_for_tile(tile: tuple[int, int] | None, theme: Theme) -&gt; None\n</code></pre> <p>Create points on the canvas around where a tile is.</p> <p>We create an area that's half the tile width/height beyond the boundary of the tile. We also spread the points out in a random manner and try to avoid having points next to each other.</p> <p>Multiple calls to this function will not override existing points on the canvas.</p> PARAMETER DESCRIPTION <code>tile</code> <p>Tile coordinates (x, y) or None for single tile</p> <p> TYPE: <code>tuple[int, int] | None</code> </p> <code>theme</code> <p>Theme containing colors to distribute</p> <p> TYPE: <code>Theme</code> </p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def add_points_for_tile(self, tile: tuple[int, int] | None, theme: Theme) -&gt; None:\n    \"\"\"Create points on the canvas around where a tile is.\n\n    We create an area that's half the tile width/height beyond the boundary\n    of the tile. We also spread the points out in a random manner and try to avoid\n    having points next to each other.\n\n    Multiple calls to this function will not override existing points on the canvas.\n\n    Args:\n        tile: Tile coordinates (x, y) or None for single tile\n        theme: Theme containing colors to distribute\n    \"\"\"\n    tile_x, tile_y = tile if tile else (0, 0)\n    tile_width = 8  # Standard tile width\n    tile_height = 8  # Standard tile height\n\n    from_x = int(tile_x - tile_width * 1.5)\n    to_x = int(tile_x + tile_width * 1.5)\n    from_y = int(tile_y - tile_height * 1.5)\n    to_y = int(tile_y + tile_height * 1.5)\n\n    i = from_x\n    while i &lt; to_x:\n        j = from_y\n        while j &lt; to_y:\n            if (i, j) not in self.points:\n                if not self.has_neighbour(i, j):\n                    random_color = theme.random()\n                    self[(i, j)] = random_color\n            j += random.choice([1, 2, 3])  # nosec\n        i += random.choice([1, 2, 3])  # nosec\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.surrounding_colors","title":"surrounding_colors","text":"<pre><code>surrounding_colors(i: int, j: int) -&gt; list[HSBK]\n</code></pre> <p>Return the colors that surround this (i, j) point.</p> <p>This will only return points that exist.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def surrounding_colors(self, i: int, j: int) -&gt; list[HSBK]:\n    \"\"\"Return the colors that surround this (i, j) point.\n\n    This will only return points that exist.\n    \"\"\"\n    return [self[(x, y)] for x, y in surrounding_points(i, j) if (x, y) in self]\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.has_neighbour","title":"has_neighbour","text":"<pre><code>has_neighbour(i: int, j: int) -&gt; bool\n</code></pre> <p>Return whether there are any points around this (i, j) position.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def has_neighbour(self, i: int, j: int) -&gt; bool:\n    \"\"\"Return whether there are any points around this (i, j) position.\"\"\"\n    return any(self.surrounding_colors(i, j))\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.shuffle_points","title":"shuffle_points","text":"<pre><code>shuffle_points() -&gt; None\n</code></pre> <p>Take all the points and move them around a random amount.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def shuffle_points(self) -&gt; None:\n    \"\"\"Take all the points and move them around a random amount.\"\"\"\n    new_points = {}\n    for (i, j), color in self:\n        new_points[shuffle_point(i, j)] = color\n\n    self.points = new_points\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.blur","title":"blur","text":"<pre><code>blur() -&gt; None\n</code></pre> <p>For each point, find the average colour of that point plus all surrounding points.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def blur(self) -&gt; None:\n    \"\"\"\n    For each point, find the average colour of that point plus all surrounding\n    points.\n    \"\"\"\n    new_points = {}\n    for (i, j), original in self:\n        colors = [original for _ in range(2)]\n        for color in self.surrounding_colors(i, j):\n            colors.append(color)\n        new_points[(i, j)] = HSBK.average(colors)\n    self.points = new_points\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.blur_by_distance","title":"blur_by_distance","text":"<pre><code>blur_by_distance() -&gt; None\n</code></pre> <p>Similar to blur but will find the 8 closest points as opposed to the 8 surrounding points.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def blur_by_distance(self) -&gt; None:\n    \"\"\"Similar to blur but will find the 8 closest points as opposed to the 8\n    surrounding points.\"\"\"\n    new_points = {}\n    for (i, j), _ in self:\n        distances = self.closest_points(i, j, 8)\n        weighted = list(color_weighting(distances))\n        if weighted:\n            new_points[(i, j)] = HSBK.average(weighted)\n    self.points = new_points\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.points_for_tile","title":"points_for_tile","text":"<pre><code>points_for_tile(\n    tile: tuple[int, int] | None, width: int = 8, height: int = 8\n) -&gt; list[HSBK]\n</code></pre> <p>Return a list of HSBK values for this tile.</p> <p>For any point on the tile that doesn't have a corresponding point on the canvas return a grey value. This is useful for when we tell the applier to not fill in the gaps.</p> PARAMETER DESCRIPTION <code>tile</code> <p>Tile coordinates (x, y) or None for single tile</p> <p> TYPE: <code>tuple[int, int] | None</code> </p> <code>width</code> <p>Grid width (typically 8)</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> <code>height</code> <p>Grid height (typically 8)</p> <p> TYPE: <code>int</code> DEFAULT: <code>8</code> </p> RETURNS DESCRIPTION <code>list[HSBK]</code> <p>List of HSBK colors in row-major order</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def points_for_tile(\n    self, tile: tuple[int, int] | None, width: int = 8, height: int = 8\n) -&gt; list[HSBK]:\n    \"\"\"Return a list of HSBK values for this tile.\n\n    For any point on the tile that doesn't have a corresponding point on the\n    canvas return a grey value. This is useful for when we tell the applier\n    to not fill in the gaps.\n\n    Args:\n        tile: Tile coordinates (x, y) or None for single tile\n        width: Grid width (typically 8)\n        height: Grid height (typically 8)\n\n    Returns:\n        List of HSBK colors in row-major order\n    \"\"\"\n    tile_x, tile_y = tile if tile else (0, 0)\n    result = []\n    grey = HSBK(hue=0, saturation=0, brightness=0.3, kelvin=3500)\n\n    for j in range(tile_y, tile_y + height):\n        for i in range(tile_x, tile_x + width):\n            if (i, j) in self.points:\n                result.append(self.points[(i, j)])\n            else:\n                result.append(grey)\n\n    return result\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.fill_in_points","title":"fill_in_points","text":"<pre><code>fill_in_points(\n    canvas: Canvas, left_x: int, top_y: int, tile_width: int, tile_height: int\n) -&gt; None\n</code></pre> <p>Fill in the gaps on this canvas by blurring the points on the provided canvas</p> <p>We blur by finding the 4 closest points for each point on our tile and averaging them.</p> PARAMETER DESCRIPTION <code>canvas</code> <p>Source canvas to interpolate from</p> <p> TYPE: <code>Canvas</code> </p> <code>left_x</code> <p>Left x coordinate of tile</p> <p> TYPE: <code>int</code> </p> <code>top_y</code> <p>Top y coordinate of tile</p> <p> TYPE: <code>int</code> </p> <code>tile_width</code> <p>Width of tile</p> <p> TYPE: <code>int</code> </p> <code>tile_height</code> <p>Height of tile</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def fill_in_points(\n    self, canvas: Canvas, left_x: int, top_y: int, tile_width: int, tile_height: int\n) -&gt; None:\n    \"\"\"Fill in the gaps on this canvas by blurring the points on the provided canvas\n\n    We blur by finding the 4 closest points for each point on our tile and\n    averaging them.\n\n    Args:\n        canvas: Source canvas to interpolate from\n        left_x: Left x coordinate of tile\n        top_y: Top y coordinate of tile\n        tile_width: Width of tile\n        tile_height: Height of tile\n    \"\"\"\n    for j in range(top_y, top_y + tile_height):\n        for i in range(left_x, left_x + tile_width):\n            distances = canvas.closest_points(i, j, 4)\n            weighted = list(color_weighting(distances))\n            if weighted:\n                self[(i, j)] = HSBK.average(weighted)\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.closest_points","title":"closest_points","text":"<pre><code>closest_points(i: int, j: int, consider: int) -&gt; list[tuple[int, HSBK]]\n</code></pre> <p>Return [(distance, color), ...] for the closest consider amount of points to (i, j).</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def closest_points(self, i: int, j: int, consider: int) -&gt; list[tuple[int, HSBK]]:\n    \"\"\"Return [(distance, color), ...] for the closest consider amount of\n    points to (i, j).\"\"\"\n    distances: list[tuple[int, HSBK]] = []\n\n    for (x, y), color in self:\n        distances.append(((x - i) ** 2 + (y - j) ** 2, color))\n\n    def get_key(\n        dc: tuple[int, HSBK],\n    ) -&gt; tuple[int, tuple[float, float, float, int]]:\n        return (\n            dc[0],\n            (dc[1].hue, dc[1].saturation, dc[1].brightness, dc[1].kelvin),\n        )\n\n    distances = sorted(distances, key=get_key)\n    return distances[:consider]\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[tuple[tuple[int, int], HSBK]]\n</code></pre> <p>Yield ((i, j), color) pairs for all our points.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def __iter__(self) -&gt; Iterator[tuple[tuple[int, int], HSBK]]:\n    \"\"\"Yield ((i, j), color) pairs for all our points.\"\"\"\n    yield from self.points.items()\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(point: tuple[int, int]) -&gt; HSBK\n</code></pre> <p>Return the color at point where point is (i, j).</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def __getitem__(self, point: tuple[int, int]) -&gt; HSBK:\n    \"\"\"Return the color at point where point is (i, j).\"\"\"\n    return self.points[point]\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: tuple[int, int], color: HSBK) -&gt; None\n</code></pre> <p>Set the color at point where point is (i, j).</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def __setitem__(self, key: tuple[int, int], color: HSBK) -&gt; None:\n    \"\"\"Set the color at point where point is (i, j).\"\"\"\n    self.points[key] = color\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.__contains__","title":"__contains__","text":"<pre><code>__contains__(point: tuple[int, int]) -&gt; bool\n</code></pre> <p>Return whether this point has a color where point is (i, j).</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def __contains__(self, point: tuple[int, int]) -&gt; bool:\n    \"\"\"Return whether this point has a color where point is (i, j).\"\"\"\n    return point in self.points\n</code></pre>"},{"location":"api/themes/#lifx.theme.Canvas.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/lifx/theme/canvas.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    return f\"Canvas({len(self.points)} points)\"\n</code></pre>"},{"location":"api/themes/#convenience-function","title":"Convenience Function","text":""},{"location":"api/themes/#lifx.theme.get_theme","title":"get_theme","text":"<pre><code>get_theme(name: str) -&gt; Theme\n</code></pre> <p>Get a theme by name.</p> <p>Convenience function equivalent to ThemeLibrary.get(name).</p> PARAMETER DESCRIPTION <code>name</code> <p>Theme name (case-insensitive)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Theme</code> <p>Theme object</p> Example <pre><code>from lifx.theme import get_theme\n\nevening = get_theme(\"evening\")\nawait light.apply_theme(evening, power_on=True)\n</code></pre> Source code in <code>src/lifx/theme/library.py</code> <pre><code>def get_theme(name: str) -&gt; Theme:\n    \"\"\"Get a theme by name.\n\n    Convenience function equivalent to ThemeLibrary.get(name).\n\n    Args:\n        name: Theme name (case-insensitive)\n\n    Returns:\n        Theme object\n\n    Example:\n        ```python\n        from lifx.theme import get_theme\n\n        evening = get_theme(\"evening\")\n        await light.apply_theme(evening, power_on=True)\n        ```\n    \"\"\"\n    return ThemeLibrary.get(name)\n</code></pre>"},{"location":"api/themes/#available-themes-42-total","title":"Available Themes (42 Total)","text":""},{"location":"api/themes/#seasonal-3-themes","title":"Seasonal (3 themes)","text":"<ul> <li>spring, autumn, winter</li> </ul>"},{"location":"api/themes/#holiday-9-themes","title":"Holiday (9 themes)","text":"<ul> <li>christmas, halloween, hanukkah, kwanzaa, shamrock, thanksgiving, calaveras, pumpkin, santa</li> </ul>"},{"location":"api/themes/#mood-16-themes","title":"Mood (16 themes)","text":"<ul> <li>peaceful, serene, relaxing, mellow, gentle, soothing, blissful, cheerful, romantic, romance, love, energizing, exciting, epic, intense, powerful, warming</li> </ul>"},{"location":"api/themes/#ambient-6-themes","title":"Ambient (6 themes)","text":"<ul> <li>dream, fantasy, spacey, stardust, zombie, party</li> </ul>"},{"location":"api/themes/#functional-3-themes","title":"Functional (3 themes)","text":"<ul> <li>focusing, evening, bias_lighting</li> </ul>"},{"location":"api/themes/#atmosphere-3-themes","title":"Atmosphere (3 themes)","text":"<ul> <li>hygge, tranquil, sports</li> </ul>"},{"location":"architecture/effects-architecture/","title":"Effects Architecture","text":"<p>This document provides a comprehensive overview of the Light Effects Framework architecture, including design decisions, implementation details, and lifecycle management.</p>"},{"location":"architecture/effects-architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>High-Level Overview</li> <li>Component Architecture</li> <li>Effect Lifecycle</li> <li>State Management</li> <li>Concurrency Model</li> <li>Device Type Handling</li> <li>Design Decisions</li> </ul>"},{"location":"architecture/effects-architecture/#high-level-overview","title":"High-Level Overview","text":"<p>The Light Effects Framework is built on a layered architecture that separates concerns and provides a clean abstraction for effect management:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Application Layer                       \u2502\n\u2502  (User code, business logic, effect selection)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Effects API Layer                       \u2502\n\u2502   \u2022 Conductor (orchestration)                       \u2502\n\u2502   \u2022 EffectPulse, EffectColorloop (implementations)  \u2502\n\u2502   \u2022 LIFXEffect (base class)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Device Layer (lifx.devices)               \u2502\n\u2502   \u2022 Light, MultiZoneLight, MatrixLight              \u2502\n\u2502   \u2022 Device state methods (get_color, set_color)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Network Layer (lifx.network)               \u2502\n\u2502   \u2022 DeviceConnection (UDP transport)                \u2502\n\u2502   \u2022 Message building and parsing                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Protocol Layer (lifx.protocol)              \u2502\n\u2502   \u2022 Binary serialization/deserialization            \u2502\n\u2502   \u2022 Packet definitions (auto-generated)             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/effects-architecture/#key-principles","title":"Key Principles","text":"<ol> <li>Zero Dependencies: Uses only Python stdlib and existing lifx-async components</li> <li>State Preservation: Automatically captures and restores device state</li> <li>Type Safety: Full type hints with strict Pyright validation</li> <li>Async/Await: Native asyncio for concurrent operations</li> <li>Extensibility: Abstract base class for custom effects</li> </ol>"},{"location":"architecture/effects-architecture/#component-architecture","title":"Component Architecture","text":""},{"location":"architecture/effects-architecture/#module-structure","title":"Module Structure","text":"<pre><code>src/lifx/effects/\n\u251c\u2500\u2500 __init__.py              # Public API exports\n\u251c\u2500\u2500 base.py                  # LIFXEffect abstract base class\n\u251c\u2500\u2500 conductor.py             # Conductor orchestrator\n\u251c\u2500\u2500 pulse.py                 # EffectPulse implementation\n\u251c\u2500\u2500 colorloop.py             # EffectColorloop implementation\n\u251c\u2500\u2500 models.py                # PreState, RunningEffect dataclasses\n\u2514\u2500\u2500 utils.py                 # Shared utilities (future)\n</code></pre>"},{"location":"architecture/effects-architecture/#component-responsibilities","title":"Component Responsibilities","text":""},{"location":"architecture/effects-architecture/#conductor-conductorpy","title":"Conductor (<code>conductor.py</code>)","text":"<p>Purpose: Central orchestrator managing effect lifecycle across multiple devices.</p> <p>Responsibilities:</p> <ul> <li>Track running effects per device (serial \u2192 RunningEffect mapping)</li> <li>Capture device state before effects</li> <li>Power on devices if needed</li> <li>Execute effects via <code>effect.async_perform()</code></li> <li>Restore device state after effects complete</li> <li>Handle concurrent effects on different devices</li> <li>Provide thread-safe state management with <code>asyncio.Lock()</code></li> </ul> <p>Key Data Structures:</p> <pre><code>class Conductor:\n    _running: dict[str, RunningEffect]  # serial \u2192 RunningEffect\n    _lock: asyncio.Lock                 # Thread-safe access\n</code></pre>"},{"location":"architecture/effects-architecture/#lifxeffect-base-class-basepy","title":"LIFXEffect Base Class (<code>base.py</code>)","text":"<p>Purpose: Abstract base for all effect implementations.</p> <p>Responsibilities:</p> <ul> <li>Define effect interface (abstract <code>async_play()</code> method)</li> <li>Handle power-on logic in <code>async_perform()</code></li> <li>Provide startup color via <code>from_poweroff_hsbk()</code></li> <li>Enable state inheritance optimization via <code>inherit_prestate()</code></li> <li>Store conductor reference and participants</li> </ul> <p>Key Methods:</p> <pre><code>class LIFXEffect(ABC):\n    async def async_perform(participants):  # Setup + call async_play()\n        ...\n\n    @abstractmethod\n    async def async_play():                 # Effect logic (override)\n        ...\n\n    async def from_poweroff_hsbk(light):    # Startup color (override)\n        ...\n\n    def inherit_prestate(other):            # State inheritance (override)\n        ...\n</code></pre>"},{"location":"architecture/effects-architecture/#effect-implementations","title":"Effect Implementations","text":"<p>EffectPulse (<code>pulse.py</code>):</p> <ul> <li>Implements pulse/blink/breathe effects</li> <li>Five modes with different timing and waveforms</li> <li>Intelligent color selection based on mode</li> <li>Auto-completion after configured cycles</li> </ul> <p>EffectColorloop (<code>colorloop.py</code>):</p> <ul> <li>Implements continuous hue rotation</li> <li>Randomized direction, device order, saturation</li> <li>Runs indefinitely until stopped</li> <li>Supports state inheritance for seamless transitions</li> </ul>"},{"location":"architecture/effects-architecture/#data-models-modelspy","title":"Data Models (<code>models.py</code>)","text":"<p>PreState:</p> <p>Stores device state before effect:</p> <pre><code>@dataclass\nclass PreState:\n    power: bool                     # Power state (on/off)\n    color: HSBK                     # Current color\n    zone_colors: list[HSBK] | None  # Multizone colors (if applicable)\n</code></pre> <p>RunningEffect:</p> <p>Associates effect with its pre-state:</p> <pre><code>@dataclass\nclass RunningEffect:\n    effect: LIFXEffect    # Effect instance\n    prestate: PreState    # Captured state\n</code></pre>"},{"location":"architecture/effects-architecture/#effect-lifecycle","title":"Effect Lifecycle","text":"<p>The effect lifecycle consists of five distinct phases:</p>"},{"location":"architecture/effects-architecture/#1-initialization","title":"1. Initialization","text":"<p>User creates effect instance with desired parameters:</p> <pre><code>effect = EffectPulse(mode='blink', cycles=5)\n</code></pre> <p>What happens:</p> <ul> <li>Effect object created with parameters stored</li> <li>No network activity yet</li> <li>No conductor association yet</li> </ul>"},{"location":"architecture/effects-architecture/#2-state-capture","title":"2. State Capture","text":"<p>Conductor starts effect and captures current device state:</p> <pre><code>await conductor.start(effect, [light1, light2])\n</code></pre> <p>What happens:</p> <pre><code>For each light:\n  1. Check if prestate can be inherited from running effect\n  2. If not, capture new prestate:\n     a. Get power state (get_power)\n     b. Get current color (get_color)\n     c. Get zone colors if multizone (get_color_zones or get_extended_color_zones)\n  3. Store in RunningEffect and register in conductor._running\n</code></pre> <p>Timing: &lt;1 second per device (mostly network I/O)</p> <p>Special Cases:</p> <ul> <li>Prestate Inheritance: If <code>effect.inherit_prestate(current_effect)</code> returns <code>True</code>, reuses existing PreState</li> <li>Multizone Devices: Uses extended messages if supported, falls back to standard messages</li> <li>Powered-off Devices: All state is still captured (including zone colors that may be inaccurate)</li> </ul>"},{"location":"architecture/effects-architecture/#3-power-on-optional","title":"3. Power-On (Optional)","text":"<p>If <code>effect.power_on == True</code>, devices are powered on:</p> <pre><code>async def async_perform(self, participants):\n    if self.power_on:\n        for light in self.participants:\n            power_level = await light.get_power()\n            if power_level == 0:\n                startup_color = await self.from_poweroff_hsbk(light)\n                await light.set_color(startup_color, duration=0)\n                await light.set_power(True, duration=0.3)\n</code></pre> <p>What happens:</p> <pre><code>For each powered-off light:\n  1. Get startup color from from_poweroff_hsbk()\n  2. Set color immediately (duration=0)\n  3. Power on with 0.3s fade (duration=0.3)\n</code></pre> <p>Timing: 0.3 seconds per powered-off device</p>"},{"location":"architecture/effects-architecture/#4-effect-execution","title":"4. Effect Execution","text":"<p>Effect logic runs via <code>async_play()</code>:</p> <pre><code>await effect.async_play()\n</code></pre> <p>What happens:</p> <ul> <li>Subclass-specific effect logic executes</li> <li>Can access <code>self.participants</code> and <code>self.conductor</code></li> <li>Can issue commands to devices</li> <li>Pulse effects: Send waveform, wait for completion</li> <li>ColorLoop effects: Continuous loop until stopped</li> </ul> <p>Timing:</p> <ul> <li>EffectPulse: <code>period * cycles</code> seconds</li> <li>EffectColorloop: Runs indefinitely</li> </ul>"},{"location":"architecture/effects-architecture/#5-state-restoration","title":"5. State Restoration","text":"<p>Conductor restores devices to pre-effect state:</p> <pre><code>await conductor.stop([light1, light2])\n</code></pre> <p>What happens:</p> <pre><code>For each light:\n  1. Restore multizone colors (if applicable):\n     - Use extended messages if supported\n     - Use standard messages with apply=NO_APPLY, then apply=APPLY\n     - Wait 0.3s for device processing\n  2. Restore color:\n     - set_color(prestate.color, duration=0)\n     - Wait 0.3s\n  3. Restore power:\n     - set_power(prestate.power, duration=0)\n</code></pre> <p>Timing: 0.6-1.0 seconds per device (includes delays)</p> <p>Special Cases:</p> <ul> <li>Multizone devices get zones restored first</li> <li>0.3s delays ensure device processing completes</li> <li>Errors are logged but don't stop other devices</li> </ul>"},{"location":"architecture/effects-architecture/#state-management","title":"State Management","text":""},{"location":"architecture/effects-architecture/#state-storage","title":"State Storage","text":"<p>The conductor maintains a registry of running effects:</p> <pre><code>_running: dict[str, RunningEffect]\n</code></pre> <p>Key: Device serial number (12-digit hex string) Value: <code>RunningEffect</code> containing effect instance and captured <code>PreState</code></p>"},{"location":"architecture/effects-architecture/#state-capture-details","title":"State Capture Details","text":""},{"location":"architecture/effects-architecture/#power-state","title":"Power State","text":"<p>Integer power level captured via <code>get_power()</code>:</p> <pre><code>power_level = await light.get_power()  # Returns int (0 or 65535)\nis_on = power_level &gt; 0\n</code></pre>"},{"location":"architecture/effects-architecture/#color-state","title":"Color State","text":"<p>HSBK color captured via <code>get_color()</code>:</p> <pre><code>color, power, _ = await light.get_color()  # power is int (0 or 65535)\n</code></pre> <p>Returns:</p> <ul> <li><code>color</code>: HSBK (hue, saturation, brightness, kelvin)</li> <li><code>power</code>: Power level as integer (0 for off, 65535 for on)</li> <li><code>label</code>: Device label</li> </ul>"},{"location":"architecture/effects-architecture/#multizone-state","title":"Multizone State","text":"<p>For <code>MultiZoneLight</code> devices, zone colors are captured:</p> <pre><code>if isinstance(light, MultiZoneLight):\n    # Get all zones using the convenience method\n    # Automatically uses the best method based on capabilities\n    zone_colors = await light.get_all_color_zones()\n</code></pre> <p>Extended Multizone:</p> <ul> <li>Single message retrieves all zones</li> <li>Returns <code>list[HSBK]</code> with all zone colors</li> <li>More efficient, used when available</li> </ul> <p>Standard Multizone:</p> <ul> <li>Retrieves zones in batches of 8</li> <li>Multiple messages required for &gt;8 zones</li> <li>Used as fallback for older devices</li> </ul>"},{"location":"architecture/effects-architecture/#state-restoration-details","title":"State Restoration Details","text":""},{"location":"architecture/effects-architecture/#multizone-restoration","title":"Multizone Restoration","text":"<p>Zones are restored before color and power:</p> <p>Extended Multizone:</p> <pre><code>await light.set_extended_color_zones(\n    zone_index=0,\n    colors=zone_colors,\n    duration=0.0,\n    apply=MultiZoneExtendedApplicationRequest.APPLY\n)\n</code></pre> <p>Single message restores all zones.</p> <p>Standard Multizone:</p> <pre><code>for i, color in enumerate(zone_colors):\n    is_last = (i == len(zone_colors) - 1)\n    apply = APPLY if is_last else NO_APPLY\n\n    await light.set_color_zones(\n        start=i, end=i,\n        color=color,\n        duration=0.0,\n        apply=apply\n    )\n</code></pre> <p>Multiple messages with <code>apply</code> logic:</p> <ul> <li><code>NO_APPLY</code> (0): Update buffer, don't display</li> <li><code>APPLY</code> (1): Update buffer and display (used on last zone)</li> </ul> <p>This ensures atomic update visible only when all zones are set.</p>"},{"location":"architecture/effects-architecture/#timing-delays","title":"Timing Delays","text":"<p>Critical 0.3-second delays ensure device processing:</p> <pre><code># After multizone restoration\nawait asyncio.sleep(0.3)\n\n# After color restoration\nawait asyncio.sleep(0.3)\n\n# No delay after power (last operation)\n</code></pre> <p>Without these delays, subsequent operations may arrive before device finishes processing, causing state corruption.</p>"},{"location":"architecture/effects-architecture/#prestate-inheritance","title":"Prestate Inheritance","text":"<p>Optimization that skips state capture/restore for compatible consecutive effects:</p> <pre><code>def inherit_prestate(self, other: LIFXEffect) -&gt; bool:\n    \"\"\"Return True if can skip restoration.\"\"\"\n    return isinstance(other, EffectColorloop)  # Example\n</code></pre> <p>When used:</p> <pre><code>current_running = self._running.get(serial)\nif current_running and effect.inherit_prestate(current_running.effect):\n    # Reuse existing prestate\n    prestate = current_running.prestate\nelse:\n    # Capture new prestate\n    prestate = await self._capture_prestate(light)\n</code></pre> <p>Benefits:</p> <ul> <li>Eliminates flash/reset between compatible effects</li> <li>Reduces network traffic</li> <li>Faster effect transitions</li> </ul> <p>Used by:</p> <ul> <li><code>EffectColorloop.inherit_prestate()</code> \u2192 Returns <code>True</code> for other <code>EffectColorloop</code> instances</li> <li><code>EffectPulse</code> doesn't use it (returns <code>False</code>)</li> </ul>"},{"location":"architecture/effects-architecture/#concurrency-model","title":"Concurrency Model","text":""},{"location":"architecture/effects-architecture/#thread-safety","title":"Thread Safety","text":"<p>The conductor uses an <code>asyncio.Lock()</code> for thread-safe state management:</p> <pre><code>async def start(self, effect, participants):\n    async with self._lock:\n        # Critical section: state capture and registration\n        for light in participants:\n            prestate = await self._capture_prestate(light)\n            self._running[light.serial] = RunningEffect(effect, prestate)\n\n    # Effect execution happens outside lock (concurrent)\n    await effect.async_perform(participants)\n</code></pre> <p>Why lock is needed:</p> <ul> <li>Prevents race conditions when starting/stopping effects concurrently</li> <li>Protects <code>_running</code> dictionary modifications</li> <li>Ensures atomic state capture and registration</li> </ul> <p>Why effect execution is outside lock:</p> <ul> <li>Allows multiple effects to run concurrently on different devices</li> <li>Effect logic doesn't modify conductor state</li> <li>Prevents blocking other operations during long-running effects</li> </ul>"},{"location":"architecture/effects-architecture/#concurrent-device-operations","title":"Concurrent Device Operations","text":"<p>Effects use <code>asyncio.gather()</code> for concurrent device operations:</p> <pre><code># Apply waveform to all devices concurrently\ntasks = [\n    light.set_waveform(color, period, cycles, waveform)\n    for light in self.participants\n]\nawait asyncio.gather(*tasks)\n</code></pre> <p>Benefits:</p> <ul> <li>Multiple devices updated in parallel</li> <li>Network latency overlaps</li> <li>Total time \u2248 single device time (not N \u00d7 device time)</li> </ul>"},{"location":"architecture/effects-architecture/#background-response-dispatcher","title":"Background Response Dispatcher","text":"<p>Each <code>DeviceConnection</code> has a background receiver task that routes responses:</p> <pre><code># In DeviceConnection\nasync def _response_receiver(self):\n    while self._running:\n        packet = await self._receive_packet()\n        # Route by sequence number to waiting coroutine\n        self._pending[seq_num].set_result(packet)\n</code></pre> <p>Implications for effects:</p> <ul> <li>Multiple concurrent requests on same device are supported</li> <li>Responses are correctly matched even with concurrent operations</li> <li>No additional coordination needed in effect code</li> </ul>"},{"location":"architecture/effects-architecture/#effect-concurrency-patterns","title":"Effect Concurrency Patterns","text":""},{"location":"architecture/effects-architecture/#pattern-1-sequential-effects-on-same-devices","title":"Pattern 1: Sequential Effects on Same Devices","text":"<pre><code># Effect 1 completes before Effect 2 starts\nawait conductor.start(effect1, lights)\nawait asyncio.sleep(duration1)\nawait conductor.start(effect2, lights)  # Captures new state\n</code></pre> <p>State is automatically restored between effects.</p>"},{"location":"architecture/effects-architecture/#pattern-2-concurrent-effects-on-different-devices","title":"Pattern 2: Concurrent Effects on Different Devices","text":"<pre><code># Different devices, completely independent\nawait conductor.start(effect1, group1)\nawait conductor.start(effect2, group2)\n# Both run concurrently\n</code></pre> <p>No locking needed - different devices, different state.</p>"},{"location":"architecture/effects-architecture/#pattern-3-replacing-running-effect","title":"Pattern 3: Replacing Running Effect","text":"<pre><code># Start effect1\nawait conductor.start(effect1, lights)\nawait asyncio.sleep(5)\n\n# Replace with effect2\nawait conductor.start(effect2, lights)  # Prestate may be inherited\n</code></pre> <p>If <code>effect2.inherit_prestate(effect1)</code> returns <code>True</code>, no restoration happens.</p>"},{"location":"architecture/effects-architecture/#device-type-handling","title":"Device Type Handling","text":""},{"location":"architecture/effects-architecture/#device-capabilities-detection","title":"Device Capabilities Detection","text":"<p>The effects framework adapts to device capabilities automatically:</p> <pre><code># Check if multizone\nif isinstance(light, MultiZoneLight):\n    # Capture zone colors\n    zone_colors = await light.get_color_zones(...)\n\n# Check if extended multizone supported\nif light.capabilities and light.capabilities.has_extended_multizone:\n    # Use efficient extended messages\n    await light.set_extended_color_zones(...)\n</code></pre>"},{"location":"architecture/effects-architecture/#device-specific-behavior","title":"Device-Specific Behavior","text":""},{"location":"architecture/effects-architecture/#color-lights-light","title":"Color Lights (<code>Light</code>)","text":"<ul> <li>Full HSBK color support</li> <li>All effect parameters apply</li> <li>No special handling needed</li> </ul>"},{"location":"architecture/effects-architecture/#multizone-lights-multizonelight","title":"Multizone Lights (<code>MultiZoneLight</code>)","text":"<ul> <li>State Capture: Zone colors captured using extended or standard messages</li> <li>State Restoration: All zones restored with proper <code>apply</code> logic</li> <li>Effect Behavior: Entire device pulses/cycles together (zones not individually controlled)</li> <li>Timing: 0.3s delay after zone restoration</li> </ul>"},{"location":"architecture/effects-architecture/#matrix-lights-matrixlight","title":"Matrix Lights (<code>MatrixLight</code>)","text":"<ul> <li>Current Implementation: Treated like color lights (no matrix-specific logic yet)</li> <li>Future Enhancement: Could apply effects to individual tiles using device chain</li> </ul>"},{"location":"architecture/effects-architecture/#hev-lights-hevlight","title":"HEV Lights (<code>HevLight</code>)","text":"<ul> <li>Treated like standard color lights</li> <li>HEV cycle not affected by effects</li> <li>Effects don't interfere with HEV functionality</li> </ul>"},{"location":"architecture/effects-architecture/#infrared-lights-infraredlight","title":"Infrared Lights (<code>InfraredLight</code>)","text":"<ul> <li>Treated like standard color lights</li> <li>Infrared LED not affected by color effects</li> <li>Effects only control visible light</li> </ul>"},{"location":"architecture/effects-architecture/#monochromewhite-lights","title":"Monochrome/White Lights","text":"<ul> <li>Color parameters ignored: Hue and saturation have no effect</li> <li>Brightness works: Effects can still toggle/fade brightness</li> <li>Kelvin preserved: Temperature setting maintained</li> <li>Recommendation: Limited usefulness (only brightness changes visible)</li> </ul>"},{"location":"architecture/effects-architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"architecture/effects-architecture/#why-conductor-pattern","title":"Why Conductor Pattern?","text":"<p>Decision: Central conductor manages all effect lifecycle instead of effects managing themselves.</p> <p>Rationale:</p> <ol> <li>Centralized State: Single source of truth for what's running where</li> <li>Consistent State Management: All effects get same capture/restore logic</li> <li>Concurrency Control: Single lock protects all state modifications</li> <li>User Simplicity: Users don't manage state manually</li> </ol> <p>Alternative Considered: Effects self-manage state</p> <p>Rejected because: Would require each effect to duplicate state logic, higher chance of bugs</p>"},{"location":"architecture/effects-architecture/#why-abstract-base-class","title":"Why Abstract Base Class?","text":"<p>Decision: <code>LIFXEffect</code> is abstract with required <code>async_play()</code> override.</p> <p>Rationale:</p> <ol> <li>Type Safety: Enforces effect interface at type-check time</li> <li>Code Reuse: Common setup logic in <code>async_perform()</code></li> <li>Extensibility: Users can create custom effects easily</li> <li>Consistency: All effects follow same pattern</li> </ol>"},{"location":"architecture/effects-architecture/#why-two-phase-effect-execution","title":"Why Two-Phase Effect Execution?","text":"<p>Decision: <code>async_perform()</code> calls <code>async_play()</code> instead of single method.</p> <p>Rationale:</p> <ol> <li>Separation of Concerns: Setup logic separate from effect logic</li> <li>User Simplicity: Users only override <code>async_play()</code>, setup is automatic</li> <li>Consistency: All effects get same power-on behavior</li> <li>Flexibility: Base class can add more setup steps without breaking subclasses</li> </ol>"},{"location":"architecture/effects-architecture/#why-no-rate-limiting","title":"Why No Rate Limiting?","text":"<p>Decision: Effects don't implement rate limiting.</p> <p>Rationale:</p> <ol> <li>Simplicity: Keeps core library simple and focused</li> <li>Flexibility: Applications have different rate limit needs</li> <li>Transparency: Users see actual device behavior</li> <li>Consistency: Matches lifx-async philosophy (no hidden rate limiting)</li> </ol> <p>Recommendation: Applications should implement rate limiting if sending many concurrent requests.</p>"},{"location":"architecture/effects-architecture/#why-03-second-delays","title":"Why 0.3-Second Delays?","text":"<p>Decision: Fixed 0.3-second delays between state restoration operations.</p> <p>Rationale:</p> <ol> <li>Device Processing Time: LIFX devices need time to process commands</li> <li>Empirical Testing: 0.3s works reliably across all device types</li> <li>State Integrity: Prevents race conditions and state corruption</li> <li>Trade-off: Slightly slower restoration but guaranteed correctness</li> </ol> <p>Alternative Considered: No delays, faster restoration</p> <p>Rejected because: Causes state corruption and unpredictable behavior</p>"},{"location":"architecture/effects-architecture/#why-prestate-inheritance","title":"Why Prestate Inheritance?","text":"<p>Decision: Optional optimization via <code>inherit_prestate()</code> method.</p> <p>Rationale:</p> <ol> <li>Performance: Eliminates unnecessary state reset</li> <li>User Experience: No visible flash between compatible effects</li> <li>Opt-in: Only used when effect explicitly enables it</li> <li>Safe Default: Returns <code>False</code> unless overridden</li> </ol> <p>Use Cases:</p> <ul> <li>ColorLoop \u2192 ColorLoop: Seamless transition</li> <li>Pulse \u2192 Pulse: Could enable but currently disabled</li> <li>Different types: Should not inherit (different visual intent)</li> </ul>"},{"location":"architecture/effects-architecture/#why-no-tile-specific-logic-yet","title":"Why No Tile-Specific Logic (Yet)?","text":"<p>Decision: Tiles treated like single-color lights for now.</p> <p>Rationale:</p> <ol> <li>MVP Scope: Phase 1 focuses on core framework</li> <li>Complexity: Tile effects require 2D coordinate system</li> <li>Future Enhancement: Architecture supports adding tile-specific effects later</li> <li>Current Usefulness: Effects still work on tiles (just not tile-aware)</li> </ol> <p>Future Work: Tile-specific effects would use <code>MatrixLight.set_matrix_colors()</code> and apply per-tile logic similar to theme support.</p>"},{"location":"architecture/effects-architecture/#integration-points","title":"Integration Points","text":""},{"location":"architecture/effects-architecture/#with-device-layer","title":"With Device Layer","text":"<p>Effects use standard device methods:</p> <ul> <li><code>get_power()</code>, <code>set_power()</code></li> <li><code>get_color()</code>, <code>set_color()</code></li> <li><code>set_waveform()</code> (EffectPulse)</li> <li><code>get_color_zones()</code>, <code>set_color_zones()</code> (MultiZoneLight)</li> <li><code>get_extended_color_zones()</code>, <code>set_extended_color_zones()</code> (MultiZoneLight)</li> </ul> <p>No special device modifications needed.</p>"},{"location":"architecture/effects-architecture/#with-network-layer","title":"With Network Layer","text":"<p>Effects rely on existing lazy connection and concurrent request support:</p> <ul> <li>Lazy connections open on first request and are reused</li> <li>Requests are serialized via lock to prevent response mixing</li> <li>No effect-specific network code needed</li> </ul>"},{"location":"architecture/effects-architecture/#with-protocol-layer","title":"With Protocol Layer","text":"<p>Effects use existing protocol structures:</p> <ul> <li><code>HSBK</code> for color representation</li> <li><code>LightWaveform</code> enum for waveform types</li> <li><code>MultiZoneApplicationRequest</code> for zone apply logic</li> <li>Auto-generated packet classes</li> </ul>"},{"location":"architecture/effects-architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/effects-architecture/#memory-usage","title":"Memory Usage","text":"<ul> <li>Conductor: ~10KB base + running effects</li> <li>Per Effect: ~1KB per device + effect-specific state</li> <li>PreState: ~200 bytes per device (~100 bytes + zone colors)</li> </ul>"},{"location":"architecture/effects-architecture/#cpu-usage","title":"CPU Usage","text":"<ul> <li>Minimal: Async I/O bound, not CPU bound</li> <li>Concurrency: Multiple devices don't increase CPU significantly</li> <li>Background Tasks: Requests serialized per connection, concurrent across devices</li> </ul>"},{"location":"architecture/effects-architecture/#network-traffic","title":"Network Traffic","text":""},{"location":"architecture/effects-architecture/#state-capture","title":"State Capture","text":"<ul> <li>Power: 1 request per device</li> <li>Color: 1 request per device</li> <li>Multizone: 1 request (extended) or N/8 requests (standard)</li> <li>Total: 3-4 packets per device</li> </ul>"},{"location":"architecture/effects-architecture/#effect-execution","title":"Effect Execution","text":"<ul> <li>Pulse: 1 waveform packet per device</li> <li>ColorLoop: 1 color packet per device per iteration</li> </ul>"},{"location":"architecture/effects-architecture/#state-restoration","title":"State Restoration","text":"<ul> <li>Multizone: 1 request (extended) or N requests (standard)</li> <li>Color: 1 request per device</li> <li>Power: 1 request per device</li> <li>Total: 2-3 packets per device (or N+2 for standard multizone)</li> </ul>"},{"location":"architecture/effects-architecture/#scalability","title":"Scalability","text":"<ul> <li>Tested: 10+ devices</li> <li>Expected: 50+ devices in production</li> <li>Limitation: Network capacity and device response time</li> <li>Recommendation: For 50+ devices, consider grouping effects or staggering start times</li> </ul>"},{"location":"architecture/effects-architecture/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic usage</li> <li>Effects Reference - Detailed API documentation</li> <li>Custom Effects - Creating your own effects</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>lifx-async is built as a layered architecture with clear separation of concerns.</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"Layer 4: High-Level API\"\n        API[api.py&lt;br/&gt;discover, find_lights, etc.]\n        DeviceGroup[DeviceGroup&lt;br/&gt;Batch operations]\n    end\n\n    subgraph \"Layer 3: Device Layer\"\n        Device[Device&lt;br/&gt;Base class]\n        Light[Light&lt;br/&gt;Color control]\n        Hev[HevLight&lt;br /&gt;HEV support]\n        Infrared[InfraredLight&lt;br /&gt;Infrared support]\n        MultiZone[MultiZoneLight&lt;br/&gt;Linear/1D zones]\n        Matrix[MatrixLight&lt;br/&gt;Matrix/2D zones]\n    end\n\n    subgraph \"Layer 2: Network Layer\"\n        Discovery[Discovery&lt;br/&gt;UDP broadcast]\n        Connection[Connection&lt;br/&gt;Lazy opening]\n        Transport[Transport&lt;br/&gt;UDP sockets]\n    end\n\n    subgraph \"Layer 1: Protocol Layer\"\n        Generator[Generator&lt;br/&gt;YAML \u2192 Python]\n        Types[Protocol Types&lt;br/&gt;Enums, HSBK, etc.]\n        Packets[Packets&lt;br/&gt;Message classes]\n    end\n\n    subgraph \"External\"\n        YAML[protocol.yml&lt;br/&gt;LIFX specification]\n        Network[UDP Network&lt;br/&gt;Port 56700]\n    end\n\n    API --&gt; DeviceGroup\n    DeviceGroup --&gt; Light\n    DeviceGroup --&gt; Hev\n    DeviceGroup --&gt; Infrared\n    DeviceGroup --&gt; MultiZone\n    DeviceGroup --&gt; Matrix\n    API --&gt; Discovery\n    Device --&gt; Connection\n    Light --&gt; Device\n    Hev --&gt; Light\n    Infrared --&gt; Light\n    MultiZone --&gt; Light\n    Matrix --&gt; Light\n    Connection --&gt; Transport\n    Connection --&gt; Packets\n    Discovery --&gt; Transport\n    Packets --&gt; Types\n    Transport --&gt; Network\n    Generator --&gt; YAML\n    Generator -.generates.-&gt; Types\n    Generator -.generates.-&gt; Packets\n\n    style API fill:#e1f5e1\n    style Device fill:#e1f0ff\n    style Connection fill:#fff4e1\n    style Generator fill:#ffe1f0</code></pre>"},{"location":"architecture/overview/#layer-responsibilities","title":"Layer Responsibilities","text":""},{"location":"architecture/overview/#layer-1-protocol-layer","title":"Layer 1: Protocol Layer","text":"<p>Purpose: Handle LIFX binary protocol</p> <ul> <li>Auto-Generated: All code generated from <code>protocol.yml</code></li> <li>Type-Safe: Full type hints for all structures</li> <li>Binary Serialization: Pack/unpack protocol messages</li> <li>No Business Logic: Pure data structures</li> </ul> <p>Key Files:</p> <ul> <li><code>protocol_types.py</code> - Enums, HSBK, field structures</li> <li><code>packets.py</code> - Packet class definitions</li> <li><code>generator.py</code> - Code generation from YAML</li> </ul> <p>Example:</p> <pre><code>from lifx.protocol.packets import Light\nfrom lifx import HSBK\n\n# Create a packet\npacket = Light.SetColor(\n    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0\n)\n\n# Serialize to bytes\ndata = packet.pack()\n</code></pre>"},{"location":"architecture/overview/#layer-2-network-layer","title":"Layer 2: Network Layer","text":"<p>Purpose: Handle network communication</p> <ul> <li>UDP Transport: Async socket operations</li> <li>Discovery: Broadcast-based device discovery</li> <li>Lazy Connections: Auto-open on first request</li> <li>Retry Logic: Automatic retry with exponential backoff</li> </ul> <p>Key Files:</p> <ul> <li><code>transport.py</code> - UDP socket wrapper</li> <li><code>discovery.py</code> - Device discovery</li> <li><code>connection.py</code> - Connection management</li> <li><code>message.py</code> - Message building</li> </ul> <p>Example:</p> <pre><code>from lifx.network.connection import DeviceConnection\n\nconn = DeviceConnection(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n# Connection opens lazily on first request\nresponse = await conn.request(packet)\n</code></pre>"},{"location":"architecture/overview/#layer-3-device-layer","title":"Layer 3: Device Layer","text":"<p>Purpose: Device abstractions with high-level operations</p> <ul> <li>Device Types: Base, Light, HevLight, InfraredLight, MultiZoneLight, MatrixLight</li> <li>State Caching: Cached state properties for efficient access</li> <li>Type Detection: Automatic capability detection</li> <li>Async Context Managers: Automatic resource cleanup</li> </ul> <p>Key Files:</p> <ul> <li><code>base.py</code> - Base Device class</li> <li><code>light.py</code> - Light class</li> <li><code>hev.py</code> - HevLight class</li> <li><code>infrared.py</code> - InfraredLight class</li> <li><code>multizone.py</code> - MultiZoneLight class</li> <li><code>matrix.py</code> - MatrixLight class</li> </ul> <p>Example:</p> <pre><code>from lifx import Light\n\nasync with Light(serial, ip) as light:\n    # High-level operations\n    await light.set_color(Colors.BLUE)\n    await light.pulse(Colors.RED, period=1.0, cycles=5)\n</code></pre>"},{"location":"architecture/overview/#layer-4-high-level-api","title":"Layer 4: High-Level API","text":"<p>Purpose: Simple, batteries-included API</p> <ul> <li>Simplified Discovery: One-line device discovery</li> <li>Batch Operations: Control multiple devices</li> <li>Direct Connection: Connect by IP without discovery</li> <li>Filtered Discovery: Find devices by label or serial</li> </ul> <p>Key Files:</p> <ul> <li><code>api.py</code> - High-level functions</li> <li><code>color.py</code> - Color utilities</li> </ul> <p>Example:</p> <pre><code>from lifx import discover, DeviceGroup, Colors\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait group.set_color(Colors.BLUE)\n</code></pre>"},{"location":"architecture/overview/#data-flow","title":"Data Flow","text":""},{"location":"architecture/overview/#sending-a-command","title":"Sending a Command","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Light\n    participant Connection\n    participant Transport\n    participant Device\n\n    User-&gt;&gt;Light: set_color(Colors.BLUE)\n    Light-&gt;&gt;Light: Convert to HSBK\n    Light-&gt;&gt;Connection: send_packet(SetColor)\n    Connection-&gt;&gt;Connection: Serialize packet\n    Connection-&gt;&gt;Transport: send_message(bytes)\n    Transport-&gt;&gt;Device: UDP packet\n    Device--&gt;&gt;Transport: UDP acknowledgment\n    Transport--&gt;&gt;Connection: Response\n    Connection--&gt;&gt;Connection: Deserialize packet\n    Connection--&gt;&gt;Light: Reply\n    Light--&gt;&gt;User: Success</code></pre>"},{"location":"architecture/overview/#discovery-process","title":"Discovery Process","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Discovery\n    participant Transport\n    participant Network\n    participant Devices\n\n    User-&gt;&gt;Discovery: discover_devices(timeout=3.0)\n    Discovery-&gt;&gt;Transport: Open UDP socket\n    Discovery-&gt;&gt;Transport: Send broadcast (GetService)\n    Transport-&gt;&gt;Network: Broadcast on 255.255.255.255\n    Network-&gt;&gt;Devices: Broadcast packet\n    Devices--&gt;&gt;Network: StateService responses\n    Network--&gt;&gt;Transport: Multiple responses\n    Transport--&gt;&gt;Discovery: Parse responses\n    Discovery-&gt;&gt;Discovery: Collect device info\n    Discovery--&gt;&gt;User: List[DiscoveredDevice]</code></pre>"},{"location":"architecture/overview/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"architecture/overview/#async-first","title":"Async-First","text":"<p>Why: LIFX operations involve network I/O which benefits from async</p> <pre><code># Multiple devices controlled concurrently\nawait asyncio.gather(\n    light1.set_color(Colors.RED),\n    light2.set_color(Colors.BLUE),\n    light3.set_color(Colors.GREEN),\n)\n</code></pre>"},{"location":"architecture/overview/#lazy-connections","title":"Lazy Connections","text":"<p>Why: Simple lifecycle management with automatic cleanup</p> <pre><code># Connection opens lazily on first request\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.RED)  # Opens connection here\n    await light.set_brightness(0.5)  # Reuses same connection\n    await light.get_label()  # Reuses same connection\n# Connection automatically closed on exit\n</code></pre>"},{"location":"architecture/overview/#state-caching","title":"State Caching","text":"<p>Why: Reduces network traffic and provides fast access to semi-static device state</p> <pre><code># Semi-static properties return cached values:\nlabel = light.label\nif label:\n    # Use cached label\n    print(f\"Label: {label}\")\nelse:\n    # No cached data yet, fetch from device\n    label = await light.get_label()\n    print(f\"Fetched label: {label}\")\n\n# Volatile state (power, color) always requires fresh fetch\n# get_color() will cache the label value only\ncolor, power, label = await light.get_color()\nprint(f\"Current state of {light.label} - Power: {power}, Color: {color}\")\n</code></pre>"},{"location":"architecture/overview/#code-generation","title":"Code Generation","text":"<p>Why: Protocol updates are automatic, reduces errors</p> <pre><code># Regenerate code\nuv run python -m lifx.protocol.generator\n</code></pre>"},{"location":"architecture/overview/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/overview/#connection-lifecycle","title":"Connection Lifecycle","text":"<ul> <li>Lazy Opening: Opens on first request, not on creation</li> <li>Explicit Cleanup: Closes via <code>close()</code> or context manager exit</li> <li>Low Overhead: One UDP socket per device</li> </ul>"},{"location":"architecture/overview/#state-caching-as-properties","title":"State Caching as Properties","text":"<ul> <li>Format: Cached values or <code>None</code> if not yet fetched</li> <li>Properties: All device state available as properties</li> <li>Getting Fresh Data: Use <code>get_*()</code> methods to always fetch from device</li> </ul>"},{"location":"architecture/overview/#concurrency-model","title":"Concurrency Model","text":"<p>Each connection serializes requests to prevent response mixing:</p> <pre><code>conn = DeviceConnection(serial=\"d073d5123456\", ip=\"192.168.1.100\")\n# Requests are serialized on the same connection\nresult1 = await conn.request(packet1)\nresult2 = await conn.request(packet2)\nawait conn.close()\n</code></pre> <p>How it works:</p> <ul> <li>Requests are serialized via <code>_request_lock</code> on same connection</li> <li>Responses matched to requests by sequence number</li> <li>Async generator streaming for efficient multi-response protocols</li> <li>Single UDP socket per connection</li> </ul>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"getting-started/effects/","title":"Getting Started with Light Effects","text":"<p>The Light Effects Framework provides a comprehensive system for creating and managing visual effects on LIFX devices. This guide will help you get started with the built-in effects and show you common patterns for using the effects system.</p>"},{"location":"getting-started/effects/#overview","title":"Overview","text":"<p>The effects framework consists of three main components:</p> <ul> <li>Conductor: Central orchestrator that manages effect lifecycle and state</li> <li>Effects: Pre-built effect classes (EffectPulse, EffectColorloop) and base class for custom effects</li> <li>State Management: Automatic capture and restoration of device state before and after effects</li> </ul>"},{"location":"getting-started/effects/#installation","title":"Installation","text":"<p>The effects framework is included with lifx-async 1.3.0+. No additional installation is required:</p> <pre><code># Using uv (recommended)\nuv pip install lifx-async\n\n# Or using pip\npip install lifx-async\n</code></pre>"},{"location":"getting-started/effects/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/effects/#your-first-pulse-effect","title":"Your First Pulse Effect","text":"<p>The simplest way to use the effects framework is with the <code>EffectPulse</code> class:</p> <pre><code>import asyncio\nfrom lifx import discover, DeviceGroup\nfrom lifx.effects import Conductor, EffectPulse\n\nasync def main():\n    # Discover lights on your network\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    if not group.lights:\n        print(\"No lights found\")\n        return\n\n    # Create a conductor to manage effects\n    conductor = Conductor()\n\n    # Create a blink effect\n    effect = EffectPulse(mode='blink', cycles=5)\n\n    # Start the effect on all lights\n    await conductor.start(effect, group.lights)\n\n    # Wait for effect to complete (5 cycles * 1 second)\n    await asyncio.sleep(6)\n\n    print(\"Effect complete - lights restored to original state\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/effects/#your-first-colorloop-effect","title":"Your First ColorLoop Effect","text":"<p>The <code>EffectColorloop</code> creates a continuous rainbow effect:</p> <pre><code>import asyncio\nfrom lifx import discover, DeviceGroup\nfrom lifx.effects import Conductor, EffectColorloop\n\nasync def main():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    if not group.lights:\n        print(\"No lights found\")\n        return\n\n    conductor = Conductor()\n\n        # Create a rainbow effect\n        effect = EffectColorloop(\n            period=30,      # 30 seconds per full cycle\n            change=20,      # Change hue by 20 degrees each step\n            spread=60       # Spread colors across devices\n        )\n\n        # Start the effect\n        await conductor.start(effect, group.lights)\n\n        # Let it run for 2 minutes\n        await asyncio.sleep(120)\n\n        # Stop and restore lights to original state\n        await conductor.stop(group.lights)\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/effects/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/effects/#conductor","title":"Conductor","text":"<p>The <code>Conductor</code> is the central orchestrator that:</p> <ul> <li>Captures device state before effects run</li> <li>Powers on devices if needed</li> <li>Executes effects</li> <li>Restores devices to original state when done</li> </ul> <p>You typically create one conductor instance and reuse it for multiple effects.</p>"},{"location":"getting-started/effects/#effect-state-management","title":"Effect State Management","text":"<p>The effects framework automatically:</p> <ol> <li>Captures current state (power, color, zones) before effect starts</li> <li>Powers on devices if they're off (configurable)</li> <li>Executes the effect</li> <li>Restores all devices to their pre-effect state</li> </ol> <p>This happens completely automatically - you don't need to manage state yourself.</p>"},{"location":"getting-started/effects/#effect-completion","title":"Effect Completion","text":"<p>There are two ways effects complete:</p> <ol> <li>Automatic - Pulse effects complete after their cycles finish</li> <li>Manual - ColorLoop effects run continuously until <code>conductor.stop()</code> is called</li> </ol>"},{"location":"getting-started/effects/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/effects/#using-specific-lights","title":"Using Specific Lights","text":"<p>You can apply effects to specific lights instead of all discovered devices:</p> <pre><code>from lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nconductor = Conductor()\n\n# Get lights by label\nbedroom_lights = [\n    light for light in group.lights\n    if \"Bedroom\" in await light.get_label()\n]\n\n# Apply effect only to bedroom lights\neffect = EffectPulse(mode='breathe', cycles=3)\nawait conductor.start(effect, bedroom_lights)\nawait asyncio.sleep(4)\n</code></pre>"},{"location":"getting-started/effects/#sequential-effects","title":"Sequential Effects","text":"<p>You can run multiple effects one after another:</p> <pre><code>conductor = Conductor()\n\n# First effect: blink\neffect1 = EffectPulse(mode='blink', cycles=3)\nawait conductor.start(effect1, group.lights)\nawait asyncio.sleep(4)\n\n# Second effect: breathe\neffect2 = EffectPulse(mode='breathe', cycles=2)\nawait conductor.start(effect2, group.lights)\nawait asyncio.sleep(5)\n</code></pre> <p>Note: The conductor automatically restores state between effects, so each effect starts with the original device state.</p>"},{"location":"getting-started/effects/#concurrent-effects-on-different-devices","title":"Concurrent Effects on Different Devices","text":"<p>You can run different effects on different groups of lights simultaneously:</p> <pre><code>conductor = Conductor()\n\n# Split lights into two groups\ngroup1 = group.lights[:len(group.lights)//2]\ngroup2 = group.lights[len(group.lights)//2:]\n\n# Start both effects concurrently\neffect1 = EffectPulse(mode='blink')\neffect2 = EffectColorloop(period=20)\n\nawait conductor.start(effect1, group1)\nawait conductor.start(effect2, group2)\n\n# Let them run\nawait asyncio.sleep(30)\n\n# Stop all\nawait conductor.stop(group.lights)\n</code></pre>"},{"location":"getting-started/effects/#custom-colors","title":"Custom Colors","text":"<p>Both pulse and colorloop effects support custom colors:</p> <pre><code>from lifx import HSBK\n\n# Create custom color\nred = HSBK.from_rgb(255, 0, 0)\nblue = HSBK.from_rgb(0, 0, 255)\n\n# Pulse with custom color\neffect = EffectPulse(mode='breathe', cycles=5, color=red)\nawait conductor.start(effect, group.lights)\nawait asyncio.sleep(6)\n</code></pre>"},{"location":"getting-started/effects/#checking-running-effects","title":"Checking Running Effects","text":"<p>You can check what effect is currently running on a device:</p> <pre><code>conductor = Conductor()\neffect = EffectColorloop(period=30)\nawait conductor.start(effect, group.lights)\n\n# Check what's running\nfor light in group.lights:\n    current = conductor.effect(light)\n    if current:\n        print(f\"{light.label}: {type(current).__name__}\")\n    else:\n        print(f\"{light.label}: idle\")\n</code></pre>"},{"location":"getting-started/effects/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/effects/#1-use-a-single-conductor","title":"1. Use a Single Conductor","text":"<p>Create one conductor instance and reuse it throughout your application:</p> <pre><code># Good\nconductor = Conductor()\nawait conductor.start(effect1, lights)\nawait conductor.start(effect2, lights)\n\n# Not recommended - creates unnecessary overhead\nconductor1 = Conductor()\nawait conductor1.start(effect1, lights)\nconductor2 = Conductor()\nawait conductor2.start(effect2, lights)\n</code></pre>"},{"location":"getting-started/effects/#2-always-wait-for-completion","title":"2. Always Wait for Completion","text":"<p>For pulse effects, wait for the effect duration before starting another:</p> <pre><code>effect = EffectPulse(mode='blink', period=1.0, cycles=5)\nawait conductor.start(effect, lights)\n# Wait for effect to complete\nawait asyncio.sleep(5 * 1.0 + 0.5)  # cycles * period + buffer\n</code></pre>"},{"location":"getting-started/effects/#3-stop-colorloop-effects-explicitly","title":"3. Stop ColorLoop Effects Explicitly","text":"<p>ColorLoop effects run indefinitely, so always call <code>conductor.stop()</code>:</p> <pre><code>effect = EffectColorloop(period=30)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(60)\n# Must explicitly stop\nawait conductor.stop(lights)\n</code></pre>"},{"location":"getting-started/effects/#4-handle-discovery-failures","title":"4. Handle Discovery Failures","text":"<p>Always check if lights were found before attempting effects:</p> <pre><code>from lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nif not group.lights:\n    print(\"No lights found on network\")\n    return\n\n# Safe to use effects\nconductor = Conductor()\n# ...\n</code></pre>"},{"location":"getting-started/effects/#5-use-devicegroup-for-organization","title":"5. Use DeviceGroup for Organization","text":"<p>The DeviceGroup provides convenient access to device collections:</p> <pre><code>from lifx import discover, DeviceGroup\n\n# Discover devices\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nconductor = Conductor()\nawait conductor.start(effect, group.lights)\n</code></pre>"},{"location":"getting-started/effects/#complete-examples","title":"Complete Examples","text":""},{"location":"getting-started/effects/#notification-effect","title":"Notification Effect","text":"<p>Use effects to create a notification system:</p> <pre><code>async def notify(lights: list, level: str = 'info'):\n    \"\"\"Flash lights to indicate a notification.\"\"\"\n    conductor = Conductor()\n\n    if level == 'info':\n        # Blue breathe\n        color = HSBK.from_rgb(0, 0, 255)\n        effect = EffectPulse(mode='breathe', cycles=2, color=color)\n    elif level == 'warning':\n        # Orange blink\n        color = HSBK.from_rgb(255, 165, 0)\n        effect = EffectPulse(mode='blink', cycles=3, color=color)\n    elif level == 'error':\n        # Red strobe\n        color = HSBK.from_rgb(255, 0, 0)\n        effect = EffectPulse(mode='strobe', cycles=10, color=color)\n\n    await conductor.start(effect, lights)\n    await asyncio.sleep(4)  # Wait for completion\n\n# Usage\nfrom lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait notify(group.lights, level='warning')\n</code></pre>"},{"location":"getting-started/effects/#party-mode","title":"Party Mode","text":"<p>Cycle through different effects:</p> <pre><code>async def party_mode(lights: list, duration: int = 60):\n    \"\"\"Run various effects for a party.\"\"\"\n    conductor = Conductor()\n    end_time = asyncio.get_event_loop().time() + duration\n\n    effects = [\n        EffectColorloop(period=20, change=30, spread=60),\n        EffectPulse(mode='strobe', cycles=20),\n        EffectColorloop(period=15, change=45, brightness=0.8),\n    ]\n\n    effect_idx = 0\n    while asyncio.get_event_loop().time() &lt; end_time:\n        effect = effects[effect_idx % len(effects)]\n\n        if isinstance(effect, EffectColorloop):\n            await conductor.start(effect, lights)\n            await asyncio.sleep(20)\n            await conductor.stop(lights)\n        else:\n            await conductor.start(effect, lights)\n            await asyncio.sleep(3)\n\n        effect_idx += 1\n\n    # Ensure everything is stopped and restored\n    await conductor.stop(lights)\n\n# Usage\nfrom lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait party_mode(group.lights, duration=120)\n</code></pre>"},{"location":"getting-started/effects/#next-steps","title":"Next Steps","text":"<ul> <li>See Effects Reference for detailed documentation on all effect parameters</li> <li>See Custom Effects to learn how to create your own effects</li> <li>See Effects Architecture to understand how the system works internally</li> <li>See Troubleshooting for common issues and solutions</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.11 or higher</li> <li>Network: Local network access to LIFX devices</li> <li>OS: Linux, macOS, Windows</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p><code>uv</code> is a fast Python package installer and resolver written in Rust. It's significantly faster than pip and is the recommended installation method:</p> <pre><code>uv pip install lifx-async\n</code></pre> <p>If you don't have <code>uv</code> installed yet:</p> <pre><code># On macOS and Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Or with pip\npip install uv\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>If you prefer to use pip:</p> <pre><code>pip install lifx-async\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>For the latest development version:</p> <pre><code>git clone https://github.com/Djelibeybi/lifx-async.git\ncd lifx\n\n# Using uv (recommended)\nuv pip install -e .\n\n# Or using pip\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#with-development-dependencies","title":"With Development Dependencies","text":"<p>To install with development tools (recommended for contributors):</p> <pre><code>git clone https://github.com/Djelibeybi/lifx-async.git\ncd lifx\n\n# Using uv (recommended)\nuv sync\n\n# Or using pip\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that lifx-async is installed correctly:</p> <pre><code>import lifx\n\nprint(lifx.__version__)\n</code></pre> <p>Or run a quick discovery:</p> <pre><code>import asyncio\nfrom lifx import discover\n\n\nasync def main():\n    async with discover(timeout=3.0) as group:\n        print(f\"Found {len(group)} devices\")\n        for device in group:\n            label = await device.get_label()\n            print(f\"  - {label}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-error","title":"Import Error","text":"<p>If you see <code>ModuleNotFoundError: No module named 'lifx'</code>:</p> <ol> <li>Ensure lifx-async is installed: <code>uv pip list | grep lifx-async</code> or <code>pip list | grep lifx-async</code></li> <li>Check your Python version: <code>python --version</code></li> <li>Verify you're using the correct Python environment</li> </ol>"},{"location":"getting-started/installation/#network-discovery-issues","title":"Network Discovery Issues","text":"<p>If discovery doesn't find devices:</p> <ol> <li>Ensure LIFX devices are on the same network</li> <li>Check firewall settings allow UDP broadcasts</li> <li>Try increasing the timeout: <code>discover(timeout=10.0)</code></li> <li>Use direct connection if you know the IP: <code>Light.from_ip(\"192.168.1.100\")</code></li> </ol>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>On some systems, you may need elevated permissions for network operations:</p> <pre><code># Linux/macOS\nsudo python your_script.py\n\n# Or add your user to the appropriate group\nsudo usermod -a -G netdev $USER  # Linux\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Start controlling your lights</li> <li>API Reference - Complete API documentation</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get up and running with lifx-async in minutes!</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#1-discover-lights","title":"1. Discover Lights","text":"<p>The simplest way to find and control LIFX lights:</p> <pre><code>import asyncio\nfrom lifx import discover\n\n\nasync def main():\n    count = 0\n    async for device in discover():\n        count += 1\n        print(f\"Found: {device.serial}\")\n    print(f\"Total: {count} lights\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#2-control-a-light","title":"2. Control a Light","text":"<p>Turn on the first discovered light, then change its color:</p> <pre><code>import asyncio\nfrom lifx import discover, Colors\n\n\nasync def main():\n    async for light in discover():\n        await light.set_power(True)\n        await light.set_color(Colors.BLUE, duration=1.0)\n        break\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#3-batch-operations","title":"3. Batch Operations","text":"<p>Control multiple lights as a group:</p> <pre><code>import asyncio\nfrom lifx import discover, DeviceGroup, Colors\n\n\nasync def main():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n\n    # Create DeviceGroup for batch operations\n    group = DeviceGroup(devices)\n    await group.set_power(True)\n    await group.set_color(Colors.BLUE, duration=1.0)\n    await group.set_brightness(0.5)\n\n\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#direct-connection-no-discovery","title":"Direct Connection (No Discovery)","text":"<p>If you know the IP:</p> <pre><code>import asyncio\nfrom lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        await light.set_color(Colors.RED)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#find-specific-devices","title":"Find Specific Devices","text":"<p>Find devices by label, IP, or serial:</p> <pre><code>import asyncio\nfrom lifx import find_by_label, find_by_ip, find_by_serial, Colors\n\n\nasync def main():\n    # Find by label (substring match)\n    async for device in find_by_label(\"Bedroom\"):  # Matches \"Bedroom\", \"Master Bedroom\", etc.\n        await device.set_color(Colors.WARM_WHITE)\n\n    # Find by exact label\n    async for device in find_by_label(\"Master Bedroom\", exact_match=True):\n        await device.set_brightness(0.8)\n        break  # exact_match returns at most one device\n\n    # Find by IP address (fastest if you only know the IP)\n    device = await find_by_ip(\"192.168.1.100\")\n    if device:\n        await device.set_power(True)\n\n    # Find by serial number\n    device = await find_by_serial(\"d073d5123456\")\n    if device:\n        await device.set_color(Colors.BLUE)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#color-presets","title":"Color Presets","text":"<p>Use built-in color presets:</p> <pre><code>from lifx import Colors\n\n# Primary colors\nColors.RED\nColors.GREEN\nColors.BLUE\n\n# White variants\nColors.WARM_WHITE\nColors.COOL_WHITE\nColors.DAYLIGHT\n\n# Pastels\nColors.PASTEL_BLUE\nColors.PASTEL_PINK\n</code></pre>"},{"location":"getting-started/quickstart/#rgb-to-hsbk","title":"RGB to HSBK","text":"<p>Convert RGB values to HSBK:</p> <pre><code>from lifx import HSBK\n\n# Create color from RGB\npurple = HSBK.from_rgb(128, 0, 128)\nawait light.set_color(purple)\n</code></pre>"},{"location":"getting-started/quickstart/#effects","title":"Effects","text":"<p>Create visual effects:</p> <pre><code>import asyncio\nfrom lifx import Light, Colors\n\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Pulse effect\n        await light.pulse(Colors.RED, period=1.0, cycles=5)\n\n        # Breathe effect (infinite)\n        await light.breathe(Colors.BLUE, period=2.0, cycles=0)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>Always use proper error handling:</p> <pre><code>import asyncio\nfrom lifx import discover, Colors, LifxError\n\n\nasync def main():\n    try:\n        async for device in discover():\n            await device.set_color(Colors.GREEN)\n    except LifxError as e:\n        print(f\"LIFX error: {e}\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Architecture - How lifx-async works</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"getting-started/themes/","title":"Themes Quick Start","text":"<p>Themes allow you to apply professionally-curated color palettes to your LIFX devices with a single command.</p>"},{"location":"getting-started/themes/#apply-a-theme","title":"Apply a Theme","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\n# Get a theme by name\ntheme = ThemeLibrary.get(\"evening\")\n\n# Apply to all devices\nawait group.apply_theme(theme)\n</code></pre>"},{"location":"getting-started/themes/#list-available-themes","title":"List Available Themes","text":"<pre><code>from lifx import ThemeLibrary\n\n# Get all 42 theme names\nthemes = ThemeLibrary.list()\nprint(themes)\n\n# Get themes by category\nseasonal = ThemeLibrary.get_by_category(\"seasonal\")\nholidays = ThemeLibrary.get_by_category(\"holiday\")\nmoods = ThemeLibrary.get_by_category(\"mood\")\n</code></pre>"},{"location":"getting-started/themes/#theme-categories","title":"Theme Categories","text":"<p>The library includes 42 official LIFX app themes:</p> <ul> <li>Seasonal (3): spring, autumn, winter</li> <li>Holiday (9): christmas, halloween, hanukkah, kwanzaa, shamrock, thanksgiving, calaveras, pumpkin, santa</li> <li>Mood (16): peaceful, serene, relaxing, mellow, gentle, soothing, blissful, cheerful, romantic, romance, love, energizing, exciting, epic, intense, powerful</li> <li>Ambient (6): dream, fantasy, spacey, stardust, zombie, party</li> <li>Functional (3): focusing, evening, bias_lighting</li> <li>Atmosphere (3): hygge, tranquil, sports</li> </ul>"},{"location":"getting-started/themes/#common-options","title":"Common Options","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\ntheme = ThemeLibrary.get(\"christmas\")\n\n# Apply with options\nawait group.apply_theme(\n    theme,\n    power_on=True,      # Turn on lights before applying\n    duration=1.5        # Transition duration in seconds\n)\n</code></pre>"},{"location":"getting-started/themes/#create-a-custom-theme","title":"Create a Custom Theme","text":"<pre><code>from lifx import HSBK, Theme, discover\n\n# Create custom theme with specific colors\ncustom_theme = Theme([\n    HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500),      # Red\n    HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500),    # Green\n    HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500),    # Blue\n])\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait group.apply_theme(custom_theme, power_on=True)\n</code></pre>"},{"location":"getting-started/themes/#next-steps","title":"Next Steps","text":"<ul> <li>See Themes API Reference for detailed API documentation</li> <li>See Device Classes for device-specific <code>apply_theme()</code> methods</li> <li>See Color Utilities for HSBK color representation</li> </ul>"},{"location":"migration/effect-api-changes/","title":"Effect API Changes (v4.3.0)","text":"<p>This document describes changes to the effect handling API introduced in version 4.3.0.</p>"},{"location":"migration/effect-api-changes/#overview","title":"Overview","text":"<p>The effect handling API has been simplified and unified to provide a cleaner, more consistent interface:</p> <ol> <li>Unified Effect Enum: <code>MultiZoneEffectType</code> and <code>TileEffectType</code> merged into <code>FirmwareEffect</code></li> <li>Direction Enum: New <code>Direction</code> enum for MOVE effect direction control</li> <li>Simplified Methods: Effect methods renamed for clarity (<code>set_effect</code>, <code>get_effect</code>)</li> <li>Unified Application Request: <code>MultiZoneExtendedApplicationRequest</code> removed in favor of single <code>MultiZoneApplicationRequest</code></li> </ol>"},{"location":"migration/effect-api-changes/#changes","title":"Changes","text":""},{"location":"migration/effect-api-changes/#1-effect-type-enums-consolidated","title":"1. Effect Type Enums Consolidated","text":"<p>Before: <pre><code>from lifx import MultiZoneEffectType, TileEffectType\n\n# MultiZone effects\neffect = MultiZoneEffectType.MOVE\n\n# Tile effects\neffect = TileEffectType.MORPH\n</code></pre></p> <p>After: <pre><code>from lifx import FirmwareEffect\n\n# All firmware effects (multizone and matrix)\neffect = FirmwareEffect.MOVE   # MultiZone\neffect = FirmwareEffect.MORPH  # Matrix/Tile\neffect = FirmwareEffect.FLAME  # Matrix/Tile\neffect = FirmwareEffect.SKY    # Matrix/Tile\n</code></pre></p>"},{"location":"migration/effect-api-changes/#2-direction-control-for-move-effects","title":"2. Direction Control for MOVE Effects","text":"<p>Before: <pre><code># Direction was embedded in specialized methods\nawait light.set_move_effect(speed=5.0, direction=1)  # 0=reversed, 1=forward\n</code></pre></p> <p>After: <pre><code>from lifx import FirmwareEffect, Direction\n\n# Direction is a proper enum with named values\nawait light.set_effect(\n    effect_type=FirmwareEffect.MOVE,\n    speed=5.0,\n    direction=Direction.FORWARD,  # or Direction.REVERSED\n)\n\n# Direction can also be accessed as a property on MultiZoneEffect\neffect = await light.get_effect()\nif effect.effect_type == FirmwareEffect.MOVE:\n    print(f\"Direction: {effect.direction.name}\")  # FORWARD or REVERSED\n</code></pre></p>"},{"location":"migration/effect-api-changes/#3-method-naming-simplified","title":"3. Method Naming Simplified","text":"<p>Before: <pre><code># MultiZone devices\nawait multizone_light.set_multizone_effect(...)\neffect = await multizone_light.get_multizone_effect()\n\n# Tile/Matrix devices\nawait matrix_light.set_tile_effect(...)\neffect = await matrix_light.get_tile_effect()\n\n# Specialized MOVE method\nawait multizone_light.set_move_effect(speed=5.0, direction=1)\n</code></pre></p> <p>After: <pre><code># Unified naming across all device types\nawait multizone_light.set_effect(effect_type=FirmwareEffect.MOVE, ...)\neffect = await multizone_light.get_effect()\n\nawait matrix_light.set_effect(effect_type=FirmwareEffect.FLAME, ...)\neffect = await matrix_light.get_effect()\n\n# No more specialized methods - use set_effect with Direction enum\n</code></pre></p>"},{"location":"migration/effect-api-changes/#4-application-request-enum-unified","title":"4. Application Request Enum Unified","text":"<p>Before: <pre><code>from lifx import MultiZoneApplicationRequest, MultiZoneExtendedApplicationRequest\n\n# Different enums for different packet types\nawait light.set_color_zones(..., apply=MultiZoneApplicationRequest.APPLY)\nawait light.set_extended_color_zones(..., apply=MultiZoneExtendedApplicationRequest.APPLY)\n</code></pre></p> <p>After: <pre><code>from lifx import MultiZoneApplicationRequest\n\n# Single enum for all multizone application control\nawait light.set_color_zones(..., apply=MultiZoneApplicationRequest.APPLY)\nawait light.set_extended_color_zones(..., apply=MultiZoneApplicationRequest.APPLY)\n</code></pre></p>"},{"location":"migration/effect-api-changes/#migration-guide","title":"Migration Guide","text":""},{"location":"migration/effect-api-changes/#updating-multizone-effect-code","title":"Updating MultiZone Effect Code","text":"<p>Old Code: <pre><code>from lifx import MultiZoneLight, MultiZoneEffectType\n\nasync with await MultiZoneLight.from_ip(\"192.168.1.100\") as light:\n    # Old API\n    await light.set_multizone_effect(\n        effect_type=MultiZoneEffectType.MOVE,\n        speed=5.0,\n    )\n\n    # Or using specialized method\n    await light.set_move_effect(speed=5.0, direction=1)\n\n    effect = await light.get_multizone_effect()\n</code></pre></p> <p>New Code: <pre><code>from lifx import MultiZoneLight, FirmwareEffect, Direction\n\nasync with await MultiZoneLight.from_ip(\"192.168.1.100\") as light:\n    # New unified API\n    await light.set_effect(\n        effect_type=FirmwareEffect.MOVE,\n        speed=5.0,\n        direction=Direction.FORWARD,\n    )\n\n    effect = await light.get_effect()\n    if effect.effect_type == FirmwareEffect.MOVE:\n        print(f\"Direction: {effect.direction.name}\")\n</code></pre></p>"},{"location":"migration/effect-api-changes/#updating-matrixtile-effect-code","title":"Updating Matrix/Tile Effect Code","text":"<p>Old Code: <pre><code>from lifx import MatrixLight, TileEffectType\n\nasync with await MatrixLight.from_ip(\"192.168.1.100\") as light:\n    # Old API\n    await light.set_tile_effect(\n        effect_type=TileEffectType.FLAME,\n        speed=5.0,\n    )\n\n    effect = await light.get_tile_effect()\n</code></pre></p> <p>New Code: <pre><code>from lifx import MatrixLight, FirmwareEffect\n\nasync with await MatrixLight.from_ip(\"192.168.1.100\") as light:\n    # New unified API\n    await light.set_effect(\n        effect_type=FirmwareEffect.FLAME,\n        speed=5.0,\n    )\n\n    effect = await light.get_effect()\n</code></pre></p>"},{"location":"migration/effect-api-changes/#updating-application-request-code","title":"Updating Application Request Code","text":"<p>Old Code: <pre><code>from lifx import MultiZoneApplicationRequest, MultiZoneExtendedApplicationRequest\n\n# Standard zones\nawait light.set_color_zones(\n    start=0,\n    end=9,\n    color=color,\n    apply=MultiZoneApplicationRequest.APPLY,\n)\n\n# Extended zones\nawait light.set_extended_color_zones(\n    zone_index=0,\n    colors=colors,\n    apply=MultiZoneExtendedApplicationRequest.APPLY,\n)\n</code></pre></p> <p>New Code: <pre><code>from lifx import MultiZoneApplicationRequest\n\n# Standard zones\nawait light.set_color_zones(\n    start=0,\n    end=9,\n    color=color,\n    apply=MultiZoneApplicationRequest.APPLY,\n)\n\n# Extended zones\nawait light.set_extended_color_zones(\n    zone_index=0,\n    colors=colors,\n    apply=MultiZoneApplicationRequest.APPLY,  # Same enum\n)\n</code></pre></p>"},{"location":"migration/effect-api-changes/#summary-of-removals","title":"Summary of Removals","text":"<p>The following have been removed in v4.3.0:</p> <ul> <li><code>lifx.protocol.protocol_types.MultiZoneEffectType</code> \u2192 use <code>FirmwareEffect</code></li> <li><code>lifx.protocol.protocol_types.TileEffectType</code> \u2192 use <code>FirmwareEffect</code></li> <li><code>lifx.protocol.protocol_types.MultiZoneExtendedApplicationRequest</code> \u2192 use <code>MultiZoneApplicationRequest</code></li> <li><code>MultiZoneLight.set_multizone_effect()</code> \u2192 use <code>set_effect()</code></li> <li><code>MultiZoneLight.get_multizone_effect()</code> \u2192 use <code>get_effect()</code></li> <li><code>MultiZoneLight.set_move_effect()</code> \u2192 use <code>set_effect(effect_type=FirmwareEffect.MOVE, direction=Direction.FORWARD)</code></li> <li><code>MultiZoneLight.get_move_effect()</code> \u2192 use <code>get_effect()</code> and access <code>effect.direction</code></li> <li><code>MatrixLight.set_tile_effect()</code> \u2192 use <code>set_effect()</code></li> <li><code>MatrixLight.get_tile_effect()</code> \u2192 use <code>get_effect()</code></li> </ul>"},{"location":"migration/effect-api-changes/#benefits","title":"Benefits","text":"<p>These changes provide several improvements:</p> <ol> <li>Consistency: All firmware effects use the same enum and method names</li> <li>Type Safety: Direction is now a proper enum instead of integer values (0/1)</li> <li>Discoverability: Cleaner API with fewer specialized methods</li> <li>Simplicity: One enum for application requests instead of two identical ones</li> <li>Maintainability: Easier to extend with new effect types in the future</li> </ol>"},{"location":"user-guide/advanced-usage/","title":"Advanced Usage","text":"<p>This guide covers advanced lifx patterns and techniques for building robust LIFX integrations.</p>"},{"location":"user-guide/advanced-usage/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Storing State</li> <li>Connection Management</li> <li>Concurrency Patterns</li> <li>Error Handling</li> <li>Device Capabilities</li> <li>Custom Effects</li> <li>Performance Optimization</li> </ul>"},{"location":"user-guide/advanced-usage/#storing-state","title":"Storing State","text":"<p>Device properties return cached values that were last retrieved from the device.</p> <p>lifx-async automatically populates initial state values when a device is used as an async context manager.</p>"},{"location":"user-guide/advanced-usage/#understanding-stored-state","title":"Understanding Stored State","text":"<p>All device state properties return cached values or <code>None</code> if not yet fetched:</p> <pre><code>from lifx import Light\n\nasync def check_stored_state():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Property returns cached value or None\n        label = light.label\n        if label:\n            print(f\"Cached label: {label}\")\n        else:\n            print(\"No cached label - fetching from device\")\n            label = await light.get_label()\n            print(f\"Label: {label}\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#fetching-fresh-data","title":"Fetching Fresh Data","text":"<p>Use the <code>get_*()</code> methods to always fetch from the device:</p> <pre><code>async def always_fresh():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Always fetches from device\n        # Note: get_color() returns a tuple of (color, power, label)\n        color, power, label = await light.get_color()\n\n        # Get other device info\n        version = await light.get_version()\n\n        # Some properties cache semi-static data\n        cached_label = light.label  # Updated from get_color()\n</code></pre>"},{"location":"user-guide/advanced-usage/#working-with-cached-data","title":"Working with Cached Data","text":"<p>Use cached values when available for semi-static data, always fetch volatile state:</p> <pre><code>async def use_cached_or_fetch():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Check if we have cached label (semi-static)\n        label = light.label\n        if label:\n            print(f\"Using cached label: {label}\")\n        else:\n            print(\"No cached label, fetching from device\")\n            label = await light.get_label()\n            print(f\"Fetched label: {label}\")\n\n        # For volatile state (power, color), always fetch fresh data\n        # get_color() will only cache the label\n        color, power, label = await light.get_color()\n        print(f\"Current state of {light.label} - Power: {power}, Color: {color}\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#available-properties","title":"Available Properties","text":""},{"location":"user-guide/advanced-usage/#device-properties","title":"Device Properties","text":"<ul> <li><code>Device.label</code> - Device name/label</li> <li><code>Device.version</code> - Vendor ID and Product ID</li> <li><code>Device.host_firmware</code> - Major and minor host firmware version and build number</li> <li><code>Device.wifi_firmware</code> - Major and minor wifi firmware version and build number</li> <li><code>Device.location</code> - Device location name/label</li> <li><code>Device.group</code> - Device group name/label</li> </ul>"},{"location":"user-guide/advanced-usage/#non-state-properties","title":"Non-State Properties","text":"<ul> <li><code>Device.model</code> - Device product model</li> </ul>"},{"location":"user-guide/advanced-usage/#light-properties","title":"Light properties","text":""},{"location":"user-guide/advanced-usage/#non-state-properties_1","title":"Non-State Properties","text":"<ul> <li><code>Light.min_kelvin</code> - Lowest supported kelvin value</li> <li><code>Light.max_kelvin</code> - Highest supported kelvin value</li> </ul>"},{"location":"user-guide/advanced-usage/#infraredlight-properties","title":"InfraredLight properties","text":"<ul> <li><code>InfraredLight.infrared</code> - Infrared brightness</li> </ul>"},{"location":"user-guide/advanced-usage/#hevlight-properties","title":"HevLight properties:","text":"<ul> <li><code>HevLight.hev_config</code> - HEV configuration</li> <li><code>HevLight.hev_result</code> - Last HEV result</li> </ul>"},{"location":"user-guide/advanced-usage/#multizonelight-properties","title":"MultiZoneLight properties:","text":"<ul> <li><code>MultiZoneLight.zone_count</code> - Number of zones</li> <li><code>MultiZoneLight.multizone_effect</code> - Either MOVE or OFF</li> </ul>"},{"location":"user-guide/advanced-usage/#matrixlight-properties","title":"MatrixLight properties:","text":"<ul> <li><code>MatrixLight.tile_count</code> - Number of tiles on the chain</li> <li><code>MatrixLight.device_chain</code> - Details of each tile on the chain</li> <li><code>MatrixLight.tile_effect</code> - Either MORPH, FLAME, SKY or OFF</li> </ul>"},{"location":"user-guide/advanced-usage/#ceilinglight-properties","title":"CeilingLight properties:","text":"<ul> <li><code>CeilingLight.uplight_zone</code> - Zone index of the uplight component</li> <li><code>CeilingLight.downlight_zones</code> - Slice representing downlight zones</li> <li><code>CeilingLight.uplight_is_on</code> - True if uplight has brightness &gt; 0 (requires recent data)</li> <li><code>CeilingLight.downlight_is_on</code> - True if any downlight zone has brightness &gt; 0 (requires recent data)</li> </ul> <p>Note: Volatile state properties (power, color, hev_cycle, zones, tile_colors) have been removed. Always use <code>get_*()</code> methods to fetch these values from devices as they change too frequently to benefit from caching.</p> <p>All cached properties return <code>None</code> if no data has been cached yet, or the cached value if available.</p>"},{"location":"user-guide/advanced-usage/#connection-management","title":"Connection Management","text":""},{"location":"user-guide/advanced-usage/#understanding-lazy-connections","title":"Understanding Lazy Connections","text":"<p>Each device owns its own connection that opens lazily on first request:</p> <pre><code>from lifx import Light\n\nasync def main():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Connection opens automatically on first request\n        await light.set_power(True)\n        # All subsequent operations reuse the same connection\n        await light.set_color(Colors.BLUE)\n        await light.get_label()\n        # Connection automatically closed when exiting context\n</code></pre> <p>Benefits:</p> <ul> <li>Simple lifecycle: one connection per device</li> <li>Lazy opening: connection opens only when needed</li> <li>Automatic cleanup on context exit</li> <li>Requests are serialized to prevent response mixing</li> </ul>"},{"location":"user-guide/advanced-usage/#concurrency-patterns","title":"Concurrency Patterns","text":""},{"location":"user-guide/advanced-usage/#concurrent-requests-single-device","title":"Concurrent Requests (Single Device)","text":"<p>Send multiple requests concurrently to one device:</p> <pre><code>import asyncio\nfrom lifx import Light\n\nasync def concurrent_operations():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # These execute concurrently!\n        # get_color() returns (color, power, label)\n        (color, power, label), version = await asyncio.gather(\n            light.get_color(),\n            light.get_version(),\n        )\n\n        print(f\"{label}: Power={power}, Color={color}, Firmware={version.firmware}\")\n</code></pre> <p>Performance Note: Concurrent requests execute with maximum parallelism. However, per the LIFX protocol specification, devices can handle approximately 20 messages per second. When sending many concurrent requests to a single device, consider implementing rate limiting in your application to avoid overwhelming the device.</p>"},{"location":"user-guide/advanced-usage/#multi-device-control","title":"Multi-Device Control","text":"<p>Control multiple devices in parallel:</p> <pre><code>import asyncio\nfrom lifx import discover, DeviceGroup, Colors\n\nasync def multi_device_control():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    # Create different tasks for different devices\n    tasks = [\n        group.devices[0].set_color(Colors.RED),\n        group.devices[1].set_color(Colors.GREEN),\n        group.devices[2].set_color(Colors.BLUE),\n    ]\n\n    # Execute all at once\n    await asyncio.gather(*tasks)\n</code></pre>"},{"location":"user-guide/advanced-usage/#batched-discovery","title":"Batched Discovery","text":"<p>Discover devices in batches for large networks:</p> <pre><code>from lifx.network.discovery import discover_devices\n\nasync def discover_in_batches():\n    # First batch: quick discovery\n    devices_quick = await discover_devices(\n        timeout=1.0,\n        broadcast_address=\"255.255.255.255\"\n    )\n\n    # Second batch: thorough discovery\n    if len(devices_quick) &lt; expected_count:\n        devices_full = await discover_devices(\n            timeout=5.0,\n            broadcast_address=\"255.255.255.255\"\n        )\n        return devices_full\n\n    return devices_quick\n</code></pre>"},{"location":"user-guide/advanced-usage/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/advanced-usage/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>from lifx import (\n    LifxError,              # Base exception\n    LifxTimeoutError,       # Request timeout\n    LifxConnectionError,    # Connection failed\n    LifxProtocolError,      # Invalid protocol response\n    LifxDeviceNotFoundError,# Device not discovered\n    LifxNetworkError,       # Network issues\n    LifxUnsupportedCommandError,  # Device doesn't support operation\n)\n</code></pre>"},{"location":"user-guide/advanced-usage/#robust-error-handling","title":"Robust Error Handling","text":"<pre><code>import asyncio\nfrom lifx import Light, Colors, LifxTimeoutError, LifxConnectionError\n\nasync def resilient_control():\n    max_retries = 3\n\n    for attempt in range(max_retries):\n        try:\n            async with await Light.from_ip(\"192.168.1.100\") as light:\n                await light.set_color(Colors.BLUE)\n                print(\"Success!\")\n                return\n\n        except LifxTimeoutError:\n            print(f\"Timeout (attempt {attempt + 1}/{max_retries})\")\n            if attempt &lt; max_retries - 1:\n                await asyncio.sleep(1.0)  # Wait before retry\n\n        except LifxConnectionError as e:\n            print(f\"Connection failed: {e}\")\n            break  # Don't retry connection errors\n\n    print(\"All retries exhausted\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>from lifx import discover, DeviceGroup, LifxError\n\nasync def best_effort_control():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    results = []\n\n    # Try to control all lights, continue on errors\n    for light in group.lights:\n        try:\n            await light.set_color(Colors.GREEN)\n            results.append((light, \"success\"))\n        except LifxError as e:\n            results.append((light, f\"failed: {e}\"))\n\n    # Report results\n    for light, status in results:\n        label = await light.get_label() if status == \"success\" else \"Unknown\"\n        print(f\"{label}: {status}\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#device-capabilities","title":"Device Capabilities","text":""},{"location":"user-guide/advanced-usage/#detecting-capabilities","title":"Detecting Capabilities","text":"<p>Light capabilities are automatically populated:</p> <pre><code>from lifx import Light\nfrom lifx.products.registry import ProductCapability\n\nasync def check_capabilities():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n\n        print(f\"Product: {light.model}\")\n        print(f\"Capabilities: {light.capabilities}\")\n\n        # Check specific capabilities\n        if ProductCapability.COLOR in light.capabilities:\n            await light.set_color(Colors.BLUE)\n\n        if ProductCapability.MULTIZONE in light.capabilities:\n            print(\"This is a multizone device!\")\n\n        if ProductCapability.INFRARED in light.capabilities:\n            print(\"Supports infrared!\")\n</code></pre>"},{"location":"user-guide/advanced-usage/#capability-based-logic","title":"Capability-Based Logic","text":"<pre><code>from lifx import discover, DeviceGroup\nfrom lifx.products.registry import ProductCapability\n\nasync def capability_aware_control():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    for device in group.devices:\n\n        # Color devices\n        if ProductCapability.COLOR in device.capabilities:\n            await device.set_color(Colors.PURPLE)\n\n        # Multizone devices\n        if ProductCapability.MULTIZONE in device.capabilities:\n            await device.set_color_zones(0, 8, Colors.RED)\n</code></pre>"},{"location":"user-guide/advanced-usage/#custom-effects","title":"Custom Effects","text":""},{"location":"user-guide/advanced-usage/#creating-smooth-transitions","title":"Creating Smooth Transitions","text":"<pre><code>import asyncio\nfrom lifx import Light, HSBK\n\nasync def smooth_color_cycle():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        hues = [0, 60, 120, 180, 240, 300, 360]\n\n        for hue in hues:\n            color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)\n            await light.set_color(color, duration=2.0)  # 2 second transition\n            await asyncio.sleep(2.0)\n</code></pre>"},{"location":"user-guide/advanced-usage/#synchronized-multi-device-effects","title":"Synchronized Multi-Device Effects","text":"<pre><code>import asyncio\nfrom lifx import discover, DeviceGroup, Colors\n\nasync def synchronized_flash():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    # Flash all devices simultaneously\n    for _ in range(5):\n        await group.set_color(Colors.RED, duration=0.0)\n        await asyncio.sleep(0.2)\n        await group.set_color(Colors.OFF, duration=0.0)\n        await asyncio.sleep(0.2)\n</code></pre>"},{"location":"user-guide/advanced-usage/#wave-effect-across-devices","title":"Wave Effect Across Devices","text":"<pre><code>import asyncio\nfrom lifx import discover, DeviceGroup, Colors\n\nasync def wave_effect():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    for i, device in enumerate(group.devices):\n        # Each device changes color with a delay\n        asyncio.create_task(\n            delayed_color_change(device, Colors.BLUE, delay=i * 0.3)\n        )\n\nasync def delayed_color_change(device, color, delay):\n    await asyncio.sleep(delay)\n    await device.set_color(color, duration=1.0)\n</code></pre>"},{"location":"user-guide/advanced-usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user-guide/advanced-usage/#minimize-network-requests","title":"Minimize Network Requests","text":"<pre><code># \u274c Inefficient: Multiple round-trips\nasync def inefficient():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        await light.set_power(True)\n        await asyncio.sleep(0.1)\n        await light.set_color(Colors.BLUE)\n        await asyncio.sleep(0.1)\n        await light.set_brightness(0.8)\n\n# \u2705 Efficient: Set color and brightness together\nasync def efficient():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        await light.set_power(True)\n        # Set color includes brightness\n        color = HSBK(hue=240, saturation=1.0, brightness=0.8, kelvin=3500)\n        await light.set_color(color, duration=0.0)\n</code></pre>"},{"location":"user-guide/advanced-usage/#batch-operations","title":"Batch Operations","text":"<pre><code>from lifx import discover, DeviceGroup, Colors\n\n# \u274c Sequential: Takes N * latency\nasync def sequential():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    for device in group.devices:\n        await device.set_color(Colors.GREEN)\n\n# \u2705 Parallel: Takes ~latency\nasync def parallel():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    await group.set_color(Colors.GREEN)\n</code></pre>"},{"location":"user-guide/advanced-usage/#connection-reuse","title":"Connection Reuse","text":"<pre><code># \u274c Creates new connection each time\nasync def no_reuse():\n    for _ in range(10):\n        async with await Light.from_ip(\"192.168.1.100\") as light:\n            await light.set_brightness(0.5)\n        # Connection closed here\n\n# \u2705 Reuses connection\nasync def with_reuse():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        for _ in range(10):\n            await light.set_brightness(0.5)\n        # Connection closed once at end\n</code></pre>"},{"location":"user-guide/advanced-usage/#fire-and-forget-mode-for-high-frequency-animations","title":"Fire-and-Forget Mode for High-Frequency Animations","text":"<p>For animations sending more than 20 updates per second, waiting for device acknowledgement creates unacceptable latency. Use the <code>fast=True</code> parameter to enable fire-and-forget mode:</p> <pre><code>import asyncio\nfrom lifx import MultiZoneLight, HSBK\n\nasync def rainbow_animation():\n    async with await MultiZoneLight.from_ip(\"192.168.1.100\") as light:\n        zone_count = await light.get_zone_count()\n\n        # Animation loop at ~30 FPS\n        offset = 0\n        while True:\n            # Generate rainbow colors\n            colors = [\n                HSBK(hue=(i * 360 / zone_count + offset) % 360,\n                     saturation=1.0, brightness=1.0, kelvin=3500)\n                for i in range(zone_count)\n            ]\n\n            # Fire-and-forget: no waiting for response\n            await light.set_extended_color_zones(0, colors, fast=True)\n\n            offset = (offset + 5) % 360\n            await asyncio.sleep(0.033)  # ~30 FPS\n</code></pre> <p>When to use <code>fast=True</code>:</p> <ul> <li>High-frequency animations (&gt;20 updates/second)</li> <li>Real-time visualizations (music sync, games)</li> <li>Smooth color transitions requiring rapid updates</li> </ul> <p>Trade-offs:</p> <ul> <li>No confirmation that the device received or applied the colors</li> <li>No error detection (timeouts, unsupported commands)</li> <li>Best for visual effects where occasional dropped frames are acceptable</li> </ul> <p>Note: <code>MatrixLight.set64()</code> is already fire-and-forget by default, making it ideal for tile animations without any additional parameters.</p>"},{"location":"user-guide/advanced-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Troubleshooting Guide - Common issues and solutions</li> <li>Protocol Reference - Low-level protocol details</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/ceiling-lights/","title":"Ceiling Lights","text":"<p>LIFX Ceiling lights are unique fixtures that combine two lighting components in one device:</p> <ul> <li>Downlight: Main illumination with multiple addressable zones (63 or 127 zones)</li> <li>Uplight: Ambient/indirect lighting via a single zone</li> </ul> <p>The <code>CeilingLight</code> class provides high-level control over these components while inheriting full matrix functionality from <code>MatrixLight</code>.</p>"},{"location":"user-guide/ceiling-lights/#supported-devices","title":"Supported Devices","text":"Product Zones Layout LIFX Ceiling (US/Intl) 64 8x8 grid, zone 63 = uplight LIFX Ceiling Capsule (US/Intl) 128 16x8 grid, zone 127 = uplight"},{"location":"user-guide/ceiling-lights/#quick-start","title":"Quick Start","text":"<pre><code>from lifx import CeilingLight\nfrom lifx.color import HSBK\n\nasync def main():\n    async with await CeilingLight.from_ip(\"192.168.1.100\") as ceiling:\n        # Set downlight to warm white\n        await ceiling.set_downlight_colors(\n            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3000)\n        )\n\n        # Set uplight to a dim, warm ambient glow\n        await ceiling.set_uplight_color(\n            HSBK(hue=30, saturation=0.2, brightness=0.3, kelvin=2700)\n        )\n</code></pre>"},{"location":"user-guide/ceiling-lights/#component-control","title":"Component Control","text":""},{"location":"user-guide/ceiling-lights/#setting-colors","title":"Setting Colors","text":""},{"location":"user-guide/ceiling-lights/#downlight","title":"Downlight","text":"<p>Set all downlight zones to the same color:</p> <pre><code># Single color for all zones\nawait ceiling.set_downlight_colors(\n    HSBK(hue=0, saturation=0, brightness=0.8, kelvin=4000)\n)\n</code></pre> <p>Or set each zone individually:</p> <pre><code># Create a gradient across all zones\nzone_count = len(range(*ceiling.downlight_zones.indices(256)))\ncolors = [\n    HSBK(hue=(i * 360 / zone_count), saturation=1.0, brightness=0.5, kelvin=3500)\n    for i in range(zone_count)\n]\nawait ceiling.set_downlight_colors(colors)\n</code></pre>"},{"location":"user-guide/ceiling-lights/#uplight","title":"Uplight","text":"<pre><code>await ceiling.set_uplight_color(\n    HSBK(hue=30, saturation=0.1, brightness=0.4, kelvin=2700)\n)\n</code></pre>"},{"location":"user-guide/ceiling-lights/#reading-current-colors","title":"Reading Current Colors","text":"<pre><code># Get current uplight color\nuplight_color = await ceiling.get_uplight_color()\nprint(f\"Uplight: H={uplight_color.hue}, B={uplight_color.brightness}\")\n\n# Get all downlight colors\ndownlight_colors = await ceiling.get_downlight_colors()\nprint(f\"Downlight zones: {len(downlight_colors)}\")\n</code></pre>"},{"location":"user-guide/ceiling-lights/#turning-components-onoff","title":"Turning Components On/Off","text":"<p>The <code>turn_*_on()</code> and <code>turn_*_off()</code> methods provide smart state management:</p> <pre><code># Turn off uplight (stores current color for later restoration)\nawait ceiling.turn_uplight_off()\n\n# Turn uplight back on (restores previous color)\nawait ceiling.turn_uplight_on()\n\n# Turn on with a specific color\nawait ceiling.turn_uplight_on(\n    color=HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500)\n)\n</code></pre> <p>The same pattern works for downlights:</p> <pre><code># Turn off downlight\nawait ceiling.turn_downlight_off()\n\n# Turn downlight back on\nawait ceiling.turn_downlight_on()\n\n# Turn on with specific colors\nawait ceiling.turn_downlight_on(\n    colors=HSBK(hue=0, saturation=0, brightness=0.8, kelvin=4000)\n)\n</code></pre>"},{"location":"user-guide/ceiling-lights/#checking-component-state","title":"Checking Component State","text":"<pre><code># Check if components are on\nif ceiling.uplight_is_on:\n    print(\"Uplight is on\")\n\nif ceiling.downlight_is_on:\n    print(\"Downlight is on\")\n</code></pre> <p>State Properties Require Recent Data</p> <p>The <code>uplight_is_on</code> and <code>downlight_is_on</code> properties rely on cached data. Call <code>get_uplight_color()</code> or <code>get_downlight_colors()</code> first to ensure accurate state.</p>"},{"location":"user-guide/ceiling-lights/#device-state","title":"Device State","text":"<p>After connecting to a CeilingLight, you can access the complete device state via the <code>state</code> property, which returns a <code>CeilingLightState</code> dataclass:</p> <pre><code>from lifx import CeilingLight, CeilingLightState\n\nasync with await CeilingLight.from_ip(\"192.168.1.100\") as ceiling:\n    state: CeilingLightState = ceiling.state\n\n    # Access ceiling-specific state\n    print(f\"Uplight color: {state.uplight_color}\")\n    print(f\"Uplight is on: {state.uplight_is_on}\")\n    print(f\"Downlight zones: {len(state.downlight_colors)}\")\n    print(f\"Downlight is on: {state.downlight_is_on}\")\n\n    # Access inherited state from MatrixLightState/LightState\n    print(f\"Device label: {state.label}\")\n    print(f\"Power: {'on' if state.power else 'off'}\")\n    print(f\"Model: {state.model}\")\n</code></pre>"},{"location":"user-guide/ceiling-lights/#ceilinglightstate-attributes","title":"CeilingLightState Attributes","text":"<p><code>CeilingLightState</code> extends <code>MatrixLightState</code> with ceiling-specific attributes:</p> Attribute Type Description <code>uplight_color</code> <code>HSBK</code> Current color of the uplight component <code>downlight_colors</code> <code>list[HSBK]</code> Colors for each downlight zone (63 or 127) <code>uplight_is_on</code> <code>bool</code> True if uplight brightness &gt; 0 <code>downlight_is_on</code> <code>bool</code> True if any downlight zone brightness &gt; 0 <code>uplight_zone</code> <code>int</code> Zone index for uplight (63 or 127) <code>downlight_zones</code> <code>slice</code> Slice for downlight zones <p>Plus all attributes inherited from <code>MatrixLightState</code>: <code>chain</code>, <code>tile_colors</code>, <code>tile_count</code>, <code>effect</code>, and from <code>LightState</code>: <code>color</code>, <code>power</code>, <code>label</code>, <code>model</code>, <code>serial</code>, <code>mac_address</code>, <code>capabilities</code>, etc.</p>"},{"location":"user-guide/ceiling-lights/#zone-layout","title":"Zone Layout","text":"<p>Access the component zone indices directly:</p> <pre><code>async with await CeilingLight.from_ip(\"192.168.1.100\") as ceiling:\n    # Get uplight zone index (63 or 127 depending on model)\n    uplight_idx = ceiling.uplight_zone\n    print(f\"Uplight zone: {uplight_idx}\")\n\n    # Get downlight zones as a slice\n    downlight_slice = ceiling.downlight_zones\n    print(f\"Downlight zones: {downlight_slice}\")  # slice(0, 63) or slice(0, 127)\n\n    # Calculate number of downlight zones\n    zone_count = len(range(*downlight_slice.indices(256)))\n    print(f\"Number of downlight zones: {zone_count}\")\n</code></pre>"},{"location":"user-guide/ceiling-lights/#state-persistence","title":"State Persistence","text":"<p>CeilingLight supports optional state persistence to preserve component colors across sessions:</p> <pre><code>async with await CeilingLight.from_ip(\n    \"192.168.1.100\",\n    state_file=\"~/.lifx/ceiling_state.json\"\n) as ceiling:\n    # Colors are automatically loaded from file on connection\n    # and saved when using turn_*_off() methods\n\n    await ceiling.turn_uplight_off()  # Saves current color to file\n    # ... later ...\n    await ceiling.turn_uplight_on()   # Restores from file if available\n</code></pre> <p>The state file stores colors per device serial number, supporting multiple devices:</p> <pre><code>{\n  \"d073d5123456\": {\n    \"uplight\": {\n      \"hue\": 30.0,\n      \"saturation\": 0.2,\n      \"brightness\": 0.4,\n      \"kelvin\": 2700\n    },\n    \"downlight\": [\n      {\"hue\": 0.0, \"saturation\": 0.0, \"brightness\": 0.8, \"kelvin\": 4000}\n    ]\n  }\n}\n</code></pre>"},{"location":"user-guide/ceiling-lights/#brightness-determination","title":"Brightness Determination","text":"<p>When calling <code>turn_uplight_on()</code> or <code>turn_downlight_on()</code> without a color parameter, CeilingLight uses the following priority to determine brightness:</p> <ol> <li>Stored state: If a color was previously saved (via <code>turn_*_off()</code> or <code>set_*_color()</code>)</li> <li>Infer from other component: Average brightness of the other component</li> <li>Default: 80% brightness</li> </ol> <p>This ensures a reasonable brightness level even when no state is available.</p>"},{"location":"user-guide/ceiling-lights/#transition-duration","title":"Transition Duration","text":"<p>All color-setting methods support smooth transitions:</p> <pre><code># 2-second transition to new color\nawait ceiling.set_uplight_color(\n    HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500),\n    duration=2.0  # seconds\n)\n\n# Instant change (default)\nawait ceiling.set_downlight_colors(\n    HSBK(hue=240, saturation=1.0, brightness=0.5, kelvin=3500),\n    duration=0.0\n)\n</code></pre>"},{"location":"user-guide/ceiling-lights/#matrixlight-compatibility","title":"MatrixLight Compatibility","text":"<p>CeilingLight extends <code>MatrixLight</code>, so all matrix operations are available:</p> <pre><code>async with await CeilingLight.from_ip(\"192.168.1.100\") as ceiling:\n    # Use MatrixLight methods directly\n    all_colors = await ceiling.get_all_tile_colors()\n    tile_chain = await ceiling.get_tile_chain()\n\n    # Set raw matrix colors (bypasses component abstraction)\n    await ceiling.set_matrix_colors(0, colors)\n\n    # Apply effects\n    from lifx.protocol.protocol_types import TileEffectType\n    await ceiling.set_tile_effect(\n        effect_type=TileEffectType.MORPH,\n        speed=5000,\n    )\n</code></pre>"},{"location":"user-guide/ceiling-lights/#example-night-mode","title":"Example: Night Mode","text":"<p>Create a subtle night light with dim uplight and downlight off:</p> <pre><code>from lifx import CeilingLight\nfrom lifx.color import HSBK\n\nasync def night_mode(ip: str):\n    async with await CeilingLight.from_ip(ip) as ceiling:\n        # Store current colors before turning off\n        await ceiling.turn_downlight_off()\n\n        # Set uplight to very dim warm glow\n        await ceiling.set_uplight_color(\n            HSBK(hue=30, saturation=0.3, brightness=0.05, kelvin=2200),\n            duration=2.0\n        )\n</code></pre>"},{"location":"user-guide/ceiling-lights/#example-daytime-productivity","title":"Example: Daytime Productivity","text":"<p>Bright, cool white for focus:</p> <pre><code>async def daytime_mode(ip: str):\n    async with await CeilingLight.from_ip(ip) as ceiling:\n        # Bright cool downlight for task lighting\n        await ceiling.set_downlight_colors(\n            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=5500),\n            duration=1.0\n        )\n\n        # Turn off uplight during the day\n        await ceiling.turn_uplight_off(duration=1.0)\n</code></pre>"},{"location":"user-guide/ceiling-lights/#example-evening-ambiance","title":"Example: Evening Ambiance","text":"<p>Warm tones with accent uplight:</p> <pre><code>async def evening_mode(ip: str):\n    async with await CeilingLight.from_ip(ip) as ceiling:\n        # Dimmed warm downlight\n        await ceiling.set_downlight_colors(\n            HSBK(hue=30, saturation=0.1, brightness=0.4, kelvin=2700),\n            duration=2.0\n        )\n\n        # Colorful uplight accent\n        await ceiling.set_uplight_color(\n            HSBK(hue=280, saturation=0.6, brightness=0.3, kelvin=3500),\n            duration=2.0\n        )\n</code></pre>"},{"location":"user-guide/ceiling-lights/#api-reference","title":"API Reference","text":"<p>See CeilingLight API Reference for complete method documentation.</p>"},{"location":"user-guide/effects-custom/","title":"Creating Custom Effects","text":"<p>This guide shows you how to create your own light effects by subclassing the <code>LIFXEffect</code> base class. You'll learn the required methods, common patterns, and best practices for building custom effects.</p>"},{"location":"user-guide/effects-custom/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Basic Structure</li> <li>Required Methods</li> <li>Optional Methods</li> <li>Common Patterns</li> <li>Complete Examples</li> <li>Best Practices</li> </ul>"},{"location":"user-guide/effects-custom/#overview","title":"Overview","text":"<p>Creating a custom effect involves:</p> <ol> <li>Subclass <code>LIFXEffect</code></li> <li>Implement <code>async_play()</code> with your effect logic</li> <li>Optionally override <code>from_poweroff_hsbk()</code> for custom startup colors</li> <li>Optionally override <code>inherit_prestate()</code> for state inheritance optimization</li> </ol> <p>The conductor handles all state management automatically - you just focus on the visual effect.</p>"},{"location":"user-guide/effects-custom/#basic-structure","title":"Basic Structure","text":"<p>Every custom effect follows this pattern:</p> <pre><code>from lifx import LIFXEffect, Light\n\nclass MyCustomEffect(LIFXEffect):\n    \"\"\"Brief description of what this effect does.\"\"\"\n\n    def __init__(self, param1, param2, power_on: bool = True):\n        \"\"\"Initialize the effect with custom parameters.\n\n        Args:\n            param1: Description of parameter 1\n            param2: Description of parameter 2\n            power_on: Whether to power on devices (default True)\n        \"\"\"\n        super().__init__(power_on=power_on)\n        self.param1 = param1\n        self.param2 = param2\n\n    async def async_play(self) -&gt; None:\n        \"\"\"Execute the effect logic.\"\"\"\n        # Your effect implementation here\n        pass\n</code></pre>"},{"location":"user-guide/effects-custom/#minimal-example","title":"Minimal Example","text":"<p>Here's the simplest possible custom effect:</p> <pre><code>from lifx.effects import LIFXEffect\nimport asyncio\n\nclass FlashEffect(LIFXEffect):\n    \"\"\"Flash all lights once.\"\"\"\n\n    async def async_play(self) -&gt; None:\n        # Turn all lights on\n        tasks = [light.set_brightness(1.0) for light in self.participants]\n        await asyncio.gather(*tasks)\n        await asyncio.sleep(0.5)\n\n        # Turn all lights off\n        tasks = [light.set_brightness(0.0) for light in self.participants]\n        await asyncio.gather(*tasks)\n        await asyncio.sleep(0.5)\n\n        # Restore state\n        if self.conductor:\n            await self.conductor.stop(self.participants)\n</code></pre> <p>Usage:</p> <pre><code>conductor = Conductor()\neffect = FlashEffect()\nawait conductor.start(effect, lights)\nawait asyncio.sleep(2)\n</code></pre>"},{"location":"user-guide/effects-custom/#required-methods","title":"Required Methods","text":""},{"location":"user-guide/effects-custom/#async_play-none","title":"<code>async_play() -&gt; None</code>","text":"<p>This is the only required method you must implement. This is where your effect logic lives.</p> <p>Important: This method is <code>async</code> - use <code>await</code> for all async operations.</p> <p>Available attributes:</p> <ul> <li><code>self.participants</code>: List of <code>Light</code> instances to apply effect to</li> <li><code>self.conductor</code>: Reference to the <code>Conductor</code> managing this effect</li> <li><code>self.power_on</code>: Whether devices should be powered on (already handled)</li> </ul> <p>When called:</p> <p>After the conductor has:</p> <ol> <li>Captured device state</li> <li>Powered on devices (if <code>power_on=True</code>)</li> </ol> <p>Example:</p> <pre><code>async def async_play(self) -&gt; None:\n    \"\"\"Cycle through red, green, blue.\"\"\"\n    from lifx import HSBK\n\n    colors = [\n        HSBK.from_rgb(255, 0, 0),    # Red\n        HSBK.from_rgb(0, 255, 0),    # Green\n        HSBK.from_rgb(0, 0, 255),    # Blue\n    ]\n\n    for color in colors:\n        # Apply color to all lights concurrently\n        tasks = [\n            light.set_color(color, duration=0.5)\n            for light in self.participants\n        ]\n        await asyncio.gather(*tasks)\n        await asyncio.sleep(1.0)\n\n    # Restore original state\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre> <p>Key Points:</p> <ul> <li>Use <code>asyncio.gather()</code> to apply operations to multiple devices concurrently</li> <li>Call <code>self.conductor.stop(self.participants)</code> when effect is complete to restore state</li> <li>Don't forget <code>await</code> on async operations</li> </ul>"},{"location":"user-guide/effects-custom/#optional-methods","title":"Optional Methods","text":""},{"location":"user-guide/effects-custom/#from_poweroff_hsbklight-light-hsbk","title":"<code>from_poweroff_hsbk(light: Light) -&gt; HSBK</code>","text":"<p>Override this to customize the color used when powering on a device.</p> <p>Default behavior: Returns random hue, full saturation, zero brightness, neutral white.</p> <p>When called: When a device needs to be powered on for the effect (if it was off when effect started).</p> <p>Example:</p> <pre><code>async def from_poweroff_hsbk(self, light: Light) -&gt; HSBK:\n    \"\"\"Always start with soft blue.\"\"\"\n    return HSBK.from_rgb(0, 50, 200, kelvin=KELVIN_NEUTRAL)\n</code></pre> <p>Use cases:</p> <ul> <li>Effect always starts with specific color</li> <li>Effect wants coordinated startup across devices</li> <li>Effect wants device-specific startup colors</li> </ul>"},{"location":"user-guide/effects-custom/#inherit_prestateother-lifxeffect-bool","title":"<code>inherit_prestate(other: LIFXEffect) -&gt; bool</code>","text":"<p>Override this to enable state inheritance optimization.</p> <p>Default behavior: Returns <code>False</code> (always capture fresh state).</p> <p>When called: Before starting effect, to check if previous effect's state can be reused.</p> <p>Example:</p> <pre><code>def inherit_prestate(self, other: LIFXEffect) -&gt; bool:\n    \"\"\"Can inherit from same effect type.\"\"\"\n    return type(self) == type(other)\n</code></pre> <p>Returns:</p> <ul> <li><code>True</code>: Skip state capture/restore, reuse existing <code>PreState</code></li> <li><code>False</code>: Capture fresh state as normal</li> </ul> <p>Benefits:</p> <ul> <li>Faster effect transitions</li> <li>No visible reset between compatible effects</li> <li>Reduces network traffic</li> </ul> <p>Use with caution: Only return <code>True</code> if the incoming effect is truly compatible (won't cause visual artifacts).</p>"},{"location":"user-guide/effects-custom/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/effects-custom/#pattern-1-synchronized-actions","title":"Pattern 1: Synchronized Actions","text":"<p>All devices do the same thing at the same time:</p> <pre><code>async def async_play(self) -&gt; None:\n    \"\"\"Pulse all devices together.\"\"\"\n    for cycle in range(self.cycles):\n        # All bright\n        await asyncio.gather(*[\n            light.set_brightness(1.0, duration=0.3)\n            for light in self.participants\n        ])\n        await asyncio.sleep(0.5)\n\n        # All dim\n        await asyncio.gather(*[\n            light.set_brightness(0.2, duration=0.3)\n            for light in self.participants\n        ])\n        await asyncio.sleep(0.5)\n\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre>"},{"location":"user-guide/effects-custom/#pattern-2-sequential-actions","title":"Pattern 2: Sequential Actions","text":"<p>Devices act one after another (wave effect):</p> <pre><code>async def async_play(self) -&gt; None:\n    \"\"\"Light up devices sequentially.\"\"\"\n    for light in self.participants:\n        await light.set_color(self.color, duration=0.5)\n        await asyncio.sleep(self.delay)\n\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre>"},{"location":"user-guide/effects-custom/#pattern-3-continuous-loop-until-stopped","title":"Pattern 3: Continuous Loop Until Stopped","text":"<p>Effect runs indefinitely (like ColorLoop):</p> <pre><code>async def async_play(self) -&gt; None:\n    \"\"\"Continuous random color changes.\"\"\"\n    import random\n\n    self._running = True\n    while self._running:\n        # Random color for each device\n        tasks = []\n        for light in self.participants:\n            hue = random.randint(0, 360)\n            color = HSBK(hue, 1.0, 1.0, KELVIN_NEUTRAL)\n            tasks.append(light.set_color(color, duration=1.0))\n\n        await asyncio.gather(*tasks)\n        await asyncio.sleep(self.interval)\n\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n\ndef stop(self) -&gt; None:\n    \"\"\"Stop the effect.\"\"\"\n    self._running = False\n</code></pre> <p>Usage:</p> <pre><code>effect = RandomColorEffect(interval=2.0)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(30)\neffect.stop()  # Signal to stop\n</code></pre>"},{"location":"user-guide/effects-custom/#pattern-4-device-specific-behavior","title":"Pattern 4: Device-Specific Behavior","text":"<p>Different actions based on device properties:</p> <pre><code>async def async_play(self) -&gt; None:\n    \"\"\"Different colors based on device label.\"\"\"\n    tasks = []\n    for light in self.participants:\n        label = await light.get_label()\n\n        if \"Bedroom\" in label:\n            color = HSBK.from_rgb(0, 0, 255)  # Blue\n        elif \"Kitchen\" in label:\n            color = HSBK.from_rgb(255, 255, 255)  # White\n        else:\n            color = HSBK.from_rgb(255, 0, 0)  # Red\n\n        tasks.append(light.set_color(color, duration=1.0))\n\n    await asyncio.gather(*tasks)\n    await asyncio.sleep(2.0)\n\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre>"},{"location":"user-guide/effects-custom/#pattern-5-state-access","title":"Pattern 5: State Access","text":"<p>Access current device state during effect:</p> <pre><code>async def async_play(self) -&gt; None:\n    \"\"\"Pulse brighter than current brightness.\"\"\"\n    for light in self.participants:\n        # Get current state\n        current_color, _, _ = await light.get_color()\n\n        # Create brighter version\n        bright_color = current_color.with_brightness(1.0)\n\n        # Pulse\n        await light.set_color(bright_color, duration=0.3)\n        await asyncio.sleep(0.5)\n        await light.set_color(current_color, duration=0.3)\n        await asyncio.sleep(0.5)\n\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre> <p>Note: Conductor already captured state, so you can also access it via the prestate (though this requires conductor internals access).</p>"},{"location":"user-guide/effects-custom/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/effects-custom/#example-1-flash-effect","title":"Example 1: Flash Effect","text":"<p>Flash all lights in unison with configurable count and duration:</p> <pre><code>from lifx import LIFXEffect\nimport asyncio\n\nclass FlashEffect(LIFXEffect):\n    \"\"\"Flash all lights in unison.\n\n    Simple effect that demonstrates basic synchronization across devices.\n    \"\"\"\n\n    def __init__(\n        self,\n        flash_count: int = 5,\n        duration: float = 0.5,\n        power_on: bool = True\n    ) -&gt; None:\n        \"\"\"Initialize flash effect.\n\n        Args:\n            flash_count: Number of flashes\n            duration: Duration of each flash in seconds\n            power_on: Whether to power on lights if off\n        \"\"\"\n        super().__init__(power_on=power_on)\n        self.flash_count = flash_count\n        self.duration = duration\n\n    async def async_play(self) -&gt; None:\n        \"\"\"Execute the flash effect on all participants.\"\"\"\n        for i in range(self.flash_count):\n            # All devices on\n            tasks = [light.set_brightness(1.0) for light in self.participants]\n            await asyncio.gather(*tasks)\n            await asyncio.sleep(self.duration / 2)\n\n            # All devices off\n            tasks = [light.set_brightness(0.0) for light in self.participants]\n            await asyncio.gather(*tasks)\n            await asyncio.sleep(self.duration / 2)\n\n        # Restore state\n        if self.conductor:\n            await self.conductor.stop(self.participants)\n</code></pre> <p>Usage:</p> <pre><code>conductor = Conductor()\neffect = FlashEffect(flash_count=10, duration=0.3)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(4)\n</code></pre>"},{"location":"user-guide/effects-custom/#example-2-wave-effect","title":"Example 2: Wave Effect","text":"<p>Sequential color wave across multiple lights:</p> <pre><code>from lifx.effects import LIFXEffect\nfrom lifx import HSBK\nimport asyncio\n\nclass WaveEffect(LIFXEffect):\n    \"\"\"Create a color wave across multiple lights.\n\n    More complex example showing sequential color updates across devices.\n    \"\"\"\n\n    def __init__(\n        self,\n        wave_count: int = 3,\n        wave_speed: float = 0.3,\n        power_on: bool = True\n    ) -&gt; None:\n        \"\"\"Initialize wave effect.\n\n        Args:\n            wave_count: Number of waves to run\n            wave_speed: Speed of wave in seconds per light\n            power_on: Whether to power on lights if off\n        \"\"\"\n        super().__init__(power_on=power_on)\n        self.wave_count = wave_count\n        self.wave_speed = wave_speed\n\n    async def async_play(self) -&gt; None:\n        \"\"\"Execute the wave effect.\"\"\"\n        # Define wave colors\n        colors = [\n            HSBK.from_rgb(255, 0, 0),      # Red\n            HSBK.from_rgb(255, 127, 0),    # Orange\n            HSBK.from_rgb(255, 255, 0),    # Yellow\n            HSBK.from_rgb(0, 255, 0),      # Green\n            HSBK.from_rgb(0, 0, 255),      # Blue\n        ]\n\n        for wave in range(self.wave_count):\n            # Wave forward\n            for i, light in enumerate(self.participants):\n                color = colors[i % len(colors)]\n                await light.set_color(color, duration=self.wave_speed)\n                await asyncio.sleep(self.wave_speed)\n\n            await asyncio.sleep(0.5)  # Pause between waves\n\n        # Restore state\n        if self.conductor:\n            await self.conductor.stop(self.participants)\n</code></pre> <p>Usage:</p> <pre><code>conductor = Conductor()\neffect = WaveEffect(wave_count=3, wave_speed=0.4)\nawait conductor.start(effect, lights)\ntotal_time = 3 * (len(lights) * 0.4 + 0.5)\nawait asyncio.sleep(total_time + 1)\n</code></pre>"},{"location":"user-guide/effects-custom/#example-3-random-color-effect","title":"Example 3: Random Color Effect","text":"<p>Continuous random color changes until stopped:</p> <pre><code>from lifx.effects import LIFXEffect\nfrom lifx import HSBK\nimport asyncio\nimport random\n\nclass RandomColorEffect(LIFXEffect):\n    \"\"\"Continuously change to random colors.\n\n    Example of continuous effect that runs until stopped.\n    \"\"\"\n\n    def __init__(\n        self,\n        interval: float = 2.0,\n        saturation_min: float = 0.7,\n        saturation_max: float = 1.0,\n        power_on: bool = True\n    ) -&gt; None:\n        \"\"\"Initialize random color effect.\n\n        Args:\n            interval: Seconds between color changes\n            saturation_min: Minimum saturation (0.0-1.0)\n            saturation_max: Maximum saturation (0.0-1.0)\n            power_on: Whether to power on lights if off\n        \"\"\"\n        super().__init__(power_on=power_on)\n        self.interval = interval\n        self.saturation_min = saturation_min\n        self.saturation_max = saturation_max\n        self._running = False\n\n    async def async_play(self) -&gt; None:\n        \"\"\"Execute random color changes continuously.\"\"\"\n        self._running = True\n\n        while self._running:\n            # Random color for each device\n            tasks = []\n            for light in self.participants:\n                color = HSBK(\n                    hue=random.randint(0, 360),\n                    saturation=random.uniform(self.saturation_min, self.saturation_max),\n                    brightness=1.0,\n                    kelvin=KELVIN_NEUTRAL\n                )\n                tasks.append(light.set_color(color, duration=self.interval * 0.8))\n\n            await asyncio.gather(*tasks)\n            await asyncio.sleep(self.interval)\n\n        # Restore state when stopped\n        if self.conductor:\n            await self.conductor.stop(self.participants)\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the continuous effect.\"\"\"\n        self._running = False\n\n    def inherit_prestate(self, other: LIFXEffect) -&gt; bool:\n        \"\"\"Can inherit from other RandomColorEffect instances.\"\"\"\n        return isinstance(other, RandomColorEffect)\n</code></pre> <p>Usage:</p> <pre><code>conductor = Conductor()\neffect = RandomColorEffect(interval=3.0, saturation_min=0.8)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(30)\neffect.stop()  # Signal to stop\nawait asyncio.sleep(3)  # Wait for current iteration to finish\n</code></pre>"},{"location":"user-guide/effects-custom/#example-4-notification-effect","title":"Example 4: Notification Effect","text":"<p>Different visual patterns based on notification level:</p> <pre><code>from lifx.effects import LIFXEffect\nfrom lifx import HSBK\nimport asyncio\n\nclass NotificationEffect(LIFXEffect):\n    \"\"\"Visual notification with different levels.\n\n    Example showing how to implement different behaviors in one effect class.\n    \"\"\"\n\n    def __init__(\n        self,\n        level: str = 'info',\n        power_on: bool = True\n    ) -&gt; None:\n        \"\"\"Initialize notification effect.\n\n        Args:\n            level: Notification level ('info', 'warning', 'error')\n            power_on: Whether to power on lights if off\n        \"\"\"\n        super().__init__(power_on=power_on)\n        if level not in ('info', 'warning', 'error'):\n            raise ValueError(f\"Invalid level: {level}\")\n        self.level = level\n\n    async def async_play(self) -&gt; None:\n        \"\"\"Execute notification based on level.\"\"\"\n        if self.level == 'info':\n            await self._info_notification()\n        elif self.level == 'warning':\n            await self._warning_notification()\n        elif self.level == 'error':\n            await self._error_notification()\n\n        # Restore state\n        if self.conductor:\n            await self.conductor.stop(self.participants)\n\n    async def _info_notification(self) -&gt; None:\n        \"\"\"Blue breathe - calm information.\"\"\"\n        blue = HSBK.from_rgb(0, 0, 255)\n        for _ in range(2):\n            await asyncio.gather(*[\n                light.set_color(blue, duration=0.5)\n                for light in self.participants\n            ])\n            await asyncio.sleep(0.7)\n            await asyncio.gather(*[\n                light.set_brightness(0.3, duration=0.5)\n                for light in self.participants\n            ])\n            await asyncio.sleep(0.7)\n\n    async def _warning_notification(self) -&gt; None:\n        \"\"\"Orange blink - attention needed.\"\"\"\n        orange = HSBK.from_rgb(255, 165, 0)\n        for _ in range(3):\n            await asyncio.gather(*[\n                light.set_color(orange, duration=0.1)\n                for light in self.participants\n            ])\n            await asyncio.sleep(0.5)\n            await asyncio.gather(*[\n                light.set_brightness(0.0, duration=0.1)\n                for light in self.participants\n            ])\n            await asyncio.sleep(0.5)\n\n    async def _error_notification(self) -&gt; None:\n        \"\"\"Red strobe - urgent.\"\"\"\n        red = HSBK.from_rgb(255, 0, 0)\n        for _ in range(10):\n            await asyncio.gather(*[\n                light.set_color(red, duration=0.0)\n                for light in self.participants\n            ])\n            await asyncio.sleep(0.1)\n            await asyncio.gather(*[\n                light.set_brightness(0.0, duration=0.0)\n                for light in self.participants\n            ])\n            await asyncio.sleep(0.1)\n\n    async def from_poweroff_hsbk(self, light: Light) -&gt; HSBK:\n        \"\"\"Return appropriate startup color based on level.\"\"\"\n        if self.level == 'info':\n            return HSBK.from_rgb(0, 0, 255)  # Blue\n        elif self.level == 'warning':\n            return HSBK.from_rgb(255, 165, 0)  # Orange\n        else:\n            return HSBK.from_rgb(255, 0, 0)  # Red\n</code></pre> <p>Usage:</p> <pre><code>conductor = Conductor()\n\n# Different notification levels\nawait conductor.start(NotificationEffect(level='info'), lights)\nawait asyncio.sleep(3)\n\nawait conductor.start(NotificationEffect(level='warning'), lights)\nawait asyncio.sleep(3)\n\nawait conductor.start(NotificationEffect(level='error'), lights)\nawait asyncio.sleep(3)\n</code></pre>"},{"location":"user-guide/effects-custom/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/effects-custom/#1-always-restore-state","title":"1. Always Restore State","text":"<p>Call <code>conductor.stop()</code> when your effect is complete:</p> <pre><code>async def async_play(self) -&gt; None:\n    # Effect logic here\n    ...\n\n    # Always restore at the end\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre>"},{"location":"user-guide/effects-custom/#2-use-concurrent-operations","title":"2. Use Concurrent Operations","text":"<p>Use <code>asyncio.gather()</code> for operations on multiple devices:</p> <pre><code># Good - concurrent\nawait asyncio.gather(*[\n    light.set_color(color) for light in self.participants\n])\n\n# Bad - sequential (much slower)\nfor light in self.participants:\n    await light.set_color(color)\n</code></pre>"},{"location":"user-guide/effects-custom/#3-validate-parameters","title":"3. Validate Parameters","text":"<p>Validate constructor parameters early:</p> <pre><code>def __init__(self, count: int, power_on: bool = True):\n    super().__init__(power_on=power_on)\n\n    if count &lt; 1:\n        raise ValueError(f\"Count must be positive, got {count}\")\n\n    self.count = count\n</code></pre>"},{"location":"user-guide/effects-custom/#4-add-type-hints","title":"4. Add Type Hints","text":"<p>Full type hints improve IDE support and catch bugs:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from lifx import Light\n\nclass MyEffect(LIFXEffect):\n    def __init__(self, duration: float, power_on: bool = True) -&gt; None:\n        super().__init__(power_on=power_on)\n        self.duration: float = duration\n\n    async def async_play(self) -&gt; None:\n        ...\n\n    async def from_poweroff_hsbk(self, light: Light) -&gt; HSBK:\n        ...\n</code></pre>"},{"location":"user-guide/effects-custom/#5-document-your-effect","title":"5. Document Your Effect","text":"<p>Clear docstrings help users understand your effect:</p> <pre><code>class MyEffect(LIFXEffect):\n    \"\"\"Brief one-line description.\n\n    Longer description explaining:\n    - What the effect does\n    - When to use it\n    - Any important behavior\n\n    Example:\n        ```python\n        conductor = Conductor()\n        effect = MyEffect(duration=2.0)\n        await conductor.start(effect, lights)\n        await asyncio.sleep(3)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"user-guide/effects-custom/#6-handle-errors-gracefully","title":"6. Handle Errors Gracefully","text":"<p>Catch and log errors, don't let one device break the effect:</p> <pre><code>import logging\n\n_LOGGER = logging.getLogger(__name__)\n\nasync def async_play(self) -&gt; None:\n    for light in self.participants:\n        try:\n            await light.set_color(self.color)\n        except Exception as e:\n            _LOGGER.error(f\"Failed to set color on {light.serial}: {e}\")\n            # Continue with other lights\n</code></pre>"},{"location":"user-guide/effects-custom/#7-timing-considerations","title":"7. Timing Considerations","text":"<p>Add small buffers to timing for reliability:</p> <pre><code># Good - includes buffer\ntotal_duration = self.count * self.period\nawait asyncio.sleep(total_duration + 0.5)\n\n# Better - exact but requires careful calculation\nawait asyncio.sleep(self.count * self.period)\n</code></pre>"},{"location":"user-guide/effects-custom/#8-test-with-different-device-types","title":"8. Test with Different Device Types","text":"<p>Test your effect with:</p> <ul> <li>Single color light</li> <li>Multiple color lights</li> <li>Multizone light (if applicable)</li> <li>Powered-off devices</li> <li>Mix of on/off devices</li> </ul>"},{"location":"user-guide/effects-custom/#9-consider-rate-limiting","title":"9. Consider Rate Limiting","text":"<p>For effects with many rapid commands, consider rate limiting:</p> <pre><code>async def async_play(self) -&gt; None:\n    for iteration in range(self.iterations):\n        # Send commands\n        await self._apply_colors()\n\n        # Rate limit: max 20 messages/second\n        await asyncio.sleep(0.05)\n</code></pre>"},{"location":"user-guide/effects-custom/#10-use-descriptive-names","title":"10. Use Descriptive Names","text":"<p>Choose clear, descriptive names for effects and parameters:</p> <pre><code># Good\nclass PulseWaveEffect(LIFXEffect):\n    def __init__(self, wave_count: int, wave_period: float):\n        ...\n\n# Less clear\nclass Effect1(LIFXEffect):\n    def __init__(self, n: int, t: float):\n        ...\n</code></pre>"},{"location":"user-guide/effects-custom/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic usage of built-in effects</li> <li>Effects Reference - Detailed API documentation</li> <li>Architecture - How the system works internally</li> <li>Troubleshooting - Common issues and solutions</li> <li>Examples - Full working examples including <code>08_custom_effect.py</code></li> </ul>"},{"location":"user-guide/effects-troubleshooting/","title":"Effects Troubleshooting","text":"<p>This guide helps you diagnose and resolve common issues when using the Light Effects Framework.</p>"},{"location":"user-guide/effects-troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Common Issues</li> <li>Device Compatibility</li> <li>Performance Issues</li> <li>State Management</li> <li>Debugging Techniques</li> <li>Known Limitations</li> </ul>"},{"location":"user-guide/effects-troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/effects-troubleshooting/#effects-dont-start","title":"Effects Don't Start","text":"<p>Symptom: Calling <code>conductor.start()</code> doesn't appear to do anything.</p> <p>Possible Causes:</p> <ol> <li>No await keyword</li> </ol> <pre><code># Wrong - missing await\nconductor.start(effect, lights)  # Returns immediately, nothing happens\n\n# Correct\nawait conductor.start(effect, lights)\n</code></pre> <ol> <li>Devices not reachable</li> </ol> <pre><code># Check device connectivity first\nfrom lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nif not group.lights:\n    print(\"No devices found!\")\n    return\n\n# Now safe to use effects\nconductor = Conductor()\nawait conductor.start(effect, group.lights)\n</code></pre> <ol> <li>Empty participants list</li> </ol> <pre><code># Check you have lights\nif not lights:\n    print(\"No lights to apply effect to\")\n    return\n\nawait conductor.start(effect, lights)\n</code></pre> <p>Solution: Always use <code>await</code> and verify devices are discovered before starting effects.</p>"},{"location":"user-guide/effects-troubleshooting/#lights-dont-restore-to-original-state","title":"Lights Don't Restore to Original State","text":"<p>Symptom: After effect completes, lights stay in effect state instead of returning to original.</p> <p>Possible Causes:</p> <ol> <li>Missing conductor.stop() call</li> </ol> <pre><code># ColorLoop requires manual stop\neffect = EffectColorloop(period=30)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(60)\n# MISSING: await conductor.stop(lights)\n</code></pre> <p>Solution: Always call <code>conductor.stop()</code> for continuous effects:</p> <pre><code>await conductor.stop(lights)\n</code></pre> <ol> <li>Effect doesn't call conductor.stop() internally</li> </ol> <p>Custom effects must restore state:</p> <pre><code>async def async_play(self) -&gt; None:\n    # Effect logic\n    ...\n\n    # Required for auto-restore\n    if self.conductor:\n        await self.conductor.stop(self.participants)\n</code></pre> <ol> <li>Network timeout during restoration</li> </ol> <p>If restoration fails due to network issues, lights may be in inconsistent state.</p> <p>Solution: Check logs for timeout errors, verify network connectivity.</p>"},{"location":"user-guide/effects-troubleshooting/#effect-appears-to-freeze","title":"Effect Appears to Freeze","text":"<p>Symptom: Effect starts but never completes, script hangs.</p> <p>Possible Causes:</p> <ol> <li>ColorLoop running indefinitely</li> </ol> <p>ColorLoop is designed to run forever:</p> <pre><code># This will hang forever\neffect = EffectColorloop(period=30)\nawait conductor.start(effect, lights)\n# Script hangs here - ColorLoop never completes\n</code></pre> <p>Solution: Call <code>conductor.stop()</code> explicitly:</p> <pre><code>effect = EffectColorloop(period=30)\nawait conductor.start(effect, lights)\nawait asyncio.sleep(60)  # Let it run\nawait conductor.stop(lights)  # Stop it\n</code></pre> <ol> <li>Custom effect with infinite loop</li> </ol> <pre><code>async def async_play(self) -&gt; None:\n    while True:  # Infinite loop!\n        await self._do_something()\n</code></pre> <p>Solution: Add stop condition:</p> <pre><code>async def async_play(self) -&gt; None:\n    self._running = True\n    while self._running:\n        await self._do_something()\n</code></pre> <ol> <li>Missing await in effect logic</li> </ol> <pre><code>async def async_play(self) -&gt; None:\n    # Missing await - blocks event loop\n    light.set_color(color)  # Should be: await light.set_color(color)\n</code></pre> <p>Solution: Always use <code>await</code> on async operations.</p>"},{"location":"user-guide/effects-troubleshooting/#lights-flashreset-between-effects","title":"Lights Flash/Reset Between Effects","text":"<p>Symptom: When starting second effect, lights briefly return to original state before new effect starts.</p> <p>Cause: State inheritance not enabled.</p> <pre><code># Each effect resets to original state\neffect1 = EffectColorloop(period=30)\nawait conductor.start(effect1, lights)\nawait asyncio.sleep(10)\n\neffect2 = EffectColorloop(period=20)  # Lights briefly reset here\nawait conductor.start(effect2, lights)\n</code></pre> <p>Solution: Effects must implement <code>inherit_prestate()</code> to prevent reset:</p> <pre><code>class EffectColorloop(LIFXEffect):\n    def inherit_prestate(self, other: LIFXEffect) -&gt; bool:\n        return isinstance(other, EffectColorloop)\n</code></pre> <p>This is already implemented for <code>EffectColorloop</code>, but custom effects may need it.</p> <p>Note: For different effect types, the reset is intentional behavior.</p>"},{"location":"user-guide/effects-troubleshooting/#pulse-effect-too-fastslow","title":"Pulse Effect Too Fast/Slow","text":"<p>Symptom: Pulse timing doesn't match expectations.</p> <p>Cause: Misunderstanding period vs. total duration.</p> <pre><code># This runs for 1 second total (period=1.0, cycles=1)\neffect = EffectPulse(mode='blink', period=1.0, cycles=1)\n\n# This runs for 5 seconds total (period=1.0, cycles=5)\neffect = EffectPulse(mode='blink', period=1.0, cycles=5)\n\n# This runs for 2 seconds total (period=2.0, cycles=1)\neffect = EffectPulse(mode='blink', period=2.0, cycles=1)\n</code></pre> <p>Solution: Total duration = <code>period * cycles</code></p> <pre><code># Want 10-second effect?\neffect = EffectPulse(mode='breathe', period=2.0, cycles=5)  # 2.0 * 5 = 10s\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#colorloop-colors-look-wrong","title":"ColorLoop Colors Look Wrong","text":"<p>Symptom: ColorLoop shows unexpected colors or is too dim/bright.</p> <p>Possible Causes:</p> <ol> <li>Saturation constraints too restrictive</li> </ol> <pre><code># Very low saturation = washed out colors\neffect = EffectColorloop(saturation_min=0.1, saturation_max=0.3)  # Pastels\n</code></pre> <p>Solution: Use higher saturation for vibrant colors:</p> <pre><code>effect = EffectColorloop(saturation_min=0.8, saturation_max=1.0)\n</code></pre> <ol> <li>Brightness locked to low value</li> </ol> <pre><code># Locked to 30% brightness\neffect = EffectColorloop(brightness=0.3)  # Dim!\n</code></pre> <p>Solution: Use higher brightness or <code>None</code> to preserve original:</p> <pre><code>effect = EffectColorloop(brightness=None)  # Preserve original\n# or\neffect = EffectColorloop(brightness=0.8)  # 80% brightness\n</code></pre> <ol> <li>Monochrome device</li> </ol> <p>ColorLoop doesn't work on monochrome/white-only lights.</p> <p>Solution: Only use ColorLoop on color-capable devices.</p>"},{"location":"user-guide/effects-troubleshooting/#multizone-lights-dont-restore-zones-correctly","title":"Multizone Lights Don't Restore Zones Correctly","text":"<p>Symptom: After effect, multizone light zones are wrong color or all same color.</p> <p>Possible Causes:</p> <ol> <li>Device was powered off before effect</li> </ol> <p>Some older multizone devices report all zones as the same color when powered off.</p> <p>Workaround: Ensure lights are powered on before starting effects:</p> <pre><code># Power on first\nfor light in lights:\n    await light.set_power(True)\nawait asyncio.sleep(0.5)\n\n# Now start effect\nawait conductor.start(effect, lights)\n</code></pre> <ol> <li>Extended multizone messages not supported</li> </ol> <p>Older devices may not support efficient extended multizone messages.</p> <p>Solution: Framework automatically falls back to standard messages. No action needed.</p> <ol> <li>Network timeouts during zone restoration</li> </ol> <p>If restoring many zones times out, state may be incomplete.</p> <p>Solution: Check network stability, reduce concurrent operations.</p>"},{"location":"user-guide/effects-troubleshooting/#device-compatibility","title":"Device Compatibility","text":""},{"location":"user-guide/effects-troubleshooting/#color-lights","title":"Color Lights","text":"<p>Full Support: All effects work as expected.</p> <p>Models: LIFX Color, LIFX+, LIFX Mini Color, LIFX Candle Color</p>"},{"location":"user-guide/effects-troubleshooting/#monochromewhite-lights","title":"Monochrome/White Lights","text":"<p>Limited Support: Only brightness-based effects work.</p> <p>What Works:</p> <ul> <li>EffectPulse: Brightness pulsing (hue/saturation ignored)</li> <li>Custom effects using only brightness</li> </ul> <p>What Doesn't Work:</p> <ul> <li>EffectColorloop: No visible effect (can't change hue)</li> <li>Color-based custom effects: Only brightness changes visible</li> </ul> <p>Recommendation: Avoid ColorLoop on monochrome devices.</p> <p>Models: LIFX White, LIFX Mini White, LIFX Downlight</p>"},{"location":"user-guide/effects-troubleshooting/#multizone-lights","title":"Multizone Lights","text":"<p>Full Support with some considerations.</p> <p>Works Well:</p> <ul> <li>EffectPulse: All zones pulse together</li> <li>EffectColorloop: Entire device cycles color</li> </ul> <p>Special Considerations:</p> <ul> <li>Effects apply to entire device, not individual zones</li> <li>Zone colors properly restored after effect</li> <li>Extended multizone messages used when available</li> </ul> <p>Potential Enhancement: Future versions could support per-zone effects.</p> <p>Models: LIFX Z, LIFX Beam</p>"},{"location":"user-guide/effects-troubleshooting/#matrix-lights-tilecandlepath","title":"Matrix Lights (Tile/Candle/Path)","text":"<p>Full Support (treated as single unit).</p> <p>Works Well:</p> <ul> <li>EffectPulse: All tiles/zones pulse together</li> <li>EffectColorloop: All tiles/zones cycle color together</li> </ul> <p>Limitation: Current implementation doesn't use per-tile control. All tiles show same color.</p> <p>Potential Enhancement: Future versions could support per-tile effects (similar to theme support).</p> <p>Models: LIFX Tile, LIFX Candle, LIFX Path</p>"},{"location":"user-guide/effects-troubleshooting/#hev-lights","title":"HEV Lights","text":"<p>Full Support (treated like standard color lights).</p> <p>Note: Effects don't interfere with HEV cycle functionality.</p> <p>Models: LIFX Clean</p>"},{"location":"user-guide/effects-troubleshooting/#infrared-lights","title":"Infrared Lights","text":"<p>Full Support (treated like standard color lights).</p> <p>Note: Effects control visible light only, infrared LED not affected.</p> <p>Models: LIFX+, LIFX Night Vision</p>"},{"location":"user-guide/effects-troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"user-guide/effects-troubleshooting/#slow-effect-startup","title":"Slow Effect Startup","text":"<p>Symptom: Noticeable delay before effect starts.</p> <p>Cause: State capture requires network round trips.</p> <p>Expected Timing:</p> <ul> <li>Single device: &lt;1 second</li> <li>10 devices: &lt;1 second (concurrent)</li> <li>50 devices: 1-2 seconds</li> </ul> <p>If Slower:</p> <ul> <li>Check network latency (ping devices)</li> <li>Verify devices are on local network (not remote)</li> <li>Reduce concurrent discovery operations</li> </ul>"},{"location":"user-guide/effects-troubleshooting/#choppystuttering-effects","title":"Choppy/Stuttering Effects","text":"<p>Symptom: Effects don't run smoothly, visible stuttering.</p> <p>Possible Causes:</p> <ol> <li>Too many concurrent effects</li> </ol> <pre><code># 50 devices all running independent effects\nfor light in lights:\n    await conductor.start(effect, [light])  # Too many!\n</code></pre> <p>Solution: Group devices:</p> <pre><code># All devices in one effect\nawait conductor.start(effect, lights)\n</code></pre> <ol> <li>Network congestion</li> </ol> <p>Too many packets sent too quickly can overwhelm network or devices.</p> <p>Solution: Add rate limiting:</p> <pre><code># In custom effect\nfor iteration in range(self.iterations):\n    await self._update_colors()\n    await asyncio.sleep(0.05)  # Rate limit: max 20/sec\n</code></pre> <ol> <li>Blocking operations in effect</li> </ol> <pre><code># Bad - blocking sleep\nimport time\ntime.sleep(1)  # Blocks entire event loop!\n\n# Good - async sleep\nawait asyncio.sleep(1)\n</code></pre> <p>Solution: Always use async operations.</p>"},{"location":"user-guide/effects-troubleshooting/#effects-on-many-devices-are-slow","title":"Effects on Many Devices Are Slow","text":"<p>Symptom: Effects take much longer with many devices.</p> <p>Expected Behavior: Effects should scale linearly (not exponentially).</p> <p>If Slower Than Expected:</p> <ol> <li>Verify concurrent operations are used:</li> </ol> <pre><code># Good - concurrent\nawait asyncio.gather(*[\n    light.set_color(color) for light in lights\n])\n\n# Bad - sequential\nfor light in lights:\n    await light.set_color(color)\n</code></pre> <ol> <li> <p>Check for sequential operations in custom effects</p> </li> <li> <p>Verify network capacity isn't saturated</p> </li> </ol> <p>Recommendation: For 50+ devices, consider:</p> <ul> <li>Staggering effect starts</li> <li>Using fewer concurrent effects</li> <li>Implementing application-level rate limiting</li> </ul>"},{"location":"user-guide/effects-troubleshooting/#state-management","title":"State Management","text":""},{"location":"user-guide/effects-troubleshooting/#state-captured-incorrectly","title":"State Captured Incorrectly","text":"<p>Symptom: Restored state doesn't match original state.</p> <p>Possible Causes:</p> <ol> <li>State changed between capture and effect</li> </ol> <pre><code># State captured here\nawait conductor.start(effect, lights)\n\n# Meanwhile, user changes light with app\n# Effect completes, restores OLD state (not current state)\n</code></pre> <p>Solution: Effects framework works correctly - this is expected behavior. State is captured at effect start.</p> <ol> <li>Multizone device powered off during capture</li> </ol> <p>Older devices report inaccurate zone colors when off.</p> <p>Workaround: Power on before effect:</p> <pre><code>for light in lights:\n    await light.set_power(True)\nawait asyncio.sleep(0.5)\nawait conductor.start(effect, lights)\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#state-restoration-fails-silently","title":"State Restoration Fails Silently","text":"<p>Symptom: State restoration errors not visible.</p> <p>Cause: Errors are logged but don't raise exceptions (by design - one failed device shouldn't stop others).</p> <p>Solution: Enable debug logging:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger('lifx.effects')\nlogger.setLevel(logging.DEBUG)\n</code></pre> <p>Check logs for warnings like:</p> <pre><code>WARNING:lifx.effects.conductor:Failed to restore color for d073d5123456: TimeoutError\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"user-guide/effects-troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>See detailed information about effect execution:</p> <pre><code>import logging\n\n# Enable debug logging for effects\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Just effects module\nlogger = logging.getLogger('lifx.effects')\nlogger.setLevel(logging.DEBUG)\n</code></pre> <p>Output shows:</p> <ul> <li>State capture details</li> <li>Prestate inheritance decisions</li> <li>State restoration steps</li> <li>Error messages</li> </ul>"},{"location":"user-guide/effects-troubleshooting/#check-current-effect-status","title":"Check Current Effect Status","text":"<p>See what's currently running on each device:</p> <pre><code>conductor = Conductor()\n\n# After starting effects\nfor light in lights:\n    current = conductor.effect(light)\n    if current:\n        print(f\"{light.label}: {type(current).__name__}\")\n    else:\n        print(f\"{light.label}: idle\")\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#verify-device-connectivity","title":"Verify Device Connectivity","text":"<p>Before effects, verify all devices are reachable:</p> <pre><code>async def check_connectivity(lights):\n    \"\"\"Verify all lights respond.\"\"\"\n    for light in lights:\n        try:\n            label = await light.get_label()\n            print(f\"\u2713 {label} reachable\")\n        except Exception as e:\n            print(f\"\u2717 {light.serial} unreachable: {e}\")\n\n# Use before effects\nfrom lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait check_connectivity(group.lights)\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#test-with-single-device-first","title":"Test with Single Device First","text":"<p>Isolate issues by testing with one device:</p> <pre><code># Test with single device first\nfrom lifx import discover, DeviceGroup\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nif group.lights:\n    test_light = group.lights[0]\n\n    conductor = Conductor()\n    effect = EffectPulse(mode='blink', cycles=3)\n\n    print(f\"Testing with {await test_light.get_label()}\")\n    await conductor.start(effect, [test_light])\n    await asyncio.sleep(4)\n\n    print(\"Test complete - check if light restored correctly\")\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#validate-effect-parameters","title":"Validate Effect Parameters","text":"<p>Check that effect parameters are valid:</p> <pre><code># Add parameter validation\nclass MyEffect(LIFXEffect):\n    def __init__(self, count: int, period: float, power_on: bool = True):\n        super().__init__(power_on=power_on)\n\n        if count &lt; 1:\n            raise ValueError(f\"count must be positive, got {count}\")\n        if period &lt;= 0:\n            raise ValueError(f\"period must be positive, got {period}\")\n\n        self.count = count\n        self.period = period\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#measure-effect-timing","title":"Measure Effect Timing","text":"<p>Verify effect runs for expected duration:</p> <pre><code>import time\n\nstart = time.time()\n\neffect = EffectPulse(mode='blink', period=1.0, cycles=5)\nawait conductor.start(effect, lights)\n\n# Expected: 5 seconds\nawait asyncio.sleep(6)\n\nelapsed = time.time() - start\nprint(f\"Effect took {elapsed:.1f}s (expected ~5s)\")\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#known-limitations","title":"Known Limitations","text":""},{"location":"user-guide/effects-troubleshooting/#rate-limiting","title":"Rate Limiting","text":"<p>The effects framework does not implement automatic rate limiting.</p> <p>Impact: Sending too many concurrent commands may overwhelm devices or network.</p> <p>LIFX Limit: ~20 messages per second per device</p> <p>Recommendation: For rapid-fire effects, add your own rate limiting:</p> <pre><code>async def async_play(self) -&gt; None:\n    for i in range(100):\n        await self._update_lights()\n        await asyncio.sleep(0.05)  # 20/sec max\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#tile-per-tile-effects","title":"Tile Per-Tile Effects","text":"<p>Current implementation treats tiles as a single unit.</p> <p>Limitation: Can't apply different effects to individual tiles within a tile chain.</p> <p>Workaround: Use theme support for per-tile colors, or wait for future enhancement.</p> <p>Potential Future: Per-tile effect logic could be added using <code>MatrixLight.set_matrix_colors()</code>.</p>"},{"location":"user-guide/effects-troubleshooting/#multizone-per-zone-effects","title":"Multizone Per-Zone Effects","text":"<p>Current implementation treats multizone device as a single unit.</p> <p>Limitation: Can't pulse individual zones or create zone-specific effects.</p> <p>Workaround: Manually use <code>set_color_zones()</code> in custom effects.</p> <p>Example:</p> <pre><code>from lifx import MultiZoneLight\n\nasync def async_play(self) -&gt; None:\n    for light in self.participants:\n        if isinstance(light, MultiZoneLight):\n            # Control individual zones\n            zone_count = await light.get_zone_count()\n            for i in range(zone_count):\n                color = self._get_zone_color(i)\n                await light.set_color_zones(i, i, color)\n</code></pre>"},{"location":"user-guide/effects-troubleshooting/#buttonrelayswitch-devices","title":"Button/Relay/Switch Devices","text":"<p>The effects framework only supports lighting devices.</p> <p>Not Supported:</p> <ul> <li>LIFX Switch</li> <li>LIFX Relay</li> <li>Button devices</li> </ul> <p>Reason: Effects are designed for visual output (lights), not control devices.</p>"},{"location":"user-guide/effects-troubleshooting/#network-timeouts-with-many-devices","title":"Network Timeouts with Many Devices","text":"<p>With 50+ devices, state capture/restoration may timeout.</p> <p>Symptoms:</p> <ul> <li>Some devices don't restore state</li> <li>Timeout errors in logs</li> </ul> <p>Solutions:</p> <ul> <li>Increase timeout values (requires lifx-async modification)</li> <li>Reduce number of concurrent effects</li> <li>Group devices and stagger effect starts</li> <li>Verify network infrastructure can handle traffic</li> </ul>"},{"location":"user-guide/effects-troubleshooting/#prestate-inheritance-limitations","title":"Prestate Inheritance Limitations","text":"<p>State inheritance is conservative to prevent artifacts.</p> <p>Current Behavior:</p> <ul> <li>Only <code>EffectColorloop</code> supports inheritance (from other <code>EffectColorloop</code>)</li> <li>Other effect types always reset state</li> </ul> <p>Enhancement Opportunity: More effect types could support inheritance with careful design.</p>"},{"location":"user-guide/effects-troubleshooting/#still-having-issues","title":"Still Having Issues?","text":"<p>If you're experiencing issues not covered here:</p> <ol> <li>Check the logs with debug logging enabled</li> <li>Test with single device to isolate the problem</li> <li>Verify device firmware is up to date</li> <li>Check network connectivity and stability</li> <li>Review examples in the <code>examples/</code> directory</li> <li>Report issues on GitHub Issues</li> </ol> <p>When reporting issues, include:</p> <ul> <li>lifx-async version</li> <li>Python version</li> <li>Device model(s) affected</li> <li>Minimal reproduction code</li> <li>Full error message and traceback</li> <li>Debug logs if applicable</li> </ul>"},{"location":"user-guide/effects-troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic usage patterns</li> <li>Effects Reference - Detailed API documentation</li> <li>Custom Effects - Creating your own effects</li> <li>Architecture - How the system works</li> </ul>"},{"location":"user-guide/protocol-deep-dive/","title":"Protocol Deep Dive","text":"<p>Understanding the LIFX protocol and how lifx implements it.</p>"},{"location":"user-guide/protocol-deep-dive/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Protocol Overview</li> <li>Packet Structure</li> <li>Message Flow</li> <li>Protocol Types</li> <li>Code Generation</li> <li>Low-Level Usage</li> </ul>"},{"location":"user-guide/protocol-deep-dive/#protocol-overview","title":"Protocol Overview","text":"<p>The LIFX LAN Protocol is a binary protocol using UDP for communication:</p> <ul> <li>Port: 56700 (UDP)</li> <li>Packet Size: Variable (36-byte header + payload)</li> <li>Transport: Unreliable (UDP) with application-level reliability</li> <li>Discovery: Broadcast-based (255.255.255.255)</li> </ul>"},{"location":"user-guide/protocol-deep-dive/#protocol-layers","title":"Protocol Layers","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Application (lifx API)        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Packet Classes (packets.py)        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Models (models.py)                 \u2502\n\u2502  Serialization (serializer.py)      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Header (header.py)                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  UDP Transport                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#packet-structure","title":"Packet Structure","text":""},{"location":"user-guide/protocol-deep-dive/#header-format-36-bytes","title":"Header Format (36 bytes)","text":"<p>Every LIFX packet starts with a 36-byte header:</p> <pre><code>from lifx.protocol.header import LifxHeader\nfrom lifx.protocol.models import Serial\n\n# Create serial number\nserial = Serial.from_string(\"d073d5123456\")\n\nheader = LifxHeader(\n    size=64,                    # Total packet size (header + payload)\n    protocol=1024,              # Protocol version (always 1024)\n    addressable=True,           # Addressing mode\n    tagged=False,               # Broadcast vs unicast\n    source=0x12345678,          # Unique client ID\n    target=serial.to_protocol(), # Device serial (8 bytes with padding)\n    res_required=True,          # Expects response\n    ack_required=False,         # Expects acknowledgment\n    sequence=1,                 # Sequence number (0-255)\n    pkt_type=101,               # Message type\n)\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#header-fields","title":"Header Fields","text":"Field Size Description size 2 bytes Total packet size including header origin 2 bits Message origin (always 0) tagged 1 bit Broadcast (1) or targeted (0) addressable 1 bit Addressing mode (always 1) protocol 12 bits Protocol number (always 1024) source 4 bytes Unique client identifier target 8 bytes Device MAC address (6 bytes + 2 padding) reserved 6 bytes Reserved for future use res_required 1 bit Response required flag ack_required 1 bit Acknowledgment required flag reserved 6 bits Reserved sequence 1 byte Wrap-around sequence number reserved 8 bytes Reserved pkt_type 2 bytes Message type identifier reserved 2 bytes Reserved"},{"location":"user-guide/protocol-deep-dive/#payload","title":"Payload","text":"<p>Variable-length payload following the header:</p> <pre><code># Example: SetColor payload (13 bytes)\n{\n    'reserved': 0,              # 1 byte\n    'color': HSBK(...),         # 8 bytes (4 \u00d7 uint16)\n    'duration': 1000,           # 4 bytes (uint32, milliseconds)\n}\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#message-flow","title":"Message Flow","text":""},{"location":"user-guide/protocol-deep-dive/#discovery-process","title":"Discovery Process","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Network\n    participant Device1\n    participant Device2\n\n    Client-&gt;&gt;Network: Broadcast GetService (tagged=1)\n    Network-&gt;&gt;Device1: GetService\n    Network-&gt;&gt;Device2: GetService\n    Device1--&gt;&gt;Client: StateService (port 56700)\n    Device2--&gt;&gt;Client: StateService (port 56700)\n    Client-&gt;&gt;Client: Collect responses</code></pre>"},{"location":"user-guide/protocol-deep-dive/#request-response-pattern","title":"Request-Response Pattern","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Device\n\n    Client-&gt;&gt;Device: GetLabel (seq=1, res_required=1)\n    Device--&gt;&gt;Client: StateLabel (seq=1, \"Living Room\")\n\n    Client-&gt;&gt;Device: SetColor (seq=2, res_required=0, ack_required=1)\n    Device--&gt;&gt;Client: Acknowledgement (seq=2)</code></pre>"},{"location":"user-guide/protocol-deep-dive/#concurrent-requests","title":"Concurrent Requests","text":"<p>lifx-async supports concurrent requests on a single connection:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Device\n\n    Client-&gt;&gt;Device: Request 1 (seq=1)\n    Client-&gt;&gt;Device: Request 2 (seq=2)\n    Client-&gt;&gt;Device: Request 3 (seq=3)\n\n    Device--&gt;&gt;Client: Handle Response 2 (seq=2)\n    Device--&gt;&gt;Client: Handle Response 1(seq=1)\n    Device--&gt;&gt;Client: Handle Response 3 (seq=3)</code></pre>"},{"location":"user-guide/protocol-deep-dive/#protocol-types","title":"Protocol Types","text":""},{"location":"user-guide/protocol-deep-dive/#color-representation","title":"Color Representation","text":"<p>LIFX uses HSBK color space:</p> <pre><code>from lifx import HSBK\n\ncolor = HSBK(\n    hue=180.0,         # 0-360 degrees\n    saturation=1.0,    # 0.0-1.0\n    brightness=0.75,   # 0.0-1.0\n    kelvin=3500,       # 1500-9000\n)\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#packet-categories","title":"Packet Categories","text":"<p>Packets are organized by category:</p> Category Purpose Examples <code>Device</code> Device-wide operations GetLabel, SetLabel, GetPower <code>Light</code> Light control SetColor, GetColor, SetWaveform <code>MultiZone</code> Strip/beam control SetColorZones, GetColorZones <code>Tile</code> Tile device control GetTileState64, SetTileState64"},{"location":"user-guide/protocol-deep-dive/#common-packet-types","title":"Common Packet Types","text":"<pre><code>from lifx.protocol import packets\n\n# Device packets\nget_label = packets.Device.GetLabel()              # pkt_type=23\nset_label = packets.Device.SetLabel(label=\"Room\")  # pkt_type=24\n\n# Light packets\nget_color = packets.Light.Get()                    # pkt_type=101\nset_color = packets.Light.SetColor(               # pkt_type=102\n    color=HSBK(...),\n    duration=1000\n)\n\n# MultiZone packets\nget_zones = packets.MultiZone.GetColorZones(      # pkt_type=502\n    start_index=0,\n    end_index=8\n)\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#code-generation","title":"Code Generation","text":""},{"location":"user-guide/protocol-deep-dive/#from-protocolyml","title":"From protocol.yml","text":"<p>lifx-async auto-generates protocol code from the official LIFX specification:</p> <pre><code># protocol.yml excerpt\npackets:\n  - name: SetColor\n    pkt_type: 102\n    category: light\n    fields:\n      - name: reserved\n        type: uint8\n      - name: color\n        type: HSBK\n      - name: duration\n        type: uint32\n</code></pre> <p>Generates:</p> <pre><code># packets.py (generated)\n@dataclass\nclass SetColor:\n    PKT_TYPE: ClassVar[int] = 102\n    CATEGORY: ClassVar[str] = \"Light\"\n\n    reserved: int = 0\n    color: HSBK = field(default_factory=HSBK)\n    duration: int = 0\n\n    def pack(self) -&gt; bytes:\n        # Serialization logic\n        ...\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#regenerating-protocol-code","title":"Regenerating Protocol Code","text":"<pre><code># Regenerate Python code\nuv run python -m lifx.protocol.generator\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#generator-features","title":"Generator Features","text":"<ul> <li>Type Safety: Full type hints for all structures</li> <li>Validation: Bounds checking for protocol values</li> <li>Documentation: Docstrings from protocol comments</li> <li>Filtering: Excludes non-lighting categories (Button, Relay)</li> </ul>"},{"location":"user-guide/protocol-deep-dive/#low-level-usage","title":"Low-Level Usage","text":""},{"location":"user-guide/protocol-deep-dive/#direct-protocol-usage","title":"Direct Protocol Usage","text":"<pre><code>from lifx.network.connection import DeviceConnection\nfrom lifx.protocol import packets\nfrom lifx.protocol.protocol_types import HSBK\n\nasync def low_level_control():\n    # Create connection\n    conn = DeviceConnection(\n        serial=\"d073d5000001\",\n        ip=\"192.168.1.100\"\n    )\n\n    # Create packet\n    packet = packets.Light.SetColor(\n        reserved=0,\n        color=HSBK(hue=32768, saturation=65535, brightness=49151, kelvin=3500),\n        duration=1000\n    )\n\n    # Send and receive response\n    response = await conn.request(\n        packet,\n        timeout=2.0\n    )\n\n    print(f\"Response: {response}\")\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#protocol-constants","title":"Protocol Constants","text":""},{"location":"user-guide/protocol-deep-dive/#important-values","title":"Important Values","text":"<pre><code># Ports\nLIFX_UDP_PORT = 56700\n\n# Protocol version\nLIFX_PROTOCOL_VERSION = 1024\n\n# Color limits\nHUE_MAX = 65535        # Maps to 360\u00b0\nSATURATION_MAX = 65535 # Maps to 100%\nBRIGHTNESS_MAX = 65535 # Maps to 100%\nKELVIN_MIN = 1500\nKELVIN_MAX = 9000\n\n# Timing\nMAX_DURATION = 0xFFFFFFFF  # ~49 days in milliseconds\nMIN_DURATION = 0           # Instant\n</code></pre>"},{"location":"user-guide/protocol-deep-dive/#next-steps","title":"Next Steps","text":"<ul> <li>Connection Management - Connection patterns</li> <li>API Reference - Protocol API documentation</li> <li>Architecture - System architecture</li> </ul>"},{"location":"user-guide/themes/","title":"Using Themes: Practical Examples","text":"<p>Themes enable coordinated color schemes across your LIFX devices. This guide covers practical examples and patterns.</p>"},{"location":"user-guide/themes/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/themes/#apply-theme-to-all-devices","title":"Apply Theme to All Devices","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\n\nasync def apply_evening_mode():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    theme = ThemeLibrary.get(\"evening\")\n    await group.apply_theme(theme, power_on=True, duration=2.0)\n</code></pre>"},{"location":"user-guide/themes/#apply-different-themes-to-different-device-types","title":"Apply Different Themes to Different Device Types","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\n\nasync def themed_lighting():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    theme = ThemeLibrary.get(\"christmas\")\n\n    # Single-zone lights get a random color\n    for light in group.lights:\n        await light.apply_theme(theme)\n\n    # Multi-zone lights get distributed colors\n    for strip in group.multizone_lights:\n        await strip.apply_theme(theme)\n\n    # Tile devices get smooth interpolation\n    for tile in group.tiles:\n        await tile.apply_theme(theme)\n</code></pre>"},{"location":"user-guide/themes/#time-based-lighting","title":"Time-Based Lighting","text":""},{"location":"user-guide/themes/#morning-to-night-transition","title":"Morning to Night Transition","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\nimport asyncio\n\nasync def daily_lighting_schedule():\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    schedule = [\n        (\"06:00\", \"energizing\"),   # Morning\n        (\"12:00\", \"focusing\"),     # Afternoon\n        (\"18:00\", \"evening\"),      # Early evening\n        (\"21:00\", \"relaxing\"),     # Night\n        (\"23:00\", \"peaceful\"),     # Bedtime\n    ]\n\n    for time_str, theme_name in schedule:\n        theme = ThemeLibrary.get(theme_name)\n        await group.apply_theme(theme, duration=2.0)\n        # In production, schedule this with APScheduler or similar\n        await asyncio.sleep(2.0)  # Demo delay\n</code></pre>"},{"location":"user-guide/themes/#holiday-decorations","title":"Holiday Decorations","text":""},{"location":"user-guide/themes/#holiday-mode-manager","title":"Holiday Mode Manager","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\nfrom datetime import datetime\n\nasync def activate_holiday_theme():\n    \"\"\"Apply appropriate holiday theme based on current month.\"\"\"\n    month = datetime.now().month\n\n    holiday_map = {\n        3: \"shamrock\",        # March: St. Patrick's Day\n        10: \"halloween\",      # October\n        11: \"thanksgiving\",   # November\n        12: \"christmas\",      # December\n    }\n\n    theme_name = holiday_map.get(month)\n    if not theme_name:\n        return\n\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    theme = ThemeLibrary.get(theme_name)\n    await group.apply_theme(theme, power_on=True)\n</code></pre>"},{"location":"user-guide/themes/#multi-room-holiday-setup","title":"Multi-Room Holiday Setup","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\n\nasync def decorate_house_for_christmas():\n    \"\"\"Apply Christmas theme throughout the house.\"\"\"\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    theme = ThemeLibrary.get(\"christmas\")\n\n    # Living room: full brightness\n    for light in group.lights:\n        if \"living\" in light.label.lower():\n            await light.apply_theme(theme, power_on=True, duration=1.0)\n\n    # Bedroom: dimmer\n    for light in group.lights:\n        if \"bedroom\" in light.label.lower():\n            dim_theme = ThemeLibrary.get(\"peaceful\")\n            await light.apply_theme(dim_theme, power_on=True, duration=1.0)\n\n    # Strips and tiles throughout\n    for strip in group.multizone_lights:\n        await strip.apply_theme(theme, power_on=True, duration=1.5)\n\n    for tile in group.tiles:\n        await tile.apply_theme(theme, power_on=True, duration=1.5)\n</code></pre>"},{"location":"user-guide/themes/#dynamic-theme-transitions","title":"Dynamic Theme Transitions","text":""},{"location":"user-guide/themes/#smooth-theme-cycling","title":"Smooth Theme Cycling","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\nimport asyncio\n\nasync def cycle_moods():\n    \"\"\"Smoothly transition between mood themes.\"\"\"\n    mood_themes = [\n        \"peaceful\",\n        \"relaxing\",\n        \"mellow\",\n        \"cheerful\",\n        \"energizing\",\n    ]\n\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    for theme_name in mood_themes:\n        theme = ThemeLibrary.get(theme_name)\n        await group.apply_theme(theme, duration=2.0)\n        await asyncio.sleep(2.5)  # Wait for transition + 0.5s delay\n</code></pre>"},{"location":"user-guide/themes/#theme-playlist","title":"Theme Playlist","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\nimport asyncio\n\nasync def theme_playlist(themes: list[str], duration: float = 5.0):\n    \"\"\"Apply a sequence of themes with configurable timing.\"\"\"\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    for theme_name in themes:\n        try:\n            theme = ThemeLibrary.get(theme_name)\n            await group.apply_theme(theme, duration=1.0)\n            await asyncio.sleep(duration)\n        except KeyError:\n            print(f\"Theme '{theme_name}' not found, skipping\")\n\n# Usage:\n# await theme_playlist([\"evening\", \"relaxing\", \"peaceful\"], duration=10.0)\n</code></pre>"},{"location":"user-guide/themes/#room-specific-themes","title":"Room-Specific Themes","text":""},{"location":"user-guide/themes/#multi-room-coordination","title":"Multi-Room Coordination","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\nimport asyncio\n\nasync def set_room_theme(room_name: str, theme_name: str):\n    \"\"\"Apply theme to all lights in a specific room (group).\"\"\"\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    theme = ThemeLibrary.get(theme_name)\n    groups = await group.organize_by_group()\n\n    if room_name in groups:\n        room_lights = groups[\"room_name\"]\n\n    for light in room_lights.lights:\n        await light.apply_theme(theme, power_on=True)\n\n    for strip in room_lights.multizone_lights:\n        await strip.apply_theme(theme, power_on=True)\n\n# Usage:\n# await set_room_theme(\"bedroom\", \"peaceful\")\n# await set_room_theme(\"kitchen\", \"focusing\")\n</code></pre>"},{"location":"user-guide/themes/#home-scene-presets","title":"Home Scene Presets","text":"<pre><code>from lifx import discover, ThemeLibrary\n\nasync def activate_scene(scene: str):\n    \"\"\"Activate a pre-defined home scene.\"\"\"\n    scenes = {\n        \"movie_night\": {\n            \"living_room\": \"stardust\",\n            \"kitchen\": \"evening\",\n            \"bedroom\": \"peaceful\",\n        },\n        \"date_night\": {\n            \"living_room\": \"romantic\",\n            \"bedroom\": \"romance\",\n        },\n        \"party\": {\n            \"living_room\": \"party\",\n            \"kitchen\": \"energizing\",\n        },\n        \"focus\": {\n            \"home_office\": \"focusing\",\n            \"kitchen\": \"energizing\",\n        },\n    }\n\n    if scene not in scenes:\n        print(f\"Scene '{scene}' not found\")\n        return\n\n    devices = []\n    async for device in discover():\n        devices.append(device)\n    group = DeviceGroup(devices)\n\n    groups = group.organize_by_group()\n\n    for room, theme_name in scenes[scene].items():\n        if room not in groups:\n            continue\n\n        room_lights = groups[\"room\"]\n        theme = ThemeLibrary.get(theme_name)\n\n        for light in room_lights.lights:\n            await light.apply_theme(theme, power_on=True, duration=1.5)\n\n        for strip in room_lights.multizone_lights:\n            await strip.apply_theme(theme, power_on=True, duration=1.5)\n\n# Usage:\n# await activate_scene(\"movie_night\")\n# await activate_scene(\"party\")\n</code></pre>"},{"location":"user-guide/themes/#custom-themes","title":"Custom Themes","text":""},{"location":"user-guide/themes/#create-branded-theme","title":"Create Branded Theme","text":"<pre><code>from lifx import HSBK, Theme, discover, DeviceGroup\n\n# Create corporate branding theme\ncorporate_theme = Theme([\n    HSBK(hue=220, saturation=0.8, brightness=0.9, kelvin=4000),  # Professional blue\n    HSBK(hue=0, saturation=0.7, brightness=0.8, kelvin=4000),     # Corporate red\n    HSBK(hue=200, saturation=0.5, brightness=0.7, kelvin=4000),   # Light blue\n])\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait group.apply_theme(corporate_theme)\n</code></pre>"},{"location":"user-guide/themes/#sunset-gradient","title":"Sunset Gradient","text":"<pre><code>from lifx import HSBK, Theme, discover, DeviceGroup\n\n# Create sunset-inspired gradient\nsunset_theme = Theme([\n    HSBK(hue=45, saturation=1.0, brightness=1.0, kelvin=3000),   # Orange\n    HSBK(hue=15, saturation=0.9, brightness=0.9, kelvin=2700),   # Deep orange\n    HSBK(hue=0, saturation=0.8, brightness=0.8, kelvin=2500),    # Red\n    HSBK(hue=320, saturation=0.7, brightness=0.7, kelvin=2400),  # Deep red\n])\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nawait group.apply_theme(sunset_theme, duration=3.0)\n</code></pre>"},{"location":"user-guide/themes/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/themes/#robust-theme-application","title":"Robust Theme Application","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary, LifxTimeoutError, LifxDeviceNotFoundError\n\nasync def safe_apply_theme(theme_name: str):\n    \"\"\"Apply theme with comprehensive error handling.\"\"\"\n    try:\n        # Validate theme exists\n        theme = ThemeLibrary.get(theme_name)\n    except KeyError as e:\n        print(f\"Theme error: {e}\")\n        return False\n\n    try:\n        devices = []\n        async for device in discover():\n            devices.append(device)\n        group = DeviceGroup(devices)\n\n        if not group.devices:\n            print(\"No lights found\")\n            return False\n\n        await group.apply_theme(theme, power_on=True, duration=1.5)\n        print(f\"Successfully applied '{theme_name}' theme\")\n        return True\n\n    except LifxTimeoutError:\n        print(\"Timeout: Devices did not respond in time\")\n        return False\n    except LifxDeviceNotFoundError:\n        print(\"Device error: Could not reach device\")\n        return False\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return False\n</code></pre>"},{"location":"user-guide/themes/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/themes/#batch-operations","title":"Batch Operations","text":"<p>When applying themes to many devices, use <code>DeviceGroup.apply_theme()</code> for concurrent execution:</p> <pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\ntheme = ThemeLibrary.get(\"evening\")\n# All devices updated concurrently\nawait group.apply_theme(theme)\n</code></pre>"},{"location":"user-guide/themes/#avoid-rapid-transitions","title":"Avoid Rapid Transitions","text":"<pre><code>from lifx import discover, DeviceGroup, ThemeLibrary\nimport asyncio\n\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\nthemes = [\"evening\", \"relaxing\", \"peaceful\"]\n\nfor theme_name in themes:\n    theme = ThemeLibrary.get(theme_name)\n    await group.apply_theme(theme, duration=2.0)\n    # Wait for transition to complete\n    await asyncio.sleep(2.5)\n</code></pre>"},{"location":"user-guide/themes/#see-also","title":"See Also","text":"<ul> <li>Themes API Reference - Complete API documentation</li> <li>Quick Start: Themes - Simple examples</li> <li>Colors Guide - Working with HSBK colors</li> <li>Device Classes - Device-specific documentation</li> </ul>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Common issues and solutions when working with lifx.</p>"},{"location":"user-guide/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Discovery Issues</li> <li>Connection Problems</li> <li>Timeout Errors</li> <li>Performance Issues</li> <li>Debugging Tips</li> </ul>"},{"location":"user-guide/troubleshooting/#discovery-issues","title":"Discovery Issues","text":""},{"location":"user-guide/troubleshooting/#no-devices-found","title":"No Devices Found","text":"<p>Symptom: <code>discover()</code> returns an empty group</p> <p>Common Causes:</p> <ol> <li> <p>Devices not on same network <pre><code># Check network connectivity\nimport asyncio\nfrom lifx.network.discovery import discover_devices\n\ndevices = await discover_devices(timeout=5.0)\nprint(f\"Found {len(devices)} devices\")\n</code></pre></p> </li> <li> <p>Firewall blocking UDP port 56700 <pre><code># Linux: Check if port is open\nsudo netstat -an | grep 56700\n\n# Allow UDP on port 56700\nsudo ufw allow 56700/udp\n</code></pre></p> </li> <li> <p>Broadcast address incorrect</p> </li> </ol> <p>Try different broadcast addresses:</p> <pre><code>from lifx import discover, DeviceGroup\n\n# Default (255.255.255.255)\ndevices = []\nasync for device in discover():\n    devices.append(device)\ngroup = DeviceGroup(devices)\n\n# Network-specific (e.g., 192.168.1.255)\ndevices = []\nasync for device in discover(broadcast_address=\"192.168.1.255\"):\n    devices.append(device)\ngroup = DeviceGroup(devices)\n</code></pre> <p>Solution:</p> <pre><code>import asyncio\nfrom lifx.network.discovery import discover_devices\n\nasync def diagnose_discovery():\n    print(\"Attempting discovery...\")\n\n    # Try with extended timeout\n    devices = await discover_devices(\n        timeout=10.0,\n        broadcast_address=\"255.255.255.255\"\n    )\n\n    if not devices:\n        print(\"No devices found. Check:\")\n        print(\"1. Devices are powered on\")\n        print(\"2. Devices are on the same network\")\n        print(\"3. Firewall allows UDP port 56700\")\n        print(\"4. Try a network-specific broadcast address\")\n    else:\n        print(f\"Found {len(devices)} devices:\")\n        for device in devices:\n            print(f\"  - {device.serial} at {device.ip}\")\n\nasyncio.run(diagnose_discovery())\n</code></pre>"},{"location":"user-guide/troubleshooting/#partial-device-discovery","title":"Partial Device Discovery","text":"<p>Symptom: Only some devices discovered</p> <p>Causes:</p> <ul> <li>Devices on different subnets</li> <li>Network congestion</li> <li>Devices slow to respond</li> </ul> <p>Solution:</p> <pre><code>async def thorough_discovery():\n    # Multiple discovery passes with different timeouts\n    all_devices = set()\n\n    for timeout in [3.0, 5.0, 10.0]:\n        devices = await discover_devices(timeout=timeout)\n        for device in devices:\n            all_devices.add((device.serial, device.ip))\n\n    print(f\"Total devices found: {len(all_devices)}\")\n    return all_devices\n</code></pre>"},{"location":"user-guide/troubleshooting/#connection-problems","title":"Connection Problems","text":""},{"location":"user-guide/troubleshooting/#connection-refused","title":"Connection Refused","text":"<p>Symptom: <code>LifxConnectionError: Connection refused</code></p> <p>Causes:</p> <ul> <li>Incorrect IP address</li> <li>Device powered off</li> <li>Network unreachable</li> </ul> <p>Solution:</p> <pre><code>from lifx import Light, LifxConnectionError\nimport asyncio\n\nasync def test_connection(ip: str):\n    try:\n        async with await Light.from_ip(ip) as light:\n            label = await light.get_label()\n            print(f\"Connected to: {label}\")\n            return True\n\n    except LifxConnectionError as e:\n        print(f\"Connection failed: {e}\")\n        print(\"Check:\")\n        print(\"1. Device IP is correct\")\n        print(\"2. Device is powered on\")\n        print(\"3. Device is reachable (try ping)\")\n        return False\n\n# Test connectivity\nasyncio.run(test_connection(\"192.168.1.100\"))\n</code></pre>"},{"location":"user-guide/troubleshooting/#connection-drops","title":"Connection Drops","text":"<p>Symptom: Intermittent <code>LifxConnectionError</code> or <code>LifxNetworkError</code></p> <p>Causes:</p> <ul> <li>WiFi signal weak</li> <li>Network congestion</li> <li>Device overloaded</li> </ul> <p>Solution:</p> <pre><code>import asyncio\nfrom lifx import Light, LifxError\n\nasync def resilient_operation(ip: str, max_retries: int = 3):\n    \"\"\"Retry operations with exponential backoff\"\"\"\n    async with await Light.from_ip(ip) as light:\n        for attempt in range(max_retries):\n            try:\n                await light.set_power(True)\n                print(\"Success!\")\n                return\n            except LifxError as e:\n                wait_time = 2 ** attempt  # 1s, 2s, 4s\n                print(f\"Attempt {attempt + 1} failed: {e}\")\n\n                if attempt &lt; max_retries - 1:\n                    print(f\"Retrying in {wait_time}s...\")\n                    await asyncio.sleep(wait_time)\n\n    print(\"All retries exhausted\")\n</code></pre>"},{"location":"user-guide/troubleshooting/#timeout-errors","title":"Timeout Errors","text":""},{"location":"user-guide/troubleshooting/#request-timeouts","title":"Request Timeouts","text":"<p>Symptom: <code>LifxTimeoutError: Request timed out after X seconds</code></p> <p>Causes:</p> <ul> <li>Device slow to respond</li> <li>Network latency high</li> <li>Device busy processing other requests</li> </ul> <p>Solution:</p> <pre><code>from lifx import Light\n\n# Increase timeout for slow devices\nasync with await Light.from_ip(ip, timeout=5.0) as light:\n    # get_color() returns (color, power, label)\n    color, power, label = await light.get_color()\n</code></pre>"},{"location":"user-guide/troubleshooting/#discovery-timeout-too-short","title":"Discovery Timeout Too Short","text":"<p>Symptom: Some devices not found</p> <p>Solution:</p> <pre><code>from lifx import discover\n\n# Increase discovery timeout\nasync with discover(timeout=10.0) as group:  # Default is 3.0\n    print(f\"Found {len(group.devices)} devices\")\n</code></pre>"},{"location":"user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"user-guide/troubleshooting/#slow-operations","title":"Slow Operations","text":"<p>Symptom: Operations take longer than expected</p> <p>Diagnosis:</p> <pre><code>import time\nfrom lifx import Light\n\nasync def measure_latency():\n    async with await Light.from_ip(\"192.168.1.100\") as light:\n        # Measure single request\n        start = time.time()\n        await light.get_label()\n        elapsed = time.time() - start\n        print(f\"Single request: {elapsed*1000:.2f}ms\")\n\n        # Measure sequential requests\n        start = time.time()\n        for _ in range(10):\n            await light.get_label()\n        elapsed = time.time() - start\n        print(f\"10 sequential: {elapsed*1000:.2f}ms ({elapsed*100:.2f}ms avg)\")\n\n        # Measure concurrent requests\n        start = time.time()\n        await asyncio.gather(*[light.get_label() for _ in range(10)])\n        elapsed = time.time() - start\n        print(f\"10 concurrent: {elapsed*1000:.2f}ms\")\n</code></pre> <p>Common Causes:</p> <ol> <li>Sequential instead of concurrent operations</li> </ol> <p>Slow approach (sequential):    <pre><code>for device in devices:\n    await device.set_color(Colors.BLUE)\n</code></pre></p> <p>Fast approach (concurrent):    <pre><code>await asyncio.gather(\n    *[device.set_color(Colors.BLUE) for device in devices]\n)\n</code></pre></p> <ol> <li>Not reusing connections</li> </ol> <p>Inefficient (creates new connection each time):    <pre><code>for i in range(10):\n    async with await Light.from_ip(ip) as light:\n        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)\n</code></pre></p> <p>Efficient (reuses connection):    <pre><code>async with await Light.from_ip(ip) as light:\n    for i in range(10):\n        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)\n</code></pre></p> <ol> <li>Need fresh data?</li> </ol> <p>Use <code>get_*()</code> methods to always fetch from the device:</p> <pre><code># Always fetch fresh data\n# get_color() returns all three values in one call\ncolor, power, label = await light.get_color()\n\n# Or fetch other device info\nversion = await light.get_version()\n</code></pre>"},{"location":"user-guide/troubleshooting/#docker-container-networking","title":"Docker / Container Networking","text":"<p>Symptom: Discovery doesn't work in Docker container</p> <p>Cause: Container network isolation</p> <p>Solution:</p> <pre><code># docker-compose.yml\nservices:\n  app:\n    network_mode: \"host\"  # Use host network for UDP broadcast\n</code></pre> <p>Or use manual device specification:</p> <pre><code># Don't rely on discovery\nfrom lifx import Light\n\nasync with await Light.from_ip(\"192.168.1.100\") as light:\n    await light.set_color(Colors.BLUE)\n</code></pre>"},{"location":"user-guide/troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"user-guide/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\n\n# Enable DEBUG logging for lifx\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Or for specific modules\nlogging.getLogger('lifx.network').setLevel(logging.DEBUG)\nlogging.getLogger('lifx.devices').setLevel(logging.DEBUG)\n</code></pre>"},{"location":"user-guide/troubleshooting/#check-product-registry","title":"Check Product Registry","text":"<pre><code>from lifx.products import get_product, get_registry\n\n# List all known products\nregistry = get_registry()\nfor product_id, product in registry.items():\n    print(f\"{product_id}: {product.name}\")\n\n# Check specific product\nproduct = get_product(27)  # LIFX A19\nif product:\n    print(f\"Name: {product.name}\")\n    print(f\"Capabilities: {product.capabilities}\")\n</code></pre>"},{"location":"user-guide/troubleshooting/#verify-device-reachability","title":"Verify Device Reachability","text":"<pre><code># Ping device\nping 192.168.1.100\n\n# Check UDP port (requires nmap)\nsudo nmap -sU -p 56700 192.168.1.100\n\n# Test with netcat\necho -n \"test\" | nc -u 192.168.1.100 56700\n</code></pre>"},{"location":"user-guide/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check GitHub Issues: github.com/Djelibeybi/lifx-async/issues</li> <li>Enable debug logging: Capture logs with <code>logging.DEBUG</code></li> <li>Provide details:</li> <li>Python version</li> <li>lifx version</li> <li>Device model and firmware version</li> <li>Network configuration</li> <li>Minimal reproduction code</li> <li>Full error traceback</li> </ol>"},{"location":"user-guide/troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Meaning Solution <code>LifxTimeoutError</code> Device didn't respond Increase timeout, check network <code>LifxConnectionError</code> Can't connect to device Check IP, firewall, device power <code>LifxDeviceNotFoundError</code> Device not discovered Check network, increase timeout <code>LifxProtocolError</code> Invalid response Update firmware, check device type <code>LifxUnsupportedCommandError</code> Device doesn't support command Check device capabilities <code>AttributeError: 'Light' has no attribute 'set_color_zones'</code> Wrong device class Use <code>MultiZoneLight</code>"},{"location":"user-guide/troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Usage - Optimization patterns</li> <li>API Reference - Complete API documentation</li> <li>FAQ - Frequently asked questions</li> </ul>"}]}