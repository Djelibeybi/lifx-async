# lifx-async

> A modern, type-safe, async Python library for controlling LIFX lights

lifx-async is a modern, type-safe, async Python library for controlling LIFX smart devices
over the local network. Built with Python's built-in asyncio for async/await patterns and
features auto-generated protocol structures from a YAML specification.

Key features:
- Zero runtime dependencies
- Full async/await support with asyncio
- Type-safe with strict Pyright validation
- Auto-generated protocol from official LIFX specification
- Supports all LIFX device types: Light, HevLight, InfraredLight, MultiZoneLight, and TileDevice
- High-level API with device discovery and batch operations
- Concurrent request handling with connection pooling


# Getting Started

# Installation

## System Requirements

- **Python**: 3.11 or higher
- **Network**: Local network access to LIFX devices
- **OS**: Linux, macOS, Windows

## Installation Methods

### Using uv (Recommended)

[`uv`](https://github.com/astral-sh/uv) is a fast Python package installer and resolver written in Rust. It's significantly faster than pip and is the recommended installation method:

```bash
uv pip install lifx-async
```

If you don't have `uv` installed yet:

```bash
# On macOS and Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# On Windows
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"

# Or with pip
pip install uv
```

### Using pip

If you prefer to use pip:

```bash
pip install lifx-async
```

### From Source

For the latest development version:

```bash
git clone https://github.com/Djelibeybi/lifx-async.git
cd lifx

# Using uv (recommended)
uv pip install -e .

# Or using pip
pip install -e .
```

### With Development Dependencies

To install with development tools (recommended for contributors):

```bash
git clone https://github.com/Djelibeybi/lifx-async.git
cd lifx

# Using uv (recommended)
uv sync

# Or using pip
pip install -e ".[dev]"
```

## Verify Installation

Test that lifx-async is installed correctly:

```python
import lifx

print(lifx.__version__)
```

Or run a quick discovery:

```python
import asyncio
from lifx import discover


async def main():
    async with discover(timeout=3.0) as group:
        print(f"Found {len(group)} devices")
        for device in group:
            label = await device.get_label()
            print(f"  - {label}")


asyncio.run(main())
```

## Troubleshooting

### Import Error

If you see `ModuleNotFoundError: No module named 'lifx'`:

1. Ensure lifx-async is installed: `uv pip list | grep lifx-async` or `pip list | grep lifx-async`
1. Check your Python version: `python --version`
1. Verify you're using the correct Python environment

### Network Discovery Issues

If discovery doesn't find devices:

1. Ensure LIFX devices are on the same network
1. Check firewall settings allow UDP broadcasts
1. Try increasing the timeout: `discover(timeout=10.0)`
1. Use direct connection if you know the IP: `Light.from_ip("192.168.1.100")`

### Permission Errors

On some systems, you may need elevated permissions for network operations:

```bash
# Linux/macOS
sudo python your_script.py

# Or add your user to the appropriate group
sudo usermod -a -G netdev $USER  # Linux
```

## Next Steps

- [Quick Start Guide](../quickstart/) - Start controlling your lights
- [API Reference](../../api/) - Complete API documentation
- [FAQ](../../faq/) - Frequently asked questions

# Quick Start

Get up and running with lifx-async in minutes!

## Basic Usage

### 1. Discover Lights

The simplest way to find and control LIFX lights:

```python
import asyncio
from lifx import discover


async def main():
    async with discover(timeout=3.0) as group:
        print(f"Found {len(group)} lights")


asyncio.run(main())
```

### 2. Control a Light

Turn on a light and change its color:

```python
import asyncio
from lifx import discover, Colors


async def main():
    async with discover() as group:
        if group.lights:
            light = group.lights[0]
            await light.set_power(True)
            await light.set_color(Colors.BLUE, duration=1.0)


asyncio.run(main())
```

### 3. Batch Operations

Control multiple lights at once:

```python
import asyncio
from lifx import discover, Colors


async def main():
    async with discover() as group:
        # Turn all lights on and blue
        await group.set_power(True)
        await group.set_color(Colors.BLUE, duration=1.0)

        # Set brightness
        await group.set_brightness(0.5)


asyncio.run(main())
```

## Common Patterns

### Direct Connection (No Discovery)

If you know the IP:

```python
import asyncio
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        await light.set_color(Colors.RED)


asyncio.run(main())
```

### Find Specific Device

Find a device by label:

```python
import asyncio
from lifx import find_lights


async def main():
    lights = await find_lights(label_contains="Bedroom")
    if lights:
        async with lights[0] as light:
            await light.set_color(Colors.WARM_WHITE)


asyncio.run(main())
```

### Color Presets

Use built-in color presets:

```python
from lifx import Colors

# Primary colors
Colors.RED
Colors.GREEN
Colors.BLUE

# White variants
Colors.WARM_WHITE
Colors.COOL_WHITE
Colors.DAYLIGHT

# Pastels
Colors.PASTEL_BLUE
Colors.PASTEL_PINK
```

### RGB to HSBK

Convert RGB values to HSBK:

```python
from lifx import HSBK

# Create color from RGB
purple = HSBK.from_rgb(128, 0, 128)
await light.set_color(purple)
```

### Effects

Create visual effects:

```python
import asyncio
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Pulse effect
        await light.pulse(Colors.RED, period=1.0, cycles=5)

        # Breathe effect (infinite)
        await light.breathe(Colors.BLUE, period=2.0, cycles=0)


asyncio.run(main())
```

## Error Handling

Always use proper error handling:

```python
import asyncio
from lifx import discover, LifxError


async def main():
    try:
        async with discover(timeout=3.0) as group:
            if not group:
                print("No devices found")
                return

            await group.set_color(Colors.GREEN)
    except LifxError as e:
        print(f"LIFX error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")


asyncio.run(main())
```

## Next Steps

- [API Reference](../../api/) - Complete API documentation
- [Architecture](../../architecture/overview/) - How lifx-async works
- [FAQ](../../faq/) - Frequently asked questions

# Themes Quick Start

Themes allow you to apply professionally-curated color palettes to your LIFX devices with a single command.

## Apply a Theme

```python
from lifx import discover, ThemeLibrary

async with discover() as lights:
    # Get a theme by name
    theme = ThemeLibrary.get("evening")

    # Apply to all devices
    await lights.apply_theme(theme)
```

## List Available Themes

```python
from lifx import ThemeLibrary

# Get all 42 theme names
themes = ThemeLibrary.list()
print(themes)

# Get themes by category
seasonal = ThemeLibrary.get_by_category("seasonal")
holidays = ThemeLibrary.get_by_category("holiday")
moods = ThemeLibrary.get_by_category("mood")
```

## Theme Categories

The library includes 42 official LIFX app themes:

- **Seasonal** (3): spring, autumn, winter
- **Holiday** (9): christmas, halloween, hanukkah, kwanzaa, shamrock, thanksgiving, calaveras, pumpkin, santa
- **Mood** (16): peaceful, serene, relaxing, mellow, gentle, soothing, blissful, cheerful, romantic, romance, love, energizing, exciting, epic, intense, powerful
- **Ambient** (6): dream, fantasy, spacey, stardust, zombie, party
- **Functional** (3): focusing, evening, bias_lighting
- **Atmosphere** (3): hygge, tranquil, sports

## Common Options

```python
from lifx import discover, ThemeLibrary

async with discover() as lights:
    theme = ThemeLibrary.get("christmas")

    # Apply with options
    await lights.apply_theme(
        theme,
        power_on=True,      # Turn on lights before applying
        duration=1.5        # Transition duration in seconds
    )
```

## Create a Custom Theme

```python
from lifx import HSBK, Theme, discover

# Create custom theme with specific colors
custom_theme = Theme([
    HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500),      # Red
    HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500),    # Green
    HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500),    # Blue
])

async with discover() as lights:
    await lights.apply_theme(custom_theme, power_on=True)
```

## Next Steps

- See [Themes API Reference](../../api/themes/) for detailed API documentation
- See [Device Classes](../../api/devices/) for device-specific `apply_theme()` methods
- See [Color Utilities](../../api/colors/) for HSBK color representation

# Getting Started with Light Effects

The Light Effects Framework provides a comprehensive system for creating and managing visual effects on LIFX devices. This guide will help you get started with the built-in effects and show you common patterns for using the effects system.

## Overview

The effects framework consists of three main components:

- **Conductor**: Central orchestrator that manages effect lifecycle and state
- **Effects**: Pre-built effect classes (EffectPulse, EffectColorloop) and base class for custom effects
- **State Management**: Automatic capture and restoration of device state before and after effects

## Installation

The effects framework is included with lifx-async 1.3.0+. No additional installation is required:

```bash
# Using uv (recommended)
uv pip install lifx-async

# Or using pip
pip install lifx-async
```

## Basic Usage

### Your First Pulse Effect

The simplest way to use the effects framework is with the `EffectPulse` class:

```python
import asyncio
from lifx import discover
from lifx.effects import Conductor, EffectPulse

async def main():
    # Discover lights on your network
    async with discover() as group:
        if not group.lights:
            print("No lights found")
            return

        # Create a conductor to manage effects
        conductor = Conductor()

        # Create a blink effect
        effect = EffectPulse(mode='blink', cycles=5)

        # Start the effect on all lights
        await conductor.start(effect, group.lights)

        # Wait for effect to complete (5 cycles * 1 second)
        await asyncio.sleep(6)

        print("Effect complete - lights restored to original state")

asyncio.run(main())
```

### Your First ColorLoop Effect

The `EffectColorloop` creates a continuous rainbow effect:

```python
import asyncio
from lifx import discover
from lifx.effects import Conductor, EffectColorloop

async def main():
    async with discover() as group:
        if not group.lights:
            print("No lights found")
            return

        conductor = Conductor()

        # Create a rainbow effect
        effect = EffectColorloop(
            period=30,      # 30 seconds per full cycle
            change=20,      # Change hue by 20 degrees each step
            spread=60       # Spread colors across devices
        )

        # Start the effect
        await conductor.start(effect, group.lights)

        # Let it run for 2 minutes
        await asyncio.sleep(120)

        # Stop and restore lights to original state
        await conductor.stop(group.lights)

asyncio.run(main())
```

## Key Concepts

### Conductor

The `Conductor` is the central orchestrator that:

- Captures device state before effects run
- Powers on devices if needed
- Executes effects
- Restores devices to original state when done

You typically create one conductor instance and reuse it for multiple effects.

### Effect State Management

The effects framework automatically:

1. **Captures** current state (power, color, zones) before effect starts
1. **Powers on** devices if they're off (configurable)
1. **Executes** the effect
1. **Restores** all devices to their pre-effect state

This happens completely automatically - you don't need to manage state yourself.

### Effect Completion

There are two ways effects complete:

1. **Automatic** - Pulse effects complete after their cycles finish
1. **Manual** - ColorLoop effects run continuously until `conductor.stop()` is called

## Common Patterns

### Using Specific Lights

You can apply effects to specific lights instead of all discovered devices:

```python
async with discover() as group:
    conductor = Conductor()

    # Get lights by label
    bedroom_lights = [
        light for light in group.lights
        if "Bedroom" in await light.get_label()
    ]

    # Apply effect only to bedroom lights
    effect = EffectPulse(mode='breathe', cycles=3)
    await conductor.start(effect, bedroom_lights)
    await asyncio.sleep(4)
```

### Sequential Effects

You can run multiple effects one after another:

```python
conductor = Conductor()

# First effect: blink
effect1 = EffectPulse(mode='blink', cycles=3)
await conductor.start(effect1, group.lights)
await asyncio.sleep(4)

# Second effect: breathe
effect2 = EffectPulse(mode='breathe', cycles=2)
await conductor.start(effect2, group.lights)
await asyncio.sleep(5)
```

Note: The conductor automatically restores state between effects, so each effect starts with the original device state.

### Concurrent Effects on Different Devices

You can run different effects on different groups of lights simultaneously:

```python
conductor = Conductor()

# Split lights into two groups
group1 = group.lights[:len(group.lights)//2]
group2 = group.lights[len(group.lights)//2:]

# Start both effects concurrently
effect1 = EffectPulse(mode='blink')
effect2 = EffectColorloop(period=20)

await conductor.start(effect1, group1)
await conductor.start(effect2, group2)

# Let them run
await asyncio.sleep(30)

# Stop all
await conductor.stop(group.lights)
```

### Custom Colors

Both pulse and colorloop effects support custom colors:

```python
from lifx import HSBK

# Create custom color
red = HSBK.from_rgb(255, 0, 0)
blue = HSBK.from_rgb(0, 0, 255)

# Pulse with custom color
effect = EffectPulse(mode='breathe', cycles=5, color=red)
await conductor.start(effect, group.lights)
await asyncio.sleep(6)
```

### Checking Running Effects

You can check what effect is currently running on a device:

```python
conductor = Conductor()
effect = EffectColorloop(period=30)
await conductor.start(effect, group.lights)

# Check what's running
for light in group.lights:
    current = conductor.effect(light)
    if current:
        print(f"{light.label}: {type(current).__name__}")
    else:
        print(f"{light.label}: idle")
```

## Best Practices

### 1. Use a Single Conductor

Create one conductor instance and reuse it throughout your application:

```python
# Good
conductor = Conductor()
await conductor.start(effect1, lights)
await conductor.start(effect2, lights)

# Not recommended - creates unnecessary overhead
conductor1 = Conductor()
await conductor1.start(effect1, lights)
conductor2 = Conductor()
await conductor2.start(effect2, lights)
```

### 2. Always Wait for Completion

For pulse effects, wait for the effect duration before starting another:

```python
effect = EffectPulse(mode='blink', period=1.0, cycles=5)
await conductor.start(effect, lights)
# Wait for effect to complete
await asyncio.sleep(5 * 1.0 + 0.5)  # cycles * period + buffer
```

### 3. Stop ColorLoop Effects Explicitly

ColorLoop effects run indefinitely, so always call `conductor.stop()`:

```python
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
await asyncio.sleep(60)
# Must explicitly stop
await conductor.stop(lights)
```

### 4. Handle Discovery Failures

Always check if lights were found before attempting effects:

```python
async with discover() as group:
    if not group.lights:
        print("No lights found on network")
        return

    # Safe to use effects
    conductor = Conductor()
    # ...
```

### 5. Use Context Managers

The discovery context manager ensures proper cleanup:

```python
# Good - automatic cleanup
async with discover() as group:
    conductor = Conductor()
    await conductor.start(effect, group.lights)

# The context manager handles cleanup automatically
```

## Complete Examples

### Notification Effect

Use effects to create a notification system:

```python
async def notify(lights: list, level: str = 'info'):
    """Flash lights to indicate a notification."""
    conductor = Conductor()

    if level == 'info':
        # Blue breathe
        color = HSBK.from_rgb(0, 0, 255)
        effect = EffectPulse(mode='breathe', cycles=2, color=color)
    elif level == 'warning':
        # Orange blink
        color = HSBK.from_rgb(255, 165, 0)
        effect = EffectPulse(mode='blink', cycles=3, color=color)
    elif level == 'error':
        # Red strobe
        color = HSBK.from_rgb(255, 0, 0)
        effect = EffectPulse(mode='strobe', cycles=10, color=color)

    await conductor.start(effect, lights)
    await asyncio.sleep(4)  # Wait for completion

# Usage
async with discover() as group:
    await notify(group.lights, level='warning')
```

### Party Mode

Cycle through different effects:

```python
async def party_mode(lights: list, duration: int = 60):
    """Run various effects for a party."""
    conductor = Conductor()
    end_time = asyncio.get_event_loop().time() + duration

    effects = [
        EffectColorloop(period=20, change=30, spread=60),
        EffectPulse(mode='strobe', cycles=20),
        EffectColorloop(period=15, change=45, brightness=0.8),
    ]

    effect_idx = 0
    while asyncio.get_event_loop().time() < end_time:
        effect = effects[effect_idx % len(effects)]

        if isinstance(effect, EffectColorloop):
            await conductor.start(effect, lights)
            await asyncio.sleep(20)
            await conductor.stop(lights)
        else:
            await conductor.start(effect, lights)
            await asyncio.sleep(3)

        effect_idx += 1

    # Ensure everything is stopped and restored
    await conductor.stop(lights)

# Usage
async with discover() as group:
    await party_mode(group.lights, duration=120)
```

## Next Steps

- See [Effects Reference](../../api/effects/) for detailed documentation on all effect parameters
- See [Custom Effects](../../user-guide/effects-custom/) to learn how to create your own effects
- See [Effects Architecture](../../architecture/effects-architecture/) to understand how the system works internally
- See [Troubleshooting](../../user-guide/effects-troubleshooting/) for common issues and solutions
# User Guide

# Using Themes: Practical Examples

Themes enable coordinated color schemes across your LIFX devices. This guide covers practical examples and patterns.

## Basic Usage

### Apply Theme to All Devices

```python
from lifx import discover, ThemeLibrary

async def apply_evening_mode():
    async with discover() as lights:
        theme = ThemeLibrary.get("evening")
        await lights.apply_theme(theme, power_on=True, duration=2.0)
```

### Apply Different Themes to Different Device Types

```python
from lifx import discover, ThemeLibrary

async def themed_lighting():
    async with discover() as lights:
        theme = ThemeLibrary.get("christmas")

        # Single-zone lights get a random color
        for light in lights.lights:
            await light.apply_theme(theme)

        # Multi-zone lights get distributed colors
        for strip in lights.multizone_lights:
            await strip.apply_theme(theme)

        # Tile devices get smooth interpolation
        for tile in lights.tiles:
            await tile.apply_theme(theme)
```

## Time-Based Lighting

### Morning to Night Transition

```python
from lifx import discover, ThemeLibrary
import asyncio

async def daily_lighting_schedule():
    async with discover() as lights:
        schedule = [
            ("06:00", "energizing"),   # Morning
            ("12:00", "focusing"),     # Afternoon
            ("18:00", "evening"),      # Early evening
            ("21:00", "relaxing"),     # Night
            ("23:00", "peaceful"),     # Bedtime
        ]

        for time_str, theme_name in schedule:
            theme = ThemeLibrary.get(theme_name)
            await lights.apply_theme(theme, duration=2.0)
            # In production, schedule this with APScheduler or similar
            await asyncio.sleep(2.0)  # Demo delay
```

## Holiday Decorations

### Holiday Mode Manager

```python
from lifx import discover, ThemeLibrary
from datetime import datetime

async def activate_holiday_theme():
    """Apply appropriate holiday theme based on current month."""
    month = datetime.now().month

    holiday_map = {
        3: "shamrock",        # March: St. Patrick's Day
        10: "halloween",      # October
        11: "thanksgiving",   # November
        12: "christmas",      # December
    }

    theme_name = holiday_map.get(month)
    if not theme_name:
        return

    async with discover() as lights:
        theme = ThemeLibrary.get(theme_name)
        await lights.apply_theme(theme, power_on=True)
```

### Multi-Room Holiday Setup

```python
from lifx import discover, ThemeLibrary

async def decorate_house_for_christmas():
    """Apply Christmas theme throughout the house."""
    async with discover() as lights:
        theme = ThemeLibrary.get("christmas")

        # Living room: full brightness
        for light in lights.lights:
            if "living" in light.label.lower():
                await light.apply_theme(theme, power_on=True, duration=1.0)

        # Bedroom: dimmer
        for light in lights.lights:
            if "bedroom" in light.label.lower():
                dim_theme = ThemeLibrary.get("peaceful")
                await light.apply_theme(dim_theme, power_on=True, duration=1.0)

        # Strips and tiles throughout
        for strip in lights.multizone_lights:
            await strip.apply_theme(theme, power_on=True, duration=1.5)

        for tile in lights.tiles:
            await tile.apply_theme(theme, power_on=True, duration=1.5)
```

## Dynamic Theme Transitions

### Smooth Theme Cycling

```python
from lifx import discover, ThemeLibrary
import asyncio

async def cycle_moods():
    """Smoothly transition between mood themes."""
    mood_themes = [
        "peaceful",
        "relaxing",
        "mellow",
        "cheerful",
        "energizing",
    ]

    async with discover() as lights:
        for theme_name in mood_themes:
            theme = ThemeLibrary.get(theme_name)
            await lights.apply_theme(theme, duration=2.0)
            await asyncio.sleep(2.5)  # Wait for transition + 0.5s delay
```

### Theme Playlist

```python
from lifx import discover, ThemeLibrary
import asyncio

async def theme_playlist(themes: list[str], duration: float = 5.0):
    """Apply a sequence of themes with configurable timing."""
    async with discover() as lights:
        for theme_name in themes:
            try:
                theme = ThemeLibrary.get(theme_name)
                await lights.apply_theme(theme, duration=1.0)
                await asyncio.sleep(duration)
            except KeyError:
                print(f"Theme '{theme_name}' not found, skipping")

# Usage:
# await theme_playlist(["evening", "relaxing", "peaceful"], duration=10.0)
```

## Room-Specific Themes

### Multi-Room Coordination

```python
from lifx import discover, ThemeLibrary
import asyncio

async def set_room_theme(room_name: str, theme_name: str):
    """Apply theme to all lights in a specific room (group)."""
    async with discover() as lights:
        theme = ThemeLibrary.get(theme_name)
        groups = await lights.organize_by_group()

        if room_name in groups:
            room_lights = groups["room_name"]

        for light in room_lights.lights:
            await light.apply_theme(theme, power_on=True)

        for strip in room_lights.multizone_lights:
            await strip.apply_theme(theme, power_on=True)

# Usage:
# await set_room_theme("bedroom", "peaceful")
# await set_room_theme("kitchen", "focusing")
```

### Home Scene Presets

```python
from lifx import discover, ThemeLibrary

async def activate_scene(scene: str):
    """Activate a pre-defined home scene."""
    scenes = {
        "movie_night": {
            "living_room": "stardust",
            "kitchen": "evening",
            "bedroom": "peaceful",
        },
        "date_night": {
            "living_room": "romantic",
            "bedroom": "romance",
        },
        "party": {
            "living_room": "party",
            "kitchen": "energizing",
        },
        "focus": {
            "home_office": "focusing",
            "kitchen": "energizing",
        },
    }

    if scene not in scenes:
        print(f"Scene '{scene}' not found")
        return

    async with discover() as lights:

        groups = lights.organize_by_group()

        for room, theme_name in scenes[scene].items():
            if room not in groups:
                continue

            room_lights = groups["room"]
            theme = ThemeLibrary.get(theme_name)

            for light in room_lights.lights:
                await light.apply_theme(theme, power_on=True, duration=1.5)

            for strip in room_lights.multizone_lights:
                await strip.apply_theme(theme, power_on=True, duration=1.5)

# Usage:
# await activate_scene("movie_night")
# await activate_scene("party")
```

## Custom Themes

### Create Branded Theme

```python
from lifx import HSBK, Theme, discover

# Create corporate branding theme
corporate_theme = Theme([
    HSBK(hue=220, saturation=0.8, brightness=0.9, kelvin=4000),  # Professional blue
    HSBK(hue=0, saturation=0.7, brightness=0.8, kelvin=4000),     # Corporate red
    HSBK(hue=200, saturation=0.5, brightness=0.7, kelvin=4000),   # Light blue
])

async with discover() as lights:
    await lights.apply_theme(corporate_theme)
```

### Sunset Gradient

```python
from lifx import HSBK, Theme, discover

# Create sunset-inspired gradient
sunset_theme = Theme([
    HSBK(hue=45, saturation=1.0, brightness=1.0, kelvin=3000),   # Orange
    HSBK(hue=15, saturation=0.9, brightness=0.9, kelvin=2700),   # Deep orange
    HSBK(hue=0, saturation=0.8, brightness=0.8, kelvin=2500),    # Red
    HSBK(hue=320, saturation=0.7, brightness=0.7, kelvin=2400),  # Deep red
])

async with discover() as lights:
    await lights.apply_theme(sunset_theme, duration=3.0)
```

## Error Handling

### Robust Theme Application

```python
from lifx import discover, ThemeLibrary, LifxTimeoutError, LifxDeviceNotFoundError

async def safe_apply_theme(theme_name: str):
    """Apply theme with comprehensive error handling."""
    try:
        # Validate theme exists
        theme = ThemeLibrary.get(theme_name)
    except KeyError as e:
        print(f"Theme error: {e}")
        return False

    try:
        async with discover() as lights:
            if not lights:
                print("No lights found")
                return False

            await lights.apply_theme(theme, power_on=True, duration=1.5)
            print(f"Successfully applied '{theme_name}' theme")
            return True

    except LifxTimeoutError:
        print("Timeout: Devices did not respond in time")
        return False
    except LifxDeviceNotFoundError:
        print("Device error: Could not reach device")
        return False
    except Exception as e:
        print(f"Unexpected error: {e}")
        return False
```

## Performance Tips

### Batch Operations

When applying themes to many devices, use `DeviceGroup.apply_theme()` for concurrent execution:

```python
from lifx import discover, ThemeLibrary

async with discover() as lights:
    theme = ThemeLibrary.get("evening")
    # All devices updated concurrently
    await lights.apply_theme(theme)
```

### Avoid Rapid Transitions

```python
from lifx import discover, ThemeLibrary
import asyncio

async with discover() as lights:
    themes = ["evening", "relaxing", "peaceful"]

    for theme_name in themes:
        theme = ThemeLibrary.get(theme_name)
        await lights.apply_theme(theme, duration=2.0)
        # Wait for transition to complete
        await asyncio.sleep(2.5)
```

## See Also

- [Themes API Reference](../../api/themes/) - Complete API documentation
- [Quick Start: Themes](../../getting-started/themes/) - Simple examples
- [Colors Guide](../../api/colors/) - Working with HSBK colors
- [Device Classes](../../api/devices/) - Device-specific documentation

# Advanced Usage

This guide covers advanced lifx patterns and techniques for building robust LIFX integrations.

## Table of Contents

- [Storing State](#storing-state)
- [Connection Management](#connection-management)
- [Concurrency Patterns](#concurrency-patterns)
- [Error Handling](#error-handling)
- [Device Capabilities](#device-capabilities)
- [Custom Effects](#custom-effects)
- [Performance Optimization](#performance-optimization)

## Storing State

Device properties return stored state as `(value, timestamp)` tuples, giving you explicit control over data freshness.

lifx-async tries to automatically populate initial state values when a device is used as an async context manager.

Non-state related properties including `version`, `model`, `min_kelvin`, and `max_kelvin` do not return a timestamp.

### Understanding Stored State

All device state properties return timestamped tuples:

```python
from lifx import Light
import time

async def check_stored_state():
    async with await Light.from_ip("192.168.1.100") as light:
        # Property returns tuple with (value, timestamp)
        result = light.label
        if result:
            label_text, timestamp = result
            age = time.time() - timestamp
            print(f"Label: {label_text} (stored {age:.1f}s ago)")
        else:
            print("No stored label - fetching from device")
            label_text = await light.get_label()
            print(f"Label: {label_text}")
```

### Fetching Fresh Data

Use the `get_*()` methods to always fetch from the device:

```python
async def always_fresh():
    async with await Light.from_ip("192.168.1.100") as light:
        # Always fetches from device
        # Note: get_color() returns a tuple of (color, power, label)
        color, power, label = await light.get_color()

        # Get other device info
        version = await light.get_version()

        # Properties also get updated with new timestamp
        stored_color = light.color  # Now has fresh data
        stored_label = light.label  # Also updated from get_color()
```

### Checking Data Freshness

Determine if stored data is still relevant:

```python
import time

async def use_fresh_or_stored():
    async with await Light.from_ip("192.168.1.100") as light:
        MAX_AGE = 5.0  # Maximum age in seconds

        # Check if we have stored color
        stored = light.color
        if stored:
            color, timestamp = stored
            age = time.time() - timestamp

            if age < MAX_AGE:
                print(f"Using stored color (age: {age:.1f}s)")
            else:
                print("Stored color too old, fetching fresh color")
                # get_color() returns (color, power, label)
                color, _, _ = await light.get_color()
        else:
            print("No stored color, fetching from device")
            # get_color() returns (color, power, label)
            color, _, _ = await light.get_color()
```

### Available Properties

#### Device Properties

- `Device.label` - Device name/label
- `Device.power` - Power state (on/off)
- `Device.version` - Vendor ID and Product ID
- `Device.host_firmware` - Major and minor host firmware version and build number
- `Device.wifi_firmware` - Major and minor wifi firmware version and build number
- `Device.location` - Device location name/label
- `Device.group` - Device group name/label

##### Non-State Properties

- `Device.model` - Device product model

#### Light properties

- `Light.color` - Current color

##### Non-State Properties

- `Light.min_kelvin` - Lowest supported kelvin value
- `Light.max_kelvin` - Highest supported kelvin value

#### InfraredLight properties

- `InfraredLight.infrared` - Infrared brightness

#### HevLight properties:

- `HevLight.hev_cycle` - HEV cycle state
- `HevLight.hev_config` - HEV configuration
- `HevLight.hev_result` - Last HEV result

#### MultiZoneLight properties:

- `MultiZoneLight.zone_count` - Number of zones
- `MultiZoneLight.zone_effect` - Either MOVE or OFF
- `MultiZoneLight.zones` - List of zone colors

#### TileDevice properties:

- `TileDevice.tile_count` - Number of tiles on the chain
- `TileDevice.tile_chain` - Details of each tile on the chain
- `TileDevice.tile_effect` - Either MORPH, FLAME, SKY or OFF
- `TileDevice.tile_colors` - Dictionary of colors, width, and height indexed by tile

All state properties return `None` if no data has been stored yet, or `(value, timestamp)` if data is available.

## Connection Management

### Understanding Connection Pooling

lifx-async automatically pools connections for efficient reuse:

```python
from lifx import Light

async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # All these operations reuse the same connection
        await light.set_power(True)
        await light.set_color(Colors.BLUE)
        await light.get_label()
        # Connection automatically closed when exiting context
```

**Benefits:**

- Reduced overhead from socket creation/teardown
- Lower latency for repeated operations
- Automatic cleanup on context exit

## Concurrency Patterns

### Concurrent Requests (Single Device)

Send multiple requests concurrently to one device:

```python
import asyncio
from lifx import Light

async def concurrent_operations():
    async with await Light.from_ip("192.168.1.100") as light:
        # These execute concurrently!
        # get_color() returns (color, power, label)
        (color, power, label), version = await asyncio.gather(
            light.get_color(),
            light.get_version(),
        )

        print(f"{label}: Power={power}, Color={color}, Firmware={version.firmware}")
```

**Performance Note:** Concurrent requests execute with maximum parallelism. However, per the LIFX protocol specification, devices can handle approximately 20 messages per second. When sending many concurrent requests to a single device, consider implementing rate limiting in your application to avoid overwhelming the device.

### Multi-Device Control

Control multiple devices in parallel:

```python
import asyncio
from lifx import discover, Colors

async def multi_device_control():
    async with discover() as group:
        # Create different tasks for different devices
        tasks = [
            group.devices[0].set_color(Colors.RED),
            group.devices[1].set_color(Colors.GREEN),
            group.devices[2].set_color(Colors.BLUE),
        ]

        # Execute all at once
        await asyncio.gather(*tasks)
```

### Batched Discovery

Discover devices in batches for large networks:

```python
from lifx.network.discovery import discover_devices

async def discover_in_batches():
    # First batch: quick discovery
    devices_quick = await discover_devices(
        timeout=1.0,
        broadcast_address="255.255.255.255"
    )

    # Second batch: thorough discovery
    if len(devices_quick) < expected_count:
        devices_full = await discover_devices(
            timeout=5.0,
            broadcast_address="255.255.255.255"
        )
        return devices_full

    return devices_quick
```

## Error Handling

### Exception Hierarchy

```python
from lifx import (
    LifxError,              # Base exception
    LifxTimeoutError,       # Request timeout
    LifxConnectionError,    # Connection failed
    LifxProtocolError,      # Invalid protocol response
    LifxDeviceNotFoundError,# Device not discovered
    LifxNetworkError,       # Network issues
    LifxUnsupportedCommandError,  # Device doesn't support operation
)
```

### Robust Error Handling

```python
import asyncio
from lifx import Light, Colors, LifxTimeoutError, LifxConnectionError

async def resilient_control():
    max_retries = 3

    for attempt in range(max_retries):
        try:
            async with await Light.from_ip("192.168.1.100") as light:
                await light.set_color(Colors.BLUE)
                print("Success!")
                return

        except LifxTimeoutError:
            print(f"Timeout (attempt {attempt + 1}/{max_retries})")
            if attempt < max_retries - 1:
                await asyncio.sleep(1.0)  # Wait before retry

        except LifxConnectionError as e:
            print(f"Connection failed: {e}")
            break  # Don't retry connection errors

    print("All retries exhausted")
```

### Graceful Degradation

```python
from lifx import discover, LifxError

async def best_effort_control():
    async with discover() as group:
        results = []

        # Try to control all lights, continue on errors
        for light in group.lights:
            try:
                await light.set_color(Colors.GREEN)
                results.append((light, "success"))
            except LifxError as e:
                results.append((light, f"failed: {e}"))

        # Report results
        for light, status in results:
            label = await light.get_label() if status == "success" else "Unknown"
            print(f"{label}: {status}")
```

## Device Capabilities

### Detecting Capabilities

Light capabilities are automatically populated:

```python
from lifx import Light
from lifx.products.registry import ProductCapability

async def check_capabilities():
    async with await Light.from_ip("192.168.1.100") as light:

        print(f"Product: {light.model}")
        print(f"Capabilities: {light.capabilities}")

        # Check specific capabilities
        if ProductCapability.COLOR in light.capabilities:
            await light.set_color(Colors.BLUE)

        if ProductCapability.MULTIZONE in light.capabilities:
            print("This is a multizone device!")

        if ProductCapability.INFRARED in light.capabilities:
            print("Supports infrared!")
```

### Capability-Based Logic

```python
from lifx import discover
from lifx.products.registry import ProductCapability

async def capability_aware_control():
    async with discover() as group:

        for device in group.devices:

            # Color devices
            if ProductCapability.COLOR in device.capabilities:
                await device.set_color(Colors.PURPLE)

            # Multizone devices
            if ProductCapability.MULTIZONE in device.capabilities:
                await device.set_color_zones(0, 8, Colors.RED)
```

## Custom Effects

### Creating Smooth Transitions

```python
import asyncio
from lifx import Light, HSBK

async def smooth_color_cycle():
    async with await Light.from_ip("192.168.1.100") as light:
        hues = [0, 60, 120, 180, 240, 300, 360]

        for hue in hues:
            color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)
            await light.set_color(color, duration=2.0)  # 2 second transition
            await asyncio.sleep(2.0)
```

### Synchronized Multi-Device Effects

```python
import asyncio
from lifx import discover, Colors

async def synchronized_flash():
    async with discover() as group:
        # Flash all devices simultaneously
        for _ in range(5):
            await group.set_color(Colors.RED, duration=0.0)
            await asyncio.sleep(0.2)
            await group.set_color(Colors.OFF, duration=0.0)
            await asyncio.sleep(0.2)
```

### Wave Effect Across Devices

```python
import asyncio
from lifx import discover, Colors

async def wave_effect():
    async with discover() as group:
        for i, device in enumerate(group.devices):
            # Each device changes color with a delay
            asyncio.create_task(
                delayed_color_change(device, Colors.BLUE, delay=i * 0.3)
            )

async def delayed_color_change(device, color, delay):
    await asyncio.sleep(delay)
    await device.set_color(color, duration=1.0)
```

## Performance Optimization

### Minimize Network Requests

```python
# ❌ Inefficient: Multiple round-trips
async def inefficient():
    async with await Light.from_ip("192.168.1.100") as light:
        await light.set_power(True)
        await asyncio.sleep(0.1)
        await light.set_color(Colors.BLUE)
        await asyncio.sleep(0.1)
        await light.set_brightness(0.8)

# ✅ Efficient: Set color and brightness together
async def efficient():
    async with await Light.from_ip("192.168.1.100") as light:
        await light.set_power(True)
        # Set color includes brightness
        color = HSBK(hue=240, saturation=1.0, brightness=0.8, kelvin=3500)
        await light.set_color(color, duration=0.0)
```

### Batch Operations

```python
# ❌ Sequential: Takes N * latency
async def sequential():
    async with discover() as group:
        for device in group.devices:
            await device.set_color(Colors.GREEN)

# ✅ Parallel: Takes ~latency
async def parallel():
    async with discover() as group:
        await group.set_color(Colors.GREEN)
```

### Connection Reuse

```python
# ❌ Creates new connection each time
async def no_reuse():
    for _ in range(10):
        async with await Light.from_ip("192.168.1.100") as light:
            await light.set_brightness(0.5)
        # Connection closed here

# ✅ Reuses connection
async def with_reuse():
    async with await Light.from_ip("192.168.1.100") as light:
        for _ in range(10):
            await light.set_brightness(0.5)
        # Connection closed once at end
```

## Next Steps

- [Troubleshooting Guide](../troubleshooting/) - Common issues and solutions
- [Protocol Reference](../../api/protocol/) - Low-level protocol details
- [API Reference](../../api/) - Complete API documentation

# Creating Custom Effects

This guide shows you how to create your own light effects by subclassing the `LIFXEffect` base class. You'll learn the required methods, common patterns, and best practices for building custom effects.

## Table of Contents

- [Overview](#overview)
- [Basic Structure](#basic-structure)
- [Required Methods](#required-methods)
- [Optional Methods](#optional-methods)
- [Common Patterns](#common-patterns)
- [Complete Examples](#complete-examples)
- [Best Practices](#best-practices)

## Overview

Creating a custom effect involves:

1. Subclass `LIFXEffect`
1. Implement `async_play()` with your effect logic
1. Optionally override `from_poweroff_hsbk()` for custom startup colors
1. Optionally override `inherit_prestate()` for state inheritance optimization

The conductor handles all state management automatically - you just focus on the visual effect.

## Basic Structure

Every custom effect follows this pattern:

```python
from lifx import LIFXEffect, Light

class MyCustomEffect(LIFXEffect):
    """Brief description of what this effect does."""

    def __init__(self, param1, param2, power_on: bool = True):
        """Initialize the effect with custom parameters.

        Args:
            param1: Description of parameter 1
            param2: Description of parameter 2
            power_on: Whether to power on devices (default True)
        """
        super().__init__(power_on=power_on)
        self.param1 = param1
        self.param2 = param2

    async def async_play(self) -> None:
        """Execute the effect logic."""
        # Your effect implementation here
        pass
```

### Minimal Example

Here's the simplest possible custom effect:

```python
from lifx.effects import LIFXEffect
import asyncio

class FlashEffect(LIFXEffect):
    """Flash all lights once."""

    async def async_play(self) -> None:
        # Turn all lights on
        tasks = [light.set_brightness(1.0) for light in self.participants]
        await asyncio.gather(*tasks)
        await asyncio.sleep(0.5)

        # Turn all lights off
        tasks = [light.set_brightness(0.0) for light in self.participants]
        await asyncio.gather(*tasks)
        await asyncio.sleep(0.5)

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)
```

Usage:

```python
conductor = Conductor()
effect = FlashEffect()
await conductor.start(effect, lights)
await asyncio.sleep(2)
```

## Required Methods

### `async_play() -> None`

This is the **only required method** you must implement. This is where your effect logic lives.

**Important:** This method is `async` - use `await` for all async operations.

**Available attributes:**

- `self.participants`: List of `Light` instances to apply effect to
- `self.conductor`: Reference to the `Conductor` managing this effect
- `self.power_on`: Whether devices should be powered on (already handled)

**When called:**

After the conductor has:

1. Captured device state
1. Powered on devices (if `power_on=True`)

**Example:**

```python
async def async_play(self) -> None:
    """Cycle through red, green, blue."""
    from lifx import HSBK

    colors = [
        HSBK.from_rgb(255, 0, 0),    # Red
        HSBK.from_rgb(0, 255, 0),    # Green
        HSBK.from_rgb(0, 0, 255),    # Blue
    ]

    for color in colors:
        # Apply color to all lights concurrently
        tasks = [
            light.set_color(color, duration=0.5)
            for light in self.participants
        ]
        await asyncio.gather(*tasks)
        await asyncio.sleep(1.0)

    # Restore original state
    if self.conductor:
        await self.conductor.stop(self.participants)
```

**Key Points:**

- Use `asyncio.gather()` to apply operations to multiple devices concurrently
- Call `self.conductor.stop(self.participants)` when effect is complete to restore state
- Don't forget `await` on async operations

## Optional Methods

### `from_poweroff_hsbk(light: Light) -> HSBK`

Override this to customize the color used when powering on a device.

**Default behavior:** Returns random hue, full saturation, zero brightness, neutral white.

**When called:** When a device needs to be powered on for the effect (if it was off when effect started).

**Example:**

```python
async def from_poweroff_hsbk(self, light: Light) -> HSBK:
    """Always start with soft blue."""
    return HSBK.from_rgb(0, 50, 200, kelvin=HSBK.KELVIN_NEUTRAL)
```

**Use cases:**

- Effect always starts with specific color
- Effect wants coordinated startup across devices
- Effect wants device-specific startup colors

### `inherit_prestate(other: LIFXEffect) -> bool`

Override this to enable state inheritance optimization.

**Default behavior:** Returns `False` (always capture fresh state).

**When called:** Before starting effect, to check if previous effect's state can be reused.

**Example:**

```python
def inherit_prestate(self, other: LIFXEffect) -> bool:
    """Can inherit from same effect type."""
    return type(self) == type(other)
```

**Returns:**

- `True`: Skip state capture/restore, reuse existing `PreState`
- `False`: Capture fresh state as normal

**Benefits:**

- Faster effect transitions
- No visible reset between compatible effects
- Reduces network traffic

**Use with caution:** Only return `True` if the incoming effect is truly compatible (won't cause visual artifacts).

## Common Patterns

### Pattern 1: Synchronized Actions

All devices do the same thing at the same time:

```python
async def async_play(self) -> None:
    """Pulse all devices together."""
    for cycle in range(self.cycles):
        # All bright
        await asyncio.gather(*[
            light.set_brightness(1.0, duration=0.3)
            for light in self.participants
        ])
        await asyncio.sleep(0.5)

        # All dim
        await asyncio.gather(*[
            light.set_brightness(0.2, duration=0.3)
            for light in self.participants
        ])
        await asyncio.sleep(0.5)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

### Pattern 2: Sequential Actions

Devices act one after another (wave effect):

```python
async def async_play(self) -> None:
    """Light up devices sequentially."""
    for light in self.participants:
        await light.set_color(self.color, duration=0.5)
        await asyncio.sleep(self.delay)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

### Pattern 3: Continuous Loop Until Stopped

Effect runs indefinitely (like ColorLoop):

```python
async def async_play(self) -> None:
    """Continuous random color changes."""
    import random

    self._running = True
    while self._running:
        # Random color for each device
        tasks = []
        for light in self.participants:
            hue = random.randint(0, 360)
            color = HSBK(hue, 1.0, 1.0, HSBK.KELVIN_NEUTRAL)
            tasks.append(light.set_color(color, duration=1.0))

        await asyncio.gather(*tasks)
        await asyncio.sleep(self.interval)

    if self.conductor:
        await self.conductor.stop(self.participants)

def stop(self) -> None:
    """Stop the effect."""
    self._running = False
```

**Usage:**

```python
effect = RandomColorEffect(interval=2.0)
await conductor.start(effect, lights)
await asyncio.sleep(30)
effect.stop()  # Signal to stop
```

### Pattern 4: Device-Specific Behavior

Different actions based on device properties:

```python
async def async_play(self) -> None:
    """Different colors based on device label."""
    tasks = []
    for light in self.participants:
        label = await light.get_label()

        if "Bedroom" in label:
            color = HSBK.from_rgb(0, 0, 255)  # Blue
        elif "Kitchen" in label:
            color = HSBK.from_rgb(255, 255, 255)  # White
        else:
            color = HSBK.from_rgb(255, 0, 0)  # Red

        tasks.append(light.set_color(color, duration=1.0))

    await asyncio.gather(*tasks)
    await asyncio.sleep(2.0)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

### Pattern 5: State Access

Access current device state during effect:

```python
async def async_play(self) -> None:
    """Pulse brighter than current brightness."""
    for light in self.participants:
        # Get current state
        current_color, _, _ = await light.get_color()

        # Create brighter version
        bright_color = current_color.with_brightness(1.0)

        # Pulse
        await light.set_color(bright_color, duration=0.3)
        await asyncio.sleep(0.5)
        await light.set_color(current_color, duration=0.3)
        await asyncio.sleep(0.5)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

**Note:** Conductor already captured state, so you can also access it via the prestate (though this requires conductor internals access).

## Complete Examples

### Example 1: Flash Effect

Flash all lights in unison with configurable count and duration:

```python
from lifx import LIFXEffect
import asyncio

class FlashEffect(LIFXEffect):
    """Flash all lights in unison.

    Simple effect that demonstrates basic synchronization across devices.
    """

    def __init__(
        self,
        flash_count: int = 5,
        duration: float = 0.5,
        power_on: bool = True
    ) -> None:
        """Initialize flash effect.

        Args:
            flash_count: Number of flashes
            duration: Duration of each flash in seconds
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        self.flash_count = flash_count
        self.duration = duration

    async def async_play(self) -> None:
        """Execute the flash effect on all participants."""
        for i in range(self.flash_count):
            # All devices on
            tasks = [light.set_brightness(1.0) for light in self.participants]
            await asyncio.gather(*tasks)
            await asyncio.sleep(self.duration / 2)

            # All devices off
            tasks = [light.set_brightness(0.0) for light in self.participants]
            await asyncio.gather(*tasks)
            await asyncio.sleep(self.duration / 2)

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)
```

**Usage:**

```python
conductor = Conductor()
effect = FlashEffect(flash_count=10, duration=0.3)
await conductor.start(effect, lights)
await asyncio.sleep(4)
```

### Example 2: Wave Effect

Sequential color wave across multiple lights:

```python
from lifx.effects import LIFXEffect
from lifx import HSBK
import asyncio

class WaveEffect(LIFXEffect):
    """Create a color wave across multiple lights.

    More complex example showing sequential color updates across devices.
    """

    def __init__(
        self,
        wave_count: int = 3,
        wave_speed: float = 0.3,
        power_on: bool = True
    ) -> None:
        """Initialize wave effect.

        Args:
            wave_count: Number of waves to run
            wave_speed: Speed of wave in seconds per light
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        self.wave_count = wave_count
        self.wave_speed = wave_speed

    async def async_play(self) -> None:
        """Execute the wave effect."""
        # Define wave colors
        colors = [
            HSBK.from_rgb(255, 0, 0),      # Red
            HSBK.from_rgb(255, 127, 0),    # Orange
            HSBK.from_rgb(255, 255, 0),    # Yellow
            HSBK.from_rgb(0, 255, 0),      # Green
            HSBK.from_rgb(0, 0, 255),      # Blue
        ]

        for wave in range(self.wave_count):
            # Wave forward
            for i, light in enumerate(self.participants):
                color = colors[i % len(colors)]
                await light.set_color(color, duration=self.wave_speed)
                await asyncio.sleep(self.wave_speed)

            await asyncio.sleep(0.5)  # Pause between waves

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)
```

**Usage:**

```python
conductor = Conductor()
effect = WaveEffect(wave_count=3, wave_speed=0.4)
await conductor.start(effect, lights)
total_time = 3 * (len(lights) * 0.4 + 0.5)
await asyncio.sleep(total_time + 1)
```

### Example 3: Random Color Effect

Continuous random color changes until stopped:

```python
from lifx.effects import LIFXEffect
from lifx import HSBK
import asyncio
import random

class RandomColorEffect(LIFXEffect):
    """Continuously change to random colors.

    Example of continuous effect that runs until stopped.
    """

    def __init__(
        self,
        interval: float = 2.0,
        saturation_min: float = 0.7,
        saturation_max: float = 1.0,
        power_on: bool = True
    ) -> None:
        """Initialize random color effect.

        Args:
            interval: Seconds between color changes
            saturation_min: Minimum saturation (0.0-1.0)
            saturation_max: Maximum saturation (0.0-1.0)
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        self.interval = interval
        self.saturation_min = saturation_min
        self.saturation_max = saturation_max
        self._running = False

    async def async_play(self) -> None:
        """Execute random color changes continuously."""
        self._running = True

        while self._running:
            # Random color for each device
            tasks = []
            for light in self.participants:
                color = HSBK(
                    hue=random.randint(0, 360),
                    saturation=random.uniform(self.saturation_min, self.saturation_max),
                    brightness=1.0,
                    kelvin=HSBK.KELVIN_NEUTRAL
                )
                tasks.append(light.set_color(color, duration=self.interval * 0.8))

            await asyncio.gather(*tasks)
            await asyncio.sleep(self.interval)

        # Restore state when stopped
        if self.conductor:
            await self.conductor.stop(self.participants)

    def stop(self) -> None:
        """Stop the continuous effect."""
        self._running = False

    def inherit_prestate(self, other: LIFXEffect) -> bool:
        """Can inherit from other RandomColorEffect instances."""
        return isinstance(other, RandomColorEffect)
```

**Usage:**

```python
conductor = Conductor()
effect = RandomColorEffect(interval=3.0, saturation_min=0.8)
await conductor.start(effect, lights)
await asyncio.sleep(30)
effect.stop()  # Signal to stop
await asyncio.sleep(3)  # Wait for current iteration to finish
```

### Example 4: Notification Effect

Different visual patterns based on notification level:

```python
from lifx.effects import LIFXEffect
from lifx import HSBK
import asyncio

class NotificationEffect(LIFXEffect):
    """Visual notification with different levels.

    Example showing how to implement different behaviors in one effect class.
    """

    def __init__(
        self,
        level: str = 'info',
        power_on: bool = True
    ) -> None:
        """Initialize notification effect.

        Args:
            level: Notification level ('info', 'warning', 'error')
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        if level not in ('info', 'warning', 'error'):
            raise ValueError(f"Invalid level: {level}")
        self.level = level

    async def async_play(self) -> None:
        """Execute notification based on level."""
        if self.level == 'info':
            await self._info_notification()
        elif self.level == 'warning':
            await self._warning_notification()
        elif self.level == 'error':
            await self._error_notification()

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)

    async def _info_notification(self) -> None:
        """Blue breathe - calm information."""
        blue = HSBK.from_rgb(0, 0, 255)
        for _ in range(2):
            await asyncio.gather(*[
                light.set_color(blue, duration=0.5)
                for light in self.participants
            ])
            await asyncio.sleep(0.7)
            await asyncio.gather(*[
                light.set_brightness(0.3, duration=0.5)
                for light in self.participants
            ])
            await asyncio.sleep(0.7)

    async def _warning_notification(self) -> None:
        """Orange blink - attention needed."""
        orange = HSBK.from_rgb(255, 165, 0)
        for _ in range(3):
            await asyncio.gather(*[
                light.set_color(orange, duration=0.1)
                for light in self.participants
            ])
            await asyncio.sleep(0.5)
            await asyncio.gather(*[
                light.set_brightness(0.0, duration=0.1)
                for light in self.participants
            ])
            await asyncio.sleep(0.5)

    async def _error_notification(self) -> None:
        """Red strobe - urgent."""
        red = HSBK.from_rgb(255, 0, 0)
        for _ in range(10):
            await asyncio.gather(*[
                light.set_color(red, duration=0.0)
                for light in self.participants
            ])
            await asyncio.sleep(0.1)
            await asyncio.gather(*[
                light.set_brightness(0.0, duration=0.0)
                for light in self.participants
            ])
            await asyncio.sleep(0.1)

    async def from_poweroff_hsbk(self, light: Light) -> HSBK:
        """Return appropriate startup color based on level."""
        if self.level == 'info':
            return HSBK.from_rgb(0, 0, 255)  # Blue
        elif self.level == 'warning':
            return HSBK.from_rgb(255, 165, 0)  # Orange
        else:
            return HSBK.from_rgb(255, 0, 0)  # Red
```

**Usage:**

```python
conductor = Conductor()

# Different notification levels
await conductor.start(NotificationEffect(level='info'), lights)
await asyncio.sleep(3)

await conductor.start(NotificationEffect(level='warning'), lights)
await asyncio.sleep(3)

await conductor.start(NotificationEffect(level='error'), lights)
await asyncio.sleep(3)
```

## Best Practices

### 1. Always Restore State

Call `conductor.stop()` when your effect is complete:

```python
async def async_play(self) -> None:
    # Effect logic here
    ...

    # Always restore at the end
    if self.conductor:
        await self.conductor.stop(self.participants)
```

### 2. Use Concurrent Operations

Use `asyncio.gather()` for operations on multiple devices:

```python
# Good - concurrent
await asyncio.gather(*[
    light.set_color(color) for light in self.participants
])

# Bad - sequential (much slower)
for light in self.participants:
    await light.set_color(color)
```

### 3. Validate Parameters

Validate constructor parameters early:

```python
def __init__(self, count: int, power_on: bool = True):
    super().__init__(power_on=power_on)

    if count < 1:
        raise ValueError(f"Count must be positive, got {count}")

    self.count = count
```

### 4. Add Type Hints

Full type hints improve IDE support and catch bugs:

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from lifx import Light

class MyEffect(LIFXEffect):
    def __init__(self, duration: float, power_on: bool = True) -> None:
        super().__init__(power_on=power_on)
        self.duration: float = duration

    async def async_play(self) -> None:
        ...

    async def from_poweroff_hsbk(self, light: Light) -> HSBK:
        ...
```

### 5. Document Your Effect

Clear docstrings help users understand your effect:

````python
class MyEffect(LIFXEffect):
    """Brief one-line description.

    Longer description explaining:
    - What the effect does
    - When to use it
    - Any important behavior

    Example:
        ```python
        conductor = Conductor()
        effect = MyEffect(duration=2.0)
        await conductor.start(effect, lights)
        await asyncio.sleep(3)
        ```
    """
````

### 6. Handle Errors Gracefully

Catch and log errors, don't let one device break the effect:

```python
import logging

_LOGGER = logging.getLogger(__name__)

async def async_play(self) -> None:
    for light in self.participants:
        try:
            await light.set_color(self.color)
        except Exception as e:
            _LOGGER.error(f"Failed to set color on {light.serial}: {e}")
            # Continue with other lights
```

### 7. Timing Considerations

Add small buffers to timing for reliability:

```python
# Good - includes buffer
total_duration = self.count * self.period
await asyncio.sleep(total_duration + 0.5)

# Better - exact but requires careful calculation
await asyncio.sleep(self.count * self.period)
```

### 8. Test with Different Device Types

Test your effect with:

- Single color light
- Multiple color lights
- Multizone light (if applicable)
- Powered-off devices
- Mix of on/off devices

### 9. Consider Rate Limiting

For effects with many rapid commands, consider rate limiting:

```python
async def async_play(self) -> None:
    for iteration in range(self.iterations):
        # Send commands
        await self._apply_colors()

        # Rate limit: max 20 messages/second
        await asyncio.sleep(0.05)
```

### 10. Use Descriptive Names

Choose clear, descriptive names for effects and parameters:

```python
# Good
class PulseWaveEffect(LIFXEffect):
    def __init__(self, wave_count: int, wave_period: float):
        ...

# Less clear
class Effect1(LIFXEffect):
    def __init__(self, n: int, t: float):
        ...
```

## See Also

- [Getting Started](../../getting-started/effects/) - Basic usage of built-in effects
- [Effects Reference](../../api/effects/) - Detailed API documentation
- [Architecture](../../architecture/effects-architecture/) - How the system works internally
- [Troubleshooting](../effects-troubleshooting/) - Common issues and solutions
- [Examples](../../examples/) - Full working examples including `08_custom_effect.py`

# Troubleshooting Guide

Common issues and solutions when working with lifx.

## Table of Contents

- [Discovery Issues](#discovery-issues)
- [Connection Problems](#connection-problems)
- [Timeout Errors](#timeout-errors)
- [Performance Issues](#performance-issues)
- [Debugging Tips](#debugging-tips)

## Discovery Issues

### No Devices Found

**Symptom:** `discover()` returns an empty group

**Common Causes:**

1. **Devices not on same network**

   ```python
   # Check network connectivity
   import asyncio
   from lifx.network.discovery import discover_devices

   devices = await discover_devices(timeout=5.0)
   print(f"Found {len(devices)} devices")
   ```

1. **Firewall blocking UDP port 56700**

   ```bash
   # Linux: Check if port is open
   sudo netstat -an | grep 56700

   # Allow UDP on port 56700
   sudo ufw allow 56700/udp
   ```

1. **Broadcast address incorrect**

Try different broadcast addresses:

```python
from lifx import discover

# Default (255.255.255.255)
async with discover() as group:
    pass

# Network-specific (e.g., 192.168.1.255)
async with discover(broadcast_address="192.168.1.255") as group:
    pass
```

**Solution:**

```python
import asyncio
from lifx.network.discovery import discover_devices

async def diagnose_discovery():
    print("Attempting discovery...")

    # Try with extended timeout
    devices = await discover_devices(
        timeout=10.0,
        broadcast_address="255.255.255.255"
    )

    if not devices:
        print("No devices found. Check:")
        print("1. Devices are powered on")
        print("2. Devices are on the same network")
        print("3. Firewall allows UDP port 56700")
        print("4. Try a network-specific broadcast address")
    else:
        print(f"Found {len(devices)} devices:")
        for device in devices:
            print(f"  - {device.serial} at {device.ip}")

asyncio.run(diagnose_discovery())
```

### Partial Device Discovery

**Symptom:** Only some devices discovered

**Causes:**

- Devices on different subnets
- Network congestion
- Devices slow to respond

**Solution:**

```python
async def thorough_discovery():
    # Multiple discovery passes with different timeouts
    all_devices = set()

    for timeout in [3.0, 5.0, 10.0]:
        devices = await discover_devices(timeout=timeout)
        for device in devices:
            all_devices.add((device.serial, device.ip))

    print(f"Total devices found: {len(all_devices)}")
    return all_devices
```

## Connection Problems

### Connection Refused

**Symptom:** `LifxConnectionError: Connection refused`

**Causes:**

- Incorrect IP address
- Device powered off
- Network unreachable

**Solution:**

```python
from lifx import Light, LifxConnectionError
import asyncio

async def test_connection(ip: str):
    try:
        async with await Light.from_ip(ip) as light:
            label = await light.get_label()
            print(f"Connected to: {label}")
            return True

    except LifxConnectionError as e:
        print(f"Connection failed: {e}")
        print("Check:")
        print("1. Device IP is correct")
        print("2. Device is powered on")
        print("3. Device is reachable (try ping)")
        return False

# Test connectivity
asyncio.run(test_connection("192.168.1.100"))
```

### Connection Drops

**Symptom:** Intermittent `LifxConnectionError` or `LifxNetworkError`

**Causes:**

- WiFi signal weak
- Network congestion
- Device overloaded

**Solution:**

```python
import asyncio
from lifx import Light, LifxError

async def resilient_operation(ip: str, max_retries: int = 3):
    """Retry operations with exponential backoff"""
    async with await Light.from_ip(ip) as light:
        for attempt in range(max_retries):
            try:
                await light.set_power(True)
                print("Success!")
                return
            except LifxError as e:
                wait_time = 2 ** attempt  # 1s, 2s, 4s
                print(f"Attempt {attempt + 1} failed: {e}")

                if attempt < max_retries - 1:
                    print(f"Retrying in {wait_time}s...")
                    await asyncio.sleep(wait_time)

    print("All retries exhausted")
```

## Timeout Errors

### Request Timeouts

**Symptom:** `LifxTimeoutError: Request timed out after X seconds`

**Causes:**

- Device slow to respond
- Network latency high
- Device busy processing other requests

**Solution:**

```python
from lifx import Light

# Increase timeout for slow devices
async with await Light.from_ip(ip, timeout=5.0) as light:
    # get_color() returns (color, power, label)
    color, power, label = await light.get_color()
```

### Discovery Timeout Too Short

**Symptom:** Some devices not found

**Solution:**

```python
from lifx import discover

# Increase discovery timeout
async with discover(timeout=10.0) as group:  # Default is 3.0
    print(f"Found {len(group.devices)} devices")
```

## Performance Issues

### Slow Operations

**Symptom:** Operations take longer than expected

**Diagnosis:**

```python
import time
from lifx import Light

async def measure_latency():
    async with await Light.from_ip("192.168.1.100") as light:
        # Measure single request
        start = time.time()
        await light.get_label()
        elapsed = time.time() - start
        print(f"Single request: {elapsed*1000:.2f}ms")

        # Measure sequential requests
        start = time.time()
        for _ in range(10):
            await light.get_label()
        elapsed = time.time() - start
        print(f"10 sequential: {elapsed*1000:.2f}ms ({elapsed*100:.2f}ms avg)")

        # Measure concurrent requests
        start = time.time()
        await asyncio.gather(*[light.get_label() for _ in range(10)])
        elapsed = time.time() - start
        print(f"10 concurrent: {elapsed*1000:.2f}ms")
```

**Common Causes:**

1. **Sequential instead of concurrent operations**

Slow approach (sequential):

```python
for device in devices:
    await device.set_color(Colors.BLUE)
```

Fast approach (concurrent):

```python
await asyncio.gather(
    *[device.set_color(Colors.BLUE) for device in devices]
)
```

1. **Not using connection pooling**

Inefficient (creates new connection each time):

```python
for i in range(10):
    async with await Light.from_ip(ip) as light:
        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)
```

Efficient (reuses connection):

```python
async with await Light.from_ip(ip) as light:
    for i in range(10):
        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)
```

1. **Need fresh data?**

Use `get_*()` methods to always fetch from the device:

```python
# Always fetch fresh data
# get_color() returns all three values in one call
color, power, label = await light.get_color()

# Or fetch other device info
version = await light.get_version()
```

### Docker / Container Networking

**Symptom:** Discovery doesn't work in Docker container

**Cause:** Container network isolation

**Solution:**

```yaml
# docker-compose.yml
services:
  app:
    network_mode: "host"  # Use host network for UDP broadcast
```

Or use manual device specification:

```python
# Don't rely on discovery
from lifx import Light

async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)
```

## Debugging Tips

### Enable Debug Logging

```python
import logging

# Enable DEBUG logging for lifx
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Or for specific modules
logging.getLogger('lifx.network').setLevel(logging.DEBUG)
logging.getLogger('lifx.devices').setLevel(logging.DEBUG)
```

### Check Product Registry

```python
from lifx.products import get_product, get_registry

# List all known products
registry = get_registry()
for product_id, product in registry.items():
    print(f"{product_id}: {product.name}")

# Check specific product
product = get_product(27)  # LIFX A19
if product:
    print(f"Name: {product.name}")
    print(f"Capabilities: {product.capabilities}")
```

### Verify Device Reachability

```bash
# Ping device
ping 192.168.1.100

# Check UDP port (requires nmap)
sudo nmap -sU -p 56700 192.168.1.100

# Test with netcat
echo -n "test" | nc -u 192.168.1.100 56700
```

## Getting Help

If you're still experiencing issues:

1. **Check GitHub Issues**: [github.com/Djelibeybi/lifx-async/issues](https://github.com/Djelibeybi/lifx-async/issues)
1. **Enable debug logging**: Capture logs with `logging.DEBUG`
1. **Provide details**:
1. Python version
1. lifx version
1. Device model and firmware version
1. Network configuration
1. Minimal reproduction code
1. Full error traceback

## Common Error Messages

| Error                                                        | Meaning                        | Solution                           |
| ------------------------------------------------------------ | ------------------------------ | ---------------------------------- |
| `LifxTimeoutError`                                           | Device didn't respond          | Increase timeout, check network    |
| `LifxConnectionError`                                        | Can't connect to device        | Check IP, firewall, device power   |
| `LifxDeviceNotFoundError`                                    | Device not discovered          | Check network, increase timeout    |
| `LifxProtocolError`                                          | Invalid response               | Update firmware, check device type |
| `LifxUnsupportedCommandError`                                | Device doesn't support command | Check device capabilities          |
| `AttributeError: 'Light' has no attribute 'set_color_zones'` | Wrong device class             | Use `MultiZoneLight`               |

## Next Steps

- [Advanced Usage](../advanced-usage/) - Optimization patterns
- [API Reference](../../api/) - Complete API documentation
- [FAQ](../../faq/) - Frequently asked questions

# Effects Troubleshooting

This guide helps you diagnose and resolve common issues when using the Light Effects Framework.

## Table of Contents

- [Common Issues](#common-issues)
- [Device Compatibility](#device-compatibility)
- [Performance Issues](#performance-issues)
- [State Management](#state-management)
- [Debugging Techniques](#debugging-techniques)
- [Known Limitations](#known-limitations)

## Common Issues

### Effects Don't Start

**Symptom:** Calling `conductor.start()` doesn't appear to do anything.

**Possible Causes:**

1. **No await keyword**

```python
# Wrong - missing await
conductor.start(effect, lights)  # Returns immediately, nothing happens

# Correct
await conductor.start(effect, lights)
```

1. **Devices not reachable**

```python
# Check device connectivity first
async with discover() as group:
    if not group.lights:
        print("No devices found!")
        return

    # Now safe to use effects
    conductor = Conductor()
    await conductor.start(effect, group.lights)
```

1. **Empty participants list**

```python
# Check you have lights
if not lights:
    print("No lights to apply effect to")
    return

await conductor.start(effect, lights)
```

**Solution:** Always use `await` and verify devices are discovered before starting effects.

______________________________________________________________________

### Lights Don't Restore to Original State

**Symptom:** After effect completes, lights stay in effect state instead of returning to original.

**Possible Causes:**

1. **Missing conductor.stop() call**

```python
# ColorLoop requires manual stop
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
await asyncio.sleep(60)
# MISSING: await conductor.stop(lights)
```

**Solution:** Always call `conductor.stop()` for continuous effects:

```python
await conductor.stop(lights)
```

1. **Effect doesn't call conductor.stop() internally**

Custom effects must restore state:

```python
async def async_play(self) -> None:
    # Effect logic
    ...

    # Required for auto-restore
    if self.conductor:
        await self.conductor.stop(self.participants)
```

1. **Network timeout during restoration**

If restoration fails due to network issues, lights may be in inconsistent state.

**Solution:** Check logs for timeout errors, verify network connectivity.

______________________________________________________________________

### Effect Appears to Freeze

**Symptom:** Effect starts but never completes, script hangs.

**Possible Causes:**

1. **ColorLoop running indefinitely**

ColorLoop is designed to run forever:

```python
# This will hang forever
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
# Script hangs here - ColorLoop never completes
```

**Solution:** Call `conductor.stop()` explicitly:

```python
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
await asyncio.sleep(60)  # Let it run
await conductor.stop(lights)  # Stop it
```

1. **Custom effect with infinite loop**

```python
async def async_play(self) -> None:
    while True:  # Infinite loop!
        await self._do_something()
```

**Solution:** Add stop condition:

```python
async def async_play(self) -> None:
    self._running = True
    while self._running:
        await self._do_something()
```

1. **Missing await in effect logic**

```python
async def async_play(self) -> None:
    # Missing await - blocks event loop
    light.set_color(color)  # Should be: await light.set_color(color)
```

**Solution:** Always use `await` on async operations.

______________________________________________________________________

### Lights Flash/Reset Between Effects

**Symptom:** When starting second effect, lights briefly return to original state before new effect starts.

**Cause:** State inheritance not enabled.

```python
# Each effect resets to original state
effect1 = EffectColorloop(period=30)
await conductor.start(effect1, lights)
await asyncio.sleep(10)

effect2 = EffectColorloop(period=20)  # Lights briefly reset here
await conductor.start(effect2, lights)
```

**Solution:** Effects must implement `inherit_prestate()` to prevent reset:

```python
class EffectColorloop(LIFXEffect):
    def inherit_prestate(self, other: LIFXEffect) -> bool:
        return isinstance(other, EffectColorloop)
```

This is already implemented for `EffectColorloop`, but custom effects may need it.

**Note:** For different effect types, the reset is intentional behavior.

______________________________________________________________________

### Pulse Effect Too Fast/Slow

**Symptom:** Pulse timing doesn't match expectations.

**Cause:** Misunderstanding period vs. total duration.

```python
# This runs for 1 second total (period=1.0, cycles=1)
effect = EffectPulse(mode='blink', period=1.0, cycles=1)

# This runs for 5 seconds total (period=1.0, cycles=5)
effect = EffectPulse(mode='blink', period=1.0, cycles=5)

# This runs for 2 seconds total (period=2.0, cycles=1)
effect = EffectPulse(mode='blink', period=2.0, cycles=1)
```

**Solution:** Total duration = `period * cycles`

```python
# Want 10-second effect?
effect = EffectPulse(mode='breathe', period=2.0, cycles=5)  # 2.0 * 5 = 10s
```

______________________________________________________________________

### ColorLoop Colors Look Wrong

**Symptom:** ColorLoop shows unexpected colors or is too dim/bright.

**Possible Causes:**

1. **Saturation constraints too restrictive**

```python
# Very low saturation = washed out colors
effect = EffectColorloop(saturation_min=0.1, saturation_max=0.3)  # Pastels
```

**Solution:** Use higher saturation for vibrant colors:

```python
effect = EffectColorloop(saturation_min=0.8, saturation_max=1.0)
```

1. **Brightness locked to low value**

```python
# Locked to 30% brightness
effect = EffectColorloop(brightness=0.3)  # Dim!
```

**Solution:** Use higher brightness or `None` to preserve original:

```python
effect = EffectColorloop(brightness=None)  # Preserve original
# or
effect = EffectColorloop(brightness=0.8)  # 80% brightness
```

1. **Monochrome device**

ColorLoop doesn't work on monochrome/white-only lights.

**Solution:** Only use ColorLoop on color-capable devices.

______________________________________________________________________

### Multizone Lights Don't Restore Zones Correctly

**Symptom:** After effect, multizone light zones are wrong color or all same color.

**Possible Causes:**

1. **Device was powered off before effect**

Some older multizone devices report all zones as the same color when powered off.

**Workaround:** Ensure lights are powered on before starting effects:

```python
# Power on first
for light in lights:
    await light.set_power(True)
await asyncio.sleep(0.5)

# Now start effect
await conductor.start(effect, lights)
```

1. **Extended multizone messages not supported**

Older devices may not support efficient extended multizone messages.

**Solution:** Framework automatically falls back to standard messages. No action needed.

1. **Network timeouts during zone restoration**

If restoring many zones times out, state may be incomplete.

**Solution:** Check network stability, reduce concurrent operations.

______________________________________________________________________

## Device Compatibility

### Color Lights

**Full Support:** All effects work as expected.

**Models:** LIFX Color, LIFX+, LIFX Mini Color, LIFX Candle Color

______________________________________________________________________

### Monochrome/White Lights

**Limited Support:** Only brightness-based effects work.

**What Works:**

- EffectPulse: Brightness pulsing (hue/saturation ignored)
- Custom effects using only brightness

**What Doesn't Work:**

- EffectColorloop: No visible effect (can't change hue)
- Color-based custom effects: Only brightness changes visible

**Recommendation:** Avoid ColorLoop on monochrome devices.

**Models:** LIFX White, LIFX Mini White, LIFX Downlight

______________________________________________________________________

### Multizone Lights

**Full Support** with some considerations.

**Works Well:**

- EffectPulse: All zones pulse together
- EffectColorloop: Entire device cycles color

**Special Considerations:**

- Effects apply to entire device, not individual zones
- Zone colors properly restored after effect
- Extended multizone messages used when available

**Potential Enhancement:** Future versions could support per-zone effects.

**Models:** LIFX Z, LIFX Beam

______________________________________________________________________

### Tile Devices

**Full Support** (tiles treated as single unit).

**Works Well:**

- EffectPulse: All tiles pulse together
- EffectColorloop: All tiles cycle color together

**Limitation:** Current implementation doesn't use per-tile control. All tiles show same color.

**Potential Enhancement:** Future versions could support per-tile effects (similar to theme support).

**Models:** LIFX Tile

______________________________________________________________________

### HEV Lights

**Full Support** (treated like standard color lights).

**Note:** Effects don't interfere with HEV cycle functionality.

**Models:** LIFX Clean

______________________________________________________________________

### Infrared Lights

**Full Support** (treated like standard color lights).

**Note:** Effects control visible light only, infrared LED not affected.

**Models:** LIFX+, LIFX Night Vision

______________________________________________________________________

## Performance Issues

### Slow Effect Startup

**Symptom:** Noticeable delay before effect starts.

**Cause:** State capture requires network round trips.

**Expected Timing:**

- Single device: \<1 second
- 10 devices: \<1 second (concurrent)
- 50 devices: 1-2 seconds

**If Slower:**

- Check network latency (ping devices)
- Verify devices are on local network (not remote)
- Reduce concurrent discovery operations

______________________________________________________________________

### Choppy/Stuttering Effects

**Symptom:** Effects don't run smoothly, visible stuttering.

**Possible Causes:**

1. **Too many concurrent effects**

```python
# 50 devices all running independent effects
for light in lights:
    await conductor.start(effect, [light])  # Too many!
```

**Solution:** Group devices:

```python
# All devices in one effect
await conductor.start(effect, lights)
```

1. **Network congestion**

Too many packets sent too quickly can overwhelm network or devices.

**Solution:** Add rate limiting:

```python
# In custom effect
for iteration in range(self.iterations):
    await self._update_colors()
    await asyncio.sleep(0.05)  # Rate limit: max 20/sec
```

1. **Blocking operations in effect**

```python
# Bad - blocking sleep
import time
time.sleep(1)  # Blocks entire event loop!

# Good - async sleep
await asyncio.sleep(1)
```

**Solution:** Always use async operations.

______________________________________________________________________

### Effects on Many Devices Are Slow

**Symptom:** Effects take much longer with many devices.

**Expected Behavior:** Effects should scale linearly (not exponentially).

**If Slower Than Expected:**

1. Verify concurrent operations are used:

```python
# Good - concurrent
await asyncio.gather(*[
    light.set_color(color) for light in lights
])

# Bad - sequential
for light in lights:
    await light.set_color(color)
```

1. Check for sequential operations in custom effects
1. Verify network capacity isn't saturated

**Recommendation:** For 50+ devices, consider:

- Staggering effect starts
- Using fewer concurrent effects
- Implementing application-level rate limiting

______________________________________________________________________

## State Management

### State Captured Incorrectly

**Symptom:** Restored state doesn't match original state.

**Possible Causes:**

1. **State changed between capture and effect**

```python
# State captured here
await conductor.start(effect, lights)

# Meanwhile, user changes light with app
# Effect completes, restores OLD state (not current state)
```

**Solution:** Effects framework works correctly - this is expected behavior. State is captured at effect start.

1. **Multizone device powered off during capture**

Older devices report inaccurate zone colors when off.

**Workaround:** Power on before effect:

```python
for light in lights:
    await light.set_power(True)
await asyncio.sleep(0.5)
await conductor.start(effect, lights)
```

______________________________________________________________________

### State Restoration Fails Silently

**Symptom:** State restoration errors not visible.

**Cause:** Errors are logged but don't raise exceptions (by design - one failed device shouldn't stop others).

**Solution:** Enable debug logging:

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger('lifx.effects')
logger.setLevel(logging.DEBUG)
```

Check logs for warnings like:

```text
WARNING:lifx.effects.conductor:Failed to restore color for d073d5123456: TimeoutError
```

______________________________________________________________________

## Debugging Techniques

### Enable Debug Logging

See detailed information about effect execution:

```python
import logging

# Enable debug logging for effects
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Just effects module
logger = logging.getLogger('lifx.effects')
logger.setLevel(logging.DEBUG)
```

**Output shows:**

- State capture details
- Prestate inheritance decisions
- State restoration steps
- Error messages

______________________________________________________________________

### Check Current Effect Status

See what's currently running on each device:

```python
conductor = Conductor()

# After starting effects
for light in lights:
    current = conductor.effect(light)
    if current:
        print(f"{light.label}: {type(current).__name__}")
    else:
        print(f"{light.label}: idle")
```

______________________________________________________________________

### Verify Device Connectivity

Before effects, verify all devices are reachable:

```python
async def check_connectivity(lights):
    """Verify all lights respond."""
    for light in lights:
        try:
            label = await light.get_label()
            print(f"✓ {label} reachable")
        except Exception as e:
            print(f"✗ {light.serial} unreachable: {e}")

# Use before effects
async with discover() as group:
    await check_connectivity(group.lights)
```

______________________________________________________________________

### Test with Single Device First

Isolate issues by testing with one device:

```python
# Test with single device first
async with discover() as group:
    if group.lights:
        test_light = group.lights[0]

        conductor = Conductor()
        effect = EffectPulse(mode='blink', cycles=3)

        print(f"Testing with {await test_light.get_label()}")
        await conductor.start(effect, [test_light])
        await asyncio.sleep(4)

        print("Test complete - check if light restored correctly")
```

______________________________________________________________________

### Validate Effect Parameters

Check that effect parameters are valid:

```python
# Add parameter validation
class MyEffect(LIFXEffect):
    def __init__(self, count: int, period: float, power_on: bool = True):
        super().__init__(power_on=power_on)

        if count < 1:
            raise ValueError(f"count must be positive, got {count}")
        if period <= 0:
            raise ValueError(f"period must be positive, got {period}")

        self.count = count
        self.period = period
```

______________________________________________________________________

### Measure Effect Timing

Verify effect runs for expected duration:

```python
import time

start = time.time()

effect = EffectPulse(mode='blink', period=1.0, cycles=5)
await conductor.start(effect, lights)

# Expected: 5 seconds
await asyncio.sleep(6)

elapsed = time.time() - start
print(f"Effect took {elapsed:.1f}s (expected ~5s)")
```

______________________________________________________________________

## Known Limitations

### Rate Limiting

The effects framework **does not** implement automatic rate limiting.

**Impact:** Sending too many concurrent commands may overwhelm devices or network.

**LIFX Limit:** ~20 messages per second per device

**Recommendation:** For rapid-fire effects, add your own rate limiting:

```python
async def async_play(self) -> None:
    for i in range(100):
        await self._update_lights()
        await asyncio.sleep(0.05)  # 20/sec max
```

______________________________________________________________________

### Tile Per-Tile Effects

Current implementation treats tiles as a single unit.

**Limitation:** Can't apply different effects to individual tiles within a tile chain.

**Workaround:** Use theme support for per-tile colors, or wait for future enhancement.

**Potential Future:** Per-tile effect logic could be added using `TileDevice.set_tile_colors()`.

______________________________________________________________________

### Multizone Per-Zone Effects

Current implementation treats multizone device as a single unit.

**Limitation:** Can't pulse individual zones or create zone-specific effects.

**Workaround:** Manually use `set_color_zones()` in custom effects.

**Example:**

```python
from lifx import MultiZoneLight

async def async_play(self) -> None:
    for light in self.participants:
        if isinstance(light, MultiZoneLight):
            # Control individual zones
            zone_count = await light.get_zone_count()
            for i in range(zone_count):
                color = self._get_zone_color(i)
                await light.set_color_zones(i, i, color)
```

______________________________________________________________________

### Button/Relay/Switch Devices

The effects framework **only supports lighting devices**.

**Not Supported:**

- LIFX Switch
- LIFX Relay
- Button devices

**Reason:** Effects are designed for visual output (lights), not control devices.

______________________________________________________________________

### Network Timeouts with Many Devices

With 50+ devices, state capture/restoration may timeout.

**Symptoms:**

- Some devices don't restore state
- Timeout errors in logs

**Solutions:**

- Increase timeout values (requires lifx-async modification)
- Reduce number of concurrent effects
- Group devices and stagger effect starts
- Verify network infrastructure can handle traffic

______________________________________________________________________

### Prestate Inheritance Limitations

State inheritance is conservative to prevent artifacts.

**Current Behavior:**

- Only `EffectColorloop` supports inheritance (from other `EffectColorloop`)
- Other effect types always reset state

**Enhancement Opportunity:** More effect types could support inheritance with careful design.

______________________________________________________________________

## Still Having Issues?

If you're experiencing issues not covered here:

1. **Check the logs** with debug logging enabled
1. **Test with single device** to isolate the problem
1. **Verify device firmware** is up to date
1. **Check network** connectivity and stability
1. **Review examples** in the `examples/` directory
1. **Report issues** on [GitHub Issues](https://github.com/Djelibeybi/lifx-async/issues)

When reporting issues, include:

- lifx-async version
- Python version
- Device model(s) affected
- Minimal reproduction code
- Full error message and traceback
- Debug logs if applicable

## See Also

- [Getting Started](../../getting-started/effects/) - Basic usage patterns
- [Effects Reference](../../api/effects/) - Detailed API documentation
- [Custom Effects](../effects-custom/) - Creating your own effects
- [Architecture](../../architecture/effects-architecture/) - How the system works

# Protocol Deep Dive

Understanding the LIFX protocol and how lifx implements it.

## Table of Contents

- [Protocol Overview](#protocol-overview)
- [Packet Structure](#packet-structure)
- [Message Flow](#message-flow)
- [Protocol Types](#protocol-types)
- [Code Generation](#code-generation)
- [Low-Level Usage](#low-level-usage)

## Protocol Overview

The LIFX LAN Protocol is a binary protocol using UDP for communication:

- **Port:** 56700 (UDP)
- **Packet Size:** Variable (36-byte header + payload)
- **Transport:** Unreliable (UDP) with application-level reliability
- **Discovery:** Broadcast-based (255.255.255.255)

### Protocol Layers

```text
┌─────────────────────────────────────┐
│     Application (lifx API)        │
├─────────────────────────────────────┤
│  Packet Classes (packets.py)        │
├─────────────────────────────────────┤
│  Models (models.py)                 │
│  Serialization (serializer.py)      │
├─────────────────────────────────────┤
│  Header (header.py)                 │
├─────────────────────────────────────┤
│  UDP Transport                      │
└─────────────────────────────────────┘
```

## Packet Structure

### Header Format (36 bytes)

Every LIFX packet starts with a 36-byte header:

```python
from lifx.protocol.header import LifxHeader
from lifx.protocol.models import Serial

# Create serial number
serial = Serial.from_string("d073d5123456")

header = LifxHeader(
    size=64,                    # Total packet size (header + payload)
    protocol=1024,              # Protocol version (always 1024)
    addressable=True,           # Addressing mode
    tagged=False,               # Broadcast vs unicast
    source=0x12345678,          # Unique client ID
    target=serial.to_protocol(), # Device serial (8 bytes with padding)
    res_required=True,          # Expects response
    ack_required=False,         # Expects acknowledgment
    sequence=1,                 # Sequence number (0-255)
    pkt_type=101,               # Message type
)
```

### Header Fields

| Field        | Size    | Description                              |
| ------------ | ------- | ---------------------------------------- |
| size         | 2 bytes | Total packet size including header       |
| origin       | 2 bits  | Message origin (always 0)                |
| tagged       | 1 bit   | Broadcast (1) or targeted (0)            |
| addressable  | 1 bit   | Addressing mode (always 1)               |
| protocol     | 12 bits | Protocol number (always 1024)            |
| source       | 4 bytes | Unique client identifier                 |
| target       | 8 bytes | Device MAC address (6 bytes + 2 padding) |
| reserved     | 6 bytes | Reserved for future use                  |
| res_required | 1 bit   | Response required flag                   |
| ack_required | 1 bit   | Acknowledgment required flag             |
| reserved     | 6 bits  | Reserved                                 |
| sequence     | 1 byte  | Wrap-around sequence number              |
| reserved     | 8 bytes | Reserved                                 |
| pkt_type     | 2 bytes | Message type identifier                  |
| reserved     | 2 bytes | Reserved                                 |

### Payload

Variable-length payload following the header:

```python
# Example: SetColor payload (13 bytes)
{
    'reserved': 0,              # 1 byte
    'color': HSBK(...),         # 8 bytes (4 × uint16)
    'duration': 1000,           # 4 bytes (uint32, milliseconds)
}
```

## Message Flow

### Discovery Process

```
sequenceDiagram
    participant Client
    participant Network
    participant Device1
    participant Device2

    Client->>Network: Broadcast GetService (tagged=1)
    Network->>Device1: GetService
    Network->>Device2: GetService
    Device1-->>Client: StateService (port 56700)
    Device2-->>Client: StateService (port 56700)
    Client->>Client: Collect responses
```

### Request-Response Pattern

```
sequenceDiagram
    participant Client
    participant Device

    Client->>Device: GetLabel (seq=1, res_required=1)
    Device-->>Client: StateLabel (seq=1, "Living Room")

    Client->>Device: SetColor (seq=2, res_required=0, ack_required=1)
    Device-->>Client: Acknowledgement (seq=2)
```

### Concurrent Requests

lifx-async supports concurrent requests on a single connection:

```
sequenceDiagram
    participant Client
    participant Device

    Client->>Device: Request 1 (seq=1)
    Client->>Device: Request 2 (seq=2)
    Client->>Device: Request 3 (seq=3)

    Device-->>Client: Handle Response 2 (seq=2)
    Device-->>Client: Handle Response 1(seq=1)
    Device-->>Client: Handle Response 3 (seq=3)
```

## Protocol Types

### Color Representation

LIFX uses HSBK color space:

```python
from lifx import HSBK

color = HSBK(
    hue=180.0,         # 0-360 degrees
    saturation=1.0,    # 0.0-1.0
    brightness=0.75,   # 0.0-1.0
    kelvin=3500,       # 1500-9000
)
```

### Packet Categories

Packets are organized by category:

| Category    | Purpose                | Examples                        |
| ----------- | ---------------------- | ------------------------------- |
| `Device`    | Device-wide operations | GetLabel, SetLabel, GetPower    |
| `Light`     | Light control          | SetColor, GetColor, SetWaveform |
| `MultiZone` | Strip/beam control     | SetColorZones, GetColorZones    |
| `Tile`      | Tile device control    | GetTileState64, SetTileState64  |

### Common Packet Types

```python
from lifx.protocol import packets

# Device packets
get_label = packets.Device.GetLabel()              # pkt_type=23
set_label = packets.Device.SetLabel(label="Room")  # pkt_type=24

# Light packets
get_color = packets.Light.Get()                    # pkt_type=101
set_color = packets.Light.SetColor(               # pkt_type=102
    color=HSBK(...),
    duration=1000
)

# MultiZone packets
get_zones = packets.MultiZone.GetColorZones(      # pkt_type=502
    start_index=0,
    end_index=8
)
```

## Code Generation

### From protocol.yml

lifx-async auto-generates protocol code from the official LIFX specification:

```yaml
# protocol.yml excerpt
packets:
  - name: SetColor
    pkt_type: 102
    category: light
    fields:
      - name: reserved
        type: uint8
      - name: color
        type: HSBK
      - name: duration
        type: uint32
```

Generates:

```python
# packets.py (generated)
@dataclass
class SetColor:
    PKT_TYPE: ClassVar[int] = 102
    CATEGORY: ClassVar[str] = "Light"

    reserved: int = 0
    color: HSBK = field(default_factory=HSBK)
    duration: int = 0

    def pack(self) -> bytes:
        # Serialization logic
        ...
```

### Regenerating Protocol Code

```bash
# Regenerate Python code
uv run python -m lifx.protocol.generator
```

### Generator Features

- **Type Safety:** Full type hints for all structures
- **Validation:** Bounds checking for protocol values
- **Documentation:** Docstrings from protocol comments
- **Filtering:** Excludes non-lighting categories (Button, Relay)

## Low-Level Usage

### Direct Protocol Usage

```python
from lifx.network.connection import DeviceConnection
from lifx.protocol import packets
from lifx.protocol.protocol_types import HSBK

async def low_level_control():
    # Create connection
    conn = DeviceConnection(
        serial="d073d5000001",
        ip="192.168.1.100"
    )

    # Create packet
    packet = packets.Light.SetColor(
        reserved=0,
        color=HSBK(hue=32768, saturation=65535, brightness=49151, kelvin=3500),
        duration=1000
    )

    # Send and receive response
    response = await conn.request(
        packet,
        timeout=2.0
    )

    print(f"Response: {response}")
```

## Protocol Constants

### Important Values

```python
# Ports
LIFX_UDP_PORT = 56700

# Protocol version
LIFX_PROTOCOL_VERSION = 1024

# Color limits
HUE_MAX = 65535        # Maps to 360°
SATURATION_MAX = 65535 # Maps to 100%
BRIGHTNESS_MAX = 65535 # Maps to 100%
KELVIN_MIN = 1500
KELVIN_MAX = 9000

# Timing
MAX_DURATION = 0xFFFFFFFF  # ~49 days in milliseconds
MIN_DURATION = 0           # Instant
```

## Next Steps

- [Connection Management](../advanced-usage/#connection-management) - Connection patterns
- [API Reference](../../api/protocol/) - Protocol API documentation
- [Architecture](../../architecture/overview/) - System architecture
# Architecture

# Architecture Overview

lifx-async is built as a layered architecture with clear separation of concerns.

## System Architecture

```
graph TB
    subgraph "Layer 4: High-Level API"
        API[api.py<br/>discover, find_lights, etc.]
        DeviceGroup[DeviceGroup<br/>Batch operations]
    end

    subgraph "Layer 3: Device Layer"
        Device[Device<br/>Base class]
        Light[Light<br/>Color control]
        Hev[HevLight<br />HEV support]
        Infrared[InfraredLight<br />Infrared support]
        MultiZone[MultiZoneLight<br/>Linear/1D zones]
        Tile[TileDevice<br/>Matrix/2D zones]
    end

    subgraph "Layer 2: Network Layer"
        Discovery[Discovery<br/>UDP broadcast]
        Connection[Connection<br/>Connection pooling]
        Transport[Transport<br/>UDP sockets]
    end

    subgraph "Layer 1: Protocol Layer"
        Generator[Generator<br/>YAML → Python]
        Types[Protocol Types<br/>Enums, HSBK, etc.]
        Packets[Packets<br/>Message classes]
    end

    subgraph "External"
        YAML[protocol.yml<br/>LIFX specification]
        Network[UDP Network<br/>Port 56700]
    end

    API --> DeviceGroup
    DeviceGroup --> Light
    DeviceGroup --> Hev
    DeviceGroup --> Infrared
    DeviceGroup --> MultiZone
    DeviceGroup --> Tile
    API --> Discovery
    Device --> Connection
    Light --> Device
    Hev --> Light
    Infrared --> Light
    MultiZone --> Light
    Tile --> Light
    Connection --> Transport
    Connection --> Packets
    Discovery --> Transport
    Packets --> Types
    Transport --> Network
    Generator --> YAML
    Generator -.generates.-> Types
    Generator -.generates.-> Packets

    style API fill:#e1f5e1
    style Device fill:#e1f0ff
    style Connection fill:#fff4e1
    style Generator fill:#ffe1f0
```

## Layer Responsibilities

### Layer 1: Protocol Layer

**Purpose**: Handle LIFX binary protocol

- **Auto-Generated**: All code generated from `protocol.yml`
- **Type-Safe**: Full type hints for all structures
- **Binary Serialization**: Pack/unpack protocol messages
- **No Business Logic**: Pure data structures

**Key Files**:

- `protocol_types.py` - Enums, HSBK, field structures
- `packets.py` - Packet class definitions
- `generator.py` - Code generation from YAML

**Example**:

```python
from lifx.protocol.packets import Light
from lifx import HSBK

# Create a packet
packet = Light.SetColor(
    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0
)

# Serialize to bytes
data = packet.pack()
```

### Layer 2: Network Layer

**Purpose**: Handle network communication

- **UDP Transport**: Async socket operations
- **Discovery**: Broadcast-based device discovery
- **Connection Pooling**: Efficient connection reuse (LRU cache)
- **Retry Logic**: Automatic retry with exponential backoff

**Key Files**:

- `transport.py` - UDP socket wrapper
- `discovery.py` - Device discovery
- `connection.py` - Connection management
- `message.py` - Message building

**Example**:

```python
from lifx.network.connection import DeviceConnection

conn = DeviceConnection(serial="d073d5123456", ip="192.168.1.100")
# Connection automatically pooled
response = await conn.request_response(packet, response_type)
```

### Layer 3: Device Layer

**Purpose**: Device abstractions with high-level operations

- **Device Types**: Base, Light, HevLight, InfraredLight, MultiZoneLight, TileDevice
- **State Storage**: Timestamped state properties with explicit freshness control
- **Type Detection**: Automatic capability detection
- **Async Context Managers**: Automatic resource cleanup

**Key Files**:

- `base.py` - Base Device class
- `light.py` - Light class
- `hev.py` - HevLight class
- `infrared.py` - InfraredLight class
- `multizone.py` - MultiZoneLight class
- `tile.py` - TileDevice class

**Example**:

```python
from lifx import Light

async with Light(serial, ip) as light:
    # High-level operations
    await light.set_color(Colors.BLUE)
    await light.pulse(Colors.RED, period=1.0, cycles=5)
```

### Layer 4: High-Level API

**Purpose**: Simple, batteries-included API

- **Simplified Discovery**: One-line device discovery
- **Batch Operations**: Control multiple devices
- **Direct Connection**: Connect by IP without discovery
- **Filtered Discovery**: Find devices by label or serial

**Key Files**:

- `api.py` - High-level functions
- `color.py` - Color utilities

**Example**:

```python
from lifx import discover, Colors

async with discover() as group:
    await group.set_color(Colors.BLUE)
```

## Data Flow

### Sending a Command

```
sequenceDiagram
    participant User
    participant Light
    participant Connection
    participant Transport
    participant Device

    User->>Light: set_color(Colors.BLUE)
    Light->>Light: Convert to HSBK
    Light->>Connection: send_packet(SetColor)
    Connection->>Connection: Serialize packet
    Connection->>Transport: send_message(bytes)
    Transport->>Device: UDP packet
    Device-->>Transport: UDP acknowledgment
    Transport-->>Connection: Response
    Connection-->>Connection: Deserialize packet
    Connection-->>Light: Reply
    Light-->>User: Success
```

### Discovery Process

```
sequenceDiagram
    participant User
    participant Discovery
    participant Transport
    participant Network
    participant Devices

    User->>Discovery: discover_devices(timeout=3.0)
    Discovery->>Transport: Open UDP socket
    Discovery->>Transport: Send broadcast (GetService)
    Transport->>Network: Broadcast on 255.255.255.255
    Network->>Devices: Broadcast packet
    Devices-->>Network: StateService responses
    Network-->>Transport: Multiple responses
    Transport-->>Discovery: Parse responses
    Discovery->>Discovery: Collect device info
    Discovery-->>User: List[DiscoveredDevice]
```

## Key Design Decisions

### Async-First

**Why**: LIFX operations involve network I/O which benefits from async

```python
# Multiple devices controlled concurrently
await asyncio.gather(
    light1.set_color(Colors.RED),
    light2.set_color(Colors.BLUE),
    light3.set_color(Colors.GREEN),
)
```

### Connection Pooling

**Why**: Reduces overhead and improves performance

```python
# Same connection reused automatically
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.RED)  # Connection 1
    await light.set_brightness(0.5)  # Reuses Connection 1
    await light.get_label()  # Reuses Connection 1
```

### Storing State with Timestamps

**Why**: Reduces network traffic while keeping you in control of data freshness

```python
import time

# Properties return (value, timestamp) tuples when stored:
stored_color = light.color
if stored_state:
    color, timestamp = stored_color
    age = time.time() - timestamp
    if age < 5.0:  # Still fresh
        # Use stored color
    else:
        # Data is stale, fetch fresh from device
        color, _, _ = await light.get_color()
else:
    # No stored data yet
    color, _, _ = await light.get_color()
```

### Code Generation

**Why**: Protocol updates are automatic, reduces errors

```bash
# Regenerate code
uv run python -m lifx.protocol.generator
```

## Performance Characteristics

### Connection Pool

- **LRU Cache**: Least Recently Used eviction
- **Max Size**: Configurable (default: 128)
- **Metrics**: Track hits, misses, evictions

### Storing State as Properties

- **Format**: `(value, timestamp)` tuples for explicit freshness control
- **Properties**: All device state available as properties
- **Freshness**: Application explicitly manages data age via timestamp
- **Getting Fresh Data**: Use `get_*()` methods to always fetch from device

## Concurrency Model

Each connection supports concurrent requests:

```python
async with DeviceConnection(serial, ip) as conn:
    # All three execute concurrently
    results = await asyncio.gather(
        conn.request_response(packet1, type1),
        conn.request_response(packet2, type2),
        conn.request_response(packet3, type3),
    )
```

**How it works**:

- Background receiver task continuously reads UDP packets
- Responses matched to requests by sequence number
- Each request waits on an `asyncio.Event`
- Single UDP socket per connection

## Next Steps

- [API Reference](../../api/) - Detailed API documentation
- [FAQ](../../faq/) - Frequently asked questions

# Effects Architecture

This document provides a comprehensive overview of the Light Effects Framework architecture, including design decisions, implementation details, and lifecycle management.

## Table of Contents

- [High-Level Overview](#high-level-overview)
- [Component Architecture](#component-architecture)
- [Effect Lifecycle](#effect-lifecycle)
- [State Management](#state-management)
- [Concurrency Model](#concurrency-model)
- [Device Type Handling](#device-type-handling)
- [Design Decisions](#design-decisions)

## High-Level Overview

The Light Effects Framework is built on a layered architecture that separates concerns and provides a clean abstraction for effect management:

```text
┌─────────────────────────────────────────────────────┐
│              Application Layer                       │
│  (User code, business logic, effect selection)      │
└────────────────┬────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────┐
│              Effects API Layer                       │
│   • Conductor (orchestration)                       │
│   • EffectPulse, EffectColorloop (implementations)  │
│   • LIFXEffect (base class)                         │
└────────────────┬────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────┐
│            Device Layer (lifx.devices)               │
│   • Light, MultiZoneLight, TileDevice               │
│   • Device state methods (get_color, set_color)     │
└────────────────┬────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────┐
│           Network Layer (lifx.network)               │
│   • DeviceConnection (UDP transport)                │
│   • Message building and parsing                    │
└────────────────┬────────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────────┐
│          Protocol Layer (lifx.protocol)              │
│   • Binary serialization/deserialization            │
│   • Packet definitions (auto-generated)             │
└─────────────────────────────────────────────────────┘
```

### Key Principles

1. **Zero Dependencies**: Uses only Python stdlib and existing lifx-async components
1. **State Preservation**: Automatically captures and restores device state
1. **Type Safety**: Full type hints with strict Pyright validation
1. **Async/Await**: Native asyncio for concurrent operations
1. **Extensibility**: Abstract base class for custom effects

## Component Architecture

### Module Structure

```text
src/lifx/effects/
├── __init__.py              # Public API exports
├── base.py                  # LIFXEffect abstract base class
├── conductor.py             # Conductor orchestrator
├── pulse.py                 # EffectPulse implementation
├── colorloop.py             # EffectColorloop implementation
├── models.py                # PreState, RunningEffect dataclasses
└── utils.py                 # Shared utilities (future)
```

### Component Responsibilities

#### Conductor (`conductor.py`)

**Purpose:** Central orchestrator managing effect lifecycle across multiple devices.

**Responsibilities:**

- Track running effects per device (serial → RunningEffect mapping)
- Capture device state before effects
- Power on devices if needed
- Execute effects via `effect.async_perform()`
- Restore device state after effects complete
- Handle concurrent effects on different devices
- Provide thread-safe state management with `asyncio.Lock()`

**Key Data Structures:**

```python
class Conductor:
    _running: dict[str, RunningEffect]  # serial → RunningEffect
    _lock: asyncio.Lock                 # Thread-safe access
```

#### LIFXEffect Base Class (`base.py`)

**Purpose:** Abstract base for all effect implementations.

**Responsibilities:**

- Define effect interface (abstract `async_play()` method)
- Handle power-on logic in `async_perform()`
- Provide startup color via `from_poweroff_hsbk()`
- Enable state inheritance optimization via `inherit_prestate()`
- Store conductor reference and participants

**Key Methods:**

```python
class LIFXEffect(ABC):
    async def async_perform(participants):  # Setup + call async_play()
        ...

    @abstractmethod
    async def async_play():                 # Effect logic (override)
        ...

    async def from_poweroff_hsbk(light):    # Startup color (override)
        ...

    def inherit_prestate(other):            # State inheritance (override)
        ...
```

#### Effect Implementations

**EffectPulse (`pulse.py`):**

- Implements pulse/blink/breathe effects
- Five modes with different timing and waveforms
- Intelligent color selection based on mode
- Auto-completion after configured cycles

**EffectColorloop (`colorloop.py`):**

- Implements continuous hue rotation
- Randomized direction, device order, saturation
- Runs indefinitely until stopped
- Supports state inheritance for seamless transitions

#### Data Models (`models.py`)

**PreState:**

Stores device state before effect:

```python
@dataclass
class PreState:
    power: bool                     # Power state (on/off)
    color: HSBK                     # Current color
    zone_colors: list[HSBK] | None  # Multizone colors (if applicable)
```

**RunningEffect:**

Associates effect with its pre-state:

```python
@dataclass
class RunningEffect:
    effect: LIFXEffect    # Effect instance
    prestate: PreState    # Captured state
```

## Effect Lifecycle

The effect lifecycle consists of five distinct phases:

### 1. Initialization

User creates effect instance with desired parameters:

```python
effect = EffectPulse(mode='blink', cycles=5)
```

**What happens:**

- Effect object created with parameters stored
- No network activity yet
- No conductor association yet

### 2. State Capture

Conductor starts effect and captures current device state:

```python
await conductor.start(effect, [light1, light2])
```

**What happens:**

```text
For each light:
  1. Check if prestate can be inherited from running effect
  2. If not, capture new prestate:
     a. Get power state (get_power)
     b. Get current color (get_color)
     c. Get zone colors if multizone (get_color_zones or get_extended_color_zones)
  3. Store in RunningEffect and register in conductor._running
```

**Timing:** \<1 second per device (mostly network I/O)

**Special Cases:**

- **Prestate Inheritance:** If `effect.inherit_prestate(current_effect)` returns `True`, reuses existing PreState
- **Multizone Devices:** Uses extended messages if supported, falls back to standard messages
- **Powered-off Devices:** All state is still captured (including zone colors that may be inaccurate)

### 3. Power-On (Optional)

If `effect.power_on == True`, devices are powered on:

```python
async def async_perform(self, participants):
    if self.power_on:
        for light in self.participants:
            is_on = await light.get_power()
            if not is_on:
                startup_color = await self.from_poweroff_hsbk(light)
                await light.set_color(startup_color, duration=0)
                await light.set_power(True, duration=0.3)
```

**What happens:**

```text
For each powered-off light:
  1. Get startup color from from_poweroff_hsbk()
  2. Set color immediately (duration=0)
  3. Power on with 0.3s fade (duration=0.3)
```

**Timing:** 0.3 seconds per powered-off device

### 4. Effect Execution

Effect logic runs via `async_play()`:

```python
await effect.async_play()
```

**What happens:**

- Subclass-specific effect logic executes
- Can access `self.participants` and `self.conductor`
- Can issue commands to devices
- Pulse effects: Send waveform, wait for completion
- ColorLoop effects: Continuous loop until stopped

**Timing:**

- EffectPulse: `period * cycles` seconds
- EffectColorloop: Runs indefinitely

### 5. State Restoration

Conductor restores devices to pre-effect state:

```python
await conductor.stop([light1, light2])
```

**What happens:**

```text
For each light:
  1. Restore multizone colors (if applicable):
     - Use extended messages if supported
     - Use standard messages with apply=NO_APPLY, then apply=APPLY
     - Wait 0.3s for device processing
  2. Restore color:
     - set_color(prestate.color, duration=0)
     - Wait 0.3s
  3. Restore power:
     - set_power(prestate.power, duration=0)
```

**Timing:** 0.6-1.0 seconds per device (includes delays)

**Special Cases:**

- Multizone devices get zones restored first
- 0.3s delays ensure device processing completes
- Errors are logged but don't stop other devices

## State Management

### State Storage

The conductor maintains a registry of running effects:

```python
_running: dict[str, RunningEffect]
```

**Key:** Device serial number (12-digit hex string) **Value:** `RunningEffect` containing effect instance and captured `PreState`

### State Capture Details

#### Power State

Simple boolean captured via `get_power()`:

```python
power = await light.get_power()
```

#### Color State

HSBK color captured via `get_color()`:

```python
color, _, _ = await light.get_color()
```

Returns:

- `color`: HSBK (hue, saturation, brightness, kelvin)
- `power`: Power level (unused - we use get_power())
- `label`: Device label (unused)

#### Multizone State

For `MultiZoneLight` devices, zone colors are captured:

```python
if isinstance(light, MultiZoneLight):
    zone_count = await light.get_zone_count()

    # Try extended multizone first (more efficient)
    if light.capabilities.has_extended_multizone:
        zone_colors = await light.get_extended_color_zones(
            start=0, end=zone_count - 1
        )
    else:
        # Fall back to standard multizone
        zone_colors = await light.get_color_zones(
            start=0, end=zone_count - 1
        )
```

**Extended Multizone:**

- Single message retrieves all zones
- Returns `list[HSBK]` with all zone colors
- More efficient, used when available

**Standard Multizone:**

- Retrieves zones in batches of 8
- Multiple messages required for >8 zones
- Used as fallback for older devices

### State Restoration Details

#### Multizone Restoration

Zones are restored **before** color and power:

**Extended Multizone:**

```python
await light.set_extended_color_zones(
    zone_index=0,
    colors=zone_colors,
    duration=0.0,
    apply=MultiZoneExtendedApplicationRequest.APPLY
)
```

Single message restores all zones.

**Standard Multizone:**

```python
for i, color in enumerate(zone_colors):
    is_last = (i == len(zone_colors) - 1)
    apply = APPLY if is_last else NO_APPLY

    await light.set_color_zones(
        start=i, end=i,
        color=color,
        duration=0.0,
        apply=apply
    )
```

Multiple messages with `apply` logic:

- `NO_APPLY` (0): Update buffer, don't display
- `APPLY` (1): Update buffer and display (used on last zone)

This ensures atomic update visible only when all zones are set.

#### Timing Delays

Critical 0.3-second delays ensure device processing:

```python
# After multizone restoration
await asyncio.sleep(0.3)

# After color restoration
await asyncio.sleep(0.3)

# No delay after power (last operation)
```

Without these delays, subsequent operations may arrive before device finishes processing, causing state corruption.

### Prestate Inheritance

Optimization that skips state capture/restore for compatible consecutive effects:

```python
def inherit_prestate(self, other: LIFXEffect) -> bool:
    """Return True if can skip restoration."""
    return isinstance(other, EffectColorloop)  # Example
```

**When used:**

```python
current_running = self._running.get(serial)
if current_running and effect.inherit_prestate(current_running.effect):
    # Reuse existing prestate
    prestate = current_running.prestate
else:
    # Capture new prestate
    prestate = await self._capture_prestate(light)
```

**Benefits:**

- Eliminates flash/reset between compatible effects
- Reduces network traffic
- Faster effect transitions

**Used by:**

- `EffectColorloop.inherit_prestate()` → Returns `True` for other `EffectColorloop` instances
- `EffectPulse` doesn't use it (returns `False`)

## Concurrency Model

### Thread Safety

The conductor uses an `asyncio.Lock()` for thread-safe state management:

```python
async def start(self, effect, participants):
    async with self._lock:
        # Critical section: state capture and registration
        for light in participants:
            prestate = await self._capture_prestate(light)
            self._running[light.serial] = RunningEffect(effect, prestate)

    # Effect execution happens outside lock (concurrent)
    await effect.async_perform(participants)
```

**Why lock is needed:**

- Prevents race conditions when starting/stopping effects concurrently
- Protects `_running` dictionary modifications
- Ensures atomic state capture and registration

**Why effect execution is outside lock:**

- Allows multiple effects to run concurrently on different devices
- Effect logic doesn't modify conductor state
- Prevents blocking other operations during long-running effects

### Concurrent Device Operations

Effects use `asyncio.gather()` for concurrent device operations:

```python
# Apply waveform to all devices concurrently
tasks = [
    light.set_waveform(color, period, cycles, waveform)
    for light in self.participants
]
await asyncio.gather(*tasks)
```

**Benefits:**

- Multiple devices updated in parallel
- Network latency overlaps
- Total time ≈ single device time (not N × device time)

### Background Response Dispatcher

Each `DeviceConnection` has a background receiver task that routes responses:

```python
# In DeviceConnection
async def _response_receiver(self):
    while self._running:
        packet = await self._receive_packet()
        # Route by sequence number to waiting coroutine
        self._pending[seq_num].set_result(packet)
```

**Implications for effects:**

- Multiple concurrent requests on same device are supported
- Responses are correctly matched even with concurrent operations
- No additional coordination needed in effect code

### Effect Concurrency Patterns

#### Pattern 1: Sequential Effects on Same Devices

```python
# Effect 1 completes before Effect 2 starts
await conductor.start(effect1, lights)
await asyncio.sleep(duration1)
await conductor.start(effect2, lights)  # Captures new state
```

State is automatically restored between effects.

#### Pattern 2: Concurrent Effects on Different Devices

```python
# Different devices, completely independent
await conductor.start(effect1, group1)
await conductor.start(effect2, group2)
# Both run concurrently
```

No locking needed - different devices, different state.

#### Pattern 3: Replacing Running Effect

```python
# Start effect1
await conductor.start(effect1, lights)
await asyncio.sleep(5)

# Replace with effect2
await conductor.start(effect2, lights)  # Prestate may be inherited
```

If `effect2.inherit_prestate(effect1)` returns `True`, no restoration happens.

## Device Type Handling

### Device Capabilities Detection

The effects framework adapts to device capabilities automatically:

```python
# Check if multizone
if isinstance(light, MultiZoneLight):
    # Capture zone colors
    zone_colors = await light.get_color_zones(...)

# Check if extended multizone supported
if light.capabilities and light.capabilities.has_extended_multizone:
    # Use efficient extended messages
    await light.set_extended_color_zones(...)
```

### Device-Specific Behavior

#### Color Lights (`Light`)

- Full HSBK color support
- All effect parameters apply
- No special handling needed

#### Multizone Lights (`MultiZoneLight`)

- **State Capture:** Zone colors captured using extended or standard messages
- **State Restoration:** All zones restored with proper `apply` logic
- **Effect Behavior:** Entire device pulses/cycles together (zones not individually controlled)
- **Timing:** 0.3s delay after zone restoration

#### Tile Devices (`TileDevice`)

- **Current Implementation:** Treated like color lights (no tile-specific logic yet)
- **Future Enhancement:** Could apply effects to individual tiles using tile chain

#### HEV Lights (`HevLight`)

- Treated like standard color lights
- HEV cycle not affected by effects
- Effects don't interfere with HEV functionality

#### Infrared Lights (`InfraredLight`)

- Treated like standard color lights
- Infrared LED not affected by color effects
- Effects only control visible light

#### Monochrome/White Lights

- **Color parameters ignored:** Hue and saturation have no effect
- **Brightness works:** Effects can still toggle/fade brightness
- **Kelvin preserved:** Temperature setting maintained
- **Recommendation:** Limited usefulness (only brightness changes visible)

## Design Decisions

### Why Conductor Pattern?

**Decision:** Central conductor manages all effect lifecycle instead of effects managing themselves.

**Rationale:**

1. **Centralized State:** Single source of truth for what's running where
1. **Consistent State Management:** All effects get same capture/restore logic
1. **Concurrency Control:** Single lock protects all state modifications
1. **User Simplicity:** Users don't manage state manually

**Alternative Considered:** Effects self-manage state

**Rejected because:** Would require each effect to duplicate state logic, higher chance of bugs

### Why Abstract Base Class?

**Decision:** `LIFXEffect` is abstract with required `async_play()` override.

**Rationale:**

1. **Type Safety:** Enforces effect interface at type-check time
1. **Code Reuse:** Common setup logic in `async_perform()`
1. **Extensibility:** Users can create custom effects easily
1. **Consistency:** All effects follow same pattern

### Why Two-Phase Effect Execution?

**Decision:** `async_perform()` calls `async_play()` instead of single method.

**Rationale:**

1. **Separation of Concerns:** Setup logic separate from effect logic
1. **User Simplicity:** Users only override `async_play()`, setup is automatic
1. **Consistency:** All effects get same power-on behavior
1. **Flexibility:** Base class can add more setup steps without breaking subclasses

### Why No Rate Limiting?

**Decision:** Effects don't implement rate limiting.

**Rationale:**

1. **Simplicity:** Keeps core library simple and focused
1. **Flexibility:** Applications have different rate limit needs
1. **Transparency:** Users see actual device behavior
1. **Consistency:** Matches lifx-async philosophy (no hidden rate limiting)

**Recommendation:** Applications should implement rate limiting if sending many concurrent requests.

### Why 0.3-Second Delays?

**Decision:** Fixed 0.3-second delays between state restoration operations.

**Rationale:**

1. **Device Processing Time:** LIFX devices need time to process commands
1. **Empirical Testing:** 0.3s works reliably across all device types
1. **State Integrity:** Prevents race conditions and state corruption
1. **Trade-off:** Slightly slower restoration but guaranteed correctness

**Alternative Considered:** No delays, faster restoration

**Rejected because:** Causes state corruption and unpredictable behavior

### Why Prestate Inheritance?

**Decision:** Optional optimization via `inherit_prestate()` method.

**Rationale:**

1. **Performance:** Eliminates unnecessary state reset
1. **User Experience:** No visible flash between compatible effects
1. **Opt-in:** Only used when effect explicitly enables it
1. **Safe Default:** Returns `False` unless overridden

**Use Cases:**

- ColorLoop → ColorLoop: Seamless transition
- Pulse → Pulse: Could enable but currently disabled
- Different types: Should not inherit (different visual intent)

### Why No Tile-Specific Logic (Yet)?

**Decision:** Tiles treated like single-color lights for now.

**Rationale:**

1. **MVP Scope:** Phase 1 focuses on core framework
1. **Complexity:** Tile effects require 2D coordinate system
1. **Future Enhancement:** Architecture supports adding tile-specific effects later
1. **Current Usefulness:** Effects still work on tiles (just not tile-aware)

**Future Work:** Tile-specific effects would use `TileDevice.set_tile_colors()` and apply per-tile logic similar to theme support.

## Integration Points

### With Device Layer

Effects use standard device methods:

- `get_power()`, `set_power()`
- `get_color()`, `set_color()`
- `set_waveform()` (EffectPulse)
- `get_color_zones()`, `set_color_zones()` (MultiZoneLight)
- `get_extended_color_zones()`, `set_extended_color_zones()` (MultiZoneLight)

No special device modifications needed.

### With Network Layer

Effects rely on existing connection pooling and concurrent request support:

- Connection pooling (LRU cache) reuses connections
- Background response dispatcher handles concurrent requests
- No effect-specific network code needed

### With Protocol Layer

Effects use existing protocol structures:

- `HSBK` for color representation
- `LightWaveform` enum for waveform types
- `MultiZoneApplicationRequest` for zone apply logic
- Auto-generated packet classes

## Performance Characteristics

### Memory Usage

- **Conductor:** ~10KB base + running effects
- **Per Effect:** ~1KB per device + effect-specific state
- **PreState:** ~200 bytes per device (~100 bytes + zone colors)

### CPU Usage

- **Minimal:** Async I/O bound, not CPU bound
- **Concurrency:** Multiple devices don't increase CPU significantly
- **Background Tasks:** One receiver task per connection (managed by connection pool)

### Network Traffic

#### State Capture

- Power: 1 request per device
- Color: 1 request per device
- Multizone: 1 request (extended) or N/8 requests (standard)
- **Total:** 3-4 packets per device

#### Effect Execution

- Pulse: 1 waveform packet per device
- ColorLoop: 1 color packet per device per iteration

#### State Restoration

- Multizone: 1 request (extended) or N requests (standard)
- Color: 1 request per device
- Power: 1 request per device
- **Total:** 2-3 packets per device (or N+2 for standard multizone)

### Scalability

- **Tested:** 10+ devices
- **Expected:** 50+ devices in production
- **Limitation:** Network capacity and device response time
- **Recommendation:** For 50+ devices, consider grouping effects or staggering start times

## See Also

- [Getting Started](../../getting-started/effects/) - Basic usage
- [Effects Reference](../../api/effects/) - Detailed API documentation
- [Custom Effects](../../user-guide/effects-custom/) - Creating your own effects
- [Troubleshooting](../../user-guide/effects-troubleshooting/) - Common issues
# API Reference

# API Reference

Complete reference documentation for lifx-async.

## Module Structure

```text
lifx/
├── __init__.py               # High-level API exports
├── api.py                    # Simplified discovery and device group functions
├── color.py                  # Color utilities (HSBK, Colors)
├── const.py                  # Network constants and URLs
├── exceptions.py             # Exception hierarchy
├── devices/                  # Device classes
│   ├── base.py              # Base Device class
│   ├── light.py             # Light device (color control)
│   ├── hev.py               # HevLight device (anti-bacterial cleaning)
│   ├── infrared.py          # InfraredLight device (night vision)
│   ├── multizone.py         # MultiZoneLight (strips/beams)
│   └── tile.py              # TileDevice (2D pixel grids)
├── network/                  # Network layer
│   ├── connection.py        # Device connections with pooling
│   ├── discovery.py         # Network device discovery
│   ├── message.py           # Message building and parsing
│   └── transport.py         # UDP transport
├── products/                 # Product registry
│   ├── registry.py          # Auto-generated product database
│   ├── generator.py         # Generator to download/parse products.json
│   └── __init__.py          # Public API exports
└── protocol/                 # Protocol layer (auto-generated)
    ├── base.py              # Base packet class
    ├── generator.py         # Code generator from protocol.yml
    ├── header.py            # Protocol header (36 bytes)
    ├── models.py            # Protocol models (Serial, HEV types)
    ├── packets.py           # Packet definitions
    ├── protocol_types.py    # Type definitions and enums
    └── serializer.py        # Binary serialization/deserialization
```

## Quick Reference

### High-Level API

Main entry points for most users:

- [`discover()`](high-level/#lifx.api.discover) - Simple device discovery
- [`find_lights()`](high-level/#lifx.api.find_lights) - Find Light devices
- [`find_by_serial()`](high-level/#lifx.api.find_by_serial) - Find specific device
- [`DeviceGroup`](high-level/#lifx.api.DeviceGroup) - Batch operations

### Device Classes

Control your LIFX devices:

- [`Device`](devices/#lifx.devices.base.Device) - Base device operations
- [`Light`](devices/#lifx.devices.light.Light) - Color control
- [`HevLight`](devices/#lifx.devices.hev.HevLight) - Anti-bacterial cleaning cycles
- [`InfraredLight`](devices/#lifx.devices.infrared.InfraredLight) - Night vision infrared LED
- [`MultiZoneLight`](devices/#lifx.devices.multizone.MultiZoneLight) - Strips/beams
- [`TileDevice`](devices/#lifx.devices.tile.TileDevice) - 2D tile grids

### Color Utilities

Work with colors:

- [`HSBK`](colors/#lifx.color.HSBK) - Color representation
- [`Colors`](colors/#lifx.color.Colors) - Built-in presets

### Network Layer

Low-level network operations:

- [`discover_devices()`](network/#lifx.network.discovery.discover_devices) - Low-level discovery
- [`DeviceConnection`](network/#lifx.network.connection.DeviceConnection) - Device connections

### Products Registry

Device capabilities and automatic type detection:

- [`ProductInfo`](protocol/#lifx.products.ProductInfo) - Product information
- [`ProductCapability`](protocol/#lifx.products.ProductCapability) - Device capabilities

### Exceptions

Error handling:

- [`LifxError`](exceptions/#lifx.exceptions.LifxError) - Base exception
- [`LifxTimeoutError`](exceptions/#lifx.exceptions.LifxTimeoutError) - Timeout errors
- [`LifxConnectionError`](exceptions/#lifx.exceptions.LifxConnectionError) - Connection errors

## Usage Patterns

### Async Context Managers

All device classes support async context managers for automatic resource cleanup:

```python
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)
# Connection automatically closed
```

### Batch Operations

Use `DeviceGroup` for efficient batch operations:

```python
async with discover() as group:
    await group.set_power(True)
    await group.set_color(Colors.BLUE)
```

### Connection Pooling

Connections are automatically pooled and reused:

```python
# Multiple operations reuse the same connection
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.RED)
    await light.set_brightness(0.5)
    await light.get_label()
```

### Concurrent Requests

Devices support concurrent requests via asyncio.gather:

```python
# Execute multiple operations concurrently
async with await Light.from_ip("192.168.1.100") as light:
    # Note: get_color() returns (color, power, label) tuple
    (color, power, label), version = await asyncio.gather(
        light.get_color(),
        light.get_version()
    )
    brightness = color.brightness
    print(f"{label}: Brightness={brightness}, Firmware={version.firmware}")
```

## Type Hints

lifx-async is fully type-hinted. Use a type checker like Pyright or mypy:

```python
from lifx import Light, HSBK


async def set_custom_color(light: Light, hue: float) -> None:
    color: HSBK = HSBK(hue=hue, saturation=1.0, brightness=0.8, kelvin=3500)
    await light.set_color(color)
```

## API Sections

- **High-Level API**

______________________________________________________________________

Simple, batteries-included API for common tasks

[High-Level API](high-level/)

- **Device Classes**

______________________________________________________________________

Control LIFX lights, strips, and tiles

[Devices](devices/)

- **Color Utilities**

______________________________________________________________________

Work with colors, RGB, and HSBK

[Colors](colors/)

- **Network Layer**

______________________________________________________________________

Low-level network operations

[Network](network/)

- **Protocol Layer**

______________________________________________________________________

Auto-generated protocol structures

[Protocol](protocol/)

- **Exceptions**

______________________________________________________________________

Error handling and exception hierarchy

[Exceptions](exceptions/)

## Best Practices

### Always Use Context Managers

```python
# ✅ Good - automatic cleanup
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)

# ❌ Bad - manual cleanup required
light = Light("d073d5123456", "192.168.1.100")
await light.connect()
await light.set_color(Colors.BLUE)
await light.disconnect()
```

### Handle Exceptions

```python
from lifx import discover, LifxError

try:
    async with discover() as group:
        await group.set_color(Colors.GREEN)
except LifxError as e:
    print(f"LIFX error: {e}")
```

### Use Type Hints

```python
from lifx import Light, HSBK


async def control_light(light: Light) -> str:
    label: str = await light.get_label()
    return label
```

## Further Reading

- [Architecture](../architecture/overview/) - How lifx-async works
- [FAQ](../faq/) - Frequently asked questions

# High-Level API

The high-level API provides simplified functions for common LIFX operations. These are the recommended entry points for most users.

## Discovery Functions

### discover

```python
discover(
    timeout: float = 3.0,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> DiscoveryContext
```

Discover LIFX devices and return a discovery context manager.

This function returns an async context manager that performs device discovery and automatically handles connection/disconnection.

| PARAMETER                 | DESCRIPTION                                                                                           |
| ------------------------- | ----------------------------------------------------------------------------------------------------- |
| `timeout`                 | Discovery timeout in seconds (default 3.0) **TYPE:** `float` **DEFAULT:** `3.0`                       |
| `broadcast_address`       | Broadcast address to use (default "255.255.255.255") **TYPE:** `str` **DEFAULT:** `'255.255.255.255'` |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                      |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                     |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                      |

| RETURNS            | DESCRIPTION                            |
| ------------------ | -------------------------------------- |
| `DiscoveryContext` | DiscoveryContext async context manager |

Example

```python
# Discover and control all devices using context manager
async with discover() as group:
    await group.set_power(True)
    await group.set_color(Colors.BLUE)
```

Source code in `src/lifx/api.py`

````python
def discover(
    timeout: float = 3.0,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> DiscoveryContext:
    """Discover LIFX devices and return a discovery context manager.

    This function returns an async context manager that performs device
    discovery and automatically handles connection/disconnection.

    Args:
        timeout: Discovery timeout in seconds (default 3.0)
        broadcast_address: Broadcast address to use (default "255.255.255.255")
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier

    Returns:
        DiscoveryContext async context manager

    Example:
        ```python
        # Discover and control all devices using context manager
        async with discover() as group:
            await group.set_power(True)
            await group.set_color(Colors.BLUE)
        ```
    """
    return DiscoveryContext(
        timeout=timeout,
        broadcast_address=broadcast_address,
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
    )
````

### find_lights

```python
find_lights(
    label_contains: str | None = None,
    timeout: float = 3.0,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> list[Light]
```

Find Light devices with optional label filtering.

| PARAMETER                 | DESCRIPTION                                                                                           |
| ------------------------- | ----------------------------------------------------------------------------------------------------- |
| `label_contains`          | Filter by label substring (case-insensitive) **TYPE:** \`str                                          |
| `timeout`                 | Discovery timeout in seconds (default 3.0) **TYPE:** `float` **DEFAULT:** `3.0`                       |
| `broadcast_address`       | Broadcast address to use (default "255.255.255.255") **TYPE:** `str` **DEFAULT:** `'255.255.255.255'` |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                      |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                     |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                      |

| RETURNS       | DESCRIPTION                                   |
| ------------- | --------------------------------------------- |
| `list[Light]` | List of Light instances matching the criteria |

Example

```python
# Find all lights with "bedroom" in the label
lights = await find_lights(label_contains="bedroom")
for light in lights:
    async with light:
        await light.set_color(Colors.WARM_WHITE)
```

Source code in `src/lifx/api.py`

````python
async def find_lights(
    label_contains: str | None = None,
    timeout: float = 3.0,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> list[Light]:
    """Find Light devices with optional label filtering.

    Args:
        label_contains: Filter by label substring (case-insensitive)
        timeout: Discovery timeout in seconds (default 3.0)
        broadcast_address: Broadcast address to use (default "255.255.255.255")
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier

    Returns:
        List of Light instances matching the criteria

    Example:
        ```python
        # Find all lights with "bedroom" in the label
        lights = await find_lights(label_contains="bedroom")
        for light in lights:
            async with light:
                await light.set_color(Colors.WARM_WHITE)
        ```
    """
    discovered = await discover_devices(
        timeout=timeout,
        broadcast_address=broadcast_address,
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
    )

    # Detect device types in parallel
    results: list[Device | None] = [None] * len(discovered)

    async def detect_and_store(index: int, disc: DiscoveredDevice) -> None:
        results[index] = await _detect_device_type(disc)

    async with asyncio.TaskGroup() as tg:
        for i, disc in enumerate(discovered):
            tg.create_task(detect_and_store(i, disc))

    devices = [d for d in results if d is not None]

    # Filter to only Light devices (and subclasses like MultiZoneLight, TileDevice)
    lights: list[Light] = [d for d in devices if isinstance(d, Light)]

    # If label filtering is requested, connect and check label
    if label_contains is not None:
        filtered_lights: list[Light] = []
        for light in lights:
            async with light:
                try:
                    label = await light.get_label()
                    if label_contains.lower() in label.lower():
                        filtered_lights.append(light)
                except LifxTimeoutError:
                    # Skip devices that fail to respond
                    _LOGGER.warning(
                        {
                            "class": "find_lights",
                            "method": "filter_devices",
                            "action": "no_response",
                            "serial": light.serial,
                            "ip": light.ip,
                        }
                    )
        return filtered_lights

    return lights
````

### find_by_serial

```python
find_by_serial(
    serial: bytes | str,
    timeout: float = 3.0,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> Device | None
```

Find a specific device by serial number.

| PARAMETER                 | DESCRIPTION                                                                                           |
| ------------------------- | ----------------------------------------------------------------------------------------------------- |
| `serial`                  | Serial number as bytes or hex string (with or without separators) **TYPE:** \`bytes                   |
| `timeout`                 | Discovery timeout in seconds (default 3.0) **TYPE:** `float` **DEFAULT:** `3.0`                       |
| `broadcast_address`       | Broadcast address to use (default "255.255.255.255") **TYPE:** `str` **DEFAULT:** `'255.255.255.255'` |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                      |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                     |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                      |

| RETURNS  | DESCRIPTION |
| -------- | ----------- |
| \`Device | None\`      |

Example

```python
# Find by serial number
device = await find_by_serial("d073d5123456")
if device:
    async with device:
        await device.set_power(True)
```

Source code in `src/lifx/api.py`

````python
async def find_by_serial(
    serial: bytes | str,
    timeout: float = 3.0,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> Device | None:
    """Find a specific device by serial number.

    Args:
        serial: Serial number as bytes or hex string (with or without separators)
        timeout: Discovery timeout in seconds (default 3.0)
        broadcast_address: Broadcast address to use (default "255.255.255.255")
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier

    Returns:
        Device instance if found, None otherwise

    Example:
        ```python
        # Find by serial number
        device = await find_by_serial("d073d5123456")
        if device:
            async with device:
                await device.set_power(True)
        ```
    """
    # Normalize serial to string format (12-digit hex, no separators)
    if isinstance(serial, bytes):
        serial_str = serial.hex()
    else:
        serial_str = serial.replace(":", "").replace("-", "").lower()

    discovered = await discover_devices(
        timeout=timeout,
        broadcast_address=broadcast_address,
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
    )

    for d in discovered:
        if d.serial.lower() == serial_str:
            # Detect device type and return appropriate class
            return await _detect_device_type(d)

    return None
````

## Discovery Context

### DiscoveryContext

```python
DiscoveryContext(
    timeout: float,
    broadcast_address: str,
    port: int,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
)
```

Async context manager for device discovery.

Handles device discovery and automatic connection/disconnection. Use with the `discover()` function for convenient device discovery.

Example

```python
async with discover(timeout=5.0) as group:
    await group.set_power(True)
```

| PARAMETER                 | DESCRIPTION                                                                       |
| ------------------------- | --------------------------------------------------------------------------------- |
| `timeout`                 | Discovery timeout in seconds **TYPE:** `float`                                    |
| `broadcast_address`       | Broadcast address to use **TYPE:** `str`                                          |
| `port`                    | Port to use **TYPE:** `int`                                                       |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME` |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`  |

| METHOD       | DESCRIPTION                           |
| ------------ | ------------------------------------- |
| `__aenter__` | Discover devices and connect to them. |
| `__aexit__`  | Disconnect from all devices.          |

Source code in `src/lifx/api.py`

```python
def __init__(
    self,
    timeout: float,
    broadcast_address: str,
    port: int,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> None:
    """Initialize discovery context.

    Args:
        timeout: Discovery timeout in seconds
        broadcast_address: Broadcast address to use
        port: Port to use
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier
    """
    self.timeout = timeout
    self.broadcast_address = broadcast_address
    self.port = port
    self._group: DeviceGroup | None = None
    self._max_response_time = max_response_time
    self._idle_timeout_multiplier = idle_timeout_multiplier
```

#### Functions

##### __aenter__

```python
__aenter__() -> DeviceGroup
```

Discover devices and connect to them.

| RETURNS       | DESCRIPTION                                   |
| ------------- | --------------------------------------------- |
| `DeviceGroup` | DeviceGroup containing all discovered devices |

Source code in `src/lifx/api.py`

```python
async def __aenter__(self) -> DeviceGroup:
    """Discover devices and connect to them.

    Returns:
        DeviceGroup containing all discovered devices
    """
    # Perform discovery
    discovered = await discover_devices(
        timeout=self.timeout,
        broadcast_address=self.broadcast_address,
        port=self.port,
        max_response_time=self._max_response_time,
        idle_timeout_multiplier=self._idle_timeout_multiplier,
    )

    # Detect device types and instantiate appropriate classes
    results: list[Device | None] = [None] * len(discovered)

    async def detect_and_store(index: int, disc: DiscoveredDevice) -> None:
        results[index] = await _detect_device_type(disc)

    async with asyncio.TaskGroup() as tg:
        for i, disc in enumerate(discovered):
            tg.create_task(detect_and_store(i, disc))

    # Filter out None values (unresponsive devices)
    devices = [d for d in results if d is not None]

    # Create group and connect all devices
    self._group = DeviceGroup(devices)
    await self._group.__aenter__()

    return self._group
```

##### __aexit__

```python
__aexit__(
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: TracebackType | None,
) -> None
```

Disconnect from all devices.

Source code in `src/lifx/api.py`

```python
async def __aexit__(
    self,
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: TracebackType | None,
) -> None:
    """Disconnect from all devices."""
    if self._group:
        await self._group.__aexit__(exc_type, exc_val, exc_tb)
```

## Device Group

### DeviceGroup

```python
DeviceGroup(
    devices: list[
        Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice
    ],
)
```

A group of devices for batch operations.

Provides convenient methods to control multiple devices simultaneously.

Example

```python
async with discover() as group:
    await group.set_power(True)
    await group.set_color(Colors.BLUE)
```

| PARAMETER | DESCRIPTION                                       |
| --------- | ------------------------------------------------- |
| `devices` | List of Device instances **TYPE:** \`list\[Device |

| METHOD                      | DESCRIPTION                                        |
| --------------------------- | -------------------------------------------------- |
| `__aenter__`                | Enter async context manager.                       |
| `__aexit__`                 | Exit async context manager.                        |
| `__iter__`                  | Iterate over devices in the group.                 |
| `__len__`                   | Get number of devices in the group.                |
| `set_power`                 | Set power state for all devices in the group.      |
| `set_color`                 | Set color for all Light devices in the group.      |
| `set_brightness`            | Set brightness for all Light devices in the group. |
| `pulse`                     | Pulse effect for all Light devices.                |
| `organize_by_location`      | Organize devices by location label.                |
| `organize_by_group`         | Organize devices by group label.                   |
| `filter_by_location`        | Filter devices to a specific location.             |
| `filter_by_group`           | Filter devices to a specific group.                |
| `get_unassigned_devices`    | Get devices without location or group assigned.    |
| `apply_theme`               | Apply a theme to all devices in the group.         |
| `invalidate_metadata_cache` | Clear all cached location and group metadata.      |

| ATTRIBUTE          | DESCRIPTION                                                                    |
| ------------------ | ------------------------------------------------------------------------------ |
| `devices`          | Get all the devices in the group. **TYPE:** `list[Device]`                     |
| `lights`           | Get all Light devices in the group. **TYPE:** `list[Light]`                    |
| `hev_lights`       | Get the HEV lights in the group. **TYPE:** `list[HevLight]`                    |
| `infrared_lights`  | Get the Infrared lights in the group. **TYPE:** `list[InfraredLight]`          |
| `multizone_lights` | Get all MultiZone light devices in the group. **TYPE:** `list[MultiZoneLight]` |
| `tiles`            | Get all Tile devices in the group. **TYPE:** `list[TileDevice]`                |

Source code in `src/lifx/api.py`

```python
def __init__(
    self,
    devices: list[
        Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice
    ],
) -> None:
    """Initialize device group.

    Args:
        devices: List of Device instances
    """
    self._devices = devices
    self._locations_cache: dict[str, DeviceGroup] | None = None
    self._groups_cache: dict[str, DeviceGroup] | None = None
    self._location_metadata: dict[bytes, LocationGrouping] | None = None
    self._group_metadata: dict[bytes, GroupGrouping] | None = None
```

#### Attributes

##### devices

```python
devices: list[Device]
```

Get all the devices in the group.

##### lights

```python
lights: list[Light]
```

Get all Light devices in the group.

##### hev_lights

```python
hev_lights: list[HevLight]
```

Get the HEV lights in the group.

##### infrared_lights

```python
infrared_lights: list[InfraredLight]
```

Get the Infrared lights in the group.

##### multizone_lights

```python
multizone_lights: list[MultiZoneLight]
```

Get all MultiZone light devices in the group.

##### tiles

```python
tiles: list[TileDevice]
```

Get all Tile devices in the group.

#### Functions

##### __aenter__

```python
__aenter__() -> DeviceGroup
```

Enter async context manager.

Note: With the new connection architecture, explicit connect/disconnect is not needed. Connections are managed automatically by the connection pool when requests are made.

Source code in `src/lifx/api.py`

```python
async def __aenter__(self) -> DeviceGroup:
    """Enter async context manager.

    Note: With the new connection architecture, explicit connect/disconnect
    is not needed. Connections are managed automatically by the connection
    pool when requests are made.
    """
    return self
```

##### __aexit__

```python
__aexit__(
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: TracebackType | None,
) -> None
```

Exit async context manager.

Note: Cleanup is handled automatically by the connection pool.

Source code in `src/lifx/api.py`

```python
async def __aexit__(
    self,
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: TracebackType | None,
) -> None:
    """Exit async context manager.

    Note: Cleanup is handled automatically by the connection pool.
    """
    pass
```

##### __iter__

```python
__iter__() -> Iterator[
    Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice
]
```

Iterate over devices in the group.

Source code in `src/lifx/api.py`

```python
def __iter__(
    self,
) -> Iterator[
    Device | Light | HevLight | InfraredLight | MultiZoneLight | TileDevice
]:
    """Iterate over devices in the group."""
    return iter(self._devices)
```

##### __len__

```python
__len__() -> int
```

Get number of devices in the group.

Source code in `src/lifx/api.py`

```python
def __len__(self) -> int:
    """Get number of devices in the group."""
    return len(self._devices)
```

##### set_power

```python
set_power(on: bool, duration: float = 0.0) -> None
```

Set power state for all devices in the group.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `on`       | True to turn on, False to turn off **TYPE:** `bool`                               |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
async with discover() as group:
    await group.set_power(True, duration=1.0)
```

Source code in `src/lifx/api.py`

````python
async def set_power(self, on: bool, duration: float = 0.0) -> None:
    """Set power state for all devices in the group.

    Args:
        on: True to turn on, False to turn off
        duration: Transition duration in seconds (default 0.0)

    Example:
        ```python
        async with discover() as group:
            await group.set_power(True, duration=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.set_power(on, duration))
````

##### set_color

```python
set_color(color: HSBK, duration: float = 0.0) -> None
```

Set color for all Light devices in the group.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
async with discover() as group:
    await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)
```

Source code in `src/lifx/api.py`

````python
async def set_color(self, color: HSBK, duration: float = 0.0) -> None:
    """Set color for all Light devices in the group.

    Args:
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)

    Example:
        ```python
        async with discover() as group:
            await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.set_color(color, duration))
````

##### set_brightness

```python
set_brightness(brightness: float, duration: float = 0.0) -> None
```

Set brightness for all Light devices in the group.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `brightness` | Brightness level (0.0-1.0) **TYPE:** `float`                                      |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
async with discover() as group:
    await group.set_brightness(0.5, duration=1.0)
```

Source code in `src/lifx/api.py`

````python
async def set_brightness(self, brightness: float, duration: float = 0.0) -> None:
    """Set brightness for all Light devices in the group.

    Args:
        brightness: Brightness level (0.0-1.0)
        duration: Transition duration in seconds (default 0.0)

    Example:
        ```python
        async with discover() as group:
            await group.set_brightness(0.5, duration=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.set_brightness(brightness, duration))
````

##### pulse

```python
pulse(color: HSBK, period: float = 1.0, cycles: float = 1.0) -> None
```

Pulse effect for all Light devices.

| PARAMETER | DESCRIPTION                                                         |
| --------- | ------------------------------------------------------------------- |
| `color`   | Color to pulse to **TYPE:** `HSBK`                                  |
| `period`  | Period of one cycle in seconds **TYPE:** `float` **DEFAULT:** `1.0` |
| `cycles`  | Number of cycles **TYPE:** `float` **DEFAULT:** `1.0`               |

Example

```python
async with discover() as group:
    await group.pulse(Colors.RED, period=1.0, cycles=1.0)
```

Source code in `src/lifx/api.py`

````python
async def pulse(
    self, color: HSBK, period: float = 1.0, cycles: float = 1.0
) -> None:
    """Pulse effect for all Light devices.

    Args:
        color: Color to pulse to
        period: Period of one cycle in seconds
        cycles: Number of cycles

    Example:
        ```python
        async with discover() as group:
            await group.pulse(Colors.RED, period=1.0, cycles=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.pulse(color, period, cycles))
````

##### organize_by_location

```python
organize_by_location(
    include_unassigned: bool = False,
) -> dict[str, DeviceGroup]
```

Organize devices by location label.

Fetches location metadata if not cached and groups devices by location label.

| PARAMETER            | DESCRIPTION                                                      |
| -------------------- | ---------------------------------------------------------------- |
| `include_unassigned` | Include "Unassigned" group **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS                  | DESCRIPTION                                                 |
| ------------------------ | ----------------------------------------------------------- |
| `dict[str, DeviceGroup]` | Dictionary mapping location labels to DeviceGroup instances |

Example

```python
async with discover() as group:
    by_location = await group.organize_by_location()
    kitchen = by_location["Kitchen"]
    await kitchen.set_color(Colors.BLUE)
```

Source code in `src/lifx/api.py`

````python
async def organize_by_location(
    self, include_unassigned: bool = False
) -> dict[str, DeviceGroup]:
    """Organize devices by location label.

    Fetches location metadata if not cached and groups devices by location label.

    Args:
        include_unassigned: Include "Unassigned" group

    Returns:
        Dictionary mapping location labels to DeviceGroup instances

    Example:
        ```python
        async with discover() as group:
            by_location = await group.organize_by_location()
            kitchen = by_location["Kitchen"]
            await kitchen.set_color(Colors.BLUE)
        ```
    """
    # Fetch metadata if not cached
    if self._location_metadata is None:
        await self._fetch_location_metadata()

    # Build and cache groups
    if self._locations_cache is None:
        self._locations_cache = self._build_location_groups(include_unassigned)

    return self._locations_cache
````

##### organize_by_group

```python
organize_by_group(include_unassigned: bool = False) -> dict[str, DeviceGroup]
```

Organize devices by group label.

Fetches group metadata if not cached and groups devices by group label.

| PARAMETER            | DESCRIPTION                                                      |
| -------------------- | ---------------------------------------------------------------- |
| `include_unassigned` | Include "Unassigned" group **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS                  | DESCRIPTION                                              |
| ------------------------ | -------------------------------------------------------- |
| `dict[str, DeviceGroup]` | Dictionary mapping group labels to DeviceGroup instances |

Example

```python
async with discover() as group:
    by_group = await group.organize_by_group()
    bedroom = by_group["Bedroom Lights"]
    await bedroom.set_power(False)
```

Source code in `src/lifx/api.py`

````python
async def organize_by_group(
    self, include_unassigned: bool = False
) -> dict[str, DeviceGroup]:
    """Organize devices by group label.

    Fetches group metadata if not cached and groups devices by group label.

    Args:
        include_unassigned: Include "Unassigned" group

    Returns:
        Dictionary mapping group labels to DeviceGroup instances

    Example:
        ```python
        async with discover() as group:
            by_group = await group.organize_by_group()
            bedroom = by_group["Bedroom Lights"]
            await bedroom.set_power(False)
        ```
    """
    # Fetch metadata if not cached
    if self._group_metadata is None:
        await self._fetch_group_metadata()

    # Build and cache groups
    if self._groups_cache is None:
        self._groups_cache = self._build_group_groups(include_unassigned)

    return self._groups_cache
````

##### filter_by_location

```python
filter_by_location(label: str, case_sensitive: bool = False) -> DeviceGroup
```

Filter devices to a specific location.

| PARAMETER        | DESCRIPTION                                                                                     |
| ---------------- | ----------------------------------------------------------------------------------------------- |
| `label`          | Location label to filter by **TYPE:** `str`                                                     |
| `case_sensitive` | If True, performs case-sensitive matching (default False) **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS       | DESCRIPTION                                              |
| ------------- | -------------------------------------------------------- |
| `DeviceGroup` | DeviceGroup containing devices in the specified location |

| RAISES     | DESCRIPTION                 |
| ---------- | --------------------------- |
| `KeyError` | If location label not found |

Example

```python
async with discover() as group:
    living_room = await group.filter_by_location("Living Room")
    await living_room.set_brightness(0.7)
```

Source code in `src/lifx/api.py`

````python
async def filter_by_location(
    self, label: str, case_sensitive: bool = False
) -> DeviceGroup:
    """Filter devices to a specific location.

    Args:
        label: Location label to filter by
        case_sensitive: If True, performs case-sensitive matching (default False)

    Returns:
        DeviceGroup containing devices in the specified location

    Raises:
        KeyError: If location label not found

    Example:
        ```python
        async with discover() as group:
            living_room = await group.filter_by_location("Living Room")
            await living_room.set_brightness(0.7)
        ```
    """
    locations = await self.organize_by_location(include_unassigned=False)

    # Find matching label
    if case_sensitive:
        if label not in locations:
            raise KeyError(f"Location '{label}' not found")
        return locations[label]
    else:
        label_lower = label.lower()
        for loc_label, device_group in locations.items():
            if loc_label.lower() == label_lower:
                return device_group
        raise KeyError(f"Location '{label}' not found")
````

##### filter_by_group

```python
filter_by_group(label: str, case_sensitive: bool = False) -> DeviceGroup
```

Filter devices to a specific group.

| PARAMETER        | DESCRIPTION                                                                                     |
| ---------------- | ----------------------------------------------------------------------------------------------- |
| `label`          | Group label to filter by **TYPE:** `str`                                                        |
| `case_sensitive` | If True, performs case-sensitive matching (default False) **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS       | DESCRIPTION                                           |
| ------------- | ----------------------------------------------------- |
| `DeviceGroup` | DeviceGroup containing devices in the specified group |

| RAISES     | DESCRIPTION              |
| ---------- | ------------------------ |
| `KeyError` | If group label not found |

Example

```python
async with discover() as group:
    bedroom = await group.filter_by_group("Bedroom Lights")
    await bedroom.set_color(Colors.WARM_WHITE)
```

Source code in `src/lifx/api.py`

````python
async def filter_by_group(
    self, label: str, case_sensitive: bool = False
) -> DeviceGroup:
    """Filter devices to a specific group.

    Args:
        label: Group label to filter by
        case_sensitive: If True, performs case-sensitive matching (default False)

    Returns:
        DeviceGroup containing devices in the specified group

    Raises:
        KeyError: If group label not found

    Example:
        ```python
        async with discover() as group:
            bedroom = await group.filter_by_group("Bedroom Lights")
            await bedroom.set_color(Colors.WARM_WHITE)
        ```
    """
    groups = await self.organize_by_group(include_unassigned=False)

    # Find matching label
    if case_sensitive:
        if label not in groups:
            raise KeyError(f"Group '{label}' not found")
        return groups[label]
    else:
        label_lower = label.lower()
        for grp_label, device_group in groups.items():
            if grp_label.lower() == label_lower:
                return device_group
        raise KeyError(f"Group '{label}' not found")
````

##### get_unassigned_devices

```python
get_unassigned_devices(
    metadata_type: Literal["location", "group"] = "location",
) -> list[Device]
```

Get devices without location or group assigned.

| PARAMETER       | DESCRIPTION                                                                                                          |
| --------------- | -------------------------------------------------------------------------------------------------------------------- |
| `metadata_type` | Type of metadata to check ("location" or "group") **TYPE:** `Literal['location', 'group']` **DEFAULT:** `'location'` |

| RETURNS        | DESCRIPTION                                         |
| -------------- | --------------------------------------------------- |
| `list[Device]` | List of devices without the specified metadata type |

| RAISES         | DESCRIPTION                         |
| -------------- | ----------------------------------- |
| `RuntimeError` | If metadata hasn't been fetched yet |

Example

```python
async with discover() as group:
    await group.organize_by_location()
    unassigned = group.get_unassigned_devices(metadata_type="location")
    print(f"Found {len(unassigned)} devices without location")
```

Source code in `src/lifx/api.py`

````python
def get_unassigned_devices(
    self, metadata_type: Literal["location", "group"] = "location"
) -> list[Device]:
    """Get devices without location or group assigned.

    Args:
        metadata_type: Type of metadata to check ("location" or "group")

    Returns:
        List of devices without the specified metadata type

    Raises:
        RuntimeError: If metadata hasn't been fetched yet

    Example:
        ```python
        async with discover() as group:
            await group.organize_by_location()
            unassigned = group.get_unassigned_devices(metadata_type="location")
            print(f"Found {len(unassigned)} devices without location")
        ```
    """
    if metadata_type == "location":
        if self._location_metadata is None:
            raise RuntimeError(
                "Location metadata not fetched. Call organize_by_location() first."
            )
        return [d for d in self._devices if not self._has_location(d)]
    else:
        if self._group_metadata is None:
            raise RuntimeError(
                "Group metadata not fetched. Call organize_by_group() first."
            )
        return [d for d in self._devices if not self._has_group(d)]
````

##### apply_theme

```python
apply_theme(
    theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None
```

Apply a theme to all devices in the group.

Each device applies the theme according to its capabilities:

- Light: Selects random color from theme
- MultiZoneLight: Distributes colors evenly across zones
- TileDevice: Uses interpolation for smooth gradients
- Other devices: No action (themes only apply to color devices)

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                    |
| `power_on` | Turn on devices if True **TYPE:** `bool` **DEFAULT:** `False`       |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
from lifx.theme import get_theme

async with discover() as group:
    evening = get_theme("evening")
    await group.apply_theme(evening, power_on=True, duration=1.0)
```

Source code in `src/lifx/api.py`

````python
async def apply_theme(
    self, theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None:
    """Apply a theme to all devices in the group.

    Each device applies the theme according to its capabilities:
    - Light: Selects random color from theme
    - MultiZoneLight: Distributes colors evenly across zones
    - TileDevice: Uses interpolation for smooth gradients
    - Other devices: No action (themes only apply to color devices)

    Args:
        theme: Theme to apply
        power_on: Turn on devices if True
        duration: Transition duration in seconds

    Example:
        ```python
        from lifx.theme import get_theme

        async with discover() as group:
            evening = get_theme("evening")
            await group.apply_theme(evening, power_on=True, duration=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        # Apply theme to all lights
        for light in self.lights:
            tg.create_task(light.apply_theme(theme, power_on, duration))

        # Apply theme to all multizone lights
        for multizone in self.multizone_lights:
            tg.create_task(multizone.apply_theme(theme, power_on, duration))

        # Apply theme to all tile devices
        for tile in self.tiles:
            tg.create_task(tile.apply_theme(theme, power_on, duration))
````

##### invalidate_metadata_cache

```python
invalidate_metadata_cache() -> None
```

Clear all cached location and group metadata.

Use this if you've changed device locations/groups and want to re-fetch.

Example

```python
async with discover() as group:
    # First organization
    by_location = await group.organize_by_location()

    # ... change device locations ...

    # Clear cache and re-organize
    group.invalidate_metadata_cache()
    by_location = await group.organize_by_location()
```

Source code in `src/lifx/api.py`

````python
def invalidate_metadata_cache(self) -> None:
    """Clear all cached location and group metadata.

    Use this if you've changed device locations/groups and want to re-fetch.

    Example:
        ```python
        async with discover() as group:
            # First organization
            by_location = await group.organize_by_location()

            # ... change device locations ...

            # Clear cache and re-organize
            group.invalidate_metadata_cache()
            by_location = await group.organize_by_location()
        ```
    """
    self._locations_cache = None
    self._groups_cache = None
    self._location_metadata = None
    self._group_metadata = None
````

## Examples

### Simple Discovery

```python
from lifx import discover, Colors


async def main():
    async with discover() as group:
        print(f"Found {len(group.devices)} devices")
        await group.set_power(True)
        await group.set_color(Colors.BLUE)
```

### Find Specific Lights

```python
from lifx import find_lights


async def main():
    # Find all lights with "Kitchen" in the label
    async with find_lights(label_filter="Kitchen") as lights:
        for light in lights:
            await light.set_brightness(0.8)
```

### Find by Serial Number

```python
from lifx import find_by_serial


async def main():
    # Find specific device by serial number
    device = await find_by_serial("d073d5123456")
    if device:
        async with device:
            await device.set_power(True)
```

# Themes API Reference

The theme system provides professionally-curated color palettes for coordinated lighting across LIFX devices.

## Theme Class

The `Theme` class represents a collection of HSBK colors forming a coordinated palette.

### Theme

```python
Theme(colors: list[HSBK] | None = None)
```

A collection of colors representing a theme or color palette.

Themes can be applied to LIFX devices to coordinate colors across multiple lights. Supports both single-zone and multi-zone devices.

| ATTRIBUTE | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `colors`  | List of HSBK colors in the theme **TYPE:** `list[HSBK]` |

Example

```python
# Create a theme with specific colors
theme = Theme(
    [
        HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500),  # Red
        HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500),  # Green
        HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500),  # Blue
    ]
)

# Access colors
for color in theme:
    print(f"Color: {color.hue}°")

# Get a specific color
first_color = theme[0]

# Add more colors
theme.add_color(HSBK(hue=180, saturation=1.0, brightness=1.0, kelvin=3500))
```

| PARAMETER | DESCRIPTION                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| `colors`  | List of HSBK colors (defaults to white if None or empty) **TYPE:** \`list[HSBK] |

Example

```python
# Create from list of colors
theme = Theme([color1, color2, color3])

# Create with default white color
theme = Theme()
```

| METHOD                    | DESCRIPTION                                                 |
| ------------------------- | ----------------------------------------------------------- |
| `add_color`               | Add a color to the theme.                                   |
| `random`                  | Get a random color from the theme.                          |
| `shuffled`                | Get a new theme with colors in random order.                |
| `get_next_bounds_checked` | Get the next color after index or the last color if at end. |
| `ensure_color`            | Ensure the theme has at least one color.                    |
| `__len__`                 | Get the number of colors in the theme.                      |
| `__iter__`                | Iterate over colors in the theme.                           |
| `__getitem__`             | Get a color by index.                                       |
| `__contains__`            | Check if a color is in the theme.                           |
| `__repr__`                | Return a string representation of the theme.                |

Source code in `src/lifx/theme/theme.py`

````python
def __init__(self, colors: list[HSBK] | None = None) -> None:
    """Create a new theme with the given colors.

    Args:
        colors: List of HSBK colors (defaults to white if None or empty)

    Example:
        ```python
        # Create from list of colors
        theme = Theme([color1, color2, color3])

        # Create with default white color
        theme = Theme()
        ```
    """
    if colors and len(colors) > 0:
        self.colors: list[HSBK] = colors
    else:
        # Default to white if no colors provided
        self.colors = [Colors.WHITE_NEUTRAL]
````

#### Functions

##### add_color

```python
add_color(color: HSBK) -> None
```

Add a color to the theme.

| PARAMETER | DESCRIPTION                        |
| --------- | ---------------------------------- |
| `color`   | HSBK color to add **TYPE:** `HSBK` |

Example

```python
theme = Theme()
theme.add_color(HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500))
```

Source code in `src/lifx/theme/theme.py`

````python
def add_color(self, color: HSBK) -> None:
    """Add a color to the theme.

    Args:
        color: HSBK color to add

    Example:
        ```python
        theme = Theme()
        theme.add_color(HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500))
        ```
    """
    self.colors.append(color)
````

##### random

```python
random() -> HSBK
```

Get a random color from the theme.

| RETURNS | DESCRIPTION                        |
| ------- | ---------------------------------- |
| `HSBK`  | A random HSBK color from the theme |

Example

```python
theme = Theme([red, green, blue])
color = theme.random()
```

Source code in `src/lifx/theme/theme.py`

````python
def random(self) -> HSBK:
    """Get a random color from the theme.

    Returns:
        A random HSBK color from the theme

    Example:
        ```python
        theme = Theme([red, green, blue])
        color = theme.random()
        ```
    """
    return random.choice(self.colors)  # nosec
````

##### shuffled

```python
shuffled() -> Theme
```

Get a new theme with colors in random order.

| RETURNS | DESCRIPTION                             |
| ------- | --------------------------------------- |
| `Theme` | New Theme instance with shuffled colors |

Example

```python
theme = Theme([color1, color2, color3])
shuffled_theme = theme.shuffled()
```

Source code in `src/lifx/theme/theme.py`

````python
def shuffled(self) -> Theme:
    """Get a new theme with colors in random order.

    Returns:
        New Theme instance with shuffled colors

    Example:
        ```python
        theme = Theme([color1, color2, color3])
        shuffled_theme = theme.shuffled()
        ```
    """
    shuffled_colors = self.colors.copy()
    random.shuffle(shuffled_colors)
    return Theme(shuffled_colors)
````

##### get_next_bounds_checked

```python
get_next_bounds_checked(index: int) -> HSBK
```

Get the next color after index or the last color if at end.

| PARAMETER | DESCRIPTION                            |
| --------- | -------------------------------------- |
| `index`   | Index of current color **TYPE:** `int` |

| RETURNS | DESCRIPTION                                              |
| ------- | -------------------------------------------------------- |
| `HSBK`  | Next HSBK color or the last color if index is at the end |

Example

```python
theme = Theme([red, green, blue])
color = theme.get_next_bounds_checked(0)  # green
color = theme.get_next_bounds_checked(2)  # blue (last color)
```

Source code in `src/lifx/theme/theme.py`

````python
def get_next_bounds_checked(self, index: int) -> HSBK:
    """Get the next color after index or the last color if at end.

    Args:
        index: Index of current color

    Returns:
        Next HSBK color or the last color if index is at the end

    Example:
        ```python
        theme = Theme([red, green, blue])
        color = theme.get_next_bounds_checked(0)  # green
        color = theme.get_next_bounds_checked(2)  # blue (last color)
        ```
    """
    if index + 1 < len(self.colors):
        return self.colors[index + 1]
    return self.colors[-1]
````

##### ensure_color

```python
ensure_color() -> None
```

Ensure the theme has at least one color.

If the theme is empty, adds a default white color.

Source code in `src/lifx/theme/theme.py`

```python
def ensure_color(self) -> None:
    """Ensure the theme has at least one color.

    If the theme is empty, adds a default white color.
    """
    if not self.colors:
        self.colors.append(HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500))
```

##### __len__

```python
__len__() -> int
```

Get the number of colors in the theme.

Source code in `src/lifx/theme/theme.py`

```python
def __len__(self) -> int:
    """Get the number of colors in the theme."""
    return len(self.colors)
```

##### __iter__

```python
__iter__() -> Iterator[HSBK]
```

Iterate over colors in the theme.

Source code in `src/lifx/theme/theme.py`

```python
def __iter__(self) -> Iterator[HSBK]:
    """Iterate over colors in the theme."""
    return iter(self.colors)
```

##### __getitem__

```python
__getitem__(index: int) -> HSBK
```

Get a color by index.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `index`   | Index of the color (0-based) **TYPE:** `int` |

| RETURNS | DESCRIPTION                   |
| ------- | ----------------------------- |
| `HSBK`  | HSBK color at the given index |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `IndexError` | If index is out of range |

Example

```python
theme = Theme([red, green, blue])
color = theme[1]  # green
```

Source code in `src/lifx/theme/theme.py`

````python
def __getitem__(self, index: int) -> HSBK:
    """Get a color by index.

    Args:
        index: Index of the color (0-based)

    Returns:
        HSBK color at the given index

    Raises:
        IndexError: If index is out of range

    Example:
        ```python
        theme = Theme([red, green, blue])
        color = theme[1]  # green
        ```
    """
    return self.colors[index]
````

##### __contains__

```python
__contains__(color: HSBK) -> bool
```

Check if a color is in the theme.

| PARAMETER | DESCRIPTION                          |
| --------- | ------------------------------------ |
| `color`   | HSBK color to check **TYPE:** `HSBK` |

| RETURNS | DESCRIPTION                                     |
| ------- | ----------------------------------------------- |
| `bool`  | True if color is in theme (by value comparison) |

Example

```python
theme = Theme([red, green, blue])
if red in theme:
    print("Red is in the theme")
```

Source code in `src/lifx/theme/theme.py`

````python
def __contains__(self, color: HSBK) -> bool:
    """Check if a color is in the theme.

    Args:
        color: HSBK color to check

    Returns:
        True if color is in theme (by value comparison)

    Example:
        ```python
        theme = Theme([red, green, blue])
        if red in theme:
            print("Red is in the theme")
        ```
    """
    return any(
        c.hue == color.hue
        and c.saturation == color.saturation
        and c.brightness == color.brightness
        and c.kelvin == color.kelvin
        for c in self.colors
    )
````

##### __repr__

```python
__repr__() -> str
```

Return a string representation of the theme.

Source code in `src/lifx/theme/theme.py`

```python
def __repr__(self) -> str:
    """Return a string representation of the theme."""
    color_count = len(self.colors)
    return f"Theme({color_count} colors)"
```

## ThemeLibrary Class

The `ThemeLibrary` provides access to 42 official LIFX app themes organized into 6 categories.

### ThemeLibrary

Collection of built-in color themes for LIFX devices.

Provides access to 60+ professionally designed themes organized by mood, season, occasion, and time of day.

Example

```python
# Get a specific theme
evening_theme = ThemeLibrary.get("evening")

# List all available themes
all_themes = ThemeLibrary.list()

# Get themes by category
seasonal = ThemeLibrary.get_by_category("seasonal")

# Apply to a light
await light.apply_theme(evening_theme, power_on=True)
```

| METHOD            | DESCRIPTION                     |
| ----------------- | ------------------------------- |
| `get`             | Get a theme by name.            |
| `list`            | List all available theme names. |
| `get_by_category` | Get all themes in a category.   |

#### Functions

##### get

```python
get(name: str) -> Theme
```

Get a theme by name.

| PARAMETER | DESCRIPTION                                   |
| --------- | --------------------------------------------- |
| `name`    | Theme name (case-insensitive) **TYPE:** `str` |

| RETURNS | DESCRIPTION  |
| ------- | ------------ |
| `Theme` | Theme object |

| RAISES     | DESCRIPTION                |
| ---------- | -------------------------- |
| `KeyError` | If theme name is not found |

Example

```python
from lifx.theme import ThemeLibrary

evening_theme = ThemeLibrary.get("evening")
await light.apply_theme(evening_theme, power_on=True)
```

Source code in `src/lifx/theme/library.py`

````python
@classmethod
def get(cls, name: str) -> Theme:
    """Get a theme by name.

    Args:
        name: Theme name (case-insensitive)

    Returns:
        Theme object

    Raises:
        KeyError: If theme name is not found

    Example:
        ```python
        from lifx.theme import ThemeLibrary

        evening_theme = ThemeLibrary.get("evening")
        await light.apply_theme(evening_theme, power_on=True)
        ```
    """
    normalized_name = name.lower()
    if normalized_name not in cls._THEMES:
        available = ", ".join(sorted(cls._THEMES.keys()))
        raise KeyError(f"Theme '{name}' not found. Available themes: {available}")
    return Theme(cls._THEMES[normalized_name])
````

##### list

```python
list() -> list[str]
```

List all available theme names.

| RETURNS     | DESCRIPTION                |
| ----------- | -------------------------- |
| `list[str]` | Sorted list of theme names |

Example

```python
from lifx.theme import ThemeLibrary

all_themes = ThemeLibrary.list()
for theme_name in all_themes:
    print(f"- {theme_name}")
```

Source code in `src/lifx/theme/library.py`

````python
@classmethod
def list(cls) -> list[str]:
    """List all available theme names.

    Returns:
        Sorted list of theme names

    Example:
        ```python
        from lifx.theme import ThemeLibrary

        all_themes = ThemeLibrary.list()
        for theme_name in all_themes:
            print(f"- {theme_name}")
        ```
    """
    return sorted(cls._THEMES.keys())
````

##### get_by_category

```python
get_by_category(category: str) -> dict[str, Theme]
```

Get all themes in a category.

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `category` | Category name (seasonal, mood, holiday, time, etc.) **TYPE:** `str` |

| RETURNS            | DESCRIPTION                                 |
| ------------------ | ------------------------------------------- |
| `dict[str, Theme]` | Dictionary of Theme objects in the category |

| RAISES       | DESCRIPTION                   |
| ------------ | ----------------------------- |
| `ValueError` | If category is not recognized |

Source code in `src/lifx/theme/library.py`

```python
@classmethod
def get_by_category(cls, category: str) -> dict[str, Theme]:
    """Get all themes in a category.

    Args:
        category: Category name (seasonal, mood, holiday, time, etc.)

    Returns:
        Dictionary of Theme objects in the category

    Raises:
        ValueError: If category is not recognized
    """
    category_lower = category.lower()

    categories = {
        "seasonal": [
            "spring",
            "autumn",
            "winter",
        ],
        "holiday": [
            "christmas",
            "halloween",
            "hanukkah",
            "kwanzaa",
            "shamrock",
            "thanksgiving",
            "calaveras",
            "pumpkin",
            "santa",
            "holly",
            "independence",
            "proud",
        ],
        "mood": [
            "peaceful",
            "serene",
            "relaxing",
            "mellow",
            "gentle",
            "soothing",
            "blissful",
            "cheerful",
            "romantic",
            "romance",
            "love",
            "energizing",
            "exciting",
            "epic",
            "intense",
            "powerful",
            "dramatic",
            "warming",
        ],
        "ambient": [
            "dream",
            "fantasy",
            "spacey",
            "stardust",
            "zombie",
            "party",
        ],
        "functional": [
            "focusing",
            "evening",
            "bias_lighting",
        ],
        "atmosphere": [
            "hygge",
            "tranquil",
            "sports",
        ],
    }

    if category_lower not in categories:
        available = ", ".join(sorted(categories.keys()))
        raise ValueError(
            f"Category '{category}' not recognized. "
            f"Available categories: {available}"
        )

    return {
        name: cls.get(name)
        for name in categories[category_lower]
        if name in cls._THEMES
    }
```

## Canvas Class

The `Canvas` class provides 2D sparse grid functionality for tile device color interpolation.

### Canvas

```python
Canvas()
```

A Canvas is a collection of points with methods for interacting with those points

The points are stored as (i, j) in a dictionary. The value for each point is an HSBK color.

| METHOD                | DESCRIPTION                                                                   |
| --------------------- | ----------------------------------------------------------------------------- |
| `add_points_for_tile` | Create points on the canvas around where a tile is.                           |
| `surrounding_colors`  | Return the colors that surround this (i, j) point.                            |
| `has_neighbour`       | Return whether there are any points around this (i, j) position.              |
| `shuffle_points`      | Take all the points and move them around a random amount.                     |
| `blur`                | For each point, find the average colour of that point plus all surrounding    |
| `blur_by_distance`    | Similar to blur but will find the 8 closest points as opposed to the 8        |
| `points_for_tile`     | Return a list of HSBK values for this tile.                                   |
| `fill_in_points`      | Fill in the gaps on this canvas by blurring the points on the provided canvas |
| `closest_points`      | Return [(distance, color), ...] for the closest consider amount of            |
| `__iter__`            | Yield ((i, j), color) pairs for all our points.                               |
| `__getitem__`         | Return the color at point where point is (i, j).                              |
| `__setitem__`         | Set the color at point where point is (i, j).                                 |
| `__contains__`        | Return whether this point has a color where point is (i, j).                  |
| `__repr__`            | Return string representation.                                                 |

Source code in `src/lifx/theme/canvas.py`

```python
def __init__(self) -> None:
    """Initialize the canvas."""
    self.points: dict[tuple[int, int], HSBK] = {}
```

#### Functions

##### add_points_for_tile

```python
add_points_for_tile(tile: tuple[int, int] | None, theme: Theme) -> None
```

Create points on the canvas around where a tile is.

We create an area that's half the tile width/height beyond the boundary of the tile. We also spread the points out in a random manner and try to avoid having points next to each other.

Multiple calls to this function will not override existing points on the canvas.

| PARAMETER | DESCRIPTION                                                                 |
| --------- | --------------------------------------------------------------------------- |
| `tile`    | Tile coordinates (x, y) or None for single tile **TYPE:** \`tuple[int, int] |
| `theme`   | Theme containing colors to distribute **TYPE:** `Theme`                     |

Source code in `src/lifx/theme/canvas.py`

```python
def add_points_for_tile(self, tile: tuple[int, int] | None, theme: Theme) -> None:
    """Create points on the canvas around where a tile is.

    We create an area that's half the tile width/height beyond the boundary
    of the tile. We also spread the points out in a random manner and try to avoid
    having points next to each other.

    Multiple calls to this function will not override existing points on the canvas.

    Args:
        tile: Tile coordinates (x, y) or None for single tile
        theme: Theme containing colors to distribute
    """
    tile_x, tile_y = tile if tile else (0, 0)
    tile_width = 8  # Standard tile width
    tile_height = 8  # Standard tile height

    from_x = int(tile_x - tile_width * 1.5)
    to_x = int(tile_x + tile_width * 1.5)
    from_y = int(tile_y - tile_height * 1.5)
    to_y = int(tile_y + tile_height * 1.5)

    i = from_x
    while i < to_x:
        j = from_y
        while j < to_y:
            if (i, j) not in self.points:
                if not self.has_neighbour(i, j):
                    random_color = theme.random()
                    self[(i, j)] = random_color
            j += random.choice([1, 2, 3])  # nosec
        i += random.choice([1, 2, 3])  # nosec
```

##### surrounding_colors

```python
surrounding_colors(i: int, j: int) -> list[HSBK]
```

Return the colors that surround this (i, j) point.

This will only return points that exist.

Source code in `src/lifx/theme/canvas.py`

```python
def surrounding_colors(self, i: int, j: int) -> list[HSBK]:
    """Return the colors that surround this (i, j) point.

    This will only return points that exist.
    """
    return [self[(x, y)] for x, y in surrounding_points(i, j) if (x, y) in self]
```

##### has_neighbour

```python
has_neighbour(i: int, j: int) -> bool
```

Return whether there are any points around this (i, j) position.

Source code in `src/lifx/theme/canvas.py`

```python
def has_neighbour(self, i: int, j: int) -> bool:
    """Return whether there are any points around this (i, j) position."""
    return any(self.surrounding_colors(i, j))
```

##### shuffle_points

```python
shuffle_points() -> None
```

Take all the points and move them around a random amount.

Source code in `src/lifx/theme/canvas.py`

```python
def shuffle_points(self) -> None:
    """Take all the points and move them around a random amount."""
    new_points = {}
    for (i, j), color in self:
        new_points[shuffle_point(i, j)] = color

    self.points = new_points
```

##### blur

```python
blur() -> None
```

For each point, find the average colour of that point plus all surrounding points.

Source code in `src/lifx/theme/canvas.py`

```python
def blur(self) -> None:
    """
    For each point, find the average colour of that point plus all surrounding
    points.
    """
    new_points = {}
    for (i, j), original in self:
        colors = [original for _ in range(2)]
        for color in self.surrounding_colors(i, j):
            colors.append(color)
        new_points[(i, j)] = HSBK.average(colors)
    self.points = new_points
```

##### blur_by_distance

```python
blur_by_distance() -> None
```

Similar to blur but will find the 8 closest points as opposed to the 8 surrounding points.

Source code in `src/lifx/theme/canvas.py`

```python
def blur_by_distance(self) -> None:
    """Similar to blur but will find the 8 closest points as opposed to the 8
    surrounding points."""
    new_points = {}
    for (i, j), _ in self:
        distances = self.closest_points(i, j, 8)
        weighted = list(color_weighting(distances))
        if weighted:
            new_points[(i, j)] = HSBK.average(weighted)
    self.points = new_points
```

##### points_for_tile

```python
points_for_tile(
    tile: tuple[int, int] | None, width: int = 8, height: int = 8
) -> list[HSBK]
```

Return a list of HSBK values for this tile.

For any point on the tile that doesn't have a corresponding point on the canvas return a grey value. This is useful for when we tell the applier to not fill in the gaps.

| PARAMETER | DESCRIPTION                                                                 |
| --------- | --------------------------------------------------------------------------- |
| `tile`    | Tile coordinates (x, y) or None for single tile **TYPE:** \`tuple[int, int] |
| `width`   | Grid width (typically 8) **TYPE:** `int` **DEFAULT:** `8`                   |
| `height`  | Grid height (typically 8) **TYPE:** `int` **DEFAULT:** `8`                  |

| RETURNS      | DESCRIPTION                            |
| ------------ | -------------------------------------- |
| `list[HSBK]` | List of HSBK colors in row-major order |

Source code in `src/lifx/theme/canvas.py`

```python
def points_for_tile(
    self, tile: tuple[int, int] | None, width: int = 8, height: int = 8
) -> list[HSBK]:
    """Return a list of HSBK values for this tile.

    For any point on the tile that doesn't have a corresponding point on the
    canvas return a grey value. This is useful for when we tell the applier
    to not fill in the gaps.

    Args:
        tile: Tile coordinates (x, y) or None for single tile
        width: Grid width (typically 8)
        height: Grid height (typically 8)

    Returns:
        List of HSBK colors in row-major order
    """
    tile_x, tile_y = tile if tile else (0, 0)
    result = []
    grey = HSBK(hue=0, saturation=0, brightness=0.3, kelvin=3500)

    for j in range(tile_y, tile_y + height):
        for i in range(tile_x, tile_x + width):
            if (i, j) in self.points:
                result.append(self.points[(i, j)])
            else:
                result.append(grey)

    return result
```

##### fill_in_points

```python
fill_in_points(
    canvas: Canvas, left_x: int, top_y: int, tile_width: int, tile_height: int
) -> None
```

Fill in the gaps on this canvas by blurring the points on the provided canvas

We blur by finding the 4 closest points for each point on our tile and averaging them.

| PARAMETER     | DESCRIPTION                                          |
| ------------- | ---------------------------------------------------- |
| `canvas`      | Source canvas to interpolate from **TYPE:** `Canvas` |
| `left_x`      | Left x coordinate of tile **TYPE:** `int`            |
| `top_y`       | Top y coordinate of tile **TYPE:** `int`             |
| `tile_width`  | Width of tile **TYPE:** `int`                        |
| `tile_height` | Height of tile **TYPE:** `int`                       |

Source code in `src/lifx/theme/canvas.py`

```python
def fill_in_points(
    self, canvas: Canvas, left_x: int, top_y: int, tile_width: int, tile_height: int
) -> None:
    """Fill in the gaps on this canvas by blurring the points on the provided canvas

    We blur by finding the 4 closest points for each point on our tile and
    averaging them.

    Args:
        canvas: Source canvas to interpolate from
        left_x: Left x coordinate of tile
        top_y: Top y coordinate of tile
        tile_width: Width of tile
        tile_height: Height of tile
    """
    for j in range(top_y, top_y + tile_height):
        for i in range(left_x, left_x + tile_width):
            distances = canvas.closest_points(i, j, 4)
            weighted = list(color_weighting(distances))
            if weighted:
                self[(i, j)] = HSBK.average(weighted)
```

##### closest_points

```python
closest_points(i: int, j: int, consider: int) -> list[tuple[int, HSBK]]
```

Return [(distance, color), ...] for the closest consider amount of points to (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def closest_points(self, i: int, j: int, consider: int) -> list[tuple[int, HSBK]]:
    """Return [(distance, color), ...] for the closest consider amount of
    points to (i, j)."""
    distances: list[tuple[int, HSBK]] = []

    for (x, y), color in self:
        distances.append(((x - i) ** 2 + (y - j) ** 2, color))

    def get_key(
        dc: tuple[int, HSBK],
    ) -> tuple[int, tuple[float, float, float, int]]:
        return (
            dc[0],
            (dc[1].hue, dc[1].saturation, dc[1].brightness, dc[1].kelvin),
        )

    distances = sorted(distances, key=get_key)
    return distances[:consider]
```

##### __iter__

```python
__iter__() -> Iterator[tuple[tuple[int, int], HSBK]]
```

Yield ((i, j), color) pairs for all our points.

Source code in `src/lifx/theme/canvas.py`

```python
def __iter__(self) -> Iterator[tuple[tuple[int, int], HSBK]]:
    """Yield ((i, j), color) pairs for all our points."""
    yield from self.points.items()
```

##### __getitem__

```python
__getitem__(point: tuple[int, int]) -> HSBK
```

Return the color at point where point is (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def __getitem__(self, point: tuple[int, int]) -> HSBK:
    """Return the color at point where point is (i, j)."""
    return self.points[point]
```

##### __setitem__

```python
__setitem__(key: tuple[int, int], color: HSBK) -> None
```

Set the color at point where point is (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def __setitem__(self, key: tuple[int, int], color: HSBK) -> None:
    """Set the color at point where point is (i, j)."""
    self.points[key] = color
```

##### __contains__

```python
__contains__(point: tuple[int, int]) -> bool
```

Return whether this point has a color where point is (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def __contains__(self, point: tuple[int, int]) -> bool:
    """Return whether this point has a color where point is (i, j)."""
    return point in self.points
```

##### __repr__

```python
__repr__() -> str
```

Return string representation.

Source code in `src/lifx/theme/canvas.py`

```python
def __repr__(self) -> str:
    """Return string representation."""
    return f"Canvas({len(self.points)} points)"
```

## Convenience Function

### get_theme

```python
get_theme(name: str) -> Theme
```

Get a theme by name.

Convenience function equivalent to ThemeLibrary.get(name).

| PARAMETER | DESCRIPTION                                   |
| --------- | --------------------------------------------- |
| `name`    | Theme name (case-insensitive) **TYPE:** `str` |

| RETURNS | DESCRIPTION  |
| ------- | ------------ |
| `Theme` | Theme object |

Example

```python
from lifx.theme import get_theme

evening = get_theme("evening")
await light.apply_theme(evening, power_on=True)
```

Source code in `src/lifx/theme/library.py`

````python
def get_theme(name: str) -> Theme:
    """Get a theme by name.

    Convenience function equivalent to ThemeLibrary.get(name).

    Args:
        name: Theme name (case-insensitive)

    Returns:
        Theme object

    Example:
        ```python
        from lifx.theme import get_theme

        evening = get_theme("evening")
        await light.apply_theme(evening, power_on=True)
        ```
    """
    return ThemeLibrary.get(name)
````

## Available Themes (42 Total)

### Seasonal (3 themes)

- spring, autumn, winter

### Holiday (9 themes)

- christmas, halloween, hanukkah, kwanzaa, shamrock, thanksgiving, calaveras, pumpkin, santa

### Mood (16 themes)

- peaceful, serene, relaxing, mellow, gentle, soothing, blissful, cheerful, romantic, romance, love, energizing, exciting, epic, intense, powerful, warming

### Ambient (6 themes)

- dream, fantasy, spacey, stardust, zombie, party

### Functional (3 themes)

- focusing, evening, bias_lighting

### Atmosphere (3 themes)

- hygge, tranquil, sports

# Effects Reference

This reference guide provides comprehensive documentation for all built-in effect classes in the Light Effects Framework.

## Table of Contents

- [Conductor](#conductor)
- [EffectPulse](#effectpulse)
- [EffectColorloop](#effectcolorloop)
- [LIFXEffect (Base Class)](#lifxeffect-base-class)

## Conductor

The `Conductor` class is the central orchestrator for managing light effects across multiple devices.

### Class Definition

```python
from lifx import Conductor

conductor = Conductor()
```

### Methods

#### `effect(light: Light) -> LIFXEffect | None`

Return the effect currently running on a device, or None if idle.

**Parameters:**

- `light` (Light): The device to check

**Returns:**

- `LIFXEffect | None`: Currently running effect instance, or None

**Example:**

```python
current_effect = conductor.effect(light)
if current_effect:
    print(f"Running: {type(current_effect).__name__}")
else:
    print("No effect running")
```

#### `start(effect: LIFXEffect, participants: list[Light]) -> None`

Start an effect on one or more lights.

Captures current light state, powers on if needed, and launches the effect. State is automatically restored when effect completes or `stop()` is called.

**Parameters:**

- `effect` (LIFXEffect): The effect instance to execute
- `participants` (list[Light]): List of Light instances to apply effect to

**Raises:**

- `LifxTimeoutError`: If light state capture times out
- `LifxDeviceNotFoundError`: If light becomes unreachable

**Example:**

```python
effect = EffectPulse(mode='blink', cycles=5)
await conductor.start(effect, [light1, light2])
```

#### `stop(lights: list[Light]) -> None`

Stop effects and restore light state.

Halts any running effects on the specified lights and restores them to their pre-effect state (power, color, zones).

**Parameters:**

- `lights` (list[Light]): List of lights to stop

**Example:**

```python
# Stop specific lights
await conductor.stop([light1, light2])

# Stop all lights in a group
await conductor.stop(group.lights)
```

### State Management

The conductor automatically handles:

1. **State Capture**: Power state, current color (HSBK), and multizone colors (if applicable)
1. **Power Management**: Powers on devices if needed for effect visibility
1. **Effect Execution**: Runs effect logic on all participants
1. **State Restoration**: Restores all captured state after effect completes

### Timing Considerations

- State capture: \<1 second per device (mostly network I/O)
- State restoration: 0.6-1.0 seconds per device (includes required 0.3s delays)
- All operations use concurrent execution for multiple devices

______________________________________________________________________

## EffectPulse

Pulse/blink/breathe effects using LIFX waveform modes. Supports five distinct modes with configurable timing and colors.

### Class Definition

```python
from lifx import EffectPulse, HSBK

effect = EffectPulse(
    power_on=True,
    mode='blink',
    period=None,
    cycles=None,
    hsbk=None
)
```

### Parameters

#### `power_on` (bool, default: `True`)

Whether to power on devices during effect. If `True`, devices that are off will be powered on before the effect starts.

#### `mode` (str, default: `'blink'`)

Pulse mode to use. Must be one of:

- `'blink'`: Standard on/off toggle
- `'strobe'`: Rapid flashing
- `'breathe'`: Smooth breathing effect
- `'ping'`: Single pulse with asymmetric duty cycle
- `'solid'`: Minimal brightness variation

#### `period` (float | None, default: mode-dependent)

Effect period in seconds. If not specified, uses mode default:

- `'strobe'`: 0.1 seconds
- All others: 1.0 second

#### `cycles` (int | None, default: mode-dependent)

Number of cycles to execute. If not specified, uses mode default:

- `'strobe'`: 10 cycles
- All others: 1 cycle

#### `hsbk` (HSBK | None, default: `None`)

Optional color override. If provided, this color is used instead of automatic color selection. If `None`, the effect intelligently selects colors based on mode and device capabilities.

### Pulse Modes

#### Blink Mode

Standard on/off toggle effect.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: PULSE
- Behavior: Toggles between current color and off

**Example:**

```python
# Basic blink - 5 cycles
effect = EffectPulse(mode='blink', cycles=5)
await conductor.start(effect, lights)
await asyncio.sleep(6)  # 5 cycles * 1s + buffer
```

**Best for:** Notifications, alerts, attention-getting

#### Strobe Mode

Rapid flashing effect.

**Defaults:**

- Period: 0.1 second
- Cycles: 10
- Waveform: PULSE
- Behavior: Rapid flashing from dark (cold white)

**Example:**

```python
# Rapid strobe - 20 flashes
effect = EffectPulse(mode='strobe', cycles=20)
await conductor.start(effect, lights)
await asyncio.sleep(3)  # 20 * 0.1s + buffer
```

**Best for:** Emergency notifications, dramatic effects

**Note:** Strobe mode starts from dark (0 brightness, cold white) for maximum impact.

#### Breathe Mode

Smooth, gentle breathing effect using SINE waveform.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: SINE (smooth)
- Behavior: Smooth fade in and out

**Example:**

```python
# Slow breathing effect
effect = EffectPulse(mode='breathe', period=2.0, cycles=5)
await conductor.start(effect, lights)
await asyncio.sleep(11)  # 5 * 2s + buffer
```

**Best for:** Relaxation, meditation, ambient effects

#### Ping Mode

Single pulse with asymmetric duty cycle.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: PULSE
- Skew: 0.1 (10% on, 90% off)
- Behavior: Quick flash followed by longer off period

**Example:**

```python
# Quick ping notification
red = HSBK.from_rgb(255, 0, 0)
effect = EffectPulse(mode='ping', color=red)
await conductor.start(effect, lights)
await asyncio.sleep(2)
```

**Best for:** Quick notifications, heartbeat effects

#### Solid Mode

Minimal brightness variation, almost solid color.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: PULSE
- Skew: 0.0 (minimum variation)
- Behavior: Very subtle brightness change

**Example:**

```python
# Subtle solid pulse
green = HSBK.from_rgb(0, 255, 0)
effect = EffectPulse(mode='solid', period=3.0, cycles=2, color=green)
await conductor.start(effect, lights)
await asyncio.sleep(7)
```

**Best for:** Subtle ambient effects, status indicators

### Color Selection

#### With `color` Parameter

When you provide a `color` parameter, that exact color is used:

```python
# Always use red
red = HSBK.from_rgb(255, 0, 0)
effect = EffectPulse(mode='blink', color=red)
```

#### Without `color` Parameter (Automatic)

The effect intelligently selects colors based on mode and device:

- **Strobe mode**: Starts from dark (cold white, 0 brightness)
- **Other modes**: Preserves current device color
- **Color devices**: Full HSBK color used
- **Monochrome devices**: Brightness toggled, kelvin preserved

### Device Type Behavior

#### Color Lights

All modes work as expected with full color support.

#### Multizone Lights

Pulse effects apply to entire device, not individual zones. All zones pulse together.

#### Tile Devices

Pulse effects apply to all tiles uniformly.

#### Monochrome/White Lights

Effects adapt to brightness changes only:

- Color components are ignored
- Brightness is toggled or faded
- Kelvin temperature is preserved

### Examples

#### Custom Color Pulse

```python
from lifx import HSBK

# Purple breathe effect
purple = HSBK.from_rgb(128, 0, 128)
effect = EffectPulse(
    mode='breathe',
    period=2.0,
    cycles=3,
    hsbk=purple
)
await conductor.start(effect, lights)
await asyncio.sleep(7)
```

#### Emergency Alert

```python
# Rapid red strobe
red = HSBK.from_rgb(255, 0, 0)
effect = EffectPulse(
    mode='strobe',
    period=0.1,
    cycles=30,
    hsbk=red
)
await conductor.start(effect, lights)
await asyncio.sleep(4)
```

#### Meditation Breathing

```python
# Slow blue breathing
blue = HSBK.from_rgb(0, 50, 200)
effect = EffectPulse(
    mode='breathe',
    period=4.0,  # 4 second cycle
    cycles=10,
    hsbk=blue
)
await conductor.start(effect, lights)
await asyncio.sleep(42)  # 10 * 4s + buffer
```

### Performance Notes

- Effect starts within 100ms
- Duration is precisely `period * cycles`
- State restoration adds 0.6-1.0 seconds after completion
- Multiple devices execute concurrently

______________________________________________________________________

## EffectColorloop

Continuous color rotation effect cycling through the hue spectrum. Runs indefinitely until manually stopped.

### Class Definition

```python
from lifx import EffectColorloop

effect = EffectColorloop(
    power_on=True,
    period=60,
    change=20,
    spread=30,
    brightness=None,
    saturation_min=0.8,
    saturation_max=1.0,
    transition=None
)
```

### Parameters

#### `power_on` (bool, default: `True`)

Whether to power on devices if they're off.

#### `period` (float, default: `60`)

Seconds per full 360-degree hue cycle. Lower values = faster color changes.

**Range:** Must be positive

**Examples:**

- `period=60`: One full rainbow per minute (slow)
- `period=30`: Two full rainbows per minute (medium)
- `period=15`: Four full rainbows per minute (fast)

#### `change` (float, default: `20`)

Hue degrees to shift per iteration. Larger values = larger color jumps.

**Range:** 0-360 degrees

**Examples:**

- `change=10`: Small, smooth color transitions
- `change=20`: Medium color steps (default)
- `change=45`: Large, dramatic color jumps

**Calculation:** iterations_per_cycle = 360 / change

#### `spread` (float, default: `30`)

Hue degrees spread across devices. Creates rainbow effect across multiple lights.

**Range:** 0-360 degrees

**Examples:**

- `spread=0`: All lights same color
- `spread=30`: Slight color variation (default)
- `spread=60`: Rainbow spread across devices
- `spread=120`: Wide spectrum spread

#### `brightness` (float | None, default: `None`)

Fixed brightness level. If `None`, preserves current brightness for each device.

**Range:** 0.0-1.0

**Examples:**

- `brightness=None`: Keeps original brightness (default)
- `brightness=0.5`: Locks to 50% brightness
- `brightness=1.0`: Full brightness

#### `saturation_min` (float, default: `0.8`)

Minimum saturation for random saturation selection.

**Range:** 0.0-1.0

Must be ≤ `saturation_max`

#### `saturation_max` (float, default: `1.0`)

Maximum saturation for random saturation selection.

**Range:** 0.0-1.0

Must be ≥ `saturation_min`

**Note:** Each iteration randomly selects saturation within this range.

#### `transition` (float | None, default: `None`)

Color transition time in seconds. If `None`, uses random transition time per device.

**Range:** Non-negative

**Examples:**

- `transition=None`: Random transitions (0 to 2x iteration period)
- `transition=0.5`: Quick 0.5-second transitions
- `transition=2.0`: Slow 2-second transitions

### Behavior

#### Continuous Operation

ColorLoop effects run **indefinitely** until explicitly stopped:

```python
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)

# Runs forever until you call:
await conductor.stop(lights)
```

#### Random Elements

For visual variety, ColorLoop randomizes:

1. **Initial direction**: Forward or backward through hue spectrum
1. **Device order**: Shuffled each cycle
1. **Saturation**: Random value between saturation_min and saturation_max
1. **Transition time**: Random if `transition=None`

#### Hue Calculation

For each device at each iteration:

```python
new_hue = (base_hue + iteration_offset + device_spread_offset) % 360

# Where:
# - base_hue: Initial hue when effect started
# - iteration_offset: iteration * change * direction
# - device_spread_offset: device_index * spread
```

### Device Type Behavior

#### Color Lights

Full color cycling with all parameters supported.

#### Multizone Lights

Entire device cycles as one unit (all zones same color at each iteration).

#### Tile Devices

All tiles cycle together with same color.

#### Monochrome/White Lights

- Hue changes are ignored (monochrome devices can't display colors)
- Brightness and saturation parameters are ignored
- Effect still runs but with no visible changes
- **Recommendation**: Don't use ColorLoop on monochrome devices

### Examples

#### Classic Rainbow

```python
# Slow rainbow across multiple lights
effect = EffectColorloop(
    period=60,      # Full rainbow per minute
    change=20,      # Smooth color steps
    spread=60       # Spread colors across devices
)
await conductor.start(effect, lights)
await asyncio.sleep(120)  # Run for 2 minutes
await conductor.stop(lights)
```

#### Fast Party Mode

```python
# Fast, dramatic color changes
effect = EffectColorloop(
    period=15,          # Fast rotation
    change=45,          # Large color jumps
    spread=120,         # Wide spread
    brightness=0.8,     # Fixed brightness
    saturation_min=0.9, # High saturation only
    transition=0.5      # Quick transitions
)
await conductor.start(effect, lights)
await asyncio.sleep(60)
await conductor.stop(lights)
```

#### Ambient Pastels

```python
# Subtle pastel color cycling
effect = EffectColorloop(
    period=90,          # Very slow
    change=15,          # Small steps
    spread=30,          # Slight variation
    brightness=0.4,     # Dim
    saturation_min=0.3, # Low saturation (pastels)
    saturation_max=0.6,
    transition=3.0      # Very slow transitions
)
await conductor.start(effect, lights)
# Let it run indefinitely
```

### Stopping ColorLoop

Always explicitly stop ColorLoop effects:

```python
# Start effect
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)

# Do other things...
await asyncio.sleep(60)

# Must stop manually
await conductor.stop(lights)
```

The `conductor.stop()` call will:

1. Signal the effect to stop
1. Wait for current iteration to complete
1. Restore all lights to pre-effect state (power, color, zones)

### Prestate Inheritance

ColorLoop effects support state inheritance optimization. If you start a ColorLoop while another ColorLoop is already running, the new effect inherits the existing prestate instead of resetting:

```python
# Start first colorloop
effect1 = EffectColorloop(period=30, change=20)
await conductor.start(effect1, lights)
await asyncio.sleep(10)

# Switch to different colorloop - no reset, seamless transition
effect2 = EffectColorloop(period=20, change=30)
await conductor.start(effect2, lights)  # Inherits state, no flash
```

This prevents the lights from briefly returning to their original state between consecutive ColorLoop effects.

### Performance Notes

- Iteration period: `period / (360 / change)`
- State capture: \<1 second per device
- Effect startup: \<100ms
- Multiple devices update concurrently
- No cycle limit - runs until stopped

______________________________________________________________________

## LIFXEffect (Base Class)

Abstract base class for all light effects. Subclass this to create custom effects.

### Class Definition

```python
from lifx import LIFXEffect

class MyEffect(LIFXEffect):
    def __init__(self, power_on: bool = True):
        super().__init__(power_on=power_on)

    async def async_play(self) -> None:
        # Custom effect logic here
        pass
```

### Attributes

#### `power_on` (bool)

Whether to power on devices during effect.

#### `conductor` (Conductor | None)

Reference to the conductor managing this effect. Set automatically by conductor.

#### `participants` (list[Light])

List of lights participating in the effect. Set automatically by conductor.

### Methods

#### `async_perform(participants: list[Light]) -> None`

Perform common setup and play the effect. Called by conductor.

**Do not override this method.** Override `async_play()` instead.

#### `async_play() -> None` (abstract)

Play the effect logic. **Override this in subclasses.**

This is where you implement your custom effect behavior.

**Example:**

```python
async def async_play(self) -> None:
    # Flash all lights 3 times
    for _ in range(3):
        await asyncio.gather(*[
            light.set_brightness(1.0) for light in self.participants
        ])
        await asyncio.sleep(0.3)
        await asyncio.gather(*[
            light.set_brightness(0.0) for light in self.participants
        ])
        await asyncio.sleep(0.3)

    # Restore via conductor
    if self.conductor:
        await self.conductor.stop(self.participants)
```

#### `from_poweroff_hsbk(light: Light) -> HSBK`

Return startup color when light is powered off.

**Override this** to customize the color used when powering on a light.

**Default behavior:** Returns random hue, full saturation, zero brightness, neutral white.

**Example:**

```python
async def from_poweroff_hsbk(self, light: Light) -> HSBK:
    # Always start with red
    return HSBK.from_rgb(255, 0, 0, kelvin=HSBK.KELVIN_NEUTRAL)
```

#### `inherit_prestate(other: LIFXEffect) -> bool`

Whether this effect can skip device state restoration.

**Override this** if your effect can run without resetting when following certain other effects.

**Default behavior:** Returns `False` (always reset)

**Example:**

```python
def inherit_prestate(self, other: LIFXEffect) -> bool:
    # Can inherit from same effect type
    return type(self) == type(other)
```

### Creating Custom Effects

See the [Custom Effects Guide](../../user-guide/effects-custom/) for detailed instructions on creating your own effects.

______________________________________________________________________

## See Also

- [Getting Started](../../getting-started/effects/) - Basic usage and common patterns
- [Custom Effects](../../user-guide/effects-custom/) - Creating your own effects
- [Architecture](../../architecture/effects-architecture/) - How the system works
- [Troubleshooting](../../user-guide/effects-troubleshooting/) - Common issues and solutions

# Color Utilities

lifx-async provides comprehensive color utilities for working with LIFX's HSBK color model and converting to/from RGB.

## HSBK Class

The `HSBK` class represents colors in the Hue, Saturation, Brightness, Kelvin color model used by LIFX devices.

### HSBK

```python
HSBK(hue: float, saturation: float, brightness: float, kelvin: int)
```

User-friendly HSBK color representation.

LIFX devices use HSBK (Hue, Saturation, Brightness, Kelvin) color space. This class provides a convenient interface with normalized values and conversion to/from RGB.

| ATTRIBUTE    | DESCRIPTION                                                                           |
| ------------ | ------------------------------------------------------------------------------------- |
| `hue`        | Hue value in degrees (0-360) **TYPE:** `float`                                        |
| `saturation` | Saturation (0.0-1.0, where 0 is white and 1 is fully saturated) **TYPE:** `float`     |
| `brightness` | Brightness (0.0-1.0, where 0 is off and 1 is full brightness) **TYPE:** `float`       |
| `kelvin`     | Color temperature in Kelvin (1500-9000, typically 2500-9000 for LIFX) **TYPE:** `int` |

Example

```python
# Create a red color
red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)

# Create from RGB
purple = HSBK.from_rgb(128, 0, 128)

# Convert to RGB
r, g, b = purple.to_rgb()
```

| METHOD              | DESCRIPTION                                                           |
| ------------------- | --------------------------------------------------------------------- |
| `__post_init__`     | Validate all fields after initialization.                             |
| `from_rgb`          | Create HSBK from RGB values.                                          |
| `to_rgb`            | Convert HSBK to RGB values.                                           |
| `to_protocol`       | Convert to protocol HSBK for packet serialization.                    |
| `from_protocol`     | Create HSBK from protocol HSBK.                                       |
| `with_hue`          | Create a new HSBK with modified hue.                                  |
| `with_saturation`   | Create a new HSBK with modified saturation.                           |
| `with_brightness`   | Create a new HSBK with modified brightness.                           |
| `with_kelvin`       | Create a new HSBK with modified color temperature.                    |
| `clone`             | Create a copy of this color.                                          |
| `as_tuple`          | Return HSBK values as a tuple of protocol uint16 values.              |
| `as_dict`           | Return HSBK values as a dictionary of user-friendly values.           |
| `limit_distance_to` | Return a new color with hue limited to 90 degrees from another color. |
| `average`           | Calculate the average color of a list of HSBK colors.                 |

#### Functions

##### __post_init__

```python
__post_init__() -> None
```

Validate all fields after initialization.

Source code in `src/lifx/color.py`

```python
def __post_init__(self) -> None:
    """Validate all fields after initialization."""
    self._validate_hue(self.hue)
    self._validate_saturation(self.saturation)
    self._validate_brightness(self.brightness)
    self._validate_kelvin(self.kelvin)
```

##### from_rgb

```python
from_rgb(r: int, g: int, b: int, kelvin: int = KELVIN_NEUTRAL) -> HSBK
```

Create HSBK from RGB values.

| PARAMETER | DESCRIPTION                                                                               |
| --------- | ----------------------------------------------------------------------------------------- |
| `r`       | Red component (0-255) **TYPE:** `int`                                                     |
| `g`       | Green component (0-255) **TYPE:** `int`                                                   |
| `b`       | Blue component (0-255) **TYPE:** `int`                                                    |
| `kelvin`  | Color temperature in Kelvin (default: 3500) **TYPE:** `int` **DEFAULT:** `KELVIN_NEUTRAL` |

| RETURNS | DESCRIPTION   |
| ------- | ------------- |
| `HSBK`  | HSBK instance |

| RAISES       | DESCRIPTION                            |
| ------------ | -------------------------------------- |
| `ValueError` | If RGB values are out of range (0-255) |

Example

```python
# Pure red
red = HSBK.from_rgb(255, 0, 0)

# Purple with warm white
purple = HSBK.from_rgb(128, 0, 128, kelvin=2500)
```

Source code in `src/lifx/color.py`

````python
@classmethod
def from_rgb(
    cls,
    r: int,
    g: int,
    b: int,
    kelvin: int = KELVIN_NEUTRAL,
) -> HSBK:
    """Create HSBK from RGB values.

    Args:
        r: Red component (0-255)
        g: Green component (0-255)
        b: Blue component (0-255)
        kelvin: Color temperature in Kelvin (default: 3500)

    Returns:
        HSBK instance

    Raises:
        ValueError: If RGB values are out of range (0-255)

    Example:
        ```python
        # Pure red
        red = HSBK.from_rgb(255, 0, 0)

        # Purple with warm white
        purple = HSBK.from_rgb(128, 0, 128, kelvin=2500)
        ```
    """
    cls._validate_rgb_component(r, "Red")
    cls._validate_rgb_component(g, "Green")
    cls._validate_rgb_component(b, "Blue")

    # Normalize to 0-1
    r_norm = r / 255.0
    g_norm = g / 255.0
    b_norm = b / 255.0

    # Convert to HSV using colorsys
    h, s, v = colorsys.rgb_to_hsv(r_norm, g_norm, b_norm)

    # Convert to LIFX ranges
    hue = h * 360.0  # 0-1 -> 0-360
    saturation = s  # Already 0-1
    brightness = v  # Already 0-1

    return cls(hue=hue, saturation=saturation, brightness=brightness, kelvin=kelvin)
````

##### to_rgb

```python
to_rgb() -> tuple[int, int, int]
```

Convert HSBK to RGB values.

Color temperature (kelvin) is not considered in this conversion, as it only affects the white point of the device.

| RETURNS                | DESCRIPTION                                   |
| ---------------------- | --------------------------------------------- |
| `tuple[int, int, int]` | Tuple of (red, green, blue) with values 0-255 |

Example

```python
color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
r, g, b = color.to_rgb()  # Returns (0, 255, 0) - green
```

Source code in `src/lifx/color.py`

````python
def to_rgb(self) -> tuple[int, int, int]:
    """Convert HSBK to RGB values.

    Color temperature (kelvin) is not considered in this conversion,
    as it only affects the white point of the device.

    Returns:
        Tuple of (red, green, blue) with values 0-255

    Example:
        ```python
        color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
        r, g, b = color.to_rgb()  # Returns (0, 255, 0) - green
        ```
    """
    # Convert to colorsys ranges
    h = self.hue / 360.0  # 0-360 -> 0-1
    s = self.saturation  # Already 0-1
    v = self.brightness  # Already 0-1

    # Convert using colorsys
    r_norm, g_norm, b_norm = colorsys.hsv_to_rgb(h, s, v)

    # Scale to 0-255 and round
    r = int(round(r_norm * 255))
    g = int(round(g_norm * 255))
    b = int(round(b_norm * 255))

    return (r, g, b)
````

##### to_protocol

```python
to_protocol() -> LightHsbk
```

Convert to protocol HSBK for packet serialization.

LIFX protocol uses uint16 values for all HSBK components:

- Hue: 0-65535 (represents 0-360 degrees)
- Saturation: 0-65535 (represents 0-100%)
- Brightness: 0-65535 (represents 0-100%)
- Kelvin: Direct value in Kelvin

| RETURNS     | DESCRIPTION                                 |
| ----------- | ------------------------------------------- |
| `LightHsbk` | LightHsbk instance for packet serialization |

Example

```python
color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
protocol_color = color.to_protocol()
# Use in packet: LightSetColor(color=protocol_color, ...)
```

Source code in `src/lifx/color.py`

````python
def to_protocol(self) -> LightHsbk:
    """Convert to protocol HSBK for packet serialization.

    LIFX protocol uses uint16 values for all HSBK components:
    - Hue: 0-65535 (represents 0-360 degrees)
    - Saturation: 0-65535 (represents 0-100%)
    - Brightness: 0-65535 (represents 0-100%)
    - Kelvin: Direct value in Kelvin

    Returns:
        LightHsbk instance for packet serialization

    Example:
        ```python
        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
        protocol_color = color.to_protocol()
        # Use in packet: LightSetColor(color=protocol_color, ...)
        ```
    """
    # Convert to uint16 ranges with overflow protection
    # Clamp values to prevent overflow
    hue_u16 = max(0, min(65535, int(round((self.hue / 360.0) * 65535))))
    saturation_u16 = max(0, min(65535, int(round(self.saturation * 65535))))
    brightness_u16 = max(0, min(65535, int(round(self.brightness * 65535))))

    return LightHsbk(
        hue=hue_u16,
        saturation=saturation_u16,
        brightness=brightness_u16,
        kelvin=self.kelvin,
    )
````

##### from_protocol

```python
from_protocol(protocol: LightHsbk) -> HSBK
```

Create HSBK from protocol HSBK.

| PARAMETER  | DESCRIPTION                                                          |
| ---------- | -------------------------------------------------------------------- |
| `protocol` | LightHsbk instance from packet deserialization **TYPE:** `LightHsbk` |

| RETURNS | DESCRIPTION                 |
| ------- | --------------------------- |
| `HSBK`  | User-friendly HSBK instance |

Example

```python
# After receiving LightState packet
state = await device.get_state()
color = HSBK.from_protocol(state.color)
print(f"Hue: {color.hue}°, Brightness: {color.brightness * 100}%")
```

Source code in `src/lifx/color.py`

````python
@classmethod
def from_protocol(cls, protocol: LightHsbk) -> HSBK:
    """Create HSBK from protocol HSBK.

    Args:
        protocol: LightHsbk instance from packet deserialization

    Returns:
        User-friendly HSBK instance

    Example:
        ```python
        # After receiving LightState packet
        state = await device.get_state()
        color = HSBK.from_protocol(state.color)
        print(f"Hue: {color.hue}°, Brightness: {color.brightness * 100}%")
        ```
    """
    # Convert from uint16 ranges to user-friendly ranges
    hue = (protocol.hue / 65535.0) * 360.0
    saturation = protocol.saturation / 65535.0
    brightness = protocol.brightness / 65535.0

    return cls(
        hue=hue,
        saturation=saturation,
        brightness=brightness,
        kelvin=protocol.kelvin,
    )
````

##### with_hue

```python
with_hue(hue: float) -> HSBK
```

Create a new HSBK with modified hue.

| PARAMETER | DESCRIPTION                             |
| --------- | --------------------------------------- |
| `hue`     | New hue value (0-360) **TYPE:** `float` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_hue(self, hue: float) -> HSBK:
    """Create a new HSBK with modified hue.

    Args:
        hue: New hue value (0-360)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=hue,
        saturation=self.saturation,
        brightness=self.brightness,
        kelvin=self.kelvin,
    )
```

##### with_saturation

```python
with_saturation(saturation: float) -> HSBK
```

Create a new HSBK with modified saturation.

| PARAMETER    | DESCRIPTION                                      |
| ------------ | ------------------------------------------------ |
| `saturation` | New saturation value (0.0-1.0) **TYPE:** `float` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_saturation(self, saturation: float) -> HSBK:
    """Create a new HSBK with modified saturation.

    Args:
        saturation: New saturation value (0.0-1.0)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=self.hue,
        saturation=saturation,
        brightness=self.brightness,
        kelvin=self.kelvin,
    )
```

##### with_brightness

```python
with_brightness(brightness: float) -> HSBK
```

Create a new HSBK with modified brightness.

| PARAMETER    | DESCRIPTION                                      |
| ------------ | ------------------------------------------------ |
| `brightness` | New brightness value (0.0-1.0) **TYPE:** `float` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_brightness(self, brightness: float) -> HSBK:
    """Create a new HSBK with modified brightness.

    Args:
        brightness: New brightness value (0.0-1.0)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=self.hue,
        saturation=self.saturation,
        brightness=brightness,
        kelvin=self.kelvin,
    )
```

##### with_kelvin

```python
with_kelvin(kelvin: int) -> HSBK
```

Create a new HSBK with modified color temperature.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `kelvin`  | New kelvin value (1500-9000) **TYPE:** `int` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_kelvin(self, kelvin: int) -> HSBK:
    """Create a new HSBK with modified color temperature.

    Args:
        kelvin: New kelvin value (1500-9000)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=self.hue,
        saturation=self.saturation,
        brightness=self.brightness,
        kelvin=kelvin,
    )
```

##### clone

```python
clone() -> HSBK
```

Create a copy of this color.

| RETURNS | DESCRIPTION                            |
| ------- | -------------------------------------- |
| `HSBK`  | New HSBK instance with the same values |

Source code in `src/lifx/color.py`

```python
def clone(self) -> HSBK:
    """Create a copy of this color.

    Returns:
        New HSBK instance with the same values
    """
    return HSBK(
        hue=self.hue,
        saturation=self.saturation,
        brightness=self.brightness,
        kelvin=self.kelvin,
    )
```

##### as_tuple

```python
as_tuple() -> tuple[int, int, int, int]
```

Return HSBK values as a tuple of protocol uint16 values.

| RETURNS | DESCRIPTION                                                |
| ------- | ---------------------------------------------------------- |
| `int`   | Tuple of (hue_u16, saturation_u16, brightness_u16, kelvin) |
| `int`   | where u16 values are in range 0-65535                      |

Example

```python
color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
hue, sat, bri, kel = color.as_tuple()
# Use in protocol operations
```

Source code in `src/lifx/color.py`

````python
def as_tuple(self) -> tuple[int, int, int, int]:
    """Return HSBK values as a tuple of protocol uint16 values.

    Returns:
        Tuple of (hue_u16, saturation_u16, brightness_u16, kelvin)
        where u16 values are in range 0-65535

    Example:
        ```python
        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
        hue, sat, bri, kel = color.as_tuple()
        # Use in protocol operations
        ```
    """
    protocol = self.to_protocol()
    return (protocol.hue, protocol.saturation, protocol.brightness, protocol.kelvin)
````

##### as_dict

```python
as_dict() -> dict[str, float | int]
```

Return HSBK values as a dictionary of user-friendly values.

| RETURNS            | DESCRIPTION |
| ------------------ | ----------- |
| \`dict\[str, float | int\]\`     |
| \`dict\[str, float | int\]\`     |

Example

```python
color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
color_dict = color.as_dict()
# {'hue': 180.0, 'saturation': 0.5, 'brightness': 0.75, 'kelvin': 3500}
```

Source code in `src/lifx/color.py`

````python
def as_dict(self) -> dict[str, float | int]:
    """Return HSBK values as a dictionary of user-friendly values.

    Returns:
        Dictionary with keys: hue (float), saturation (float),
        brightness (float), kelvin (int)

    Example:
        ```python
        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
        color_dict = color.as_dict()
        # {'hue': 180.0, 'saturation': 0.5, 'brightness': 0.75, 'kelvin': 3500}
        ```
    """
    return {
        "hue": self.hue,
        "saturation": self.saturation,
        "brightness": self.brightness,
        "kelvin": self.kelvin,
    }
````

##### limit_distance_to

```python
limit_distance_to(other: HSBK) -> HSBK
```

Return a new color with hue limited to 90 degrees from another color.

This is useful for preventing large hue jumps when interpolating between colors. If the hue difference is greater than 90 degrees, the hue is adjusted to be within 90 degrees of the target hue.

| PARAMETER | DESCRIPTION                                           |
| --------- | ----------------------------------------------------- |
| `other`   | Reference color to limit distance to **TYPE:** `HSBK` |

| RETURNS | DESCRIPTION                                 |
| ------- | ------------------------------------------- |
| `HSBK`  | New HSBK instance with limited hue distance |

Example

```python
red = HSBK(hue=10, saturation=1.0, brightness=1.0, kelvin=3500)
blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

# Limit red's hue to be within 90 degrees of blue's hue
adjusted = red.limit_distance_to(blue)
# Result: hue is adjusted to be within 90 degrees of 240
```

Source code in `src/lifx/color.py`

````python
def limit_distance_to(self, other: HSBK) -> HSBK:
    """Return a new color with hue limited to 90 degrees from another color.

    This is useful for preventing large hue jumps when interpolating between colors.
    If the hue difference is greater than 90 degrees, the hue is adjusted to be
    within 90 degrees of the target hue.

    Args:
        other: Reference color to limit distance to

    Returns:
        New HSBK instance with limited hue distance

    Example:
        ```python
        red = HSBK(hue=10, saturation=1.0, brightness=1.0, kelvin=3500)
        blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

        # Limit red's hue to be within 90 degrees of blue's hue
        adjusted = red.limit_distance_to(blue)
        # Result: hue is adjusted to be within 90 degrees of 240
        ```
    """
    raw_dist = (
        self.hue - other.hue if self.hue > other.hue else other.hue - self.hue
    )
    dist = 360 - raw_dist if raw_dist > 180 else raw_dist
    if abs(dist) > 90:
        h = self.hue + 90 if (other.hue + dist) % 360 == self.hue else self.hue - 90
        h = h + 360 if h < 0 else h
        return HSBK(h, self.saturation, self.brightness, self.kelvin)
    else:
        return self
````

##### average

```python
average(colors: list[HSBK]) -> HSBK
```

Calculate the average color of a list of HSBK colors.

Uses circular mean for hue to correctly handle hue wraparound (e.g., average of 10° and 350° is 0°, not 180°).

| PARAMETER | DESCRIPTION                                                               |
| --------- | ------------------------------------------------------------------------- |
| `colors`  | List of HSBK colors to average (must not be empty) **TYPE:** `list[HSBK]` |

| RETURNS | DESCRIPTION                            |
| ------- | -------------------------------------- |
| `HSBK`  | New HSBK instance with averaged values |

| RAISES       | DESCRIPTION             |
| ------------ | ----------------------- |
| `ValueError` | If colors list is empty |

Example

```python
red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)
green = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

avg_color = HSBK.average([red, green, blue])
# Result: average of the three primary colors
```

Source code in `src/lifx/color.py`

````python
@classmethod
def average(cls, colors: list[HSBK]) -> HSBK:
    """Calculate the average color of a list of HSBK colors.

    Uses circular mean for hue to correctly handle hue wraparound
    (e.g., average of 10° and 350° is 0°, not 180°).

    Args:
        colors: List of HSBK colors to average (must not be empty)

    Returns:
        New HSBK instance with averaged values

    Raises:
        ValueError: If colors list is empty

    Example:
        ```python
        red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)
        green = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
        blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

        avg_color = HSBK.average([red, green, blue])
        # Result: average of the three primary colors
        ```
    """
    if not colors:
        raise ValueError("Cannot average an empty list of colors")

    hue_x_total = 0.0
    hue_y_total = 0.0
    saturation_total = 0.0
    brightness_total = 0.0
    kelvin_total = 0.0

    for color in colors:
        hue_x_total += math.sin(color.hue * 2.0 * math.pi / 360)
        hue_y_total += math.cos(color.hue * 2.0 * math.pi / 360)
        saturation_total += color.saturation
        brightness_total += color.brightness
        kelvin_total += color.kelvin

    hue = math.atan2(hue_x_total, hue_y_total) / (2.0 * math.pi)
    if hue < 0.0:
        hue += 1.0
    hue *= 360
    hue = round(hue, 4)
    saturation = round(saturation_total / len(colors), 4)
    brightness = round(brightness_total / len(colors), 4)
    kelvin = round(kelvin_total / len(colors))

    return cls(hue, saturation, brightness, kelvin)
````

## Colors Class

The `Colors` class provides convenient color presets for common colors.

### Colors

Common color presets for convenience.

## Examples

### Creating Colors

```python
from lifx import HSBK, Colors

# Use built-in color presets
color = Colors.BLUE

# Create custom colors
custom = HSBK(hue=180.0, saturation=1.0, brightness=0.8, kelvin=3500)

# Create from RGB
red = HSBK.from_rgb(255, 0, 0, kelvin=3500)

# Convert to RGB
r, g, b = Colors.BLUE.to_rgb()
print(f"RGB: ({r}, {g}, {b})")
```

### Color Components

```python
from lifx import HSBK

color = HSBK(hue=240.0, saturation=1.0, brightness=0.5, kelvin=3500)

# Hue: 0-360 degrees (0=red, 120=green, 240=blue)
print(f"Hue: {color.hue}°")

# Saturation: 0.0-1.0 (0=white, 1=full color)
print(f"Saturation: {color.saturation * 100}%")

# Brightness: 0.0-1.0 (0=off, 1=full brightness)
print(f"Brightness: {color.brightness * 100}%")

# Kelvin: 1500-9000 (warm white to cool white)
print(f"Temperature: {color.kelvin}K")
```

### Color Manipulation

```python
from lifx import HSBK, Light


async def cycle_hue(light: Light):
    """Cycle through the color spectrum"""
    for hue in range(0, 360, 10):
        color = HSBK(hue=float(hue), saturation=1.0, brightness=0.8, kelvin=3500)
        await light.set_color(color, duration=0.1)
```

### White Balance

```python
from lifx import HSBK

# Warm white (sunset, candlelight)
warm = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=2500)

# Neutral white (daylight)
neutral = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=4000)

# Cool white (overcast, shade)
cool = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=6500)
```

## Available Color Presets

The `Colors` class provides these preset colors:

- `Colors.WHITE` - Pure white (3500K)
- `Colors.RED` - Red
- `Colors.ORANGE` - Orange
- `Colors.YELLOW` - Yellow
- `Colors.GREEN` - Green
- `Colors.CYAN` - Cyan
- `Colors.BLUE` - Blue
- `Colors.PURPLE` - Purple
- `Colors.PINK` - Pink
- `Colors.WARM_WHITE` - Warm white (2500K)
- `Colors.COOL_WHITE` - Cool white (6500K)

## Color Conversion Notes

### RGB to HSBK

When converting from RGB to HSBK, note that:

- RGB values are 0-255
- The Kelvin value must be specified (default: 3500K)
- Some RGB colors may not have exact HSBK equivalents
- Conversion uses standard HSV formulas with brightness mapping

### HSBK to RGB

When converting from HSBK to RGB:

- Returns tuple of (r, g, b) with values 0-255
- Kelvin temperature is not represented in RGB
- White colors (saturation=0) will be pure gray values
- Conversion is lossy - converting back may not yield the same HSBK

# Device Classes

Device classes provide direct control over LIFX devices. All device classes support async context managers for automatic resource cleanup.

## Base Device

The `Device` class provides common operations available on all LIFX devices.

### Device

```python
Device(
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    timeout: float = 1.0,
    max_retries: int = 3,
)
```

Base class for LIFX devices.

This class provides common functionality for all LIFX devices:

- Connection management
- Basic device queries (label, power, version, info)
- State storage with timestamps (no automatic expiration)

All properties return a tuple of (value, timestamp) or None if never fetched. Callers can use the timestamp to determine if data needs refreshing.

Example

```python
device = Device(serial="d073d5123456", ip="192.168.1.100")

async with device:
    # Get device label
    label = await device.get_label()
    print(f"Device: {label}")

    # Check label and its age
    if device.label is not None:
        label_value, updated_at = device.label
        age = time.time() - updated_at
        print(f"Label '{label_value}' is {age:.1f}s old")

    # Turn on device and auto-refresh power state
    await device.set_power(True, refresh=True)

    # Get power state with timestamp
    power_result = device.power
    if power_result:
        is_on, timestamp = power_result
        print(f"Power: {'ON' if is_on else 'OFF'}")
```

| PARAMETER     | DESCRIPTION                                                                            |
| ------------- | -------------------------------------------------------------------------------------- |
| `serial`      | Device serial number as 12-digit hex string (e.g., "d073d5123456") **TYPE:** `str`     |
| `ip`          | Device IP address **TYPE:** `str`                                                      |
| `port`        | Device UDP port **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                           |
| `timeout`     | Overall timeout for network requests in seconds **TYPE:** `float` **DEFAULT:** `1.0`   |
| `max_retries` | Maximum number of retry attempts for network requests **TYPE:** `int` **DEFAULT:** `3` |

| RAISES       | DESCRIPTION                 |
| ------------ | --------------------------- |
| `ValueError` | If any parameter is invalid |

| METHOD              | DESCRIPTION                                             |
| ------------------- | ------------------------------------------------------- |
| `from_ip`           | Create and return an instance for the given IP address. |
| `get_label`         | Get device label/name.                                  |
| `set_label`         | Set device label/name.                                  |
| `get_power`         | Get device power state.                                 |
| `set_power`         | Set device power state.                                 |
| `get_version`       | Get device version information.                         |
| `get_info`          | Get device runtime information.                         |
| `get_wifi_info`     | Get device WiFi module information.                     |
| `get_host_firmware` | Get device host (WiFi module) firmware information.     |
| `get_wifi_firmware` | Get device WiFi module firmware information.            |
| `get_location`      | Get device location information.                        |
| `set_location`      | Set device location information.                        |
| `get_group`         | Get device group information.                           |
| `set_group`         | Set device group information.                           |
| `set_reboot`        | Reboot the device.                                      |

| ATTRIBUTE       | DESCRIPTION                                                                                  |
| --------------- | -------------------------------------------------------------------------------------------- |
| `capabilities`  | Get device product capabilities. **TYPE:** \`ProductInfo                                     |
| `label`         | Get stored label with timestamp if available. **TYPE:** \`tuple[str, float]                  |
| `power`         | Get stored power state with timestamp if available. **TYPE:** \`tuple[bool, float]           |
| `version`       | Get stored version with timestamp if available. **TYPE:** \`tuple[DeviceVersion, float]      |
| `host_firmware` | Get stored host firmware with timestamp if available. **TYPE:** \`tuple[FirmwareInfo, float] |
| `wifi_firmware` | Get stored wifi firmware with timestamp if available. **TYPE:** \`tuple[FirmwareInfo, float] |
| `location`      | Get stored location name with timestamp if available. **TYPE:** \`tuple[str, float]          |
| `group`         | Get stored group name with timestamp if available. **TYPE:** \`tuple[str, float]             |
| `model`         | Get LIFX friendly model name if available. **TYPE:** \`str                                   |

Source code in `src/lifx/devices/base.py`

```python
def __init__(
    self,
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    timeout: float = 1.0,
    max_retries: int = 3,
) -> None:
    """Initialize device.

    Args:
        serial: Device serial number as 12-digit hex string (e.g., "d073d5123456")
        ip: Device IP address
        port: Device UDP port
        timeout: Overall timeout for network requests in seconds
        max_retries: Maximum number of retry attempts for network requests

    Raises:
        ValueError: If any parameter is invalid
    """
    # Parse and validate serial number
    try:
        serial_obj = Serial.from_string(serial)
    except (ValueError, TypeError) as e:
        raise ValueError(f"Invalid serial number: {e}") from e

    serial_bytes = serial_obj.value

    # Validate serial number
    # Check for all-zeros (invalid)
    if serial_bytes == b"\x00" * 6:
        raise ValueError("Serial number cannot be all zeros")

    # Check for all-ones/broadcast (invalid for unicast)
    if serial_bytes == b"\xff" * 6:
        raise ValueError(
            "Broadcast serial number not allowed for device connection"
        )

    # Check multicast bit (first byte, LSB should be 0 for unicast)
    if serial_bytes[0] & 0x01:
        raise ValueError("Multicast serial number not allowed")

    # Validate IP address
    try:
        addr = ipaddress.ip_address(ip)
    except ValueError as e:
        raise ValueError(f"Invalid IP address format: {e}")

    # Check for localhost
    if addr.is_loopback:
        raise ValueError("Localhost IP address not allowed")

    # Check for unspecified (0.0.0.0)
    if addr.is_unspecified:
        raise ValueError("Unspecified IP address (0.0.0.0) not allowed")

    # Warn for non-private IPs (LIFX should be on local network)
    if not addr.is_private:
        _LOGGER.warning(
            {
                "class": "Device",
                "method": "__init__",
                "action": "non_private_ip",
                "ip": ip,
            }
        )

    # LIFX uses IPv4 only (protocol limitation)
    if addr.version != 4:
        raise ValueError("Only IPv4 addresses are supported")

    # Validate port
    if not (1 <= port <= 65535):
        raise ValueError(f"Port must be between 1 and 65535, got {port}")

    # Warn for non-standard ports
    if port != LIFX_UDP_PORT:
        _LOGGER.warning(
            {
                "class": "Device",
                "method": "__init__",
                "action": "non_standard_port",
                "port": port,
                "default_port": LIFX_UDP_PORT,
            }
        )

    # Store normalized serial as 12-digit hex string
    self.serial = serial_obj.to_string()
    self.ip = ip
    self.port = port

    # Create lightweight connection handle - connection pooling is internal
    self.connection = DeviceConnection(
        serial=self.serial,
        ip=self.ip,
        port=self.port,
        timeout=timeout,
        max_retries=max_retries,
    )

    # State storage: Each value stored as (value, timestamp) tuple
    # Values never expire automatically - caller decides when to refresh
    self._label: tuple[str, float] | None = None
    self._power: tuple[bool, float] | None = None
    self._version: tuple[DeviceVersion, float] | None = None
    self._host_firmware: tuple[FirmwareInfo, float] | None = None
    self._wifi_firmware: tuple[FirmwareInfo, float] | None = None
    self._location: tuple[LocationInfo, float] | None = None
    self._group: tuple[GroupInfo, float] | None = None

    # Product capabilities for device features (populated on first use)
    self._capabilities: ProductInfo | None = None
```

#### Attributes

##### capabilities

```python
capabilities: ProductInfo | None
```

Get device product capabilities.

Returns product information including supported features like:

- color, infrared, multizone, extended_multizone
- matrix (for tiles), chain, relays, buttons, hev
- temperature_range

Capabilities are automatically loaded when using device as context manager.

| RETURNS       | DESCRIPTION |
| ------------- | ----------- |
| \`ProductInfo | None\`      |

Example

```python
async with device:
    if device.capabilities and device.capabilities.has_multizone:
        print("Device supports multizone")
    if device.capabilities and device.capabilities.has_extended_multizone:
        print("Device supports extended multizone")
```

##### label

```python
label: tuple[str, float] | None
```

Get stored label with timestamp if available.

Use get_label() to fetch from device.

| RETURNS             | DESCRIPTION |
| ------------------- | ----------- |
| \`tuple[str, float] | None\`      |

##### power

```python
power: tuple[bool, float] | None
```

Get stored power state with timestamp if available.

Use get_power() to fetch from device.

| RETURNS              | DESCRIPTION |
| -------------------- | ----------- |
| \`tuple[bool, float] | None\`      |

##### version

```python
version: tuple[DeviceVersion, float] | None
```

Get stored version with timestamp if available.

Use get_version() to fetch from device.

| RETURNS                       | DESCRIPTION |
| ----------------------------- | ----------- |
| \`tuple[DeviceVersion, float] | None\`      |

##### host_firmware

```python
host_firmware: tuple[FirmwareInfo, float] | None
```

Get stored host firmware with timestamp if available.

Use get_host_firmware() to fetch from device.

| RETURNS                      | DESCRIPTION |
| ---------------------------- | ----------- |
| \`tuple[FirmwareInfo, float] | None\`      |

##### wifi_firmware

```python
wifi_firmware: tuple[FirmwareInfo, float] | None
```

Get stored wifi firmware with timestamp if available.

Use get_wifi_firmware() to fetch from device.

| RETURNS                      | DESCRIPTION |
| ---------------------------- | ----------- |
| \`tuple[FirmwareInfo, float] | None\`      |

##### location

```python
location: tuple[str, float] | None
```

Get stored location name with timestamp if available.

Use get_location() to fetch from device.

| RETURNS             | DESCRIPTION |
| ------------------- | ----------- |
| \`tuple[str, float] | None\`      |

##### group

```python
group: tuple[str, float] | None
```

Get stored group name with timestamp if available.

Use get_group() to fetch from device.

| RETURNS             | DESCRIPTION |
| ------------------- | ----------- |
| \`tuple[str, float] | None\`      |

##### model

```python
model: str | None
```

Get LIFX friendly model name if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`str   | None\`      |

#### Functions

##### from_ip

```python
from_ip(
    ip: str,
    port: int = LIFX_UDP_PORT,
    serial: str | None = None,
    timeout: float = 1.0,
) -> Self
```

Create and return an instance for the given IP address.

This is a convenience class method for connecting to a known device by IP address. The returned instance can be used as a context manager.

| PARAMETER | DESCRIPTION                                                                      |
| --------- | -------------------------------------------------------------------------------- |
| `ip`      | IP address of the device **TYPE:** `str`                                         |
| `port`    | Port number (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT` |
| `serial`  | Serial number as 12-digit hex string **TYPE:** \`str                             |
| `timeout` | Request timeout for this device instance **TYPE:** `float` **DEFAULT:** `1.0`    |

| RETURNS | DESCRIPTION                                             |
| ------- | ------------------------------------------------------- |
| `Self`  | Device instance ready to use with async context manager |

Example

```python
async with await Device.from_ip(ip="192.168.1.100") as device:
    label = await device.get_label()
```

Source code in `src/lifx/devices/base.py`

````python
@classmethod
async def from_ip(
    cls,
    ip: str,
    port: int = LIFX_UDP_PORT,
    serial: str | None = None,
    timeout: float = 1.0,
) -> Self:
    """Create and return an instance for the given IP address.

    This is a convenience class method for connecting to a known device
    by IP address. The returned instance can be used as a context manager.

    Args:
        ip: IP address of the device
        port: Port number (default LIFX_UDP_PORT)
        serial: Serial number as 12-digit hex string
        timeout: Request timeout for this device instance

    Returns:
        Device instance ready to use with async context manager

    Example:
        ```python
        async with await Device.from_ip(ip="192.168.1.100") as device:
            label = await device.get_label()
        ```
    """
    if serial is None:
        temp_conn = DeviceConnection(serial="000000000000", ip=ip, port=port)
        response = await temp_conn.request(packets.Device.GetService(), timeout=2.0)
        if response and isinstance(response, packets.Device.StateService):
            if temp_conn.serial and temp_conn.serial != "000000000000":
                return cls(
                    serial=temp_conn.serial, ip=ip, port=port, timeout=timeout
                )
    else:
        return cls(serial=serial, ip=ip, port=port, timeout=timeout)

    raise LifxDeviceNotFoundError()
````

##### get_label

```python
get_label() -> str
```

Get device label/name.

Always fetches from device. Use the `label` property to access stored value.

| RETURNS | DESCRIPTION                                 |
| ------- | ------------------------------------------- |
| `str`   | Device label as string (max 32 bytes UTF-8) |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
label = await device.get_label()
print(f"Device name: {label}")

# Or use stored value
if device.label:
    label, timestamp = device.label
    print(f"Stored label: {label}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_label(self) -> str:
    """Get device label/name.

    Always fetches from device. Use the `label` property to access stored value.

    Returns:
        Device label as string (max 32 bytes UTF-8)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        label = await device.get_label()
        print(f"Device name: {label}")

        # Or use stored value
        if device.label:
            label, timestamp = device.label
            print(f"Stored label: {label}")
        ```
    """
    # Request automatically unpacks and decodes label
    state = await self.connection.request(packets.Device.GetLabel())

    # Store label with timestamp
    self._label = (state.label, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_label",
            "action": "query",
            "reply": {"label": state.label},
        }
    )
    return state.label
````

##### set_label

```python
set_label(label: str) -> None
```

Set device label/name.

| PARAMETER | DESCRIPTION                                           |
| --------- | ----------------------------------------------------- |
| `label`   | New device label (max 32 bytes UTF-8) **TYPE:** `str` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If label is too long       |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set label
await device.set_label("Living Room Light")
```

Source code in `src/lifx/devices/base.py`

````python
async def set_label(self, label: str) -> None:
    """Set device label/name.

    Args:
        label: New device label (max 32 bytes UTF-8)

    Raises:
        ValueError: If label is too long
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set label
        await device.set_label("Living Room Light")
        ```
    """
    # Encode and pad to 32 bytes
    label_bytes = label.encode("utf-8")
    if len(label_bytes) > 32:
        raise ValueError(f"Label too long: {len(label_bytes)} bytes (max 32)")

    # Pad with zeros
    label_bytes = label_bytes.ljust(32, b"\x00")

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Device.SetLabel(label=label_bytes),
    )

    # Update state with timestamp
    self._label = (label, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_label",
            "action": "change",
            "values": {"label": label},
        }
    )
````

##### get_power

```python
get_power() -> bool
```

Get device power state.

Always fetches from device. Use the `power` property to access stored value.

| RETURNS | DESCRIPTION                                   |
| ------- | --------------------------------------------- |
| `bool`  | True if device is powered on, False otherwise |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
is_on = await device.get_power()
print(f"Power: {'ON' if is_on else 'OFF'}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_power(self) -> bool:
    """Get device power state.

    Always fetches from device. Use the `power` property to access stored value.

    Returns:
        True if device is powered on, False otherwise

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        is_on = await device.get_power()
        print(f"Power: {'ON' if is_on else 'OFF'}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetPower())

    # Power level is uint16 (0 or 65535)
    is_on = state.level > 0

    self._power = (is_on, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_power",
            "action": "query",
            "reply": {"level": state.level},
        }
    )
    return is_on
````

##### set_power

```python
set_power(on: bool) -> None
```

Set device power state.

| PARAMETER | DESCRIPTION                                         |
| --------- | --------------------------------------------------- |
| `on`      | True to turn on, False to turn off **TYPE:** `bool` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Turn on device
await device.set_power(True)
```

Source code in `src/lifx/devices/base.py`

````python
async def set_power(self, on: bool) -> None:
    """Set device power state.

    Args:
        on: True to turn on, False to turn off

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Turn on device
        await device.set_power(True)
        ```
    """
    # Power level: 0 for off, 65535 for on
    level = 65535 if on else 0

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Device.SetPower(level=level),
    )

    # Update state with timestamp
    self._power = (on, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_power",
            "action": "change",
            "values": {"level": level},
        }
    )
````

##### get_version

```python
get_version() -> DeviceVersion
```

Get device version information.

Always fetches from device.

| RETURNS         | DESCRIPTION                                  |
| --------------- | -------------------------------------------- |
| `DeviceVersion` | DeviceVersion with vendor and product fields |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
version = await device.get_version()
print(f"Vendor: {version.vendor}, Product: {version.product}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_version(self) -> DeviceVersion:
    """Get device version information.

    Always fetches from device.

    Returns:
        DeviceVersion with vendor and product fields

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        version = await device.get_version()
        print(f"Vendor: {version.vendor}, Product: {version.product}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetVersion())

    version = DeviceVersion(
        vendor=state.vendor,
        product=state.product,
    )

    self._version = (version, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_version",
            "action": "query",
            "reply": {"vendor": state.vendor, "product": state.product},
        }
    )
    return version
````

##### get_info

```python
get_info() -> DeviceInfo
```

Get device runtime information.

Always fetches from device.

| RETURNS      | DESCRIPTION                                |
| ------------ | ------------------------------------------ |
| `DeviceInfo` | DeviceInfo with time, uptime, and downtime |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
info = await device.get_info()
uptime_hours = info.uptime / 1e9 / 3600
print(f"Uptime: {uptime_hours:.1f} hours")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_info(self) -> DeviceInfo:
    """Get device runtime information.

    Always fetches from device.

    Returns:
        DeviceInfo with time, uptime, and downtime

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        info = await device.get_info()
        uptime_hours = info.uptime / 1e9 / 3600
        print(f"Uptime: {uptime_hours:.1f} hours")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetInfo())  # type: ignore

    info = DeviceInfo(time=state.time, uptime=state.uptime, downtime=state.downtime)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_info",
            "action": "query",
            "reply": {
                "time": state.time,
                "uptime": state.uptime,
                "downtime": state.downtime,
            },
        }
    )
    return info
````

##### get_wifi_info

```python
get_wifi_info() -> WifiInfo
```

Get device WiFi module information.

Always fetches from device.

| RETURNS    | DESCRIPTION                                     |
| ---------- | ----------------------------------------------- |
| `WifiInfo` | WifiInfo with signal strength and network stats |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
wifi_info = await device.get_wifi_info()
print(f"WiFi signal: {wifi_info.signal} mW")
print(f"TX: {wifi_info.tx} bytes, RX: {wifi_info.rx} bytes")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_wifi_info(self) -> WifiInfo:
    """Get device WiFi module information.

    Always fetches from device.

    Returns:
        WifiInfo with signal strength and network stats

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        wifi_info = await device.get_wifi_info()
        print(f"WiFi signal: {wifi_info.signal} mW")
        print(f"TX: {wifi_info.tx} bytes, RX: {wifi_info.rx} bytes")
        ```
    """
    # Request WiFi info from device
    state = await self.connection.request(packets.Device.GetWifiInfo())

    # Extract WiFi info from response
    wifi_info = WifiInfo(signal=state.signal, tx=state.tx, rx=state.rx)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_wifi_info",
            "action": "query",
            "reply": {"signal": state.signal, "tx": state.tx, "rx": state.rx},
        }
    )
    return wifi_info
````

##### get_host_firmware

```python
get_host_firmware() -> FirmwareInfo
```

Get device host (WiFi module) firmware information.

Always fetches from device.

| RETURNS        | DESCRIPTION                                   |
| -------------- | --------------------------------------------- |
| `FirmwareInfo` | FirmwareInfo with build timestamp and version |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
firmware = await device.get_host_firmware()
print(f"Firmware: v{firmware.version_major}.{firmware.version_minor}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_host_firmware(self) -> FirmwareInfo:
    """Get device host (WiFi module) firmware information.

    Always fetches from device.

    Returns:
        FirmwareInfo with build timestamp and version

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        firmware = await device.get_host_firmware()
        print(f"Firmware: v{firmware.version_major}.{firmware.version_minor}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetHostFirmware())  # type: ignore

    firmware = FirmwareInfo(
        build=state.build,
        version_major=state.version_major,
        version_minor=state.version_minor,
    )

    self._host_firmware = (firmware, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_host_firmware",
            "action": "query",
            "reply": {
                "build": state.build,
                "version_major": state.version_major,
                "version_minor": state.version_minor,
            },
        }
    )
    return firmware
````

##### get_wifi_firmware

```python
get_wifi_firmware() -> FirmwareInfo
```

Get device WiFi module firmware information.

Always fetches from device.

| RETURNS        | DESCRIPTION                                   |
| -------------- | --------------------------------------------- |
| `FirmwareInfo` | FirmwareInfo with build timestamp and version |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
wifi_fw = await device.get_wifi_firmware()
print(f"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_wifi_firmware(self) -> FirmwareInfo:
    """Get device WiFi module firmware information.

    Always fetches from device.

    Returns:
        FirmwareInfo with build timestamp and version

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        wifi_fw = await device.get_wifi_firmware()
        print(f"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetWifiFirmware())  # type: ignore

    firmware = FirmwareInfo(
        build=state.build,
        version_major=state.version_major,
        version_minor=state.version_minor,
    )

    self._wifi_firmware = (firmware, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_wifi_firmware",
            "action": "query",
            "reply": {
                "build": state.build,
                "version_major": state.version_major,
                "version_minor": state.version_minor,
            },
        }
    )
    return firmware
````

##### get_location

```python
get_location() -> LocationInfo
```

Get device location information.

Always fetches from device.

| RETURNS        | DESCRIPTION                                                   |
| -------------- | ------------------------------------------------------------- |
| `LocationInfo` | LocationInfo with location UUID, label, and updated timestamp |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
location = await device.get_location()
print(f"Location: {location.label}")
print(f"Location ID: {location.location.hex()}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_location(self) -> LocationInfo:
    """Get device location information.

    Always fetches from device.

    Returns:
        LocationInfo with location UUID, label, and updated timestamp

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        location = await device.get_location()
        print(f"Location: {location.label}")
        print(f"Location ID: {location.location.hex()}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetLocation())  # type: ignore

    location = LocationInfo(
        location=state.location,
        label=state.label,
        updated_at=state.updated_at,
    )

    self._location = (location, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_location",
            "action": "query",
            "reply": {
                "location": state.location.hex(),
                "label": state.label,
                "updated_at": state.updated_at,
            },
        }
    )
    return location
````

##### set_location

```python
set_location(label: str, *, discover_timeout: float = 3.0) -> None
```

Set device location information.

Automatically discovers devices on the network to check if any device already has the target location label. If found, reuses that existing UUID to ensure devices with the same label share the same location UUID. If not found, generates a new UUID for this label.

| PARAMETER          | DESCRIPTION                                                                                |
| ------------------ | ------------------------------------------------------------------------------------------ |
| `label`            | Location label (max 32 characters) **TYPE:** `str`                                         |
| `discover_timeout` | Timeout for device discovery in seconds (default 3.0) **TYPE:** `float` **DEFAULT:** `3.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `ValueError`              | If label is invalid        |

Example

```python
# Set device location
await device.set_location("Living Room")

# If another device already has "Kitchen" location, this device will
# join that existing location UUID
await device.set_location("Kitchen")
```

Source code in `src/lifx/devices/base.py`

````python
async def set_location(self, label: str, *, discover_timeout: float = 3.0) -> None:
    """Set device location information.

    Automatically discovers devices on the network to check if any device already
    has the target location label. If found, reuses that existing UUID to ensure
    devices with the same label share the same location UUID. If not found,
    generates a new UUID for this label.

    Args:
        label: Location label (max 32 characters)
        discover_timeout: Timeout for device discovery in seconds (default 3.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        ValueError: If label is invalid

    Example:
        ```python
        # Set device location
        await device.set_location("Living Room")

        # If another device already has "Kitchen" location, this device will
        # join that existing location UUID
        await device.set_location("Kitchen")
        ```
    """
    # Validate label
    if not label:
        raise ValueError("Label cannot be empty")
    if len(label) > 32:
        raise ValueError(f"Label must be max 32 characters, got {len(label)}")

    # Import here to avoid circular dependency
    from lifx.network.discovery import discover_devices

    # Discover all devices to check for existing label
    location_uuid_to_use: bytes | None = None

    try:
        discovered = await discover_devices(timeout=discover_timeout)

        # Check each device for the target label
        for disc in discovered:
            try:
                # Create connection handle - no explicit open/close needed
                temp_conn = DeviceConnection(
                    serial=disc.serial, ip=disc.ip, port=disc.port
                )

                # Get location info using new request() API
                state_packet = await temp_conn.request(packets.Device.GetLocation())  # type: ignore

                # Check if this device has the target label
                if (
                    state_packet.label == label
                    and state_packet.location is not None
                    and isinstance(state_packet.location, bytes)
                ):
                    location_uuid_to_use = state_packet.location
                    # Type narrowing: we know location_uuid_to_use is not None here
                    _LOGGER.debug(
                        {
                            "action": "device.set_location",
                            "location_found": True,
                            "label": label,
                            "uuid": location_uuid_to_use.hex(),
                        }
                    )
                    break

            except Exception as e:
                _LOGGER.debug(
                    {
                        "action": "device.set_location",
                        "discovery_query_failed": True,
                        "reason": str(e),
                    }
                )
                continue

    except Exception as e:
        _LOGGER.warning(
            {
                "warning": "Discovery failed, will generate new UUID",
                "reason": str(e),
            }
        )

    # If no existing location with target label found, generate new UUID
    if location_uuid_to_use is None:
        location_uuid = uuid.uuid5(LIFX_LOCATION_NAMESPACE, label)
        location_uuid_to_use = location_uuid.bytes

    # Encode label for protocol
    label_bytes = label.encode("utf-8")[:32].ljust(32, b"\x00")

    # Always use current time as updated_at timestamp
    updated_at = int(time.time() * 1e9)

    # Update this device
    await self.connection.request(
        packets.Device.SetLocation(
            location=location_uuid_to_use, label=label_bytes, updated_at=updated_at
        ),
    )

    # Update state with timestamp
    location_info = LocationInfo(
        location=location_uuid_to_use, label=label, updated_at=updated_at
    )
    self._location = (location_info, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_location",
            "action": "change",
            "values": {
                "location": location_uuid_to_use.hex(),
                "label": label,
                "updated_at": updated_at,
            },
        }
    )
````

##### get_group

```python
get_group() -> GroupInfo
```

Get device group information.

Always fetches from device.

| RETURNS     | DESCRIPTION                                             |
| ----------- | ------------------------------------------------------- |
| `GroupInfo` | GroupInfo with group UUID, label, and updated timestamp |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
group = await device.get_group()
print(f"Group: {group.label}")
print(f"Group ID: {group.group.hex()}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_group(self) -> GroupInfo:
    """Get device group information.

    Always fetches from device.

    Returns:
        GroupInfo with group UUID, label, and updated timestamp

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        group = await device.get_group()
        print(f"Group: {group.label}")
        print(f"Group ID: {group.group.hex()}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetGroup())  # type: ignore

    group = GroupInfo(
        group=state.group,
        label=state.label,
        updated_at=state.updated_at,
    )

    self._group = (group, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_group",
            "action": "query",
            "reply": {
                "group": state.group.hex(),
                "label": state.label,
                "updated_at": state.updated_at,
            },
        }
    )
    return group
````

##### set_group

```python
set_group(label: str, *, discover_timeout: float = 3.0) -> None
```

Set device group information.

Automatically discovers devices on the network to check if any device already has the target group label. If found, reuses that existing UUID to ensure devices with the same label share the same group UUID. If not found, generates a new UUID for this label.

| PARAMETER          | DESCRIPTION                                                                                |
| ------------------ | ------------------------------------------------------------------------------------------ |
| `label`            | Group label (max 32 characters) **TYPE:** `str`                                            |
| `discover_timeout` | Timeout for device discovery in seconds (default 3.0) **TYPE:** `float` **DEFAULT:** `3.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `ValueError`              | If label is invalid        |

Example

```python
# Set device group
await device.set_group("Bedroom Lights")

# If another device already has "Upstairs" group, this device will
# join that existing group UUID
await device.set_group("Upstairs")
```

Source code in `src/lifx/devices/base.py`

````python
async def set_group(self, label: str, *, discover_timeout: float = 3.0) -> None:
    """Set device group information.

    Automatically discovers devices on the network to check if any device already
    has the target group label. If found, reuses that existing UUID to ensure
    devices with the same label share the same group UUID. If not found,
    generates a new UUID for this label.

    Args:
        label: Group label (max 32 characters)
        discover_timeout: Timeout for device discovery in seconds (default 3.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        ValueError: If label is invalid

    Example:
        ```python
        # Set device group
        await device.set_group("Bedroom Lights")

        # If another device already has "Upstairs" group, this device will
        # join that existing group UUID
        await device.set_group("Upstairs")
        ```
    """
    # Validate label
    if not label:
        raise ValueError("Label cannot be empty")
    if len(label) > 32:
        raise ValueError(f"Label must be max 32 characters, got {len(label)}")

    # Import here to avoid circular dependency
    from lifx.network.discovery import discover_devices

    # Discover all devices to check for existing label
    group_uuid_to_use: bytes | None = None

    try:
        discovered = await discover_devices(timeout=discover_timeout)

        # Check each device for the target label
        for disc in discovered:
            try:
                # Create connection handle - no explicit open/close needed
                temp_conn = DeviceConnection(
                    serial=disc.serial, ip=disc.ip, port=disc.port
                )

                # Get group info using new request() API
                state_packet = await temp_conn.request(packets.Device.GetGroup())  # type: ignore

                # Check if this device has the target label
                if (
                    state_packet.label == label
                    and state_packet.group is not None
                    and isinstance(state_packet.group, bytes)
                ):
                    group_uuid_to_use = state_packet.group
                    # Type narrowing: we know group_uuid_to_use is not None here
                    _LOGGER.debug(
                        {
                            "action": "device.set_group",
                            "group_found": True,
                            "label": label,
                            "uuid": group_uuid_to_use.hex(),
                        }
                    )
                    break

            except Exception as e:
                _LOGGER.debug(
                    {
                        "action": "device.set_group",
                        "discovery_query_failed": True,
                        "reason": str(e),
                    }
                )
                continue

    except Exception as e:
        _LOGGER.warning(
            {
                "warning": "Discovery failed, will generate new UUID",
                "reason": str(e),
            }
        )

    # If no existing group with target label found, generate new UUID
    if group_uuid_to_use is None:
        group_uuid = uuid.uuid5(LIFX_GROUP_NAMESPACE, label)
        group_uuid_to_use = group_uuid.bytes

    # Encode label for protocol
    label_bytes = label.encode("utf-8")[:32].ljust(32, b"\x00")

    # Always use current time as updated_at timestamp
    updated_at = int(time.time() * 1e9)

    # Update this device
    await self.connection.request(
        packets.Device.SetGroup(
            group=group_uuid_to_use, label=label_bytes, updated_at=updated_at
        ),
    )

    # Update state with timestamp
    group_info = GroupInfo(
        group=group_uuid_to_use, label=label, updated_at=updated_at
    )
    self._group = (group_info, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_group",
            "action": "change",
            "values": {
                "group": group_uuid_to_use.hex(),
                "label": label,
                "updated_at": updated_at,
            },
        }
    )
````

##### set_reboot

```python
set_reboot() -> None
```

Reboot the device.

This sends a reboot command to the device. The device will disconnect and restart. You should disconnect from the device after calling this method.

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
async with device:
    await device.set_reboot()
    # Device will reboot, connection will be lost
```

Note

After rebooting, you may need to wait 10-30 seconds before the device comes back online and is discoverable again.

Source code in `src/lifx/devices/base.py`

````python
async def set_reboot(self) -> None:
    """Reboot the device.

    This sends a reboot command to the device. The device will disconnect
    and restart. You should disconnect from the device after calling this method.

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        async with device:
            await device.set_reboot()
            # Device will reboot, connection will be lost
        ```

    Note:
        After rebooting, you may need to wait 10-30 seconds before the device
        comes back online and is discoverable again.
    """
    # Send reboot request
    await self.connection.request(
        packets.Device.SetReboot(),
    )
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_reboot",
            "action": "change",
            "values": {},
        }
    )
````

## Light

The `Light` class provides color control and effects for standard LIFX lights.

### Light

```python
Light(*args, **kwargs)
```

Bases: `Device`

LIFX light device with color control.

Extends the base Device class with light-specific functionality:

- Color control (HSBK)
- Brightness control
- Color temperature control
- Waveform effects

Example

```python
light = Light(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Set color
    await light.set_color(HSBK.from_rgb(255, 0, 0))

    # Set brightness
    await light.set_brightness(0.5)

    # Set temperature
    await light.set_temperature(3500)
```

Using the simplified connect method (without knowing the serial):

```python
async with await Light.from_ip(ip="192.168.1.100") as light:
    await light.set_color(HSBK.from_rgb(255, 0, 0))
```

| METHOD                  | DESCRIPTION                                                             |
| ----------------------- | ----------------------------------------------------------------------- |
| `get_color`             | Get current light color, power, and label.                              |
| `set_color`             | Set light color.                                                        |
| `set_brightness`        | Set light brightness only, preserving hue, saturation, and temperature. |
| `set_kelvin`            | Set light color temperature, preserving brightness. Saturation is       |
| `set_hue`               | Set light hue only, preserving saturation, brightness, and temperature. |
| `set_saturation`        | Set light saturation only, preserving hue, brightness, and temperature. |
| `get_power`             | Get light power state (specific to light, not device).                  |
| `set_power`             | Set light power state (specific to light, not device).                  |
| `set_waveform`          | Apply a waveform effect to the light.                                   |
| `set_waveform_optional` | Apply a waveform effect with selective color component control.         |
| `pulse`                 | Pulse the light to a specific color.                                    |
| `breathe`               | Make the light breathe to a specific color.                             |
| `apply_theme`           | Apply a theme to this light.                                            |

| ATTRIBUTE    | DESCRIPTION                                                                        |
| ------------ | ---------------------------------------------------------------------------------- |
| `color`      | Get stored light color with timestamp if available. **TYPE:** \`tuple[HSBK, float] |
| `min_kelvin` | Get the minimum supported kelvin value if available. **TYPE:** \`int               |
| `max_kelvin` | Get the maximum supported kelvin value if available. **TYPE:** \`int               |

Source code in `src/lifx/devices/light.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize Light with additional state attributes."""
    super().__init__(*args, **kwargs)
    # Light-specific state storage
    self._color: tuple[HSBK, float] | None = None
```

#### Attributes

##### color

```python
color: tuple[HSBK, float] | None
```

Get stored light color with timestamp if available.

| RETURNS              | DESCRIPTION |
| -------------------- | ----------- |
| \`tuple[HSBK, float] | None\`      |
| \`tuple[HSBK, float] | None\`      |

##### min_kelvin

```python
min_kelvin: int | None
```

Get the minimum supported kelvin value if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`int   | None\`      |

##### max_kelvin

```python
max_kelvin: int | None
```

Get the maximum supported kelvin value if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`int   | None\`      |

#### Functions

##### get_color

```python
get_color() -> tuple[HSBK, bool, str]
```

Get current light color, power, and label.

Always fetches from device. Use the `color` property to access stored value.

Returns a tuple containing:

- color: HSBK color
- power: Power state (True=on, False=off)
- label: Device label/name

| RETURNS                  | DESCRIPTION                    |
| ------------------------ | ------------------------------ |
| `tuple[HSBK, bool, str]` | Tuple of (color, power, label) |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
color, power, label = await light.get_color()
print(f"{label}: Hue: {color.hue}°, Power: {power}")
```

Source code in `src/lifx/devices/light.py`

````python
async def get_color(self) -> tuple[HSBK, bool, str]:
    """Get current light color, power, and label.

    Always fetches from device. Use the `color` property to access stored value.

    Returns a tuple containing:
    - color: HSBK color
    - power: Power state (True=on, False=off)
    - label: Device label/name

    Returns:
        Tuple of (color, power, label)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        color, power, label = await light.get_color()
        print(f"{label}: Hue: {color.hue}°, Power: {power}")
        ```
    """
    # Request automatically unpacks response and decodes labels
    state = await self.connection.request(packets.Light.GetColor())

    # Convert from protocol HSBK to user-friendly HSBK
    color = HSBK.from_protocol(state.color)
    power = state.power > 0
    label = state.label

    # Store color and other fields from StateColor response with timestamps
    import time

    timestamp = time.time()
    self._color = (color, timestamp)
    self._label = (label, timestamp)  # Already decoded to string
    self._power = (power, timestamp)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_color",
            "action": "query",
            "reply": {
                "hue": state.color.hue,
                "saturation": state.color.saturation,
                "brightness": state.color.brightness,
                "kelvin": state.color.kelvin,
                "power": state.power,
                "label": state.label,
            },
        }
    )

    return color, power, label
````

##### set_color

```python
set_color(color: HSBK, duration: float = 0.0) -> None
```

Set light color.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set to red instantly
await light.set_color(HSBK.from_rgb(255, 0, 0))

# Fade to blue over 2 seconds
await light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_color(
    self,
    color: HSBK,
    duration: float = 0.0,
) -> None:
    """Set light color.

    Args:
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to red instantly
        await light.set_color(HSBK.from_rgb(255, 0, 0))

        # Fade to blue over 2 seconds
        await light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)
        ```
    """
    # Convert to protocol HSBK
    protocol_color = color.to_protocol()

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Light.SetColor(
            color=protocol_color,
            duration=duration_ms,
        ),
    )

    # Update state with timestamp
    import time

    self._color = (color, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_color",
            "action": "change",
            "values": {
                "hue": protocol_color.hue,
                "saturation": protocol_color.saturation,
                "brightness": protocol_color.brightness,
                "kelvin": protocol_color.kelvin,
                "duration": duration_ms,
            },
        }
    )
````

##### set_brightness

```python
set_brightness(brightness: float, duration: float = 0.0) -> None
```

Set light brightness only, preserving hue, saturation, and temperature.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `brightness` | Brightness level (0.0-1.0) **TYPE:** `float`                                      |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                   |
| ------------------------- | ----------------------------- |
| `ValueError`              | If brightness is out of range |
| `LifxDeviceNotFoundError` | If device is not connected    |
| `LifxTimeoutError`        | If device does not respond    |

Example

```python
# Set to 50% brightness
await light.set_brightness(0.5)

# Fade to full brightness over 1 second
await light.set_brightness(1.0, duration=1.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_brightness(self, brightness: float, duration: float = 0.0) -> None:
    """Set light brightness only, preserving hue, saturation, and temperature.

    Args:
        brightness: Brightness level (0.0-1.0)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If brightness is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to 50% brightness
        await light.set_brightness(0.5)

        # Fade to full brightness over 1 second
        await light.set_brightness(1.0, duration=1.0)
        ```
    """
    if not (0.0 <= brightness <= 1.0):
        raise ValueError(
            f"Brightness must be between 0.0 and 1.0, got {brightness}"
        )

    # Use set_waveform_optional with HALF_SINE waveform to set brightness
    # without needing to query current color values. Convert duration to seconds.
    color = HSBK(hue=0, saturation=0, brightness=brightness, kelvin=3500)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=False,
        set_saturation=False,
        set_brightness=True,
        set_kelvin=False,
    )
````

##### set_kelvin

```python
set_kelvin(kelvin: int, duration: float = 0.0) -> None
```

Set light color temperature, preserving brightness. Saturation is automatically set to 0 to switch the light to color temperature mode.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `kelvin`   | Color temperature in Kelvin (1500-9000) **TYPE:** `int`                           |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If kelvin is out of range  |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set to warm white
await light.set_kelvin(2500)

# Fade to cool white over 2 seconds
await light.set_kelvin(6500, duration=2.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_kelvin(self, kelvin: int, duration: float = 0.0) -> None:
    """Set light color temperature, preserving brightness. Saturation is
       automatically set to 0 to switch the light to color temperature mode.

    Args:
        kelvin: Color temperature in Kelvin (1500-9000)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If kelvin is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to warm white
        await light.set_kelvin(2500)

        # Fade to cool white over 2 seconds
        await light.set_kelvin(6500, duration=2.0)
        ```
    """
    if not (HSBK.MIN_KELVIN <= kelvin <= HSBK.MAX_KELVIN):
        raise ValueError(f"Kelvin must be 1500-9000, got {kelvin}")

    # Use set_waveform_optional with HALF_SINE waveform to set kelvin
    # and saturation without needing to query current color values
    color = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=kelvin)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=False,
        set_saturation=True,
        set_brightness=False,
        set_kelvin=True,
    )
````

##### set_hue

```python
set_hue(hue: float, duration: float = 0.0) -> None
```

Set light hue only, preserving saturation, brightness, and temperature.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `hue`      | Hue in degrees (0-360) **TYPE:** `float`                                          |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If hue is out of range     |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set to red (0 degrees)
await light.set_hue(0)

# Cycle through rainbow
for hue in range(0, 360, 10):
    await light.set_hue(hue, duration=0.5)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_hue(self, hue: float, duration: float = 0.0) -> None:
    """Set light hue only, preserving saturation, brightness, and temperature.

    Args:
        hue: Hue in degrees (0-360)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If hue is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to red (0 degrees)
        await light.set_hue(0)

        # Cycle through rainbow
        for hue in range(0, 360, 10):
            await light.set_hue(hue, duration=0.5)
        ```
    """
    if not (HSBK.MIN_HUE <= hue <= HSBK.MAX_HUE):
        raise ValueError(
            f"Hue must be between {HSBK.MIN_HUE} and {HSBK.MAX_HUE}, got {hue}"
        )

    # Use set_waveform_optional with HALF_SINE waveform to set hue
    # without needing to query current color values
    color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=True,
        set_saturation=False,
        set_brightness=False,
        set_kelvin=False,
    )
````

##### set_saturation

```python
set_saturation(saturation: float, duration: float = 0.0) -> None
```

Set light saturation only, preserving hue, brightness, and temperature.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `saturation` | Saturation level (0.0-1.0) **TYPE:** `float`                                      |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                   |
| ------------------------- | ----------------------------- |
| `ValueError`              | If saturation is out of range |
| `LifxDeviceNotFoundError` | If device is not connected    |
| `LifxTimeoutError`        | If device does not respond    |

Example

```python
# Set to fully saturated
await light.set_saturation(1.0)

# Fade to white (no saturation) over 2 seconds
await light.set_saturation(0.0, duration=2.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_saturation(self, saturation: float, duration: float = 0.0) -> None:
    """Set light saturation only, preserving hue, brightness, and temperature.

    Args:
        saturation: Saturation level (0.0-1.0)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If saturation is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to fully saturated
        await light.set_saturation(1.0)

        # Fade to white (no saturation) over 2 seconds
        await light.set_saturation(0.0, duration=2.0)
        ```
    """
    if not (HSBK.MIN_SATURATION <= saturation <= HSBK.MAX_SATURATION):
        raise ValueError(f"Saturation must be 0.0-1.0, got {saturation}")

    # Use set_waveform_optional with HALF_SINE waveform to set saturation
    # without needing to query current color values
    color = HSBK(hue=0, saturation=saturation, brightness=1.0, kelvin=3500)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=False,
        set_saturation=True,
        set_brightness=False,
        set_kelvin=False,
    )
````

##### get_power

```python
get_power() -> bool
```

Get light power state (specific to light, not device).

Always fetches from device. Use the `power` property to access stored value.

This overrides Device.get_power() as it queries the light-specific power state (packet type 116/118) instead of device power (packet type 20/22).

| RETURNS | DESCRIPTION                                  |
| ------- | -------------------------------------------- |
| `bool`  | True if light is powered on, False otherwise |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
is_on = await light.get_power()
print(f"Light power: {'ON' if is_on else 'OFF'}")
```

Source code in `src/lifx/devices/light.py`

````python
async def get_power(self) -> bool:
    """Get light power state (specific to light, not device).

    Always fetches from device. Use the `power` property to access stored value.

    This overrides Device.get_power() as it queries the light-specific
    power state (packet type 116/118) instead of device power (packet type 20/22).

    Returns:
        True if light is powered on, False otherwise

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        is_on = await light.get_power()
        print(f"Light power: {'ON' if is_on else 'OFF'}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Light.GetPower())

    # Power level is uint16 (0 or 65535)
    is_on = state.level > 0

    import time

    self._power = (is_on, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_power",
            "action": "query",
            "reply": {"level": state.level},
        }
    )

    return is_on
````

##### set_power

```python
set_power(on: bool, duration: float = 0.0) -> None
```

Set light power state (specific to light, not device).

This overrides Device.set_power() as it uses the light-specific power packet (type 117) which supports transition duration.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `on`       | True to turn on, False to turn off **TYPE:** `bool`                               |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Turn on instantly
await light.set_power(True)

# Fade off over 3 seconds
await light.set_power(False, duration=3.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_power(self, on: bool, duration: float = 0.0) -> None:
    """Set light power state (specific to light, not device).

    This overrides Device.set_power() as it uses the light-specific
    power packet (type 117) which supports transition duration.

    Args:
        on: True to turn on, False to turn off
        duration: Transition duration in seconds (default 0.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Turn on instantly
        await light.set_power(True)

        # Fade off over 3 seconds
        await light.set_power(False, duration=3.0)
        ```
    """
    # Power level: 0 for off, 65535 for on
    level = 65535 if on else 0

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Light.SetPower(level=level, duration=duration_ms),
    )

    # Update state with timestamp
    import time

    self._power = (on, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_power",
            "action": "change",
            "values": {"level": level, "duration": duration_ms},
        }
    )
````

##### set_waveform

```python
set_waveform(
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
) -> None
```

Apply a waveform effect to the light.

Waveforms create repeating color transitions. Useful for effects like pulsing, breathing, or blinking.

| PARAMETER    | DESCRIPTION                                                                                        |
| ------------ | -------------------------------------------------------------------------------------------------- |
| `color`      | Target color for the waveform **TYPE:** `HSBK`                                                     |
| `period`     | Period of one cycle in seconds **TYPE:** `float`                                                   |
| `cycles`     | Number of cycles **TYPE:** `float`                                                                 |
| `waveform`   | Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE) **TYPE:** `LightWaveform`                    |
| `transient`  | If True, return to original color after effect (default True) **TYPE:** `bool` **DEFAULT:** `True` |
| `skew_ratio` | Waveform skew (0.0-1.0, default 0.5 for symmetric) **TYPE:** `float` **DEFAULT:** `0.5`            |

| RAISES                    | DESCRIPTION                    |
| ------------------------- | ------------------------------ |
| `ValueError`              | If parameters are out of range |
| `LifxDeviceNotFoundError` | If device is not connected     |
| `LifxTimeoutError`        | If device does not respond     |

Example

```python
from lifx.protocol.protocol_types import LightWaveform

# Pulse red 5 times
await light.set_waveform(
    color=HSBK.from_rgb(255, 0, 0),
    period=1.0,
    cycles=5,
    waveform=LightWaveform.SINE,
)

# Breathe white once
await light.set_waveform(
    color=HSBK(0, 0, 1.0, 3500),
    period=2.0,
    cycles=1,
    waveform=LightWaveform.SINE,
    transient=False,
)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_waveform(
    self,
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
) -> None:
    """Apply a waveform effect to the light.

    Waveforms create repeating color transitions. Useful for effects like
    pulsing, breathing, or blinking.

    Args:
        color: Target color for the waveform
        period: Period of one cycle in seconds
        cycles: Number of cycles
        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)
        transient: If True, return to original color after effect (default True)
        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)

    Raises:
        ValueError: If parameters are out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        from lifx.protocol.protocol_types import LightWaveform

        # Pulse red 5 times
        await light.set_waveform(
            color=HSBK.from_rgb(255, 0, 0),
            period=1.0,
            cycles=5,
            waveform=LightWaveform.SINE,
        )

        # Breathe white once
        await light.set_waveform(
            color=HSBK(0, 0, 1.0, 3500),
            period=2.0,
            cycles=1,
            waveform=LightWaveform.SINE,
            transient=False,
        )
        ```
    """
    if period <= 0:
        raise ValueError(f"Period must be positive, got {period}")
    if cycles < 1:
        raise ValueError(f"Cycles must be 1 or higher, got {cycles}")
    if not (0.0 <= skew_ratio <= 1.0):
        raise ValueError(
            f"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}"
        )

    # Convert to protocol values
    protocol_color = color.to_protocol()
    period_ms = int(period * 1000)
    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range

    # Send request
    await self.connection.request(
        packets.Light.SetWaveform(
            transient=bool(transient),
            color=protocol_color,
            period=period_ms,
            cycles=cycles,
            skew_ratio=skew_ratio_i16,
            waveform=waveform,
        ),
    )
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_waveform",
            "action": "change",
            "values": {
                "transient": transient,
                "hue": protocol_color.hue,
                "saturation": protocol_color.saturation,
                "brightness": protocol_color.brightness,
                "kelvin": protocol_color.kelvin,
                "period": period_ms,
                "cycles": cycles,
                "skew_ratio": skew_ratio_i16,
                "waveform": waveform.value,
            },
        }
    )
````

##### set_waveform_optional

```python
set_waveform_optional(
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
    set_hue: bool = True,
    set_saturation: bool = True,
    set_brightness: bool = True,
    set_kelvin: bool = True,
) -> None
```

Apply a waveform effect with selective color component control.

Similar to set_waveform() but allows fine-grained control over which color components (hue, saturation, brightness, kelvin) are affected by the waveform. This enables effects like pulsing brightness while keeping hue constant, or cycling hue while maintaining brightness.

| PARAMETER        | DESCRIPTION                                                                                        |
| ---------------- | -------------------------------------------------------------------------------------------------- |
| `color`          | Target color for the waveform **TYPE:** `HSBK`                                                     |
| `period`         | Period of one cycle in seconds **TYPE:** `float`                                                   |
| `cycles`         | Number of cycles **TYPE:** `float`                                                                 |
| `waveform`       | Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE) **TYPE:** `LightWaveform`                    |
| `transient`      | If True, return to original color after effect (default True) **TYPE:** `bool` **DEFAULT:** `True` |
| `skew_ratio`     | Waveform skew (0.0-1.0, default 0.5 for symmetric) **TYPE:** `float` **DEFAULT:** `0.5`            |
| `set_hue`        | Apply waveform to hue component (default True) **TYPE:** `bool` **DEFAULT:** `True`                |
| `set_saturation` | Apply waveform to saturation component (default True) **TYPE:** `bool` **DEFAULT:** `True`         |
| `set_brightness` | Apply waveform to brightness component (default True) **TYPE:** `bool` **DEFAULT:** `True`         |
| `set_kelvin`     | Apply waveform to kelvin component (default True) **TYPE:** `bool` **DEFAULT:** `True`             |

| RAISES                    | DESCRIPTION                    |
| ------------------------- | ------------------------------ |
| `ValueError`              | If parameters are out of range |
| `LifxDeviceNotFoundError` | If device is not connected     |
| `LifxTimeoutError`        | If device does not respond     |

Example

```python
from lifx.protocol.protocol_types import LightWaveform

# Pulse brightness only, keeping hue/saturation constant
await light.set_waveform_optional(
    color=HSBK(0, 1.0, 1.0, 3500),
    period=1.0,
    cycles=5,
    waveform=LightWaveform.SINE,
    set_hue=False,
    set_saturation=False,
    set_brightness=True,
    set_kelvin=False,
)

# Cycle hue while maintaining brightness
await light.set_waveform_optional(
    color=HSBK(180, 1.0, 1.0, 3500),
    period=5.0,
    cycles=0,  # Infinite
    waveform=LightWaveform.SAW,
    set_hue=True,
    set_saturation=False,
    set_brightness=False,
    set_kelvin=False,
)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_waveform_optional(
    self,
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
    set_hue: bool = True,
    set_saturation: bool = True,
    set_brightness: bool = True,
    set_kelvin: bool = True,
) -> None:
    """Apply a waveform effect with selective color component control.

    Similar to set_waveform() but allows fine-grained control over which
    color components (hue, saturation, brightness, kelvin) are affected
    by the waveform. This enables effects like pulsing brightness while
    keeping hue constant, or cycling hue while maintaining brightness.

    Args:
        color: Target color for the waveform
        period: Period of one cycle in seconds
        cycles: Number of cycles
        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)
        transient: If True, return to original color after effect (default True)
        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)
        set_hue: Apply waveform to hue component (default True)
        set_saturation: Apply waveform to saturation component (default True)
        set_brightness: Apply waveform to brightness component (default True)
        set_kelvin: Apply waveform to kelvin component (default True)

    Raises:
        ValueError: If parameters are out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        from lifx.protocol.protocol_types import LightWaveform

        # Pulse brightness only, keeping hue/saturation constant
        await light.set_waveform_optional(
            color=HSBK(0, 1.0, 1.0, 3500),
            period=1.0,
            cycles=5,
            waveform=LightWaveform.SINE,
            set_hue=False,
            set_saturation=False,
            set_brightness=True,
            set_kelvin=False,
        )

        # Cycle hue while maintaining brightness
        await light.set_waveform_optional(
            color=HSBK(180, 1.0, 1.0, 3500),
            period=5.0,
            cycles=0,  # Infinite
            waveform=LightWaveform.SAW,
            set_hue=True,
            set_saturation=False,
            set_brightness=False,
            set_kelvin=False,
        )
        ```
    """
    if period <= 0:
        raise ValueError(f"Period must be positive, got {period}")
    if cycles < 0:
        raise ValueError(f"Cycles must be non-negative, got {cycles}")
    if not (0.0 <= skew_ratio <= 1.0):
        raise ValueError(
            f"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}"
        )

    # Convert to protocol values
    protocol_color = color.to_protocol()
    period_ms = int(period * 1000)
    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range

    # Send request
    await self.connection.request(
        packets.Light.SetWaveformOptional(
            transient=bool(transient),
            color=protocol_color,
            period=period_ms,
            cycles=cycles,
            skew_ratio=skew_ratio_i16,
            waveform=waveform,
            set_hue=set_hue,
            set_saturation=set_saturation,
            set_brightness=set_brightness,
            set_kelvin=set_kelvin,
        ),
    )
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_waveform_optional",
            "action": "change",
            "values": {
                "transient": transient,
                "hue": protocol_color.hue,
                "saturation": protocol_color.saturation,
                "brightness": protocol_color.brightness,
                "kelvin": protocol_color.kelvin,
                "period": period_ms,
                "cycles": cycles,
                "skew_ratio": skew_ratio_i16,
                "waveform": waveform.value,
                "set_hue": set_hue,
                "set_saturation": set_saturation,
                "set_brightness": set_brightness,
                "set_kelvin": set_kelvin,
            },
        }
    )
````

##### pulse

```python
pulse(
    color: HSBK, period: float = 1.0, cycles: float = 1, transient: bool = True
) -> None
```

Pulse the light to a specific color.

Convenience method for creating a pulse effect using SINE waveform.

| PARAMETER   | DESCRIPTION                                                                                        |
| ----------- | -------------------------------------------------------------------------------------------------- |
| `color`     | Target color to pulse to **TYPE:** `HSBK`                                                          |
| `period`    | Period of one pulse in seconds (default 1.0) **TYPE:** `float` **DEFAULT:** `1.0`                  |
| `cycles`    | Number of pulses (default 1) **TYPE:** `float` **DEFAULT:** `1`                                    |
| `transient` | If True, return to original color after effect (default True) **TYPE:** `bool` **DEFAULT:** `True` |

Example

```python
# Pulse red once
await light.pulse(HSBK.from_rgb(255, 0, 0))

# Pulse blue 3 times, 2 seconds per pulse
await light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)
```

Source code in `src/lifx/devices/light.py`

````python
async def pulse(
    self,
    color: HSBK,
    period: float = 1.0,
    cycles: float = 1,
    transient: bool = True,
) -> None:
    """Pulse the light to a specific color.

    Convenience method for creating a pulse effect using SINE waveform.

    Args:
        color: Target color to pulse to
        period: Period of one pulse in seconds (default 1.0)
        cycles: Number of pulses (default 1)
        transient: If True, return to original color after effect (default True)

    Example:
        ```python
        # Pulse red once
        await light.pulse(HSBK.from_rgb(255, 0, 0))

        # Pulse blue 3 times, 2 seconds per pulse
        await light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)
        ```
    """
    await self.set_waveform(
        color=color,
        period=period,
        cycles=cycles,
        waveform=LightWaveform.PULSE,
        transient=transient,
    )
````

##### breathe

```python
breathe(color: HSBK, period: float = 2.0, cycles: float = 1) -> None
```

Make the light breathe to a specific color.

Convenience method for creating a breathing effect using SINE waveform.

| PARAMETER | DESCRIPTION                                                                        |
| --------- | ---------------------------------------------------------------------------------- |
| `color`   | Target color to breathe to **TYPE:** `HSBK`                                        |
| `period`  | Period of one breath in seconds (default 2.0) **TYPE:** `float` **DEFAULT:** `2.0` |
| `cycles`  | Number of breaths (default 1) **TYPE:** `float` **DEFAULT:** `1`                   |

Example

```python
# Breathe white once
await light.breathe(HSBK(0, 0, 1.0, 3500))

# Breathe purple 10 times
await light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)
```

Source code in `src/lifx/devices/light.py`

````python
async def breathe(
    self,
    color: HSBK,
    period: float = 2.0,
    cycles: float = 1,
) -> None:
    """Make the light breathe to a specific color.

    Convenience method for creating a breathing effect using SINE waveform.

    Args:
        color: Target color to breathe to
        period: Period of one breath in seconds (default 2.0)
        cycles: Number of breaths (default 1)

    Example:
        ```python
        # Breathe white once
        await light.breathe(HSBK(0, 0, 1.0, 3500))

        # Breathe purple 10 times
        await light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)
        ```
    """
    await self.set_waveform(
        color=color,
        period=period,
        cycles=cycles,
        waveform=LightWaveform.SINE,
        transient=True,
    )
````

##### apply_theme

```python
apply_theme(
    theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None
```

Apply a theme to this light.

Selects a random color from the theme and applies it to the light.

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                    |
| `power_on` | Turn on the light **TYPE:** `bool` **DEFAULT:** `False`             |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
from lifx.theme import get_theme

theme = get_theme("evening")
await light.apply_theme(theme, power_on=True, duration=0.5)
```

Source code in `src/lifx/devices/light.py`

````python
async def apply_theme(
    self,
    theme: Theme,
    power_on: bool = False,
    duration: float = 0.0,
) -> None:
    """Apply a theme to this light.

    Selects a random color from the theme and applies it to the light.

    Args:
        theme: Theme to apply
        power_on: Turn on the light
        duration: Transition duration in seconds

    Example:
        ```python
        from lifx.theme import get_theme

        theme = get_theme("evening")
        await light.apply_theme(theme, power_on=True, duration=0.5)
        ```
    """
    if self.capabilities is None:
        await self._ensure_capabilities()

    if self.capabilities and not self.capabilities.has_color:
        return

    # Select a random color from theme
    color = theme.random()

    # Check if light is on
    is_on = await self.get_power()

    # Apply color to light
    # If light is off and we're turning it on, set color immediately then fade on
    if power_on and not is_on:
        await self.set_color(color, duration=0)
        await self.set_power(True, duration=duration)
    else:
        # Light is already on, or we're not turning it on - apply with duration
        await self.set_color(color, duration=duration)
````

## HEV Light

The `HevLight` class extends `Light` with anti-bacterial cleaning cycle control for LIFX HEV devices.

### HevLight

```python
HevLight(*args, **kwargs)
```

Bases: `Light`

LIFX HEV light with anti-bacterial cleaning capabilities.

Extends the Light class with HEV (High Energy Visible) cycle control. HEV uses UV-C light to sanitize surfaces and air with anti-bacterial properties.

Example

```python
light = HevLight(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Start a 2-hour cleaning cycle
    await light.set_hev_cycle(enable=True, duration_seconds=7200)

    # Check cycle status
    state = await light.get_hev_cycle()
    if state.is_running:
        print(f"Cleaning: {state.remaining_s}s remaining")

    # Configure defaults
    await light.set_hev_config(indication=True, duration_seconds=7200)
```

Using the simplified connect method:

```python
async with await HevLight.from_ip(ip="192.168.1.100") as light:
    await light.set_hev_cycle(enable=True, duration_seconds=3600)
```

| METHOD                | DESCRIPTION                                |
| --------------------- | ------------------------------------------ |
| `get_hev_cycle`       | Get current HEV cycle state.               |
| `set_hev_cycle`       | Start or stop a HEV cleaning cycle.        |
| `get_hev_config`      | Get HEV cycle configuration.               |
| `set_hev_config`      | Configure HEV cycle defaults.              |
| `get_last_hev_result` | Get result of the last HEV cleaning cycle. |

| ATTRIBUTE    | DESCRIPTION                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------------- |
| `hev_cycle`  | Get stored HEV cycle state with timestamp if available. **TYPE:** \`tuple[HevCycleState, float]                 |
| `hev_config` | Get stored HEV configuration with timestamp if available. **TYPE:** \`tuple[HevConfig, float]                   |
| `hev_result` | Get stored last HEV cycle result with timestamp if available. **TYPE:** \`tuple[LightLastHevCycleResult, float] |

Source code in `src/lifx/devices/hev.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize HevLight with additional state attributes."""
    super().__init__(*args, **kwargs)
    # HEV-specific state storage
    self._hev_cycle: tuple[HevCycleState, float] | None = None
    self._hev_config: tuple[HevConfig, float] | None = None
    self._hev_result: tuple[LightLastHevCycleResult, float] | None = None
```

#### Attributes

##### hev_cycle

```python
hev_cycle: tuple[HevCycleState, float] | None
```

Get stored HEV cycle state with timestamp if available.

| RETURNS                       | DESCRIPTION |
| ----------------------------- | ----------- |
| \`tuple[HevCycleState, float] | None\`      |
| \`tuple[HevCycleState, float] | None\`      |

##### hev_config

```python
hev_config: tuple[HevConfig, float] | None
```

Get stored HEV configuration with timestamp if available.

| RETURNS                   | DESCRIPTION |
| ------------------------- | ----------- |
| \`tuple[HevConfig, float] | None\`      |
| \`tuple[HevConfig, float] | None\`      |

##### hev_result

```python
hev_result: tuple[LightLastHevCycleResult, float] | None
```

Get stored last HEV cycle result with timestamp if available.

| RETURNS                                 | DESCRIPTION |
| --------------------------------------- | ----------- |
| \`tuple[LightLastHevCycleResult, float] | None\`      |
| \`tuple[LightLastHevCycleResult, float] | None\`      |

#### Functions

##### get_hev_cycle

```python
get_hev_cycle() -> HevCycleState
```

Get current HEV cycle state.

Always fetches from device. Use the `hev_cycle` property to access stored value.

| RETURNS         | DESCRIPTION                                                       |
| --------------- | ----------------------------------------------------------------- |
| `HevCycleState` | HevCycleState with duration, remaining time, and last power state |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
state = await light.get_hev_cycle()
if state.is_running:
    print(f"HEV cleaning in progress: {state.remaining_s}s left")
else:
    print("No active cleaning cycle")
```

Source code in `src/lifx/devices/hev.py`

````python
async def get_hev_cycle(self) -> HevCycleState:
    """Get current HEV cycle state.

    Always fetches from device. Use the `hev_cycle` property to access stored value.

    Returns:
        HevCycleState with duration, remaining time, and last power state

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        state = await light.get_hev_cycle()
        if state.is_running:
            print(f"HEV cleaning in progress: {state.remaining_s}s left")
        else:
            print("No active cleaning cycle")
        ```
    """
    # Request HEV cycle state
    state = await self.connection.request(packets.Light.GetHevCycle())

    # Create state object
    cycle_state = HevCycleState(
        duration_s=state.duration_s,
        remaining_s=state.remaining_s,
        last_power=state.last_power,
    )

    # Store state with timestamp
    import time

    self._hev_cycle = (cycle_state, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_hev_cycle",
            "action": "query",
            "reply": {
                "duration_s": state.duration_s,
                "remaining_s": state.remaining_s,
                "last_power": state.last_power,
            },
        }
    )

    return cycle_state
````

##### set_hev_cycle

```python
set_hev_cycle(enable: bool, duration_seconds: int) -> None
```

Start or stop a HEV cleaning cycle.

| PARAMETER          | DESCRIPTION                                               |
| ------------------ | --------------------------------------------------------- |
| `enable`           | True to start cycle, False to stop **TYPE:** `bool`       |
| `duration_seconds` | Duration of the cleaning cycle in seconds **TYPE:** `int` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If duration is negative    |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Start a 1-hour cleaning cycle
await light.set_hev_cycle(enable=True, duration_seconds=3600)

# Stop the current cycle
await light.set_hev_cycle(enable=False, duration_seconds=0)
```

Source code in `src/lifx/devices/hev.py`

````python
async def set_hev_cycle(self, enable: bool, duration_seconds: int) -> None:
    """Start or stop a HEV cleaning cycle.

    Args:
        enable: True to start cycle, False to stop
        duration_seconds: Duration of the cleaning cycle in seconds

    Raises:
        ValueError: If duration is negative
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Start a 1-hour cleaning cycle
        await light.set_hev_cycle(enable=True, duration_seconds=3600)

        # Stop the current cycle
        await light.set_hev_cycle(enable=False, duration_seconds=0)
        ```
    """
    if duration_seconds < 0:
        raise ValueError(f"Duration must be non-negative, got {duration_seconds}")

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Light.SetHevCycle(
            enable=enable,
            duration_s=duration_seconds,
        ),
    )

    # Invalidate state since it changed
    self._hev_cycle = None
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_hev_cycle",
            "action": "change",
            "values": {"enable": enable, "duration_s": duration_seconds},
        }
    )
````

##### get_hev_config

```python
get_hev_config() -> HevConfig
```

Get HEV cycle configuration.

| RETURNS     | DESCRIPTION                                             |
| ----------- | ------------------------------------------------------- |
| `HevConfig` | HevConfig with indication and default duration settings |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
config = await light.get_hev_config()
print(f"Default duration: {config.duration_s}s")
print(f"Visual indication: {config.indication}")
```

Source code in `src/lifx/devices/hev.py`

````python
async def get_hev_config(self) -> HevConfig:
    """Get HEV cycle configuration.

    Returns:
        HevConfig with indication and default duration settings

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        config = await light.get_hev_config()
        print(f"Default duration: {config.duration_s}s")
        print(f"Visual indication: {config.indication}")
        ```
    """
    # Request HEV configuration
    state = await self.connection.request(packets.Light.GetHevCycleConfiguration())

    # Create config object
    config = HevConfig(
        indication=state.indication,
        duration_s=state.duration_s,
    )

    # Store state with timestamp
    import time

    self._hev_config = (config, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_hev_config",
            "action": "query",
            "reply": {
                "indication": state.indication,
                "duration_s": state.duration_s,
            },
        }
    )

    return config
````

##### set_hev_config

```python
set_hev_config(indication: bool, duration_seconds: int) -> None
```

Configure HEV cycle defaults.

| PARAMETER          | DESCRIPTION                                                        |
| ------------------ | ------------------------------------------------------------------ |
| `indication`       | Whether to show visual indication during cleaning **TYPE:** `bool` |
| `duration_seconds` | Default duration for cleaning cycles in seconds **TYPE:** `int`    |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If duration is negative    |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Configure 2-hour default with visual indication
await light.set_hev_config(indication=True, duration_seconds=7200)
```

Source code in `src/lifx/devices/hev.py`

````python
async def set_hev_config(self, indication: bool, duration_seconds: int) -> None:
    """Configure HEV cycle defaults.

    Args:
        indication: Whether to show visual indication during cleaning
        duration_seconds: Default duration for cleaning cycles in seconds

    Raises:
        ValueError: If duration is negative
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Configure 2-hour default with visual indication
        await light.set_hev_config(indication=True, duration_seconds=7200)
        ```
    """
    if duration_seconds < 0:
        raise ValueError(f"Duration must be non-negative, got {duration_seconds}")

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Light.SetHevCycleConfiguration(
            indication=indication,
            duration_s=duration_seconds,
        ),
    )

    # Update state with timestamp
    import time

    self._hev_config = (
        HevConfig(indication=indication, duration_s=duration_seconds),
        time.time(),
    )
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_hev_config",
            "action": "change",
            "values": {"indication": indication, "duration_s": duration_seconds},
        }
    )
````

##### get_last_hev_result

```python
get_last_hev_result() -> LightLastHevCycleResult
```

Get result of the last HEV cleaning cycle.

| RETURNS                   | DESCRIPTION                                                                  |
| ------------------------- | ---------------------------------------------------------------------------- |
| `LightLastHevCycleResult` | LightLastHevCycleResult enum value indicating success or interruption reason |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
result = await light.get_last_hev_result()
if result == LightLastHevCycleResult.SUCCESS:
    print("Last cleaning cycle completed successfully")
elif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:
    print("Cycle was interrupted by network command")
```

Source code in `src/lifx/devices/hev.py`

````python
async def get_last_hev_result(
    self,
) -> LightLastHevCycleResult:
    """Get result of the last HEV cleaning cycle.

    Returns:
        LightLastHevCycleResult enum value indicating success or interruption reason

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        result = await light.get_last_hev_result()
        if result == LightLastHevCycleResult.SUCCESS:
            print("Last cleaning cycle completed successfully")
        elif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:
            print("Cycle was interrupted by network command")
        ```
    """
    # Request last HEV result
    state = await self.connection.request(packets.Light.GetLastHevCycleResult())

    # Store state with timestamp
    import time

    self._hev_result = (state.result, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_last_hev_result",
            "action": "query",
            "reply": {"result": state.result.value},
        }
    )

    return state.result
````

## Infrared Light

The `InfraredLight` class extends `Light` with infrared LED control for night vision on LIFX A19 + Night Vision devices.

### InfraredLight

```python
InfraredLight(*args, **kwargs)
```

Bases: `Light`

LIFX infrared light with IR LED control.

Extends the Light class with infrared brightness control. Infrared LEDs automatically activate in low-light conditions to provide illumination for night vision cameras.

Example

```python
light = InfraredLight(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Set infrared brightness to 50%
    await light.set_infrared(0.5)

    # Get current infrared brightness
    brightness = await light.get_infrared()
    print(f"IR brightness: {brightness * 100}%")
```

Using the simplified connect method:

```python
async with await InfraredLight.from_ip(ip="192.168.1.100") as light:
    await light.set_infrared(0.8)
```

| METHOD         | DESCRIPTION                      |
| -------------- | -------------------------------- |
| `get_infrared` | Get current infrared brightness. |
| `set_infrared` | Set infrared brightness.         |

| ATTRIBUTE  | DESCRIPTION                                                                                 |
| ---------- | ------------------------------------------------------------------------------------------- |
| `infrared` | Get stored infrared brightness with timestamp if available. **TYPE:** \`tuple[float, float] |

Source code in `src/lifx/devices/infrared.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize InfraredLight with additional state attributes."""
    super().__init__(*args, **kwargs)
    # Infrared-specific state storage
    self._infrared: tuple[float, float] | None = None
```

#### Attributes

##### infrared

```python
infrared: tuple[float, float] | None
```

Get stored infrared brightness with timestamp if available.

| RETURNS               | DESCRIPTION |
| --------------------- | ----------- |
| \`tuple[float, float] | None\`      |
| \`tuple[float, float] | None\`      |

#### Functions

##### get_infrared

```python
get_infrared() -> float
```

Get current infrared brightness.

| RETURNS | DESCRIPTION                   |
| ------- | ----------------------------- |
| `float` | Infrared brightness (0.0-1.0) |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
brightness = await light.get_infrared()
if brightness > 0:
    print(f"IR LEDs active at {brightness * 100}%")
```

Source code in `src/lifx/devices/infrared.py`

````python
async def get_infrared(self) -> float:
    """Get current infrared brightness.

    Returns:
        Infrared brightness (0.0-1.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        brightness = await light.get_infrared()
        if brightness > 0:
            print(f"IR LEDs active at {brightness * 100}%")
        ```
    """
    # Request infrared state
    state = await self.connection.request(packets.Light.GetInfrared())

    # Convert from uint16 (0-65535) to float (0.0-1.0)
    brightness = state.brightness / 65535.0

    # Store state with timestamp
    import time

    self._infrared = (brightness, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_infrared",
            "action": "query",
            "reply": {"brightness": state.brightness},
        }
    )

    return brightness
````

##### set_infrared

```python
set_infrared(brightness: float) -> None
```

Set infrared brightness.

| PARAMETER    | DESCRIPTION                                     |
| ------------ | ----------------------------------------------- |
| `brightness` | Infrared brightness (0.0-1.0) **TYPE:** `float` |

| RAISES                    | DESCRIPTION                   |
| ------------------------- | ----------------------------- |
| `ValueError`              | If brightness is out of range |
| `LifxDeviceNotFoundError` | If device is not connected    |
| `LifxTimeoutError`        | If device does not respond    |

Example

```python
# Set to 75% infrared brightness
await light.set_infrared(0.75)

# Turn off infrared
await light.set_infrared(0.0)
```

Source code in `src/lifx/devices/infrared.py`

````python
async def set_infrared(self, brightness: float) -> None:
    """Set infrared brightness.

    Args:
        brightness: Infrared brightness (0.0-1.0)

    Raises:
        ValueError: If brightness is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to 75% infrared brightness
        await light.set_infrared(0.75)

        # Turn off infrared
        await light.set_infrared(0.0)
        ```
    """
    if not (0.0 <= brightness <= 1.0):
        raise ValueError(
            f"Brightness must be between 0.0 and 1.0, got {brightness}"
        )

    # Convert from float (0.0-1.0) to uint16 (0-65535)
    brightness_u16 = max(0, min(65535, int(round(brightness * 65535))))

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Light.SetInfrared(brightness=brightness_u16),
    )

    # Update state with timestamp
    import time

    self._infrared = (brightness, time.time())
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_infrared",
            "action": "change",
            "values": {"brightness": brightness_u16},
        }
    )
````

## MultiZone Light

The `MultiZoneLight` class controls LIFX strips and beams with multiple color zones.

### MultiZoneLight

```python
MultiZoneLight(*args, **kwargs)
```

Bases: `Light`

LIFX MultiZone light device (strips, beams).

Extends the Light class with zone-specific functionality:

- Individual zone color control
- Multi-zone effects (move, etc.)
- Extended color zone support for efficient bulk updates

Example

```python
light = MultiZoneLight(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Get number of zones
    zone_count = await light.get_zone_count()
    print(f"Device has {zone_count} zones")

    # Set all zones to red
    await light.set_color_zones(
        start=0, end=zone_count - 1, color=HSBK.from_rgb(255, 0, 0)
    )

    # Get colors for first 5 zones
    colors = await light.get_color_zones(0, 4)

    # Apply a moving effect
    await light.set_move_effect(speed=5.0, direction="forward")
```

Using the simplified connect method:

```python
async with await MultiZoneLight.from_ip(ip="192.168.1.100") as light:
    await light.set_move_effect(speed=5.0, direction="forward")
```

| METHOD                     | DESCRIPTION                                                          |
| -------------------------- | -------------------------------------------------------------------- |
| `get_zone_count`           | Get the number of zones in the device.                               |
| `get_color_zones`          | Get colors for a range of zones using GetColorZones.                 |
| `get_extended_color_zones` | Get colors for a range of zones using GetExtendedColorZones.         |
| `set_color_zones`          | Set color for a range of zones.                                      |
| `set_extended_color_zones` | Set colors for multiple zones efficiently (up to 82 zones per call). |
| `get_multizone_effect`     | Get current multizone effect.                                        |
| `set_multizone_effect`     | Set multizone effect.                                                |
| `stop_effect`              | Stop any running multizone effect.                                   |
| `set_move_effect`          | Apply a moving effect that shifts colors along the strip.            |
| `apply_theme`              | Apply a theme across zones.                                          |

| ATTRIBUTE          | DESCRIPTION                                                                                 |
| ------------------ | ------------------------------------------------------------------------------------------- |
| `zone_count`       | Get stored zone count with timestamp if available. **TYPE:** \`tuple[int, float]            |
| `multizone_effect` | Get stored multizone effect with timestamp if available. **TYPE:** \`tuple\[MultiZoneEffect |
| `zones`            | Get stored zone colors with timestamp if available. **TYPE:** \`tuple\[list[HSBK], float\]  |

Source code in `src/lifx/devices/multizone.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize MultiZoneLight with additional state attributes."""
    super().__init__(*args, **kwargs)
    # MultiZone-specific state storage
    self._zone_count: tuple[int, float] | None = None
    self._multizone_effect: tuple[MultiZoneEffect | None, float] | None = None
    # Zone colors - list of all zone colors with single timestamp
    # Updated whenever any zone query is performed
    self._zones: tuple[list[HSBK], float] | None = None
```

#### Attributes

##### zone_count

```python
zone_count: tuple[int, float] | None
```

Get stored zone count with timestamp if available.

| RETURNS             | DESCRIPTION |
| ------------------- | ----------- |
| \`tuple[int, float] | None\`      |
| \`tuple[int, float] | None\`      |

##### multizone_effect

```python
multizone_effect: tuple[MultiZoneEffect | None, float] | None
```

Get stored multizone effect with timestamp if available.

| RETURNS                  | DESCRIPTION   |
| ------------------------ | ------------- |
| \`tuple\[MultiZoneEffect | None, float\] |
| \`tuple\[MultiZoneEffect | None, float\] |

##### zones

```python
zones: tuple[list[HSBK], float] | None
```

Get stored zone colors with timestamp if available.

| RETURNS                      | DESCRIPTION |
| ---------------------------- | ----------- |
| \`tuple\[list[HSBK], float\] | None\`      |
| \`tuple\[list[HSBK], float\] | None\`      |

#### Functions

##### get_zone_count

```python
get_zone_count() -> int
```

Get the number of zones in the device.

Always fetches from device. Use the `zone_count` property to access stored value.

| RETURNS | DESCRIPTION     |
| ------- | --------------- |
| `int`   | Number of zones |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
zone_count = await light.get_zone_count()
print(f"Device has {zone_count} zones")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_zone_count(self) -> int:
    """Get the number of zones in the device.

    Always fetches from device.
    Use the `zone_count` property to access stored value.

    Returns:
        Number of zones

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        zone_count = await light.get_zone_count()
        print(f"Device has {zone_count} zones")
        ```
    """
    # Request automatically unpacks response
    if self.capabilities and self.capabilities.has_extended_multizone:
        state = await self.connection.request(
            packets.MultiZone.GetExtendedColorZones()
        )
    else:
        state = await self.connection.request(
            packets.MultiZone.GetColorZones(start_index=0, end_index=0)
        )

    count = state.count

    import time

    self._zone_count = (count, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_zone_count",
            "action": "query",
            "reply": {
                "count": state.count,
            },
        }
    )

    return count
````

##### get_color_zones

```python
get_color_zones(start: int, end: int) -> list[HSBK]
```

Get colors for a range of zones using GetColorZones.

Always fetches from device. Use `zones` property to access stored values.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `start`   | Start zone index (inclusive) **TYPE:** `int` |
| `end`     | End zone index (inclusive) **TYPE:** `int`   |

| RETURNS      | DESCRIPTION                       |
| ------------ | --------------------------------- |
| `list[HSBK]` | List of HSBK colors, one per zone |

| RAISES                    | DESCRIPTION                 |
| ------------------------- | --------------------------- |
| `ValueError`              | If zone indices are invalid |
| `LifxDeviceNotFoundError` | If device is not connected  |
| `LifxTimeoutError`        | If device does not respond  |
| `LifxProtocolError`       | If response is invalid      |

Example

```python
# Get colors for first 10 zones
colors = await light.get_color_zones(0, 9)
for i, color in enumerate(colors):
    print(f"Zone {i}: {color}")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_color_zones(
    self,
    start: int,
    end: int,
) -> list[HSBK]:
    """Get colors for a range of zones using GetColorZones.

    Always fetches from device.
    Use `zones` property to access stored values.

    Args:
        start: Start zone index (inclusive)
        end: End zone index (inclusive)

    Returns:
        List of HSBK colors, one per zone

    Raises:
        ValueError: If zone indices are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        # Get colors for first 10 zones
        colors = await light.get_color_zones(0, 9)
        for i, color in enumerate(colors):
            print(f"Zone {i}: {color}")
        ```
    """
    if start < 0 or end < start:
        raise ValueError(f"Invalid zone range: {start}-{end}")

    # Ensure capabilities are loaded
    if self.capabilities is None:
        await self._ensure_capabilities()

    zone_count = await self.get_zone_count()
    end = min(zone_count - 1, end)

    colors = []
    current_start = start

    while current_start <= end:
        current_end = min(current_start + 7, end)  # Max 8 zones per request
        state = await self.connection.request(
            packets.MultiZone.GetColorZones(
                start_index=current_start, end_index=current_end
            )
        )

        # Extract colors from response (up to 8 colors)
        zones_in_response = min(8, current_end - current_start + 1)
        for i in range(zones_in_response):
            if i >= len(state.colors):
                break
            protocol_hsbk = state.colors[i]
            colors.append(HSBK.from_protocol(protocol_hsbk))

        current_start += 8

    result = colors

    # Update zone storage with fetched colors
    import time

    timestamp = time.time()

    # Initialize or get existing zones array
    if self._zones is None:
        zones_array = [HSBK(0, 0, 0, 3500)] * zone_count
    else:
        zones_array, _ = self._zones
        # Ensure array is the right size
        if len(zones_array) != zone_count:
            zones_array = [HSBK(0, 0, 0, 3500)] * zone_count

    # Update the fetched range
    for i, color in enumerate(result):
        zones_array[start + i] = color

    # Store updated zones with new timestamp
    self._zones = (zones_array, timestamp)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_color_zones",
            "action": "query",
            "reply": {
                "start": start,
                "end": end,
                "zone_count": len(result),
                "colors": [
                    {
                        "hue": c.hue,
                        "saturation": c.saturation,
                        "brightness": c.brightness,
                        "kelvin": c.kelvin,
                    }
                    for c in result
                ],
            },
        }
    )

    return result
````

##### get_extended_color_zones

```python
get_extended_color_zones(start: int, end: int) -> list[HSBK]
```

Get colors for a range of zones using GetExtendedColorZones.

Always fetches from device. Use `zones` property to access stored values.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `start`   | Start zone index (inclusive) **TYPE:** `int` |
| `end`     | End zone index (inclusive) **TYPE:** `int`   |

| RETURNS      | DESCRIPTION                       |
| ------------ | --------------------------------- |
| `list[HSBK]` | List of HSBK colors, one per zone |

| RAISES                    | DESCRIPTION                 |
| ------------------------- | --------------------------- |
| `ValueError`              | If zone indices are invalid |
| `LifxDeviceNotFoundError` | If device is not connected  |
| `LifxTimeoutError`        | If device does not respond  |
| `LifxProtocolError`       | If response is invalid      |

Example

```python
# Get colors for first 10 zones
colors = await light.get_color_zones(0, 9)
for i, color in enumerate(colors):
    print(f"Zone {i}: {color}")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_extended_color_zones(self, start: int, end: int) -> list[HSBK]:
    """Get colors for a range of zones using GetExtendedColorZones.

    Always fetches from device.
    Use `zones` property to access stored values.

    Args:
        start: Start zone index (inclusive)
        end: End zone index (inclusive)

    Returns:
        List of HSBK colors, one per zone

    Raises:
        ValueError: If zone indices are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        # Get colors for first 10 zones
        colors = await light.get_color_zones(0, 9)
        for i, color in enumerate(colors):
            print(f"Zone {i}: {color}")
        ```
    """
    if start < 0 or end < start:
        raise ValueError(f"Invalid zone range: {start}-{end}")

    # Ensure capabilities are loaded
    if self.capabilities is None:
        await self._ensure_capabilities()

    zone_count = await self.get_zone_count()
    end = min(zone_count - 1, end)

    if self.capabilities and not self.capabilities.has_extended_multizone:
        return await self.get_color_zones(start=start, end=end)

    colors = []

    state = await self.connection.request(
        packets.MultiZone.GetExtendedColorZones(),
        collect_multiple=bool(zone_count > 82),
    )

    # Handle both single packet and list of packets (when collect_multiple=True)
    packets_list = state if isinstance(state, list) else [state]

    for packet in packets_list:
        # Only process valid colors based on colors_count
        for i in range(packet.colors_count):
            if i >= len(packet.colors):
                break
            protocol_hsbk = packet.colors[i]
            colors.append(HSBK.from_protocol(protocol_hsbk))

    # Update _zones attribute
    import time

    timestamp = time.time()

    # Store all zones directly - device sent complete state
    self._zones = (colors, timestamp)

    # Return only the requested range to caller
    result = colors[start : end + 1]

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_extended_color_zones",
            "action": "query",
            "reply": {
                "total_zones": len(colors),
                "requested_start": start,
                "requested_end": end,
                "returned_count": len(result),
            },
        }
    )

    return result
````

##### set_color_zones

```python
set_color_zones(
    start: int,
    end: int,
    color: HSBK,
    duration: float = 0.0,
    apply: MultiZoneApplicationRequest = APPLY,
) -> None
```

Set color for a range of zones.

| PARAMETER  | DESCRIPTION                                                                                                                                                                                                                                  |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `start`    | Start zone index (inclusive) **TYPE:** `int`                                                                                                                                                                                                 |
| `end`      | End zone index (inclusive) **TYPE:** `int`                                                                                                                                                                                                   |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                                                                                                                                                                           |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                                                                                                            |
| `apply`    | Application mode (default APPLY) - NO_APPLY: Don't apply immediately (use for batching) - APPLY: Apply this change and any pending changes - APPLY_ONLY: Apply only this change **TYPE:** `MultiZoneApplicationRequest` **DEFAULT:** `APPLY` |

| RAISES                    | DESCRIPTION                 |
| ------------------------- | --------------------------- |
| `ValueError`              | If zone indices are invalid |
| `LifxDeviceNotFoundError` | If device is not connected  |
| `LifxTimeoutError`        | If device does not respond  |

Example

```python
# Set zones 0-9 to red
await light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))

# Set with transition
await light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)

# Batch updates
await light.set_color_zones(
    0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY
)
await light.set_color_zones(
    5, 9, color2, apply=MultiZoneApplicationRequest.APPLY
)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_color_zones(
    self,
    start: int,
    end: int,
    color: HSBK,
    duration: float = 0.0,
    apply: MultiZoneApplicationRequest = MultiZoneApplicationRequest.APPLY,
) -> None:
    """Set color for a range of zones.

    Args:
        start: Start zone index (inclusive)
        end: End zone index (inclusive)
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)
        apply: Application mode (default APPLY)
               - NO_APPLY: Don't apply immediately (use for batching)
               - APPLY: Apply this change and any pending changes
               - APPLY_ONLY: Apply only this change

    Raises:
        ValueError: If zone indices are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set zones 0-9 to red
        await light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))

        # Set with transition
        await light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)

        # Batch updates
        await light.set_color_zones(
            0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY
        )
        await light.set_color_zones(
            5, 9, color2, apply=MultiZoneApplicationRequest.APPLY
        )
        ```
    """
    if start < 0 or end < start:
        raise ValueError(
            f"Invalid zone range: {start}-{end}"
        )  # Convert to protocol HSBK
    protocol_color = color.to_protocol()

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Send request
    await self.connection.request(
        packets.MultiZone.SetColorZones(
            start_index=start,
            end_index=end,
            color=protocol_color,
            duration=duration_ms,
            apply=apply,
        ),
    )

    # Update _zones attribute with the values we just set
    import time

    timestamp = time.time()

    # Initialize or get existing zones array
    if self._zones is None:
        # Need zone_count to initialize array
        if self._zone_count is None:
            zone_count = await self.get_zone_count()
        else:
            zone_count, _ = self._zone_count
        zones_array = [HSBK(0, 0, 0, 3500)] * zone_count
    else:
        zones_array, _ = self._zones

    # Update the zones we just set
    for i in range(start, min(end + 1, len(zones_array))):
        zones_array[i] = color

    # Store updated zones with new timestamp
    self._zones = (zones_array, timestamp)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_color_zones",
            "action": "change",
            "values": {
                "start": start,
                "end": end,
                "color": {
                    "hue": color.hue,
                    "saturation": color.saturation,
                    "brightness": color.brightness,
                    "kelvin": color.kelvin,
                },
                "duration": duration_ms,
                "apply": apply.name,
            },
        }
    )
````

##### set_extended_color_zones

```python
set_extended_color_zones(
    zone_index: int,
    colors: list[HSBK],
    duration: float = 0.0,
    apply: MultiZoneExtendedApplicationRequest = APPLY,
) -> None
```

Set colors for multiple zones efficiently (up to 82 zones per call).

This is more efficient than set_color_zones when setting different colors for many zones at once.

| PARAMETER    | DESCRIPTION                                                                                           |
| ------------ | ----------------------------------------------------------------------------------------------------- |
| `zone_index` | Starting zone index **TYPE:** `int`                                                                   |
| `colors`     | List of HSBK colors to set (max 82) **TYPE:** `list[HSBK]`                                            |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                     |
| `apply`      | Application mode (default APPLY) **TYPE:** `MultiZoneExtendedApplicationRequest` **DEFAULT:** `APPLY` |

| RAISES                    | DESCRIPTION                                         |
| ------------------------- | --------------------------------------------------- |
| `ValueError`              | If colors list is too long or zone index is invalid |
| `LifxDeviceNotFoundError` | If device is not connected                          |
| `LifxTimeoutError`        | If device does not respond                          |

Example

```python
# Create a rainbow effect across zones
colors = [
    HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)
    for i in range(10)
]
await light.set_extended_color_zones(0, colors)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_extended_color_zones(
    self,
    zone_index: int,
    colors: list[HSBK],
    duration: float = 0.0,
    apply: ExtendedAppReq = ExtendedAppReq.APPLY,
) -> None:
    """Set colors for multiple zones efficiently (up to 82 zones per call).

    This is more efficient than set_color_zones when setting different colors
    for many zones at once.

    Args:
        zone_index: Starting zone index
        colors: List of HSBK colors to set (max 82)
        duration: Transition duration in seconds (default 0.0)
        apply: Application mode (default APPLY)

    Raises:
        ValueError: If colors list is too long or zone index is invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Create a rainbow effect across zones
        colors = [
            HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)
            for i in range(10)
        ]
        await light.set_extended_color_zones(0, colors)
        ```
    """
    if zone_index < 0:
        raise ValueError(f"Invalid zone index: {zone_index}")
    if len(colors) > 82:
        raise ValueError(f"Too many colors: {len(colors)} (max 82 per request)")
    if len(colors) == 0:
        raise ValueError("Colors list cannot be empty")  # Convert to protocol HSBK
    protocol_colors = [color.to_protocol() for color in colors]

    # Pad to 82 colors if needed
    while len(protocol_colors) < 82:
        protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Send request
    await self.connection.request(
        packets.MultiZone.SetExtendedColorZones(
            duration=duration_ms,
            apply=apply,
            index=zone_index,
            colors_count=len(colors),
            colors=protocol_colors,
        ),
    )

    # Update _zones attribute with the values we just set
    import time

    timestamp = time.time()

    # Initialize or get existing zones array
    if self._zones is None:
        # Need zone_count to initialize array
        if self._zone_count is None:
            zone_count = await self.get_zone_count()
        else:
            zone_count, _ = self._zone_count
        zones_array = [HSBK(0, 0, 0, 3500)] * zone_count
    else:
        zones_array, _ = self._zones

    # Update the zones we just set
    for i, color in enumerate(colors):
        zone_idx = zone_index + i
        if zone_idx < len(zones_array):
            zones_array[zone_idx] = color

    # Store updated zones with new timestamp
    self._zones = (zones_array, timestamp)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_extended_color_zones",
            "action": "change",
            "values": {
                "zone_index": zone_index,
                "colors_count": len(colors),
                "colors": [
                    {
                        "hue": c.hue,
                        "saturation": c.saturation,
                        "brightness": c.brightness,
                        "kelvin": c.kelvin,
                    }
                    for c in colors
                ],
                "duration": duration_ms,
                "apply": apply.name,
            },
        }
    )
````

##### get_multizone_effect

```python
get_multizone_effect() -> MultiZoneEffect | None
```

Get current multizone effect.

Always fetches from device. Use the `multizone_effect` property to access stored value.

| RETURNS           | DESCRIPTION |
| ----------------- | ----------- |
| \`MultiZoneEffect | None\`      |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
effect = await light.get_multizone_effect()
if effect:
    print(f"Effect: {effect.effect_type}, Speed: {effect.speed}ms")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_multizone_effect(self) -> MultiZoneEffect | None:
    """Get current multizone effect.

    Always fetches from device.
    Use the `multizone_effect` property to access stored value.

    Returns:
        MultiZoneEffect if an effect is active, None if no effect

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        effect = await light.get_multizone_effect()
        if effect:
            print(f"Effect: {effect.effect_type}, Speed: {effect.speed}ms")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.MultiZone.GetEffect())

    settings = state.settings
    effect_type = settings.effect_type

    # Extract parameters from the settings parameter field
    parameters = [
        settings.parameter.parameter0,
        settings.parameter.parameter1,
        settings.parameter.parameter2,
        settings.parameter.parameter3,
        settings.parameter.parameter4,
        settings.parameter.parameter5,
        settings.parameter.parameter6,
        settings.parameter.parameter7,
    ]

    if effect_type == MultiZoneEffectType.OFF:
        result = None
    else:
        result = MultiZoneEffect(
            effect_type=effect_type,
            speed=settings.speed,
            duration=settings.duration,
            parameters=parameters,
        )

    import time

    self._multizone_effect = (result, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_multizone_effect",
            "action": "query",
            "reply": {
                "effect_type": effect_type.name,
                "speed": settings.speed,
                "duration": settings.duration,
                "parameters": parameters,
            },
        }
    )

    return result
````

##### set_multizone_effect

```python
set_multizone_effect(effect: MultiZoneEffect) -> None
```

Set multizone effect.

| PARAMETER | DESCRIPTION                                                |
| --------- | ---------------------------------------------------------- |
| `effect`  | MultiZone effect configuration **TYPE:** `MultiZoneEffect` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Apply a move effect
effect = MultiZoneEffect(
    effect_type=MultiZoneEffectType.MOVE,
    speed=5000,  # 5 seconds per cycle
    duration=0,  # Infinite
)
await light.set_multizone_effect(effect)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_multizone_effect(
    self,
    effect: MultiZoneEffect,
) -> None:
    """Set multizone effect.

    Args:
        effect: MultiZone effect configuration

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Apply a move effect
        effect = MultiZoneEffect(
            effect_type=MultiZoneEffectType.MOVE,
            speed=5000,  # 5 seconds per cycle
            duration=0,  # Infinite
        )
        await light.set_multizone_effect(effect)
        ```
    """  # Ensure parameters list is 8 elements
    parameters = effect.parameters or [0] * 8
    if len(parameters) < 8:
        parameters.extend([0] * (8 - len(parameters)))
    parameters = parameters[:8]

    # Send request
    await self.connection.request(
        packets.MultiZone.SetEffect(
            settings=MultiZoneEffectSettings(
                instanceid=0,  # 0 for new effect
                effect_type=effect.effect_type,
                speed=effect.speed,
                duration=effect.duration,
                parameter=MultiZoneEffectParameter(
                    parameter0=parameters[0],
                    parameter1=parameters[1],
                    parameter2=parameters[2],
                    parameter3=parameters[3],
                    parameter4=parameters[4],
                    parameter5=parameters[5],
                    parameter6=parameters[6],
                    parameter7=parameters[7],
                ),
            ),
        ),
    )

    # Update state attribute
    import time

    result = effect if effect.effect_type != MultiZoneEffectType.OFF else None
    self._multizone_effect = (result, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_multizone_effect",
            "action": "change",
            "values": {
                "effect_type": effect.effect_type.name,
                "speed": effect.speed,
                "duration": effect.duration,
                "parameters": parameters,
            },
        }
    )
````

##### stop_effect

```python
stop_effect() -> None
```

Stop any running multizone effect.

Example

```python
await light.stop_effect()
```

Source code in `src/lifx/devices/multizone.py`

````python
async def stop_effect(self) -> None:
    """Stop any running multizone effect.

    Example:
        ```python
        await light.stop_effect()
        ```
    """
    await self.set_multizone_effect(
        MultiZoneEffect(
            effect_type=MultiZoneEffectType.OFF,
            speed=0,
            duration=0,
        )
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "stop_effect",
            "action": "change",
            "values": {},
        }
    )
````

##### set_move_effect

```python
set_move_effect(
    speed: float = 5.0, direction: str = "forward", duration: float = 0.0
) -> None
```

Apply a moving effect that shifts colors along the strip.

| PARAMETER   | DESCRIPTION                                                                                  |
| ----------- | -------------------------------------------------------------------------------------------- |
| `speed`     | Speed in seconds per complete cycle (default 5.0) **TYPE:** `float` **DEFAULT:** `5.0`       |
| `direction` | "forward" or "backward" (default "forward") **TYPE:** `str` **DEFAULT:** `'forward'`         |
| `duration`  | Total duration in seconds (0 for infinite, default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES       | DESCRIPTION                                      |
| ------------ | ------------------------------------------------ |
| `ValueError` | If direction is invalid or speed is non-positive |

Example

```python
# Move forward at moderate speed
await light.set_move_effect(speed=5.0, direction="forward")

# Move backward slowly for 60 seconds
await light.set_move_effect(speed=10.0, direction="backward", duration=60.0)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_move_effect(
    self,
    speed: float = 5.0,
    direction: str = "forward",
    duration: float = 0.0,
) -> None:
    """Apply a moving effect that shifts colors along the strip.

    Args:
        speed: Speed in seconds per complete cycle (default 5.0)
        direction: "forward" or "backward" (default "forward")
        duration: Total duration in seconds (0 for infinite, default 0.0)

    Raises:
        ValueError: If direction is invalid or speed is non-positive

    Example:
        ```python
        # Move forward at moderate speed
        await light.set_move_effect(speed=5.0, direction="forward")

        # Move backward slowly for 60 seconds
        await light.set_move_effect(speed=10.0, direction="backward", duration=60.0)
        ```
    """
    if speed <= 0:
        raise ValueError(f"Speed must be positive, got {speed}")
    if direction not in ("forward", "backward"):
        raise ValueError(
            f"Direction must be 'forward' or 'backward', got {direction}"
        )

    # Convert speed to milliseconds
    speed_ms = int(speed * 1000)

    # Convert duration to nanoseconds
    duration_ns = int(duration * 1_000_000_000)

    # Set parameter[0] to 1 for backward, 0 for forward
    parameters = [1 if direction == "backward" else 0] + [0] * 7

    await self.set_multizone_effect(
        MultiZoneEffect(
            effect_type=MultiZoneEffectType.MOVE,
            speed=speed_ms,
            duration=duration_ns,
            parameters=parameters,
        )
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_move_effect",
            "action": "change",
            "values": {
                "speed": speed,
                "direction": direction,
                "duration": duration,
            },
        }
    )
````

##### apply_theme

```python
apply_theme(
    theme: Theme,
    power_on: bool = False,
    duration: float = 0,
    strategy: str | None = None,
) -> None
```

Apply a theme across zones.

Distributes theme colors evenly across the light's zones with smooth color blending between theme colors.

| PARAMETER  | DESCRIPTION                                                            |
| ---------- | ---------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                       |
| `power_on` | Turn on the light **TYPE:** `bool` **DEFAULT:** `False`                |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0`      |
| `strategy` | Color distribution strategy (not used yet, for future) **TYPE:** \`str |

Example

```python
from lifx.theme import get_theme

theme = get_theme("evening")
await strip.apply_theme(theme, power_on=True, duration=0.5)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def apply_theme(
    self,
    theme: Theme,
    power_on: bool = False,
    duration: float = 0,
    strategy: str | None = None,
) -> None:
    """Apply a theme across zones.

    Distributes theme colors evenly across the light's zones with smooth
    color blending between theme colors.

    Args:
        theme: Theme to apply
        power_on: Turn on the light
        duration: Transition duration in seconds
        strategy: Color distribution strategy (not used yet, for future)

    Example:
        ```python
        from lifx.theme import get_theme

        theme = get_theme("evening")
        await strip.apply_theme(theme, power_on=True, duration=0.5)
        ```
    """
    from lifx.theme.generators import MultiZoneGenerator

    # Get number of zones
    zone_count = await self.get_zone_count()

    # Use proper multizone generator with blending
    generator = MultiZoneGenerator()
    colors = generator.get_theme_colors(theme, zone_count)

    # Check if light is on
    is_on = await self.get_power()

    # Apply colors to zones using extended format for efficiency
    # If light is off and we're turning it on, set colors immediately then fade on
    if power_on and not is_on:
        await self.set_extended_color_zones(0, colors, duration=0)
        await self.set_power(True, duration=duration)
    else:
        # Light is already on, or we're not turning it on - apply with duration
        await self.set_extended_color_zones(0, colors, duration=duration)
````

## Tile Device

The `TileDevice` class controls LIFX tile grids with 2D zone control.

### TileDevice

```python
TileDevice(*args, **kwargs)
```

Bases: `Light`

LIFX Tile device with grid control.

Extends the Light class with tile-specific functionality:

- Tile chain discovery and information
- Individual tile grid color control
- Tile effects (morph, flame, sky)

Example

```python
tile = TileDevice(serial="d073d5123456", ip="192.168.1.100")

async with tile:
    # Get tile chain information
    chain = await tile.get_tile_chain()
    print(f"Device has {len(chain)} tiles")

    # Get colors from first tile
    colors = await tile.get_tile_colors(tile_index=0)

    # Set entire first tile to red
    red = HSBK.from_rgb(255, 0, 0)
    await tile.set_tile_colors(
        tile_index=0, colors=[[red] * 8 for _ in range(8)]
    )

    # Apply a flame effect
    await tile.set_flame_effect(speed=5.0)
```

Using the simplified connect method:

```python
async with await TileDevice.from_ip(ip="192.168.1.100") as light:
    await tile.set_flame_effect(speed=5.0)
```

| METHOD              | DESCRIPTION                                                    |
| ------------------- | -------------------------------------------------------------- |
| `get_tile_chain`    | Get information about all tiles in the chain.                  |
| `get_tile_count`    | Get the number of tiles in the chain.                          |
| `get_tile_colors`   | Get colors from a tile.                                        |
| `set_tile_colors`   | Set colors on a tile.                                          |
| `get_tile_effect`   | Get current tile effect.                                       |
| `set_tile_effect`   | Set tile effect.                                               |
| `stop_effect`       | Stop any running tile effect.                                  |
| `copy_frame_buffer` | Copy a rectangular region from one frame buffer to another.    |
| `set_morph_effect`  | Apply a morph effect that transitions through a color palette. |
| `set_flame_effect`  | Apply a flame effect.                                          |
| `apply_theme`       | Apply a theme to this tile device.                             |

| ATTRIBUTE     | DESCRIPTION                                                                                           |
| ------------- | ----------------------------------------------------------------------------------------------------- |
| `tile_chain`  | Get stored tile chain if available. **TYPE:** \`tuple\[list[TileInfo], float\]                        |
| `tile_count`  | Get stored tile count with timestamp if available. **TYPE:** \`tuple[int, float]                      |
| `tile_effect` | Get stored tile effect if available. **TYPE:** \`tuple\[TileEffect                                    |
| `tile_colors` | Get stored tile colors with timestamp if available. **TYPE:** \`tuple\[dict[int, TileColors], float\] |

Source code in `src/lifx/devices/tile.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize TileDevice with additional state attributes."""
    super().__init__(*args, **kwargs)
    # Tile-specific state storage
    self._tile_chain: tuple[list[TileInfo], float] | None = None
    self._tile_effect: tuple[TileEffect | None, float] | None = None
    # Tile colors: dict indexed by tile_index with TileColors for each tile
    # Structure: dict[tile_index] -> TileColors(colors, width, height)
    self._tile_colors: tuple[dict[int, TileColors], float] | None = None
```

#### Attributes

##### tile_chain

```python
tile_chain: tuple[list[TileInfo], float] | None
```

Get stored tile chain if available.

| RETURNS                          | DESCRIPTION |
| -------------------------------- | ----------- |
| \`tuple\[list[TileInfo], float\] | None\`      |

##### tile_count

```python
tile_count: tuple[int, float] | None
```

Get stored tile count with timestamp if available.

| RETURNS             | DESCRIPTION |
| ------------------- | ----------- |
| \`tuple[int, float] | None\`      |
| \`tuple[int, float] | None\`      |

##### tile_effect

```python
tile_effect: tuple[TileEffect | None, float] | None
```

Get stored tile effect if available.

| RETURNS             | DESCRIPTION   |
| ------------------- | ------------- |
| \`tuple\[TileEffect | None, float\] |

##### tile_colors

```python
tile_colors: tuple[dict[int, TileColors], float] | None
```

Get stored tile colors with timestamp if available.

| RETURNS                                 | DESCRIPTION |
| --------------------------------------- | ----------- |
| \`tuple\[dict[int, TileColors], float\] | None\`      |
| \`tuple\[dict[int, TileColors], float\] | None\`      |
| \`tuple\[dict[int, TileColors], float\] | None\`      |
| \`tuple\[dict[int, TileColors], float\] | None\`      |

Example

```python
if tile.tile_colors:
    colors_dict, timestamp = tile.tile_colors
    tile_0 = colors_dict[0]
    # Access flat list: tile_0.colors
    # Get dimensions: tile_0.width, tile_0.height
    # Get 2D array: tile_0.to_2d()
    # Get specific color: tile_0.get_color(x, y)
```

#### Functions

##### get_tile_chain

```python
get_tile_chain() -> list[TileInfo]
```

Get information about all tiles in the chain.

Always fetches from device. Use the `tile_chain` property to access stored value.

| RETURNS          | DESCRIPTION                            |
| ---------------- | -------------------------------------- |
| `list[TileInfo]` | List of TileInfo objects, one per tile |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
chain = await tile.get_tile_chain()
for i, tile_info in enumerate(chain):
    print(f"Tile {i}: {tile_info.width}x{tile_info.height}")
```

Source code in `src/lifx/devices/tile.py`

````python
async def get_tile_chain(self) -> list[TileInfo]:
    """Get information about all tiles in the chain.

    Always fetches from device.
    Use the `tile_chain` property to access stored value.

    Returns:
        List of TileInfo objects, one per tile

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        chain = await tile.get_tile_chain()
        for i, tile_info in enumerate(chain):
            print(f"Tile {i}: {tile_info.width}x{tile_info.height}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Tile.GetDeviceChain())

    # Convert protocol TileDevice objects to TileInfo
    tiles = [
        TileInfo.from_protocol(tile_device)
        for tile_device in state.tile_devices[: state.tile_devices_count]
    ]

    import time

    self._tile_chain = (tiles, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_tile_chain",
            "action": "query",
            "reply": {
                "tile_devices_count": state.tile_devices_count,
                "tiles": [
                    {
                        "width": tile.width,
                        "height": tile.height,
                        "device_version_vendor": tile.device_version_vendor,
                        "device_version_product": tile.device_version_product,
                        "firmware_version_major": tile.firmware_version_major,
                        "firmware_version_minor": tile.firmware_version_minor,
                    }
                    for tile in tiles
                ],
            },
        }
    )

    return tiles
````

##### get_tile_count

```python
get_tile_count() -> int
```

Get the number of tiles in the chain.

Always fetches from device. Use the `tile_count` property to access stored value.

| RETURNS | DESCRIPTION     |
| ------- | --------------- |
| `int`   | Number of tiles |

Example

```python
count = await tile.get_tile_count()
print(f"Device has {count} tiles")
```

Source code in `src/lifx/devices/tile.py`

````python
async def get_tile_count(self) -> int:
    """Get the number of tiles in the chain.

    Always fetches from device.
    Use the `tile_count` property to access stored value.

    Returns:
        Number of tiles

    Example:
        ```python
        count = await tile.get_tile_count()
        print(f"Device has {count} tiles")
        ```
    """
    chain = await self.get_tile_chain()
    count = len(chain)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_tile_count",
            "action": "query",
            "reply": {
                "count": count,
            },
        }
    )

    return count
````

##### get_tile_colors

```python
get_tile_colors(
    tile_index: int,
    x: int = 0,
    y: int = 0,
    width: int | None = None,
    height: int | None = None,
) -> list[list[HSBK]]
```

Get colors from a tile.

Always fetches from device. Use the `tile_colors` property to access stored value.

Returns a 2D array of colors representing the zones. For tiles with >64 zones, multiple Get64 requests are sent sequentially.

| PARAMETER    | DESCRIPTION                                                        |
| ------------ | ------------------------------------------------------------------ |
| `tile_index` | Index of tile in chain (0-based) **TYPE:** `int`                   |
| `x`          | Starting X coordinate (default 0) **TYPE:** `int` **DEFAULT:** `0` |
| `y`          | Starting Y coordinate (default 0) **TYPE:** `int` **DEFAULT:** `0` |
| `width`      | Rectangle width in zones (default: tile width) **TYPE:** \`int     |
| `height`     | Rectangle height in zones (default: tile height) **TYPE:** \`int   |

| RETURNS            | DESCRIPTION            |
| ------------------ | ---------------------- |
| `list[list[HSBK]]` | 2D list of HSBK colors |

| RAISES                    | DESCRIPTION                             |
| ------------------------- | --------------------------------------- |
| `ValueError`              | If tile_index or dimensions are invalid |
| `LifxDeviceNotFoundError` | If device is not connected              |
| `LifxTimeoutError`        | If device does not respond              |
| `LifxProtocolError`       | If response is invalid                  |

Example

```python
# Get all colors from first tile
colors = await tile.get_tile_colors(0)
print(f"Top-left zone: {colors[0][0]}")

# Get colors from specific rectangle
colors = await tile.get_tile_colors(0, x=2, y=2, width=4, height=4)
```

Source code in `src/lifx/devices/tile.py`

````python
async def get_tile_colors(
    self,
    tile_index: int,
    x: int = 0,
    y: int = 0,
    width: int | None = None,
    height: int | None = None,
) -> list[list[HSBK]]:
    """Get colors from a tile.

    Always fetches from device.
    Use the `tile_colors` property to access stored value.

    Returns a 2D array of colors representing the zones.
    For tiles with >64 zones, multiple Get64 requests are sent sequentially.

    Args:
        tile_index: Index of tile in chain (0-based)
        x: Starting X coordinate (default 0)
        y: Starting Y coordinate (default 0)
        width: Rectangle width in zones (default: tile width)
        height: Rectangle height in zones (default: tile height)

    Returns:
        2D list of HSBK colors

    Raises:
        ValueError: If tile_index or dimensions are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        # Get all colors from first tile
        colors = await tile.get_tile_colors(0)
        print(f"Top-left zone: {colors[0][0]}")

        # Get colors from specific rectangle
        colors = await tile.get_tile_colors(0, x=2, y=2, width=4, height=4)
        ```
    """
    if tile_index < 0:
        raise ValueError(f"Invalid tile index: {tile_index}")
    if x < 0 or y < 0:
        raise ValueError(f"Invalid coordinates: x={x}, y={y}")

    # Get tile info to determine dimensions
    chain = await self.get_tile_chain()
    if tile_index >= len(chain):
        raise ValueError(
            f"Tile index {tile_index} out of range (chain has {len(chain)} tiles)"
        )

    tile_info = chain[tile_index]

    # Default to full tile if dimensions not specified
    if width is None:
        width = tile_info.width - x
    if height is None:
        height = tile_info.height - y

    # Validate dimensions
    if width <= 0 or height <= 0:
        raise ValueError(f"Invalid dimensions: width={width}, height={height}")
    if x + width > tile_info.width or y + height > tile_info.height:
        raise ValueError(
            f"Rectangle exceeds tile dimensions ({x},{y},{width},{height}) "
            f"vs ({tile_info.width}x{tile_info.height})"
        )

    total_zones = width * height

    if total_zones <= 64:
        # Single Get64 request sufficient
        state = await self.connection.request(
            packets.Tile.Get64(
                tile_index=tile_index,
                length=1,
                rect=TileBufferRect(fb_index=0, x=x, y=y, width=width),
            ),
        )

        # Convert colors from protocol HSBK to HSBK
        colors_flat = [
            HSBK.from_protocol(color) for color in state.colors[:total_zones]
        ]
    else:
        # Multiple Get64 requests needed
        # Split into chunks by rows, taking as many rows as fit in 64 zones
        colors_flat: list[HSBK] = []
        current_y = y

        while current_y < y + height:
            # Calculate how many rows we can fetch in this chunk (max 64 zones)
            rows_in_chunk = min((64 // width), (y + height - current_y))
            if rows_in_chunk == 0:
                rows_in_chunk = 1  # Always fetch at least 1 row

            # Send Get64 request for this chunk
            state = await self.connection.request(
                packets.Tile.Get64(
                    tile_index=tile_index,
                    length=1,
                    rect=TileBufferRect(fb_index=0, x=x, y=current_y, width=width),
                ),
            )

            # Extract colors for this chunk
            zones_in_chunk = width * rows_in_chunk
            chunk_colors = [
                HSBK.from_protocol(color) for color in state.colors[:zones_in_chunk]
            ]
            colors_flat.extend(chunk_colors)

            current_y += rows_in_chunk

    # Convert flat list to 2D array [y][x]
    colors_2d: list[list[HSBK]] = []
    for row_idx in range(height):
        row: list[HSBK] = []
        for col_idx in range(width):
            index = row_idx * width + col_idx
            if index < len(colors_flat):
                row.append(colors_flat[index])
            else:
                # Pad with black if we don't have enough colors
                row.append(HSBK(0, 0, 0, 3500))
        colors_2d.append(row)

    # Update tile colors with fetched data
    import time

    timestamp = time.time()

    # Get tile chain to know dimensions
    if self._tile_chain is None:
        chain = await self.get_tile_chain()
    else:
        chain, _ = self._tile_chain

    # Get tile info for this specific tile
    tile_info = chain[tile_index]

    # Initialize or get existing colors dict
    if self._tile_colors is None:
        tiles_colors_dict = {}
    else:
        tiles_colors_dict, _ = self._tile_colors

    # Get or create TileColors for this tile
    if tile_index not in tiles_colors_dict:
        # Create new TileColors with default black colors
        num_zones = tile_info.width * tile_info.height
        default_colors = [HSBK(0, 0, 0, 3500)] * num_zones
        tiles_colors_dict[tile_index] = TileColors(
            colors=default_colors, width=tile_info.width, height=tile_info.height
        )

    tile_colors = tiles_colors_dict[tile_index]

    # Update the specific tile region with fetched colors
    for row_idx in range(height):
        for col_idx in range(width):
            tile_x = x + col_idx
            tile_y = y + row_idx
            if tile_y < tile_colors.height and tile_x < tile_colors.width:
                tile_colors.set_color(tile_x, tile_y, colors_2d[row_idx][col_idx])

    # Store updated colors with new timestamp
    self._tile_colors = (tiles_colors_dict, timestamp)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_tile_colors",
            "action": "query",
            "reply": {
                "tile_index": tile_index,
                "x": x,
                "y": y,
                "width": width,
                "height": height,
                "total_zones": total_zones,
            },
        }
    )

    return colors_2d
````

##### set_tile_colors

```python
set_tile_colors(
    tile_index: int,
    colors: list[list[HSBK]],
    x: int = 0,
    y: int = 0,
    duration: float = 0.0,
) -> None
```

Set colors on a tile.

For tiles with >64 zones, multiple Set64 requests are sent to frame buffer 1, then CopyFrameBuffer is used to atomically copy to frame buffer 0 with the specified duration. This eliminates flicker during multi-packet updates.

If the device is powered off, colors are set instantly (duration=0) and then the device is powered on with the specified duration for a smooth visual effect.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `tile_index` | Index of tile in chain (0-based) **TYPE:** `int`                                  |
| `colors`     | 2D list of HSBK colors **TYPE:** `list[list[HSBK]]`                               |
| `x`          | Starting X coordinate on tile (default 0) **TYPE:** `int` **DEFAULT:** `0`        |
| `y`          | Starting Y coordinate on tile (default 0) **TYPE:** `int` **DEFAULT:** `0`        |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If parameters are invalid  |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set entire 8x8 tile to red
red = HSBK.from_rgb(255, 0, 0)
colors = [[red] * 8 for _ in range(8)]
await tile.set_tile_colors(0, colors)

# Set a 4x4 area starting at (2, 2) with transition
blue = HSBK.from_rgb(0, 0, 255)
colors = [[blue] * 4 for _ in range(4)]
await tile.set_tile_colors(0, colors, x=2, y=2, duration=1.0)

# Set entire 16x8 wide tile with smooth transition
colors = [[HSBK.from_rgb(255, 0, 0)] * 16 for _ in range(8)]
await tile.set_tile_colors(0, colors, duration=2.0)
```

Source code in `src/lifx/devices/tile.py`

````python
async def set_tile_colors(
    self,
    tile_index: int,
    colors: list[list[HSBK]],
    x: int = 0,
    y: int = 0,
    duration: float = 0.0,
) -> None:
    """Set colors on a tile.

    For tiles with >64 zones, multiple Set64 requests are sent to frame buffer 1,
    then CopyFrameBuffer is used to atomically copy to frame buffer 0 with the
    specified duration. This eliminates flicker during multi-packet updates.

    If the device is powered off, colors are set instantly (duration=0) and then
    the device is powered on with the specified duration for a smooth visual effect.

    Args:
        tile_index: Index of tile in chain (0-based)
        colors: 2D list of HSBK colors
        x: Starting X coordinate on tile (default 0)
        y: Starting Y coordinate on tile (default 0)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If parameters are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set entire 8x8 tile to red
        red = HSBK.from_rgb(255, 0, 0)
        colors = [[red] * 8 for _ in range(8)]
        await tile.set_tile_colors(0, colors)

        # Set a 4x4 area starting at (2, 2) with transition
        blue = HSBK.from_rgb(0, 0, 255)
        colors = [[blue] * 4 for _ in range(4)]
        await tile.set_tile_colors(0, colors, x=2, y=2, duration=1.0)

        # Set entire 16x8 wide tile with smooth transition
        colors = [[HSBK.from_rgb(255, 0, 0)] * 16 for _ in range(8)]
        await tile.set_tile_colors(0, colors, duration=2.0)
        ```
    """
    if tile_index < 0:
        raise ValueError(f"Invalid tile index: {tile_index}")
    if x < 0 or y < 0:
        raise ValueError(f"Invalid coordinates: x={x}, y={y}")
    if not colors or not colors[0]:
        raise ValueError("Colors array cannot be empty")

    height = len(colors)
    width = len(colors[0])

    # Validate that all rows have the same width
    for row in colors:
        if len(row) != width:
            raise ValueError("All rows in colors array must have the same width")

    # Flatten colors to 1D array
    colors_flat: list[HSBK] = []
    for row in colors:
        colors_flat.extend(row)

    total_zones = width * height

    # Check power state to optimize duration handling
    # If device is off, set colors instantly then power on with duration
    # Use stored power state if available, otherwise fetch
    power_tuple = self.power
    if power_tuple is not None:
        is_powered_on, _ = power_tuple
    else:
        is_powered_on = await self.get_power()

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Apply duration to colors only if device is already on
    color_duration_ms = duration_ms if is_powered_on else 0

    if total_zones <= 64:
        # Single Set64 request sufficient - write directly to visible frame buffer 0
        # Pad to 64 colors
        protocol_colors = [color.to_protocol() for color in colors_flat]
        while len(protocol_colors) < 64:
            protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())

        await self.connection.request(
            packets.Tile.Set64(
                tile_index=tile_index,
                length=1,
                rect=TileBufferRect(fb_index=0, x=x, y=y, width=width),
                duration=color_duration_ms,
                colors=protocol_colors,
            ),
        )
    else:
        # Multiple Set64 requests needed for >64 zones
        # Write to buffer 1, then copy to buffer 0 atomically
        current_y = y
        flat_index = 0

        while flat_index < len(colors_flat):
            # Calculate how many rows we can write in this chunk (max 64 zones)
            rows_in_chunk = min((64 // width), (y + height - current_y))
            if rows_in_chunk == 0:
                rows_in_chunk = 1  # Always write at least 1 row

            # Extract colors for this chunk
            zones_in_chunk = width * rows_in_chunk
            chunk_colors = colors_flat[flat_index : flat_index + zones_in_chunk]

            # Pad to 64 colors
            protocol_colors = [color.to_protocol() for color in chunk_colors]
            while len(protocol_colors) < 64:
                protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())

            # Write to frame buffer 1 (invisible) with no duration
            await self.connection.request(
                packets.Tile.Set64(
                    tile_index=tile_index,
                    length=1,
                    rect=TileBufferRect(fb_index=1, x=x, y=current_y, width=width),
                    duration=0,
                    colors=protocol_colors,
                ),
            )

            flat_index += zones_in_chunk
            current_y += rows_in_chunk

        # Copy from buffer 1 to buffer 0 with transition duration
        copy_duration = duration if is_powered_on else 0.0
        await self.copy_frame_buffer(
            tile_index=tile_index,
            src_fb_index=1,
            dst_fb_index=0,
            src_x=x,
            src_y=y,
            dst_x=x,
            dst_y=y,
            width=width,
            height=height,
            duration=copy_duration,
        )

    # Update tile colors with the values we just set
    import time

    timestamp = time.time()

    # Get tile chain to know dimensions
    if self._tile_chain is None:
        chain = await self.get_tile_chain()
    else:
        chain, _ = self._tile_chain

    # Get tile info for this specific tile
    tile_info = chain[tile_index]

    # Initialize or get existing colors dict
    if self._tile_colors is None:
        tiles_colors_dict = {}
    else:
        tiles_colors_dict, _ = self._tile_colors

    # Get or create TileColors for this tile
    if tile_index not in tiles_colors_dict:
        # Create new TileColors with default black colors
        num_zones = tile_info.width * tile_info.height
        default_colors = [HSBK(0, 0, 0, 3500)] * num_zones
        tiles_colors_dict[tile_index] = TileColors(
            colors=default_colors, width=tile_info.width, height=tile_info.height
        )

    tile_colors = tiles_colors_dict[tile_index]

    # Update the specific tile region with colors we just set
    for row_idx in range(height):
        for col_idx in range(width):
            tile_x = x + col_idx
            tile_y = y + row_idx
            if tile_y < tile_colors.height and tile_x < tile_colors.width:
                tile_colors.set_color(tile_x, tile_y, colors[row_idx][col_idx])

    # Store updated colors with new timestamp
    self._tile_colors = (tiles_colors_dict, timestamp)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_tile_colors",
            "action": "change",
            "values": {
                "tile_index": tile_index,
                "x": x,
                "y": y,
                "width": width,
                "height": height,
                "total_zones": total_zones,
                "duration": duration,
            },
        }
    )

    # If device was off, power it on with the specified duration
    if not is_powered_on and duration > 0:
        await self.set_power(True, duration=duration)
````

##### get_tile_effect

```python
get_tile_effect() -> TileEffect | None
```

Get current tile effect.

Always fetches from device. Use the `tile_effect` property to access stored value.

| RETURNS      | DESCRIPTION |
| ------------ | ----------- |
| \`TileEffect | None\`      |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
effect = await tile.get_tile_effect()
if effect:
    print(f"Effect: {effect.effect_type}, Speed: {effect.speed}ms")
```

Source code in `src/lifx/devices/tile.py`

````python
async def get_tile_effect(self) -> TileEffect | None:
    """Get current tile effect.

    Always fetches from device.
    Use the `tile_effect` property to access stored value.

    Returns:
        TileEffect if an effect is active, None if no effect

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        effect = await tile.get_tile_effect()
        if effect:
            print(f"Effect: {effect.effect_type}, Speed: {effect.speed}ms")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Tile.GetEffect())

    settings = state.settings
    effect_type = settings.effect_type

    # Extract parameters from the settings parameter field
    parameters = [
        int(settings.parameter.sky_type),
        settings.parameter.cloud_saturation_min,
        settings.parameter.cloud_saturation_max,
    ]

    # Convert palette from protocol HSBK to HSBK
    palette = [
        HSBK.from_protocol(color)
        for color in settings.palette[: settings.palette_count]
    ]

    if effect_type == TileEffectType.OFF:
        result = None
    else:
        result = TileEffect(
            effect_type=effect_type,
            speed=settings.speed,
            duration=settings.duration,
            palette=palette,
            parameters=parameters,
        )

    import time

    self._tile_effect = (result, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_tile_effect",
            "action": "query",
            "reply": {
                "effect_type": effect_type.name,
                "speed": settings.speed,
                "duration": settings.duration,
                "palette_count": settings.palette_count,
                "parameters": parameters,
            },
        }
    )

    return result
````

##### set_tile_effect

```python
set_tile_effect(effect: TileEffect) -> None
```

Set tile effect.

| PARAMETER | DESCRIPTION                                      |
| --------- | ------------------------------------------------ |
| `effect`  | Tile effect configuration **TYPE:** `TileEffect` |

| RAISES                    | DESCRIPTION                    |
| ------------------------- | ------------------------------ |
| `ValueError`              | If palette has too many colors |
| `LifxDeviceNotFoundError` | If device is not connected     |
| `LifxTimeoutError`        | If device does not respond     |

Example

```python
# Apply a morph effect with rainbow palette
palette = [
    HSBK(0, 1.0, 1.0, 3500),  # Red
    HSBK(60, 1.0, 1.0, 3500),  # Yellow
    HSBK(120, 1.0, 1.0, 3500),  # Green
    HSBK(240, 1.0, 1.0, 3500),  # Blue
]
effect = TileEffect(
    effect_type=TileEffectType.MORPH,
    speed=5000,
    palette=palette,
)
await tile.set_tile_effect(effect)
```

Source code in `src/lifx/devices/tile.py`

````python
async def set_tile_effect(self, effect: TileEffect) -> None:
    """Set tile effect.

    Args:
        effect: Tile effect configuration

    Raises:
        ValueError: If palette has too many colors
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Apply a morph effect with rainbow palette
        palette = [
            HSBK(0, 1.0, 1.0, 3500),  # Red
            HSBK(60, 1.0, 1.0, 3500),  # Yellow
            HSBK(120, 1.0, 1.0, 3500),  # Green
            HSBK(240, 1.0, 1.0, 3500),  # Blue
        ]
        effect = TileEffect(
            effect_type=TileEffectType.MORPH,
            speed=5000,
            palette=palette,
        )
        await tile.set_tile_effect(effect)
        ```
    """
    palette = effect.palette or [HSBK(0, 0, 1.0, 3500)]
    if len(palette) > 16:
        raise ValueError(f"Palette too large: {len(palette)} colors (max 16)")

    # Convert palette to protocol HSBK and pad to 16
    protocol_palette = [color.to_protocol() for color in palette]

    while len(protocol_palette) < 16:
        protocol_palette.append(HSBK(0, 0, 0, 3500).to_protocol())

    # Ensure parameters list is 3 elements (sky_type, cloud_sat_min, cloud_sat_max)
    parameters = effect.parameters or [0] * 3
    if len(parameters) < 3:
        parameters.extend([0] * (3 - len(parameters)))
    parameters = parameters[:3]

    # Request automatically handles acknowledgement
    await self.connection.request(
        packets.Tile.SetEffect(
            settings=TileEffectSettings(
                instanceid=0,  # 0 for new effect
                effect_type=effect.effect_type,
                speed=effect.speed,
                duration=effect.duration,
                parameter=TileEffectParameter(
                    sky_type=TileEffectSkyType(value=parameters[0]),
                    cloud_saturation_min=parameters[1],
                    cloud_saturation_max=parameters[2],
                ),
                palette_count=len(palette),
                palette=protocol_palette,
            ),
        ),
    )

    # Update state attribute
    import time

    result = effect if effect.effect_type != TileEffectType.OFF else None
    self._tile_effect = (result, time.time())

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_tile_effect",
            "action": "change",
            "values": {
                "effect_type": effect.effect_type.name,
                "speed": effect.speed,
                "duration": effect.duration,
                "palette_count": len(palette),
                "parameters": parameters,
            },
        }
    )
````

##### stop_effect

```python
stop_effect() -> None
```

Stop any running tile effect.

Example

```python
await tile.stop_effect()
```

Source code in `src/lifx/devices/tile.py`

````python
async def stop_effect(self) -> None:
    """Stop any running tile effect.

    Example:
        ```python
        await tile.stop_effect()
        ```
    """
    await self.set_tile_effect(
        TileEffect(
            effect_type=TileEffectType.OFF,
            speed=0,
            duration=0,
        )
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "stop_effect",
            "action": "change",
            "values": {},
        }
    )
````

##### copy_frame_buffer

```python
copy_frame_buffer(
    tile_index: int,
    src_fb_index: int = 0,
    dst_fb_index: int = 0,
    src_x: int = 0,
    src_y: int = 0,
    dst_x: int = 0,
    dst_y: int = 0,
    width: int = 8,
    height: int = 8,
    duration: float = 0.0,
) -> None
```

Copy a rectangular region from one frame buffer to another.

This allows copying pixel data between frame buffers or within the same frame buffer on a tile. Useful for double-buffering effects or moving pixel regions.

| PARAMETER      | DESCRIPTION                                                                       |
| -------------- | --------------------------------------------------------------------------------- |
| `tile_index`   | Index of tile in chain (0-based) **TYPE:** `int`                                  |
| `src_fb_index` | Source frame buffer index (default 0) **TYPE:** `int` **DEFAULT:** `0`            |
| `dst_fb_index` | Destination frame buffer index (default 0) **TYPE:** `int` **DEFAULT:** `0`       |
| `src_x`        | Source rectangle X coordinate (default 0) **TYPE:** `int` **DEFAULT:** `0`        |
| `src_y`        | Source rectangle Y coordinate (default 0) **TYPE:** `int` **DEFAULT:** `0`        |
| `dst_x`        | Destination rectangle X coordinate (default 0) **TYPE:** `int` **DEFAULT:** `0`   |
| `dst_y`        | Destination rectangle Y coordinate (default 0) **TYPE:** `int` **DEFAULT:** `0`   |
| `width`        | Rectangle width in zones (default 8) **TYPE:** `int` **DEFAULT:** `8`             |
| `height`       | Rectangle height in zones (default 8) **TYPE:** `int` **DEFAULT:** `8`            |
| `duration`     | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                               |
| ------------------------- | ----------------------------------------- |
| `ValueError`              | If parameters are invalid or out of range |
| `LifxDeviceNotFoundError` | If device is not connected                |
| `LifxTimeoutError`        | If device does not respond                |

Example

```python
# Copy entire tile from frame buffer 0 to frame buffer 1
await tile.copy_frame_buffer(tile_index=0, src_fb_index=0, dst_fb_index=1)

# Copy a 4x4 region from (0,0) to (2,2) within same buffer with transition
await tile.copy_frame_buffer(
    tile_index=0,
    src_x=0,
    src_y=0,
    dst_x=2,
    dst_y=2,
    width=4,
    height=4,
    duration=1.0,
)
```

Source code in `src/lifx/devices/tile.py`

````python
async def copy_frame_buffer(
    self,
    tile_index: int,
    src_fb_index: int = 0,
    dst_fb_index: int = 0,
    src_x: int = 0,
    src_y: int = 0,
    dst_x: int = 0,
    dst_y: int = 0,
    width: int = 8,
    height: int = 8,
    duration: float = 0.0,
) -> None:
    """Copy a rectangular region from one frame buffer to another.

    This allows copying pixel data between frame buffers or within the same
    frame buffer on a tile. Useful for double-buffering effects or moving
    pixel regions.

    Args:
        tile_index: Index of tile in chain (0-based)
        src_fb_index: Source frame buffer index (default 0)
        dst_fb_index: Destination frame buffer index (default 0)
        src_x: Source rectangle X coordinate (default 0)
        src_y: Source rectangle Y coordinate (default 0)
        dst_x: Destination rectangle X coordinate (default 0)
        dst_y: Destination rectangle Y coordinate (default 0)
        width: Rectangle width in zones (default 8)
        height: Rectangle height in zones (default 8)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If parameters are invalid or out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Copy entire tile from frame buffer 0 to frame buffer 1
        await tile.copy_frame_buffer(tile_index=0, src_fb_index=0, dst_fb_index=1)

        # Copy a 4x4 region from (0,0) to (2,2) within same buffer with transition
        await tile.copy_frame_buffer(
            tile_index=0,
            src_x=0,
            src_y=0,
            dst_x=2,
            dst_y=2,
            width=4,
            height=4,
            duration=1.0,
        )
        ```
    """
    if tile_index < 0:
        raise ValueError(f"Invalid tile index: {tile_index}")
    if src_fb_index < 0 or dst_fb_index < 0:
        raise ValueError(
            f"Invalid frame buffer indices: src={src_fb_index}, dst={dst_fb_index}"
        )
    if src_x < 0 or src_y < 0 or dst_x < 0 or dst_y < 0:
        raise ValueError(
            f"Invalid coordinates: src=({src_x},{src_y}), dst=({dst_x},{dst_y})"
        )
    if width <= 0 or height <= 0:
        raise ValueError(f"Invalid dimensions: {width}x{height}")

    # Get tile info to validate dimensions
    chain = await self.get_tile_chain()
    if tile_index >= len(chain):
        raise ValueError(
            f"Tile index {tile_index} out of range (chain has {len(chain)} tiles)"
        )

    tile_info = chain[tile_index]

    # Validate source rectangle
    if src_x + width > tile_info.width or src_y + height > tile_info.height:
        raise ValueError(
            f"Source rectangle ({src_x},{src_y},{width},{height}) "
            f"exceeds tile dimensions ({tile_info.width}x{tile_info.height})"
        )

    # Validate destination rectangle
    if dst_x + width > tile_info.width or dst_y + height > tile_info.height:
        raise ValueError(
            f"Destination rectangle ({dst_x},{dst_y},{width},{height}) "
            f"exceeds tile dimensions ({tile_info.width}x{tile_info.height})"
        )

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Send copy command
    await self.connection.request(
        packets.Tile.CopyFrameBuffer(
            tile_index=tile_index,
            length=1,
            src_fb_index=src_fb_index,
            dst_fb_index=dst_fb_index,
            src_x=src_x,
            src_y=src_y,
            dst_x=dst_x,
            dst_y=dst_y,
            width=width,
            height=height,
            duration=duration_ms,
        ),
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "copy_frame_buffer",
            "action": "change",
            "values": {
                "tile_index": tile_index,
                "src_fb_index": src_fb_index,
                "dst_fb_index": dst_fb_index,
                "src_x": src_x,
                "src_y": src_y,
                "dst_x": dst_x,
                "dst_y": dst_y,
                "width": width,
                "height": height,
                "duration": duration_ms,
            },
        }
    )
````

##### set_morph_effect

```python
set_morph_effect(
    palette: list[HSBK], speed: float = 5.0, duration: float = 0.0
) -> None
```

Apply a morph effect that transitions through a color palette.

| PARAMETER  | DESCRIPTION                                                                                  |
| ---------- | -------------------------------------------------------------------------------------------- |
| `palette`  | List of colors to morph between (2-16 colors) **TYPE:** `list[HSBK]`                         |
| `speed`    | Speed in seconds per cycle (default 5.0) **TYPE:** `float` **DEFAULT:** `5.0`                |
| `duration` | Total duration in seconds (0 for infinite, default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES       | DESCRIPTION           |
| ------------ | --------------------- |
| `ValueError` | If palette is invalid |

Example

```python
# Morph between red, green, and blue
palette = [
    HSBK.from_rgb(255, 0, 0),
    HSBK.from_rgb(0, 255, 0),
    HSBK.from_rgb(0, 0, 255),
]
await tile.set_morph_effect(palette, speed=5.0)
```

Source code in `src/lifx/devices/tile.py`

````python
async def set_morph_effect(
    self,
    palette: list[HSBK],
    speed: float = 5.0,
    duration: float = 0.0,
) -> None:
    """Apply a morph effect that transitions through a color palette.

    Args:
        palette: List of colors to morph between (2-16 colors)
        speed: Speed in seconds per cycle (default 5.0)
        duration: Total duration in seconds (0 for infinite, default 0.0)

    Raises:
        ValueError: If palette is invalid

    Example:
        ```python
        # Morph between red, green, and blue
        palette = [
            HSBK.from_rgb(255, 0, 0),
            HSBK.from_rgb(0, 255, 0),
            HSBK.from_rgb(0, 0, 255),
        ]
        await tile.set_morph_effect(palette, speed=5.0)
        ```
    """
    if len(palette) < 2:
        raise ValueError("Palette must have at least 2 colors")
    if len(palette) > 16:
        raise ValueError(f"Palette too large: {len(palette)} colors (max 16)")

    # Convert speed to milliseconds
    speed_ms = int(speed * 1000)

    # Convert duration to nanoseconds
    duration_ns = int(duration * 1_000_000_000)

    await self.set_tile_effect(
        TileEffect(
            effect_type=TileEffectType.MORPH,
            speed=speed_ms,
            duration=duration_ns,
            palette=palette,
        )
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_morph_effect",
            "action": "change",
            "values": {
                "palette_count": len(palette),
                "speed": speed,
                "duration": duration,
            },
        }
    )
````

##### set_flame_effect

```python
set_flame_effect(
    speed: float = 5.0, duration: float = 0.0, palette: list[HSBK] | None = None
) -> None
```

Apply a flame effect.

| PARAMETER  | DESCRIPTION                                                                                  |
| ---------- | -------------------------------------------------------------------------------------------- |
| `speed`    | Effect speed in seconds per cycle (default 5.0) **TYPE:** `float` **DEFAULT:** `5.0`         |
| `duration` | Total duration in seconds (0 for infinite, default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |
| `palette`  | Optional color palette (default: fire colors) **TYPE:** \`list[HSBK]                         |

Example

```python
# Apply default flame effect
await tile.set_flame_effect()

# Custom flame colors
palette = [
    HSBK.from_rgb(255, 0, 0),  # Red
    HSBK.from_rgb(255, 100, 0),  # Orange
    HSBK.from_rgb(255, 200, 0),  # Yellow
]
await tile.set_flame_effect(speed=3.0, palette=palette)
```

Source code in `src/lifx/devices/tile.py`

````python
async def set_flame_effect(
    self,
    speed: float = 5.0,
    duration: float = 0.0,
    palette: list[HSBK] | None = None,
) -> None:
    """Apply a flame effect.

    Args:
        speed: Effect speed in seconds per cycle (default 5.0)
        duration: Total duration in seconds (0 for infinite, default 0.0)
        palette: Optional color palette (default: fire colors)

    Example:
        ```python
        # Apply default flame effect
        await tile.set_flame_effect()

        # Custom flame colors
        palette = [
            HSBK.from_rgb(255, 0, 0),  # Red
            HSBK.from_rgb(255, 100, 0),  # Orange
            HSBK.from_rgb(255, 200, 0),  # Yellow
        ]
        await tile.set_flame_effect(speed=3.0, palette=palette)
        ```
    """
    if palette is None:
        # Default fire palette
        palette = [
            HSBK(0, 1.0, 1.0, 3500),  # Red
            HSBK(30, 1.0, 1.0, 3500),  # Orange
            HSBK(45, 1.0, 0.8, 3500),  # Yellow-orange
        ]

    # Convert speed to milliseconds
    speed_ms = int(speed * 1000)

    # Convert duration to nanoseconds
    duration_ns = int(duration * 1_000_000_000)

    await self.set_tile_effect(
        TileEffect(
            effect_type=TileEffectType.FLAME,
            speed=speed_ms,
            duration=duration_ns,
            palette=palette,
        )
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_flame_effect",
            "action": "change",
            "values": {
                "palette_count": len(palette),
                "speed": speed,
                "duration": duration,
            },
        }
    )
````

##### apply_theme

```python
apply_theme(
    theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None
```

Apply a theme to this tile device.

Distributes theme colors across all tiles in the chain using Canvas-based rendering to create natural color splotches that grow outward.

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                    |
| `power_on` | Turn on the device **TYPE:** `bool` **DEFAULT:** `False`            |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
from lifx.theme import get_theme

theme = get_theme("sunset")
await tile.apply_theme(theme, power_on=True, duration=2.0)
```

Source code in `src/lifx/devices/tile.py`

````python
async def apply_theme(
    self,
    theme: Theme,
    power_on: bool = False,
    duration: float = 0.0,
) -> None:
    """Apply a theme to this tile device.

    Distributes theme colors across all tiles in the chain using Canvas-based
    rendering to create natural color splotches that grow outward.

    Args:
        theme: Theme to apply
        power_on: Turn on the device
        duration: Transition duration in seconds

    Example:
        ```python
        from lifx.theme import get_theme

        theme = get_theme("sunset")
        await tile.apply_theme(theme, power_on=True, duration=2.0)
        ```
    """
    from lifx.theme.generators import MatrixGenerator

    # Get tile dimensions
    tiles = await self.get_tile_chain()
    if not tiles:
        _LOGGER.warning("No tiles available, skipping theme application")
        return

    # Build coords_and_sizes for all tiles
    left_x = 0
    coords_and_sizes = []
    for tile in tiles:
        coords_and_sizes.append(((left_x, 0), (tile.width, tile.height)))
        left_x += tile.width

    # Create generator with all tile coordinates
    generator = MatrixGenerator(coords_and_sizes)

    # Generate colors for all tiles at once
    tile_colors_list = generator.get_theme_colors(theme)

    # Check if device is on
    is_on = await self.get_power()

    # Determine duration for color setting
    color_duration = 0 if (power_on and not is_on) else duration

    # Apply colors to each tile
    for tile_idx, colors_flat in enumerate(tile_colors_list):
        tile_info = tiles[tile_idx]

        # Convert to 2D grid for set_tile_colors
        colors_2d = []
        for y in range(tile_info.height):
            row = []
            for x in range(tile_info.width):
                idx = y * tile_info.width + x
                if idx < len(colors_flat):
                    row.append(colors_flat[idx])
                else:
                    row.append(HSBK(0, 0, 1.0, 3500))  # White fallback
            colors_2d.append(row)

        # Apply colors to tile
        await self.set_tile_colors(tile_idx, colors_2d, duration=color_duration)

    # Turn on if requested
    if power_on and not is_on:
        await self.set_power(True, duration=duration)
````

## Examples

### Basic Light Control

```python
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Turn on and set color
        await light.set_power(True)
        await light.set_color(Colors.BLUE, duration=1.0)

        # Get device info
        label = await light.get_label()
        print(f"Controlling: {label}")
```

### Light Effects

```python
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Pulse effect
        await light.pulse(Colors.RED, period=1.0, cycles=5)

        # Breathe effect
        await light.breathe(Colors.BLUE, period=2.0, cycles=3)
```

### HEV Light Control (Anti-Bacterial Cleaning)

```python
from lifx import HevLight


async def main():
    async with await HevLight.from_ip("192.168.1.100") as light:
        # Start a 2-hour cleaning cycle
        await light.set_hev_cycle(enable=True, duration_seconds=7200)

        # Check cycle status
        state = await light.get_hev_cycle()
        if state.is_running:
            print(f"Cleaning: {state.remaining_s}s remaining")

        # Configure default settings
        await light.set_hev_config(indication=True, duration_seconds=7200)
```

### Infrared Light Control (Night Vision)

```python
from lifx import InfraredLight


async def main():
    async with await InfraredLight.from_ip("192.168.1.100") as light:
        # Set infrared brightness to 50%
        await light.set_infrared(0.5)

        # Get current infrared brightness
        brightness = await light.get_infrared()
        print(f"IR brightness: {brightness * 100}%")
```

### MultiZone Control

```python
from lifx import find_lights, Colors


async def main():
    async with find_lights() as lights:
        for light in lights:
            if light.has_extended_multizone:
                await light.get_extended_color_zones()
            elif light.has_multizone:
                await light.get_color_zones()
```

### Tile Control

```python
from lifx import find_lights, HSBK


async def main():
    async with find_lights() as lights:
        for light in lights:
            if light.has_matrix:
                # Set a gradient across the tile
                colors = [
                    HSBK(hue=h, saturation=1.0, brightness=0.5, kelvin=3500)
                    for h in range(0, 360, 10)
                ]
                await light.set_tile_colors(colors)
```

# Network Layer

The network layer provides low-level operations for communicating with LIFX devices over UDP.

## Discovery

Functions for discovering LIFX devices on the local network.

### discover_devices

```python
discover_devices(
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> list[DiscoveredDevice]
```

Discover LIFX devices on the local network.

Sends a broadcast DeviceGetService packet and collects responses. Implements DoS protection via timeout, source validation, and serial validation.

| PARAMETER           | DESCRIPTION                                                                          |
| ------------------- | ------------------------------------------------------------------------------------ |
| `timeout`           | Discovery timeout in seconds **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT`      |
| `broadcast_address` | Broadcast address to use **TYPE:** `str` **DEFAULT:** `'255.255.255.255'`            |
| `port`              | UDP port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT` |

| RETURNS                  | DESCRIPTION                                                |
| ------------------------ | ---------------------------------------------------------- |
| `list[DiscoveredDevice]` | List of discovered devices (deduplicated by serial number) |

Example

```python
devices = await discover_devices(timeout=5.0)
for device in devices:
    print(f"Found device: {device.serial} at {device.ip}:{device.port}")
```

Source code in `src/lifx/network/discovery.py`

````python
async def discover_devices(
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
) -> list[DiscoveredDevice]:
    """Discover LIFX devices on the local network.

    Sends a broadcast DeviceGetService packet and collects responses.
    Implements DoS protection via timeout, source validation, and serial validation.

    Args:
        timeout: Discovery timeout in seconds
        broadcast_address: Broadcast address to use
        port: UDP port to use (default LIFX_UDP_PORT)

    Returns:
        List of discovered devices (deduplicated by serial number)

    Example:
        ```python
        devices = await discover_devices(timeout=5.0)
        for device in devices:
            print(f"Found device: {device.serial} at {device.ip}:{device.port}")
        ```
    """
    devices: dict[str, DiscoveredDevice] = {}
    packet_count = 0
    start_time = time.time()

    # Create transport with broadcast enabled
    async with UdpTransport(port=0, broadcast=True) as transport:
        # Create discovery message
        builder = MessageBuilder()
        discovery_packet = DevicePackets.GetService()
        message = builder.create_message(
            packet=discovery_packet,
            target=b"\x00" * 8,  # Broadcast
            res_required=True,
            ack_required=False,
        )

        # Send broadcast
        request_time = time.time()
        _LOGGER.debug(
            {
                "class": "discover_devices",
                "method": "discover",
                "action": "broadcast_sent",
                "broadcast_address": broadcast_address,
                "port": port,
                "max_timeout": timeout,
                "request_time": request_time,
            }
        )
        await transport.send(message, (broadcast_address, port))

        # Calculate idle timeout
        idle_timeout = max_response_time * idle_timeout_multiplier
        last_response_time = request_time

        # Collect responses with dynamic timeout
        while True:
            # Calculate elapsed time since last response
            elapsed_since_last = time.time() - last_response_time

            # Stop if we've been idle too long
            if elapsed_since_last >= idle_timeout:
                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "idle_timeout",
                        "idle_time": elapsed_since_last,
                        "idle_timeout": idle_timeout,
                    }
                )
                break

            # Stop if we've exceeded the overall timeout
            if time.time() - request_time >= timeout:
                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "overall_timeout",
                        "elapsed": time.time() - request_time,
                        "timeout": timeout,
                    }
                )
                break

            # Calculate remaining timeout (use the shorter of idle or overall timeout)
            remaining_idle = idle_timeout - elapsed_since_last
            remaining_overall = timeout - (time.time() - request_time)
            remaining = min(remaining_idle, remaining_overall)

            # Try to receive a packet
            try:
                data, addr = await transport.receive(timeout=remaining)
                response_timestamp = time.time()

            except LifxTimeoutError:
                # Timeout means no more responses within the idle period
                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "no_responses",
                    }
                )
                break

            # Increment packet counter for logging
            packet_count += 1

            try:
                # Parse message
                header, payload = parse_message(data)

                # Validate source matches expected source
                if header.source != builder.source:
                    _LOGGER.debug(
                        {
                            "class": "discover_devices",
                            "method": "discover",
                            "action": "source_mismatch",
                            "expected_source": builder.source,
                            "received_source": header.source,
                            "source_ip": addr[0],
                        }
                    )
                    continue

                # Check if this is a DeviceStateService response
                if header.pkt_type != DevicePackets.StateService.PKT_TYPE:
                    _LOGGER.debug(
                        {
                            "class": "discover_devices",
                            "method": "discover",
                            "action": "unexpected_packet_type",
                            "pkt_type": header.pkt_type,
                            "expected_type": DevicePackets.StateService.PKT_TYPE,
                            "source_ip": addr[0],
                        }
                    )
                    continue

                # Validate serial is not multicast/broadcast
                if header.target[0] & 0x01 or header.target == b"\xff" * 8:
                    _LOGGER.warning(
                        {
                            "warning": "Invalid serial number in discovery response",
                            "serial": header.target.hex(),
                            "source_ip": addr[0],
                        }
                    )
                    continue

                # Parse service info
                service, device_port = _parse_device_state_service(payload)

                # Calculate accurate response time from this specific response
                response_time = response_timestamp - request_time

                # Convert 8-byte protocol serial to string
                device_serial = Serial.from_protocol(header.target).to_string()

                # Create device info
                device = DiscoveredDevice(
                    serial=device_serial,
                    ip=addr[0],
                    port=device_port,
                    service=service,
                    response_time=response_time,
                )

                # Deduplicate by serial number
                devices[device.serial] = device

                # Update last response time for idle timeout calculation
                last_response_time = response_timestamp

                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "device_found",
                        "serial": device.serial,
                        "ip": device.ip,
                        "port": device.port,
                        "response_time": response_time,
                    }
                )

            except LifxProtocolError as e:
                # Log malformed responses
                _LOGGER.warning(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "malformed_response",
                        "reason": str(e),
                        "source_ip": addr[0],
                        "packet_size": len(data),
                    },
                    exc_info=True,
                )
                continue
            except Exception as e:
                # Log unexpected errors
                _LOGGER.error(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "unexpected_error",
                        "error_details": str(e),
                        "source_ip": addr[0],
                    },
                    exc_info=True,
                )
                continue

        _LOGGER.debug(
            {
                "class": "discover_devices",
                "method": "discover",
                "action": "complete",
                "devices_found": len(devices),
                "packets_processed": packet_count,
                "elapsed": time.time() - start_time,
            }
        )

    return list(devices.values())
````

### DiscoveredDevice

```python
DiscoveredDevice(
    serial: str,
    ip: str,
    port: int,
    service: int,
    first_seen: float = time(),
    response_time: float = 0.0,
)
```

Information about a discovered LIFX device.

| ATTRIBUTE       | DESCRIPTION                                                                        |
| --------------- | ---------------------------------------------------------------------------------- |
| `serial`        | Device serial number as 12-digit hex string (e.g., "d073d5123456") **TYPE:** `str` |
| `ip`            | Device IP address **TYPE:** `str`                                                  |
| `port`          | Device UDP port **TYPE:** `int`                                                    |
| `service`       | Service type (typically UDP=1) **TYPE:** `int`                                     |
| `first_seen`    | Timestamp when device was first discovered **TYPE:** `float`                       |
| `response_time` | Response time in seconds **TYPE:** `float`                                         |

| METHOD          | DESCRIPTION                                                       |
| --------------- | ----------------------------------------------------------------- |
| `create_device` | Create appropriate device instance based on product capabilities. |
| `__hash__`      | Hash based on serial number for deduplication.                    |
| `__eq__`        | Equality based on serial number.                                  |

#### Functions

##### create_device

```python
create_device() -> Device
```

Create appropriate device instance based on product capabilities.

Queries the device for its product ID and firmware version, then instantiates the appropriate device class (Device, Light, MultiZoneLight, or TileDevice) based on the product capabilities.

| RETURNS  | DESCRIPTION                             |
| -------- | --------------------------------------- |
| `Device` | Device instance of the appropriate type |

| RAISES                | DESCRIPTION               |
| --------------------- | ------------------------- |
| `DeviceNotFoundError` | If device doesn't respond |
| `TimeoutError`        | If device query times out |

Example

```python
devices = await discover_devices()
for discovered in devices:
    device = await discovered.create_device()
    print(f"Created {type(device).__name__}: {await device.get_label()}")
```

Source code in `src/lifx/network/discovery.py`

````python
async def create_device(self) -> Device:
    """Create appropriate device instance based on product capabilities.

    Queries the device for its product ID and firmware version, then
    instantiates the appropriate device class (Device, Light, MultiZoneLight,
    or TileDevice) based on the product capabilities.

    Returns:
        Device instance of the appropriate type

    Raises:
        DeviceNotFoundError: If device doesn't respond
        TimeoutError: If device query times out

    Example:
        ```python
        devices = await discover_devices()
        for discovered in devices:
            device = await discovered.create_device()
            print(f"Created {type(device).__name__}: {await device.get_label()}")
        ```
    """
    from lifx.devices.base import Device
    from lifx.devices.hev import HevLight
    from lifx.devices.infrared import InfraredLight
    from lifx.devices.light import Light
    from lifx.devices.multizone import MultiZoneLight
    from lifx.devices.tile import TileDevice
    from lifx.products import get_device_class_name

    # Create temporary device to query version (registry is always pre-loaded)
    temp_device = Device(serial=self.serial, ip=self.ip, port=self.port)

    try:
        version = await temp_device.get_version()
        pid = version.product

        # Get appropriate class name
        class_name = get_device_class_name(pid)

        # Instantiate the correct class
        if class_name == "TileDevice":
            device = TileDevice(serial=self.serial, ip=self.ip, port=self.port)
        elif class_name == "MultiZoneLight":
            device = MultiZoneLight(serial=self.serial, ip=self.ip, port=self.port)
        elif class_name == "HevLight":
            device = HevLight(serial=self.serial, ip=self.ip, port=self.port)
        elif class_name == "InfraredLight":
            device = InfraredLight(serial=self.serial, ip=self.ip, port=self.port)
        elif class_name == "Light":
            device = Light(serial=self.serial, ip=self.ip, port=self.port)
        else:
            device = temp_device

        return device

    except Exception:
        # If version query fails, default to Light
        device = Light(serial=self.serial, ip=self.ip, port=self.port)
        return device
````

##### __hash__

```python
__hash__() -> int
```

Hash based on serial number for deduplication.

Source code in `src/lifx/network/discovery.py`

```python
def __hash__(self) -> int:
    """Hash based on serial number for deduplication."""
    return hash(self.serial)
```

##### __eq__

```python
__eq__(other: object) -> bool
```

Equality based on serial number.

Source code in `src/lifx/network/discovery.py`

```python
def __eq__(self, other: object) -> bool:
    """Equality based on serial number."""
    if not isinstance(other, DiscoveredDevice):
        return False
    return self.serial == other.serial
```

## UDP Transport

Low-level UDP transport for sending and receiving LIFX protocol messages.

### UdpTransport

```python
UdpTransport(
    ip_address: str = DEFAULT_IP_ADDRESS, port: int = 0, broadcast: bool = False
)
```

UDP transport for sending and receiving LIFX packets.

This class provides a simple interface for UDP communication with LIFX devices. It uses asyncio for async I/O operations.

| PARAMETER   | DESCRIPTION                                                                         |
| ----------- | ----------------------------------------------------------------------------------- |
| `port`      | Local port to bind to (0 for automatic assignment) **TYPE:** `int` **DEFAULT:** `0` |
| `broadcast` | Enable broadcast mode for device discovery **TYPE:** `bool` **DEFAULT:** `False`    |

| METHOD         | DESCRIPTION                                     |
| -------------- | ----------------------------------------------- |
| `open`         | Open the UDP socket.                            |
| `send`         | Send data to a specific address.                |
| `receive`      | Receive data from socket with size validation.  |
| `receive_many` | Receive multiple packets within timeout period. |
| `close`        | Close the UDP socket.                           |

| ATTRIBUTE | DESCRIPTION                               |
| --------- | ----------------------------------------- |
| `is_open` | Check if socket is open. **TYPE:** `bool` |

Source code in `src/lifx/network/transport.py`

```python
def __init__(
    self,
    ip_address: str = DEFAULT_IP_ADDRESS,
    port: int = 0,
    broadcast: bool = False,
) -> None:
    """Initialize UDP transport.

    Args:
        port: Local port to bind to (0 for automatic assignment)
        broadcast: Enable broadcast mode for device discovery
    """
    self._ip_address = ip_address
    self._port = port
    self._broadcast = broadcast
    self._protocol: _UdpProtocol | None = None
    self._transport: DatagramTransport | None = None
```

#### Attributes

##### is_open

```python
is_open: bool
```

Check if socket is open.

#### Functions

##### open

```python
open() -> None
```

Open the UDP socket.

Source code in `src/lifx/network/transport.py`

```python
async def open(self) -> None:
    """Open the UDP socket."""
    if self._protocol is not None:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "already_open",
                "ip_address": self._ip_address,
                "port": self._port,
            }
        )
        return

    try:
        import socket as stdlib_socket

        loop = asyncio.get_running_loop()

        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "opening_socket",
                "ip_address": self._ip_address,
                "port": self._port,
                "broadcast": self._broadcast,
            }
        )

        # Create protocol
        protocol = _UdpProtocol()
        self._protocol = protocol

        # Create datagram endpoint
        self._transport, _ = await loop.create_datagram_endpoint(
            lambda: protocol,
            local_addr=(self._ip_address, self._port),
            reuse_port=bool(hasattr(stdlib_socket, "SO_REUSEPORT")),
            family=stdlib_socket.AF_INET,
        )

        # Get actual port assigned
        actual_port = self._transport.get_extra_info("sockname")[1]
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "socket_opened",
                "assigned_port": actual_port,
                "broadcast": self._broadcast,
            }
        )

        # Enable broadcast if requested
        if self._broadcast:
            sock = self._transport.get_extra_info("socket")
            if sock:
                sock.setsockopt(
                    stdlib_socket.SOL_SOCKET,
                    stdlib_socket.SO_BROADCAST,
                    1,
                )
                _LOGGER.debug(
                    {
                        "class": "UdpTransport",
                        "method": "open",
                        "action": "broadcast_enabled",
                    }
                )

    except OSError as e:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "failed",
                "ip_address": self._ip_address,
                "port": self._port,
                "reason": str(e),
            }
        )
        raise LifxNetworkError(f"Failed to open UDP socket: {e}") from e
```

##### send

```python
send(data: bytes, address: tuple[str, int]) -> None
```

Send data to a specific address.

| PARAMETER | DESCRIPTION                                       |
| --------- | ------------------------------------------------- |
| `data`    | Bytes to send **TYPE:** `bytes`                   |
| `address` | Tuple of (host, port) **TYPE:** `tuple[str, int]` |

| RAISES         | DESCRIPTION                         |
| -------------- | ----------------------------------- |
| `NetworkError` | If socket is not open or send fails |

Source code in `src/lifx/network/transport.py`

```python
async def send(self, data: bytes, address: tuple[str, int]) -> None:
    """Send data to a specific address.

    Args:
        data: Bytes to send
        address: Tuple of (host, port)

    Raises:
        NetworkError: If socket is not open or send fails
    """
    if self._transport is None or self._protocol is None:
        raise LifxNetworkError("Socket not open")

    try:
        self._transport.sendto(data, address)
    except OSError as e:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "send",
                "action": "failed",
                "destination": address,
                "packet_size": len(data),
                "reason": str(e),
            }
        )
        raise LifxNetworkError(f"Failed to send data: {e}") from e
```

##### receive

```python
receive(timeout: float = 2.0) -> tuple[bytes, tuple[str, int]]
```

Receive data from socket with size validation.

| PARAMETER | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `timeout` | Timeout in seconds **TYPE:** `float` **DEFAULT:** `2.0` |

| RETURNS                         | DESCRIPTION                                            |
| ------------------------------- | ------------------------------------------------------ |
| `tuple[bytes, tuple[str, int]]` | Tuple of (data, address) where address is (host, port) |

| RAISES             | DESCRIPTION                            |
| ------------------ | -------------------------------------- |
| `LifxTimeoutError` | If no data received within timeout     |
| `NetworkError`     | If socket is not open or receive fails |
| `ProtocolError`    | If packet size is invalid              |

Source code in `src/lifx/network/transport.py`

```python
async def receive(self, timeout: float = 2.0) -> tuple[bytes, tuple[str, int]]:
    """Receive data from socket with size validation.

    Args:
        timeout: Timeout in seconds

    Returns:
        Tuple of (data, address) where address is (host, port)

    Raises:
        LifxTimeoutError: If no data received within timeout
        NetworkError: If socket is not open or receive fails
        ProtocolError: If packet size is invalid
    """
    if self._protocol is None:
        raise LifxNetworkError("Socket not open")

    try:
        async with asyncio.timeout(timeout):
            data, addr = await self._protocol.queue.get()

            # Validate packet size
            if len(data) > MAX_PACKET_SIZE:
                from lifx.exceptions import LifxProtocolError

                _LOGGER.error(
                    {
                        "class": "UdpTransport",
                        "method": "receive",
                        "action": "packet_too_large",
                        "packet_size": len(data),
                        "max_size": MAX_PACKET_SIZE,
                    }
                )
                raise LifxProtocolError(
                    f"Packet too big: {len(data)} bytes > {MAX_PACKET_SIZE} bytes"
                )

            if len(data) < MIN_PACKET_SIZE:
                from lifx.exceptions import LifxProtocolError

                _LOGGER.error(
                    {
                        "class": "UdpTransport",
                        "method": "receive",
                        "action": "packet_too_small",
                        "packet_size": len(data),
                        "min_size": MIN_PACKET_SIZE,
                    }
                )
                raise LifxProtocolError(
                    f"Packet too small: {len(data)} bytes < {MIN_PACKET_SIZE} bytes"
                )

            return data, addr
    except TimeoutError as e:
        raise LifxTimeoutError(f"No data received within {timeout}s") from e
    except OSError as e:
        _LOGGER.error(
            {
                "class": "UdpTransport",
                "method": "receive",
                "action": "failed",
                "reason": str(e),
            }
        )
        raise LifxNetworkError(f"Failed to receive data: {e}") from e
```

##### receive_many

```python
receive_many(
    timeout: float = 5.0, max_packets: int | None = None
) -> list[tuple[bytes, tuple[str, int]]]
```

Receive multiple packets within timeout period.

| PARAMETER     | DESCRIPTION                                                               |
| ------------- | ------------------------------------------------------------------------- |
| `timeout`     | Total timeout in seconds **TYPE:** `float` **DEFAULT:** `5.0`             |
| `max_packets` | Maximum number of packets to receive (None for unlimited) **TYPE:** \`int |

| RETURNS                               | DESCRIPTION                    |
| ------------------------------------- | ------------------------------ |
| `list[tuple[bytes, tuple[str, int]]]` | List of (data, address) tuples |

| RAISES         | DESCRIPTION           |
| -------------- | --------------------- |
| `NetworkError` | If socket is not open |

Source code in `src/lifx/network/transport.py`

```python
async def receive_many(
    self, timeout: float = 5.0, max_packets: int | None = None
) -> list[tuple[bytes, tuple[str, int]]]:
    """Receive multiple packets within timeout period.

    Args:
        timeout: Total timeout in seconds
        max_packets: Maximum number of packets to receive (None for unlimited)

    Returns:
        List of (data, address) tuples

    Raises:
        NetworkError: If socket is not open
    """
    if self._protocol is None:
        raise LifxNetworkError("Socket not open")

    packets: list[tuple[bytes, tuple[str, int]]] = []

    try:
        async with asyncio.timeout(timeout):
            while True:
                if max_packets is not None and len(packets) >= max_packets:
                    break

                try:
                    data, addr = await self._protocol.queue.get()

                    # Validate packet size
                    if len(data) > MAX_PACKET_SIZE:
                        # Drop oversized packet to prevent memory exhaustion DoS
                        continue

                    if len(data) < MIN_PACKET_SIZE:
                        # Drop undersized packet (header is 36 bytes)
                        continue

                    packets.append((data, addr))
                except OSError:
                    # Ignore individual receive errors
                    break

    except TimeoutError:
        # Timeout is expected - return what we collected
        pass

    return packets
```

##### close

```python
close() -> None
```

Close the UDP socket.

Source code in `src/lifx/network/transport.py`

```python
async def close(self) -> None:
    """Close the UDP socket."""
    if self._transport is not None:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "close",
                "action": "closing",
            }
        )
        self._transport.close()
        self._transport = None
        self._protocol = None
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "close",
                "action": "closed",
            }
        )
```

## Message Building

Utilities for building and parsing LIFX protocol messages.

### MessageBuilder

```python
MessageBuilder(source: int | None = None)
```

Builder for creating LIFX messages with consistent source and sequence.

This class maintains state for source ID and sequence numbers, making it easier to create multiple messages from the same client.

| PARAMETER | DESCRIPTION                                        |
| --------- | -------------------------------------------------- |
| `source`  | Client identifier (random if None) **TYPE:** \`int |

| METHOD           | DESCRIPTION                                        |
| ---------------- | -------------------------------------------------- |
| `create_message` | Create a message with auto-incrementing sequence.  |
| `next_sequence`  | Get the next sequence number without incrementing. |

Source code in `src/lifx/network/message.py`

```python
def __init__(self, source: int | None = None) -> None:
    """Initialize message builder.

    Args:
        source: Client identifier (random if None)
    """
    self.source = (
        source if source is not None else secrets.randbelow(0xFFFFFFFF) + 1
    )
    self._sequence = 0
```

#### Functions

##### create_message

```python
create_message(
    packet: Any,
    target: bytes = b"\x00" * 8,
    ack_required: bool = False,
    res_required: bool = True,
) -> bytes
```

Create a message with auto-incrementing sequence.

| PARAMETER      | DESCRIPTION                                                                |
| -------------- | -------------------------------------------------------------------------- |
| `packet`       | Packet dataclass instance **TYPE:** `Any`                                  |
| `target`       | Device serial number in bytes **TYPE:** `bytes` **DEFAULT:** `b'\x00' * 8` |
| `ack_required` | Request acknowledgement **TYPE:** `bool` **DEFAULT:** `False`              |
| `res_required` | Request response **TYPE:** `bool` **DEFAULT:** `True`                      |

| RETURNS | DESCRIPTION            |
| ------- | ---------------------- |
| `bytes` | Complete message bytes |

Source code in `src/lifx/network/message.py`

```python
def create_message(
    self,
    packet: Any,
    target: bytes = b"\x00" * 8,
    ack_required: bool = False,
    res_required: bool = True,
) -> bytes:
    """Create a message with auto-incrementing sequence.

    Args:
        packet: Packet dataclass instance
        target: Device serial number in bytes
        ack_required: Request acknowledgement
        res_required: Request response

    Returns:
        Complete message bytes
    """
    msg = create_message(
        packet=packet,
        source=self.source,
        target=target,
        sequence=self._sequence,
        ack_required=ack_required,
        res_required=res_required,
    )
    self._sequence = (self._sequence + 1) % 256
    return msg
```

##### next_sequence

```python
next_sequence() -> int
```

Get the next sequence number without incrementing.

| RETURNS | DESCRIPTION          |
| ------- | -------------------- |
| `int`   | Next sequence number |

Source code in `src/lifx/network/message.py`

```python
def next_sequence(self) -> int:
    """Get the next sequence number without incrementing.

    Returns:
        Next sequence number
    """
    return self._sequence
```

## Examples

### Device Discovery

```python
from lifx.network.discovery import discover_devices


async def main():
    # Discover all devices on the network
    devices = await discover_devices(timeout=3.0)

    for device in devices:
        print(f"Found: {device.label} at {device.ip}")
        print(f"  Serial: {device.serial}")
        print(f"  Service: {device.service}")
```

## Concurrency

### Concurrent Requests on Single Connection

Each `DeviceConnection` supports true concurrent requests using a background response dispatcher:

```python
import asyncio
from lifx.network.connection import DeviceConnection
from lifx.protocol.packets import LightGet, LightGetPower, DeviceGetLabel


async def main():
    async with DeviceConnection(serial, ip) as conn:
        # Multiple requests execute concurrently
        state, power, label = await asyncio.gather(
            conn.request_response(LightGet(), LightState),
            conn.request_response(LightGetPower(), LightStatePower),
            conn.request_response(DeviceGetLabel(), DeviceStateLabel),
        )
```

### Concurrent Requests on Different Devices

```python
import asyncio
from lifx.network.connection import DeviceConnection


async def main():
    async with DeviceConnection(serial1, ip1) as conn1, DeviceConnection(
        serial2, ip2
    ) as conn2:
        # Fully parallel - different UDP sockets
        result1, result2 = await asyncio.gather(
            conn1.request_response(...), conn2.request_response(...)
        )
```

## Connection Management

### DeviceConnection

```python
DeviceConnection(
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    source: int | None = None,
    max_retries: int = 3,
    timeout: float = 1.0,
)
```

Handle to a device connection (lightweight, user-facing).

This is a lightweight handle that internally uses a class-level connection pool. Multiple DeviceConnection instances with the same serial/ip/port will share the same underlying connection.

All connection management (pooling, opening, closing) is internal and completely hidden from Device classes.

Device classes just call

await self.connection.request(packet)

Example

```python
conn = DeviceConnection(serial="d073d5123456", ip="192.168.1.100")
state = await conn.request(packets.Light.GetColor())
# state.label is already decoded to string
# state.color is LightHsbk instance
```

This is lightweight - doesn't actually create a connection. Connection is created/retrieved from pool on first request().

| PARAMETER     | DESCRIPTION                                                                          |
| ------------- | ------------------------------------------------------------------------------------ |
| `serial`      | Device serial number as 12-digit hex string **TYPE:** `str`                          |
| `ip`          | Device IP address **TYPE:** `str`                                                    |
| `port`        | Device UDP port (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT` |
| `source`      | Client source identifier (random if None) **TYPE:** \`int                            |
| `max_retries` | Maximum retry attempts **TYPE:** `int` **DEFAULT:** `3`                              |
| `timeout`     | Overall timeout for requests in seconds **TYPE:** `float` **DEFAULT:** `1.0`         |

| METHOD                  | DESCRIPTION                                   |
| ----------------------- | --------------------------------------------- |
| `close_all_connections` | Close all connections in the shared pool.     |
| `get_pool_metrics`      | Get connection pool metrics.                  |
| `request`               | Send request and return unpacked response(s). |

Source code in `src/lifx/network/connection.py`

```python
def __init__(
    self,
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    source: int | None = None,
    max_retries: int = 3,
    timeout: float = 1.0,
) -> None:
    """Initialize connection handle.

    This is lightweight - doesn't actually create a connection.
    Connection is created/retrieved from pool on first request().

    Args:
        serial: Device serial number as 12-digit hex string
        ip: Device IP address
        port: Device UDP port (default LIFX_UDP_PORT)
        source: Client source identifier (random if None)
        max_retries: Maximum retry attempts
        timeout: Overall timeout for requests in seconds
    """
    self.serial = serial
    self.ip = ip
    self.port = port
    self.source = source
    self.max_retries = max_retries
    self.timeout = timeout
```

#### Functions

##### close_all_connections

```python
close_all_connections() -> None
```

Close all connections in the shared pool.

Call this at application shutdown for clean teardown.

Source code in `src/lifx/network/connection.py`

```python
@classmethod
async def close_all_connections(cls) -> None:
    """Close all connections in the shared pool.

    Call this at application shutdown for clean teardown.
    """
    async with cls._pool_lock:
        if cls._pool is not None:
            await cls._pool.close_all()
            cls._pool = None
```

##### get_pool_metrics

```python
get_pool_metrics() -> ConnectionPoolMetrics | None
```

Get connection pool metrics.

| RETURNS                 | DESCRIPTION |
| ----------------------- | ----------- |
| \`ConnectionPoolMetrics | None\`      |

Source code in `src/lifx/network/connection.py`

```python
@classmethod
def get_pool_metrics(cls) -> ConnectionPoolMetrics | None:
    """Get connection pool metrics.

    Returns:
        ConnectionPoolMetrics if pool exists, None otherwise
    """
    return cls._pool.metrics if cls._pool is not None else None
```

##### request

```python
request(
    packet: Any, timeout: float = 2.0, collect_multiple: bool = False
) -> Any
```

Send request and return unpacked response(s).

This method handles everything internally:

- Getting connection from pool (creates if needed)
- Opening connection if needed
- Sending request with proper ack/response flags
- Optionally collecting multiple responses if requested
- Unpacking response(s)
- Decoding label fields

Device classes just call this and get back the result.

By default, GET requests return immediately after the first response. Set collect_multiple=True for multi-response commands to wait 200ms.

| PARAMETER          | DESCRIPTION                                                                                   |
| ------------------ | --------------------------------------------------------------------------------------------- |
| `packet`           | Packet instance to send **TYPE:** `Any`                                                       |
| `timeout`          | Request timeout in seconds **TYPE:** `float` **DEFAULT:** `2.0`                               |
| `collect_multiple` | Whether to wait for multiple responses (default: False) **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS | DESCRIPTION                                                         |
| ------- | ------------------------------------------------------------------- |
| `Any`   | Single or multiple response packets (list if collect_multiple=True) |
| `Any`   | True for SET acknowledgement                                        |

| RAISES                        | DESCRIPTION                   |
| ----------------------------- | ----------------------------- |
| `LifxTimeoutError`            | If request times out          |
| `LifxProtocolError`           | If response invalid           |
| `LifxConnectionError`         | If connection fails           |
| `LifxUnsupportedCommandError` | If packet kind is unsupported |

Example

```python
# GET request returns unpacked packet
state = await conn.request(packets.Light.GetColor())
color = HSBK.from_protocol(state.color)
label = state.label  # Already decoded to string

# SET request returns True
success = await conn.request(
    packets.Light.SetColor(color=hsbk, duration=1000)
)

# Multi-response GET - collect multiple responses
states = await conn.request(
    packets.MultiZone.GetColorZones(...), collect_multiple=True
)
if isinstance(states, list):
    for state in states:
        # process each zone state
        pass
else:
    # single response
    pass
```

Source code in `src/lifx/network/connection.py`

````python
async def request(
    self, packet: Any, timeout: float = 2.0, collect_multiple: bool = False
) -> Any:
    """Send request and return unpacked response(s).

    This method handles everything internally:
    - Getting connection from pool (creates if needed)
    - Opening connection if needed
    - Sending request with proper ack/response flags
    - Optionally collecting multiple responses if requested
    - Unpacking response(s)
    - Decoding label fields

    Device classes just call this and get back the result.

    By default, GET requests return immediately after the first response.
    Set collect_multiple=True for multi-response commands to wait 200ms.

    Args:
        packet: Packet instance to send
        timeout: Request timeout in seconds
        collect_multiple: Whether to wait for multiple responses (default: False)

    Returns:
        Single or multiple response packets (list if collect_multiple=True)
        True for SET acknowledgement

    Raises:
        LifxTimeoutError: If request times out
        LifxProtocolError: If response invalid
        LifxConnectionError: If connection fails
        LifxUnsupportedCommandError: If packet kind is unsupported

    Example:
        ```python
        # GET request returns unpacked packet
        state = await conn.request(packets.Light.GetColor())
        color = HSBK.from_protocol(state.color)
        label = state.label  # Already decoded to string

        # SET request returns True
        success = await conn.request(
            packets.Light.SetColor(color=hsbk, duration=1000)
        )

        # Multi-response GET - collect multiple responses
        states = await conn.request(
            packets.MultiZone.GetColorZones(...), collect_multiple=True
        )
        if isinstance(states, list):
            for state in states:
                # process each zone state
                pass
        else:
            # single response
            pass
        ```
    """

    # Get pool and retrieve actual connection
    pool = await self._get_pool()
    actual_conn = await pool.get_connection(
        serial=self.serial,
        ip=self.ip,
        port=self.port,
        source=self.source,
        max_retries=self.max_retries,
        timeout=self.timeout,
    )

    # Get packet metadata
    packet_kind = getattr(packet, "_packet_kind", "OTHER")

    if packet_kind == "GET":
        # Request response(s) - with optional multi-response collection
        response = await actual_conn.request_response(
            packet, timeout=timeout, collect_multiple=collect_multiple
        )

        # Use PACKET_REGISTRY to find the appropriate packet class
        from lifx.protocol.packets import get_packet_class

        # Check if we got multiple responses or a single response
        if isinstance(response, list):
            # Multiple responses - unpack each one
            unpacked_responses = []
            for header, payload in response:
                packet_class = get_packet_class(header.pkt_type)
                if packet_class is None:
                    raise LifxProtocolError(
                        f"Unknown packet type {header.pkt_type} in response"
                    )

                # Unpack (labels are automatically decoded by Packet.unpack())
                response_packet = packet_class.unpack(payload)
                unpacked_responses.append(response_packet)

            # Log the full request/reply cycle (multiple responses)
            request_values = packet.as_dict
            reply_values_by_seq: dict[int, dict[str, Any]] = {}
            for i, (header, _) in enumerate(response, 1):
                resp_pkt = unpacked_responses[i - 1]
                reply_values_by_seq[header.sequence] = resp_pkt.as_dict

            _LOGGER.debug(
                {
                    "class": "DeviceConnection",
                    "method": "request",
                    "request": {
                        "packet": type(packet).__name__,
                        "values": request_values,
                    },
                    "reply": {
                        "packet": type(unpacked_responses[0]).__name__
                        if unpacked_responses
                        else "Unknown",
                        "expected": len(response),
                        "received": len(unpacked_responses),
                        "values": reply_values_by_seq,
                    },
                    "serial": self.serial,
                    "ip": self.ip,
                }
            )

            return unpacked_responses
        else:
            # Single response - response is tuple[LifxHeader, bytes]
            header, payload = response
            packet_class = get_packet_class(header.pkt_type)
            if packet_class is None:
                raise LifxProtocolError(
                    f"Unknown packet type {header.pkt_type} in response"
                )

            # Update unknown serial with value from response header
            serial = Serial(value=header.target_serial).to_string()
            if self.serial == "000000000000" and serial != self.serial:
                self.serial = serial

            # Unpack (labels are automatically decoded by Packet.unpack())
            response_packet = packet_class.unpack(payload)

            # Log the full request/reply cycle (single response)
            request_values = packet.as_dict
            reply_values = response_packet.as_dict
            _LOGGER.debug(
                {
                    "class": "DeviceConnection",
                    "method": "request",
                    "request": {
                        "packet": type(packet).__name__,
                        "values": request_values,
                    },
                    "reply": {
                        "packet": type(response_packet).__name__,
                        "values": reply_values,
                    },
                    "serial": self.serial,
                    "ip": self.ip,
                }
            )

            return response_packet

    elif packet_kind == "SET":
        # Request acknowledgement
        await actual_conn.request_ack(packet, timeout=timeout)

        # Log the full request/ack cycle
        request_values = packet.as_dict
        _LOGGER.debug(
            {
                "class": "DeviceConnection",
                "method": "request",
                "request": {
                    "packet": type(packet).__name__,
                    "values": request_values,
                },
                "reply": {
                    "packet": "Acknowledgement",
                    "values": {},
                },
                "serial": self.serial,
                "ip": self.ip,
            }
        )

        return True

    else:
        # Handle special cases
        if hasattr(packet, "PKT_TYPE"):
            pkt_type = packet.PKT_TYPE
            # EchoRequest/EchoResponse (58/59)
            if pkt_type == 58:  # EchoRequest
                from lifx.protocol.packets import Device

                response = await actual_conn.request_response(
                    packet, timeout=timeout, collect_multiple=False
                )
                if not isinstance(response, tuple):
                    raise LifxProtocolError(
                        "Expected single response tuple for EchoRequest"
                    )

                header, payload = response
                response_packet = Device.EchoResponse.unpack(payload)

                # Log the full request/reply cycle
                request_values = packet.as_dict
                reply_values = response_packet.as_dict
                _LOGGER.debug(
                    {
                        "class": "DeviceConnection",
                        "method": "request",
                        "request": {
                            "packet": type(packet).__name__,
                            "values": request_values,
                        },
                        "reply": {
                            "packet": type(response_packet).__name__,
                            "values": reply_values,
                        },
                        "serial": self.serial,
                        "ip": self.ip,
                    }
                )

                return response_packet
            else:
                raise LifxUnsupportedCommandError(
                    f"Cannot auto-handle packet kind: {packet_kind}"
                )
        else:
            raise LifxProtocolError(
                f"Packet missing PKT_TYPE: {type(packet).__name__}"
            )
````

## Performance Considerations

### Connection Pooling

- Connections are cached with LRU eviction
- Default pool size: 100 connections
- Idle connections are automatically closed after timeout
- Pool metrics available via `get_pool_metrics()`

### Response Handling

- Background receiver task runs continuously
- Responses matched by sequence number
- Minimal overhead per concurrent request (~100 bytes)
- Clean shutdown on connection close

### Rate Limiting

The library **intentionally does not implement rate limiting** to keep the core library simple. Applications should implement their own rate limiting if needed. According to the LIFX protocol specification, devices can handle approximately 20 messages per second.

# Protocol Layer

The protocol layer contains auto-generated structures from the official LIFX protocol specification. These classes handle binary serialization and deserialization of LIFX messages.

!!! warning "Auto-Generated Code" Files in the protocol layer are automatically generated from `protocol.yml`. Never edit these files directly. To update the protocol, download the latest `protocol.yml` from the [LIFX public-protocol repository](https://github.com/LIFX/public-protocol) and run `uv run python -m lifx.protocol.generator`.

## Base Packet

The base class for all protocol packets.

### Packet

```python
Packet()
```

Base class for all LIFX protocol packets.

Each packet subclass defines:

- PKT_TYPE: ClassVar[int] - The packet type number
- \_fields: ClassVar\[list[dict]\] - Field metadata from protocol.yml
- Actual field attributes as dataclass fields

| METHOD   | DESCRIPTION                                    |
| -------- | ---------------------------------------------- |
| `pack`   | Pack packet to bytes using field metadata.     |
| `unpack` | Unpack packet from bytes using field metadata. |

| ATTRIBUTE | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `as_dict` | Return packet as dictionary. **TYPE:** `dict[str, Any]` |

#### Attributes

##### as_dict

```python
as_dict: dict[str, Any]
```

Return packet as dictionary.

#### Functions

##### pack

```python
pack() -> bytes
```

Pack packet to bytes using field metadata.

| RETURNS | DESCRIPTION                                          |
| ------- | ---------------------------------------------------- |
| `bytes` | Packed bytes ready to send in a LIFX message payload |

Source code in `src/lifx/protocol/base.py`

```python
def pack(self) -> bytes:
    """Pack packet to bytes using field metadata.

    Returns:
        Packed bytes ready to send in a LIFX message payload
    """
    from lifx.protocol import serializer

    result = b""

    for field_item in self._fields:
        # Handle reserved fields (no name)
        if "name" not in field_item:
            size_bytes = field_item.get("size_bytes", 0)
            result += serializer.pack_reserved(size_bytes)
            continue

        # Get field value from instance
        field_name = self._protocol_to_python_name(field_item["name"])
        value = getattr(self, field_name)

        # Pack based on type
        field_type = field_item["type"]
        size_bytes = field_item.get("size_bytes", 0)
        result += self._pack_field_value(value, field_type, size_bytes)

    return result
```

##### unpack

```python
unpack(data: bytes, offset: int = 0) -> Packet
```

Unpack packet from bytes using field metadata.

| PARAMETER | DESCRIPTION                                                         |
| --------- | ------------------------------------------------------------------- |
| `data`    | Bytes to unpack from **TYPE:** `bytes`                              |
| `offset`  | Offset in bytes to start unpacking **TYPE:** `int` **DEFAULT:** `0` |

| RETURNS  | DESCRIPTION                                          |
| -------- | ---------------------------------------------------- |
| `Packet` | Packet instance with label fields decoded to strings |

Source code in `src/lifx/protocol/base.py`

```python
@classmethod
def unpack(cls, data: bytes, offset: int = 0) -> Packet:
    """Unpack packet from bytes using field metadata.

    Args:
        data: Bytes to unpack from
        offset: Offset in bytes to start unpacking

    Returns:
        Packet instance with label fields decoded to strings
    """
    packet, _ = cls._unpack_internal(data, offset)

    # Decode label fields from bytes to string in-place
    # This ensures all State packets have human-readable labels
    cls._decode_labels_inplace(packet)

    # Log packet values after unpacking and decoding labels
    packet_values = asdict(packet)
    _LOGGER.debug(
        {
            "class": "Packet",
            "method": "unpack",
            "packet_type": type(packet).__name__,
            "values": packet_values,
        }
    )

    return packet
```

## Protocol Header

The LIFX protocol header structure (36 bytes).

### LifxHeader

```python
LifxHeader(
    size: int,
    protocol: int,
    source: int,
    target: bytes,
    tagged: bool,
    ack_required: bool,
    res_required: bool,
    sequence: int,
    pkt_type: int,
)
```

LIFX protocol header (36 bytes).

| ATTRIBUTE      | DESCRIPTION                                                                                                                                                                                      |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `size`         | Total packet size in bytes (header + payload) **TYPE:** `int`                                                                                                                                    |
| `protocol`     | Protocol number (must be 1024) **TYPE:** `int`                                                                                                                                                   |
| `source`       | Unique client identifier **TYPE:** `int`                                                                                                                                                         |
| `target`       | Device serial number (6 or 8 bytes, automatically padded to 8 bytes) Note: This is the LIFX serial number, which is often but not always the same as the device's MAC address. **TYPE:** `bytes` |
| `tagged`       | True for broadcast discovery, False for targeted messages **TYPE:** `bool`                                                                                                                       |
| `ack_required` | Request acknowledgement from device **TYPE:** `bool`                                                                                                                                             |
| `res_required` | Request response from device **TYPE:** `bool`                                                                                                                                                    |
| `sequence`     | Sequence number for matching requests/responses **TYPE:** `int`                                                                                                                                  |
| `pkt_type`     | Packet type identifier **TYPE:** `int`                                                                                                                                                           |

| METHOD          | DESCRIPTION                                                  |
| --------------- | ------------------------------------------------------------ |
| `__post_init__` | Validate header fields and auto-pad serial number if needed. |
| `create`        | Create a new LIFX header.                                    |
| `pack`          | Pack header into 36 bytes.                                   |
| `unpack`        | Unpack header from bytes.                                    |
| `__repr__`      | String representation of header.                             |

#### Attributes

##### target_serial

```python
target_serial: bytes
```

Get the 6-byte serial number without padding.

| RETURNS | DESCRIPTION          |
| ------- | -------------------- |
| `bytes` | 6-byte serial number |

#### Functions

##### __post_init__

```python
__post_init__() -> None
```

Validate header fields and auto-pad serial number if needed.

Source code in `src/lifx/protocol/header.py`

```python
def __post_init__(self) -> None:
    """Validate header fields and auto-pad serial number if needed."""
    # Auto-pad serial number if 6 bytes
    if len(self.target) == 6:
        self.target = self.target + b"\x00\x00"
    elif len(self.target) != 8:
        raise ValueError(f"Target must be 6 or 8 bytes, got {len(self.target)}")

    if self.protocol != self.PROTOCOL_NUMBER:
        raise ValueError(
            f"Protocol must be {self.PROTOCOL_NUMBER}, got {self.protocol}"
        )
    if self.sequence > 255:
        raise ValueError(f"Sequence must be 0-255, got {self.sequence}")
```

##### create

```python
create(
    pkt_type: int,
    source: int,
    target: bytes = b"\x00" * 6,
    tagged: bool = False,
    ack_required: bool = False,
    res_required: bool = True,
    sequence: int = 0,
    payload_size: int = 0,
) -> LifxHeader
```

Create a new LIFX header.

| PARAMETER      | DESCRIPTION                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------- |
| `pkt_type`     | Packet type identifier **TYPE:** `int`                                                                  |
| `source`       | Unique client identifier **TYPE:** `int`                                                                |
| `target`       | Device serial number (6 or 8 bytes, defaults to broadcast) **TYPE:** `bytes` **DEFAULT:** `b'\x00' * 6` |
| `tagged`       | True for broadcast, False for targeted **TYPE:** `bool` **DEFAULT:** `False`                            |
| `ack_required` | Request acknowledgement **TYPE:** `bool` **DEFAULT:** `False`                                           |
| `res_required` | Request response **TYPE:** `bool` **DEFAULT:** `True`                                                   |
| `sequence`     | Sequence number for matching requests/responses **TYPE:** `int` **DEFAULT:** `0`                        |
| `payload_size` | Size of packet payload in bytes **TYPE:** `int` **DEFAULT:** `0`                                        |

| RETURNS      | DESCRIPTION         |
| ------------ | ------------------- |
| `LifxHeader` | LifxHeader instance |

Source code in `src/lifx/protocol/header.py`

```python
@classmethod
def create(
    cls,
    pkt_type: int,
    source: int,
    target: bytes = b"\x00" * 6,
    tagged: bool = False,
    ack_required: bool = False,
    res_required: bool = True,
    sequence: int = 0,
    payload_size: int = 0,
) -> LifxHeader:
    """Create a new LIFX header.

    Args:
        pkt_type: Packet type identifier
        source: Unique client identifier
        target: Device serial number (6 or 8 bytes, defaults to broadcast)
        tagged: True for broadcast, False for targeted
        ack_required: Request acknowledgement
        res_required: Request response
        sequence: Sequence number for matching requests/responses
        payload_size: Size of packet payload in bytes

    Returns:
        LifxHeader instance
    """
    return cls(
        size=cls.HEADER_SIZE + payload_size,
        protocol=cls.PROTOCOL_NUMBER,
        source=source,
        target=target,  # __post_init__ will auto-pad if needed
        tagged=tagged,
        ack_required=ack_required,
        res_required=res_required,
        sequence=sequence,
        pkt_type=pkt_type,
    )
```

##### pack

```python
pack() -> bytes
```

Pack header into 36 bytes.

| RETURNS | DESCRIPTION         |
| ------- | ------------------- |
| `bytes` | Packed header bytes |

Source code in `src/lifx/protocol/header.py`

```python
def pack(self) -> bytes:
    """Pack header into 36 bytes.

    Returns:
        Packed header bytes
    """
    # Frame (8 bytes)
    # Byte 0-1: size (uint16)
    # Byte 2-3: origin + tagged + addressable + protocol bits
    # Byte 4-7: source (uint32)

    # Pack protocol field with flags
    protocol_field = (
        (self.ORIGIN & 0b11) << 14
        | (int(self.tagged) & 0b1) << 13
        | (self.ADDRESSABLE & 0b1) << 12
        | (self.protocol & 0xFFF)
    )

    frame = struct.pack("<HHI", self.size, protocol_field, self.source)

    # Frame Address (16 bytes)
    # Byte 0-7: target (uint64)
    # Byte 8-13: reserved (6 bytes)
    # Byte 14: res_required (bit 0) + ack_required (bit 1) + reserved (6 bits)
    # Byte 15: sequence (uint8)

    flags = (int(self.res_required) & 0b1) | ((int(self.ack_required) & 0b1) << 1)

    frame_addr = struct.pack(
        "<Q6sBB",
        int.from_bytes(self.target, byteorder="little"),
        b"\x00" * 6,  # reserved
        flags,
        self.sequence,
    )

    # Protocol Header (12 bytes)
    # Byte 0-7: reserved (uint64)
    # Byte 8-9: type (uint16)
    # Byte 10-11: reserved (uint16)

    protocol_header = struct.pack("<QHH", 0, self.pkt_type, 0)

    return frame + frame_addr + protocol_header
```

##### unpack

```python
unpack(data: bytes) -> LifxHeader
```

Unpack header from bytes.

| PARAMETER | DESCRIPTION                                        |
| --------- | -------------------------------------------------- |
| `data`    | Header bytes (at least 36 bytes) **TYPE:** `bytes` |

| RETURNS      | DESCRIPTION         |
| ------------ | ------------------- |
| `LifxHeader` | LifxHeader instance |

| RAISES       | DESCRIPTION                     |
| ------------ | ------------------------------- |
| `ValueError` | If data is too short or invalid |

Source code in `src/lifx/protocol/header.py`

```python
@classmethod
def unpack(cls, data: bytes) -> LifxHeader:
    """Unpack header from bytes.

    Args:
        data: Header bytes (at least 36 bytes)

    Returns:
        LifxHeader instance

    Raises:
        ValueError: If data is too short or invalid
    """
    if len(data) < cls.HEADER_SIZE:
        raise ValueError(f"Header data must be at least {cls.HEADER_SIZE} bytes")

    # Unpack Frame (8 bytes)
    size, protocol_field, source = struct.unpack("<HHI", data[0:8])

    # Extract protocol field components
    origin = (protocol_field >> 14) & 0b11
    tagged = bool((protocol_field >> 13) & 0b1)
    addressable = bool((protocol_field >> 12) & 0b1)
    protocol = protocol_field & 0xFFF

    # Validate origin and addressable
    if origin != cls.ORIGIN:
        raise ValueError(f"Invalid origin: {origin}")
    if not addressable:
        raise ValueError("Addressable bit must be set")

    # Unpack Frame Address (16 bytes)
    target_int, _reserved, flags, sequence = struct.unpack("<Q6sBB", data[8:24])
    target = target_int.to_bytes(8, byteorder="little")

    res_required = bool(flags & 0b1)
    ack_required = bool((flags >> 1) & 0b1)

    # Unpack Protocol Header (12 bytes)
    _reserved1, pkt_type, _reserved2 = struct.unpack("<QHH", data[24:36])

    return cls(
        size=size,
        protocol=protocol,
        source=source,
        target=target,
        tagged=tagged,
        ack_required=ack_required,
        res_required=res_required,
        sequence=sequence,
        pkt_type=pkt_type,
    )
```

##### __repr__

```python
__repr__() -> str
```

String representation of header.

Source code in `src/lifx/protocol/header.py`

```python
def __repr__(self) -> str:
    """String representation of header."""
    target_serial_str = Serial(value=self.target_serial).to_string()
    return (
        f"LifxHeader(type={self.pkt_type}, size={self.size}, "
        f"source={self.source:#x}, target={target_serial_str}, "
        f"seq={self.sequence}, tagged={self.tagged}, "
        f"ack={self.ack_required}, res={self.res_required})"
    )
```

## Serializer

Binary serialization and deserialization utilities.

### FieldSerializer

```python
FieldSerializer(field_definitions: dict[str, dict[str, str]])
```

Serializer for structured fields with nested types.

| PARAMETER           | DESCRIPTION                                                                             |
| ------------------- | --------------------------------------------------------------------------------------- |
| `field_definitions` | Dict mapping field names to structure definitions **TYPE:** `dict[str, dict[str, str]]` |

| METHOD           | DESCRIPTION                                 |
| ---------------- | ------------------------------------------- |
| `pack_field`     | Pack a structured field.                    |
| `unpack_field`   | Unpack a structured field.                  |
| `get_field_size` | Get the size in bytes of a field structure. |

Source code in `src/lifx/protocol/serializer.py`

```python
def __init__(self, field_definitions: dict[str, dict[str, str]]):
    """Initialize serializer with field definitions.

    Args:
        field_definitions: Dict mapping field names to structure definitions
    """
    self.field_definitions = field_definitions
```

#### Functions

##### pack_field

```python
pack_field(field_data: dict[str, Any], field_name: str) -> bytes
```

Pack a structured field.

| PARAMETER    | DESCRIPTION                                                |
| ------------ | ---------------------------------------------------------- |
| `field_data` | Dictionary of field values **TYPE:** `dict[str, Any]`      |
| `field_name` | Name of the field structure (e.g., "HSBK") **TYPE:** `str` |

| RETURNS | DESCRIPTION  |
| ------- | ------------ |
| `bytes` | Packed bytes |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `ValueError` | If field_name is unknown |

Source code in `src/lifx/protocol/serializer.py`

```python
def pack_field(self, field_data: dict[str, Any], field_name: str) -> bytes:
    """Pack a structured field.

    Args:
        field_data: Dictionary of field values
        field_name: Name of the field structure (e.g., "HSBK")

    Returns:
        Packed bytes

    Raises:
        ValueError: If field_name is unknown
    """
    if field_name not in self.field_definitions:
        raise ValueError(f"Unknown field: {field_name}")

    field_def = self.field_definitions[field_name]
    result = b""

    for attr_name, attr_type in field_def.items():
        if attr_name not in field_data:
            raise ValueError(f"Missing attribute {attr_name} in {field_name}")
        result += pack_value(field_data[attr_name], attr_type)

    return result
```

##### unpack_field

```python
unpack_field(
    data: bytes, field_name: str, offset: int = 0
) -> tuple[dict[str, Any], int]
```

Unpack a structured field.

| PARAMETER    | DESCRIPTION                                                |
| ------------ | ---------------------------------------------------------- |
| `data`       | Bytes to unpack from **TYPE:** `bytes`                     |
| `field_name` | Name of the field structure **TYPE:** `str`                |
| `offset`     | Offset to start unpacking **TYPE:** `int` **DEFAULT:** `0` |

| RETURNS                      | DESCRIPTION                       |
| ---------------------------- | --------------------------------- |
| `tuple[dict[str, Any], int]` | Tuple of (field_dict, new_offset) |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `ValueError` | If field_name is unknown |

Source code in `src/lifx/protocol/serializer.py`

```python
def unpack_field(
    self, data: bytes, field_name: str, offset: int = 0
) -> tuple[dict[str, Any], int]:
    """Unpack a structured field.

    Args:
        data: Bytes to unpack from
        field_name: Name of the field structure
        offset: Offset to start unpacking

    Returns:
        Tuple of (field_dict, new_offset)

    Raises:
        ValueError: If field_name is unknown
    """
    if field_name not in self.field_definitions:
        raise ValueError(f"Unknown field: {field_name}")

    field_def = self.field_definitions[field_name]
    field_data: dict[str, Any] = {}
    current_offset = offset

    for attr_name, attr_type in field_def.items():
        value, current_offset = unpack_value(data, attr_type, current_offset)
        field_data[attr_name] = value

    return field_data, current_offset
```

##### get_field_size

```python
get_field_size(field_name: str) -> int
```

Get the size in bytes of a field structure.

| PARAMETER    | DESCRIPTION                                 |
| ------------ | ------------------------------------------- |
| `field_name` | Name of the field structure **TYPE:** `str` |

| RETURNS | DESCRIPTION   |
| ------- | ------------- |
| `int`   | Size in bytes |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `ValueError` | If field_name is unknown |

Source code in `src/lifx/protocol/serializer.py`

```python
def get_field_size(self, field_name: str) -> int:
    """Get the size in bytes of a field structure.

    Args:
        field_name: Name of the field structure

    Returns:
        Size in bytes

    Raises:
        ValueError: If field_name is unknown
    """
    if field_name not in self.field_definitions:
        raise ValueError(f"Unknown field: {field_name}")

    field_def = self.field_definitions[field_name]
    return sum(TYPE_SIZES[attr_type] for attr_type in field_def.values())
```

## Protocol Types

Common protocol type definitions and enums.

### HSBK Type

#### LightHsbk

```python
LightHsbk(hue: int, saturation: int, brightness: int, kelvin: int)
```

Auto-generated field structure.

| METHOD   | DESCRIPTION        |
| -------- | ------------------ |
| `pack`   | Pack to bytes.     |
| `unpack` | Unpack from bytes. |

##### Functions

###### pack

```python
pack() -> bytes
```

Pack to bytes.

Source code in `src/lifx/protocol/protocol_types.py`

```python
def pack(self) -> bytes:
    """Pack to bytes."""
    from lifx.protocol import serializer

    result = b""

    # hue: uint16
    result += serializer.pack_value(self.hue, "uint16")
    # saturation: uint16
    result += serializer.pack_value(self.saturation, "uint16")
    # brightness: uint16
    result += serializer.pack_value(self.brightness, "uint16")
    # kelvin: uint16
    result += serializer.pack_value(self.kelvin, "uint16")

    return result
```

###### unpack

```python
unpack(data: bytes, offset: int = 0) -> tuple[LightHsbk, int]
```

Unpack from bytes.

Source code in `src/lifx/protocol/protocol_types.py`

```python
@classmethod
def unpack(cls, data: bytes, offset: int = 0) -> tuple[LightHsbk, int]:
    """Unpack from bytes."""
    from lifx.protocol import serializer

    current_offset = offset
    # hue: uint16
    hue, current_offset = serializer.unpack_value(data, "uint16", current_offset)
    # saturation: uint16
    saturation, current_offset = serializer.unpack_value(
        data, "uint16", current_offset
    )
    # brightness: uint16
    brightness, current_offset = serializer.unpack_value(
        data, "uint16", current_offset
    )
    # kelvin: uint16
    kelvin, current_offset = serializer.unpack_value(data, "uint16", current_offset)

    return cls(
        hue=hue, saturation=saturation, brightness=brightness, kelvin=kelvin
    ), current_offset
```

### Light Waveform

#### LightWaveform

Bases: `IntEnum`

Auto-generated enum.

### Device Service

#### DeviceService

Bases: `IntEnum`

Auto-generated enum.

### MultiZone Application Request

#### MultiZoneApplicationRequest

Bases: `IntEnum`

Auto-generated enum.

### MultiZone Effect Type

#### MultiZoneEffectType

Bases: `IntEnum`

Auto-generated enum.

### Tile Effect Type

#### TileEffectType

Bases: `IntEnum`

Auto-generated enum.

## Packet Definitions

The protocol layer includes packet definitions for all LIFX message types. Major categories include:

### Device Messages

- `DeviceGetService` / `DeviceStateService` - Service discovery
- `DeviceGetLabel` / `DeviceStateLabel` - Device labels
- `DeviceGetPower` / `DeviceSetPower` / `DeviceStatePower` - Power control
- `DeviceGetVersion` / `DeviceStateVersion` - Firmware version
- `DeviceGetLocation` / `DeviceStateLocation` - Location groups
- `DeviceGetGroup` / `DeviceStateGroup` - Device groups
- `DeviceGetInfo` / `DeviceStateInfo` - Runtime info (uptime, downtime)

### Light Messages

- `LightGet` / `LightState` - Get/set light state
- `LightSetColor` - Set color with transition
- `LightSetWaveform` - Waveform effects (pulse, breathe)
- `LightGetPower` / `LightSetPower` / `LightStatePower` - Light power control
- `LightGetInfrared` / `LightSetInfrared` / `LightStateInfrared` - Infrared control

### MultiZone Messages

- `MultiZoneGetColorZones` / `MultiZoneStateZone` / `MultiZoneStateMultiZone` - Zone state
- `MultiZoneSetColorZones` - Set zone colors
- `MultiZoneGetMultiZoneEffect` / `MultiZoneSetMultiZoneEffect` - Zone effects

### Tile Messages

- `TileGetDeviceChain` / `TileStateDeviceChain` - Tile chain info
- `TileGet64` / `TileState64` - Get tile state
- `TileSet64` - Set tile colors
- `TileGetTileEffect` / `TileSetTileEffect` - Tile effects

## Protocol Models

Protocol data models for working with LIFX serial numbers and HEV cycles.

### Serial

Type-safe, immutable serial number handling:

#### Serial

```python
Serial(value: bytes)
```

LIFX device serial number.

Encapsulates a device serial number with conversion methods for different formats. The LIFX serial number is often the same as the device's MAC address, but can differ (particularly the least significant byte may be off by one).

| ATTRIBUTE | DESCRIPTION                                |
| --------- | ------------------------------------------ |
| `value`   | Serial number as 6 bytes **TYPE:** `bytes` |

Example

```python
# Create from string
serial = Serial.from_string("d073d5123456")

# Convert to protocol format (8 bytes with padding)
protocol_bytes = serial.to_protocol()

# Convert to string
serial_str = serial.to_string()  # "d073d5123456"

# Create from protocol format
serial2 = Serial.from_protocol(protocol_bytes)
```

| METHOD          | DESCRIPTION                                                |
| --------------- | ---------------------------------------------------------- |
| `__post_init__` | Validate serial number after initialization.               |
| `from_string`   | Create Serial from string format.                          |
| `from_protocol` | Create Serial from protocol format (8 bytes with padding). |
| `to_string`     | Convert serial to 12-digit hex string format.              |
| `to_protocol`   | Convert serial to 8-byte protocol format with padding.     |
| `__str__`       | Return string representation.                              |
| `__repr__`      | Return detailed representation.                            |

##### Functions

###### __post_init__

```python
__post_init__() -> None
```

Validate serial number after initialization.

Source code in `src/lifx/protocol/models.py`

```python
def __post_init__(self) -> None:
    """Validate serial number after initialization."""
    self._validate_type(self.value)
    self._validate_length(self.value)
```

###### from_string

```python
from_string(serial: str) -> Serial
```

Create Serial from string format.

Accepts 12-digit hex string (with or without separators).

| PARAMETER | DESCRIPTION                                                                       |
| --------- | --------------------------------------------------------------------------------- |
| `serial`  | 12-digit hex string (e.g., "d073d5123456" or "d0:73:d5:12:34:56") **TYPE:** `str` |

| RETURNS  | DESCRIPTION     |
| -------- | --------------- |
| `Serial` | Serial instance |

| RAISES       | DESCRIPTION                 |
| ------------ | --------------------------- |
| `ValueError` | If serial number is invalid |
| `TypeError`  | If serial is not a string   |

Example

> > > Serial.from_string("d073d5123456") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56') Serial.from_string("d0:73:d5:12:34:56") # Also accepts separators Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')

Source code in `src/lifx/protocol/models.py`

```python
@classmethod
def from_string(cls, serial: str) -> Serial:
    """Create Serial from string format.

    Accepts 12-digit hex string (with or without separators).

    Args:
        serial: 12-digit hex string (e.g., "d073d5123456" or "d0:73:d5:12:34:56")

    Returns:
        Serial instance

    Raises:
        ValueError: If serial number is invalid
        TypeError: If serial is not a string

    Example:
        >>> Serial.from_string("d073d5123456")
        Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')
        >>> Serial.from_string("d0:73:d5:12:34:56")  # Also accepts separators
        Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')
    """
    cls._validate_string_type(serial)
    serial_clean = cls._remove_separators(serial)
    cls._validate_hex_length(serial_clean)
    serial_bytes = cls._parse_hex(serial_clean)

    return cls(value=serial_bytes)
```

###### from_protocol

```python
from_protocol(padded_serial: bytes) -> Serial
```

Create Serial from protocol format (8 bytes with padding).

The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.

| PARAMETER       | DESCRIPTION                                          |
| --------------- | ---------------------------------------------------- |
| `padded_serial` | 8-byte serial number from protocol **TYPE:** `bytes` |

| RETURNS  | DESCRIPTION     |
| -------- | --------------- |
| `Serial` | Serial instance |

| RAISES       | DESCRIPTION                     |
| ------------ | ------------------------------- |
| `ValueError` | If padded serial is not 8 bytes |

Example

> > > Serial.from_protocol(b"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')

Source code in `src/lifx/protocol/models.py`

```python
@classmethod
def from_protocol(cls, padded_serial: bytes) -> Serial:
    """Create Serial from protocol format (8 bytes with padding).

    The LIFX protocol uses 8 bytes for the target field, with the serial number
    in the first 6 bytes and 2 bytes of padding (zeros) at the end.

    Args:
        padded_serial: 8-byte serial number from protocol

    Returns:
        Serial instance

    Raises:
        ValueError: If padded serial is not 8 bytes

    Example:
        >>> Serial.from_protocol(b"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00")
        Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')
    """
    if len(padded_serial) != 8:
        raise ValueError(
            f"Padded serial number must be 8 bytes, got {len(padded_serial)}"
        )

    # Extract first 6 bytes
    return cls(value=padded_serial[:6])
```

###### to_string

```python
to_string() -> str
```

Convert serial to 12-digit hex string format.

| RETURNS | DESCRIPTION                                                                  |
| ------- | ---------------------------------------------------------------------------- |
| `str`   | Serial number string in format "xxxxxxxxxxxx" (12 hex digits, no separators) |

Example

> > > serial = Serial.from_string("d073d5123456") serial.to_string() 'd073d5123456'

Source code in `src/lifx/protocol/models.py`

```python
def to_string(self) -> str:
    """Convert serial to 12-digit hex string format.

    Returns:
        Serial number string in format "xxxxxxxxxxxx" (12 hex digits, no separators)

    Example:
        >>> serial = Serial.from_string("d073d5123456")
        >>> serial.to_string()
        'd073d5123456'
    """
    return self.value.hex()
```

###### to_protocol

```python
to_protocol() -> bytes
```

Convert serial to 8-byte protocol format with padding.

The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.

| RETURNS | DESCRIPTION                                               |
| ------- | --------------------------------------------------------- |
| `bytes` | 8-byte serial number with padding (suitable for protocol) |

Example

> > > serial = Serial.from_string("d073d5123456") serial.to_protocol() b'\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00'

Source code in `src/lifx/protocol/models.py`

```python
def to_protocol(self) -> bytes:
    """Convert serial to 8-byte protocol format with padding.

    The LIFX protocol uses 8 bytes for the target field, with the serial number
    in the first 6 bytes and 2 bytes of padding (zeros) at the end.

    Returns:
        8-byte serial number with padding (suitable for protocol)

    Example:
        >>> serial = Serial.from_string("d073d5123456")
        >>> serial.to_protocol()
        b'\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00'
    """
    return self.value + b"\x00\x00"
```

###### __str__

```python
__str__() -> str
```

Return string representation.

Source code in `src/lifx/protocol/models.py`

```python
def __str__(self) -> str:
    """Return string representation."""
    return self.to_string()
```

###### __repr__

```python
__repr__() -> str
```

Return detailed representation.

Source code in `src/lifx/protocol/models.py`

```python
def __repr__(self) -> str:
    """Return detailed representation."""
    return f"Serial('{self.to_string()}')"
```

### HEV Cycle State

HEV (High Energy Visible) cleaning cycle state:

#### HevCycleState

```python
HevCycleState(duration_s: int, remaining_s: int, last_power: bool)
```

HEV cleaning cycle state.

Represents the current state of a HEV (High Energy Visible) cleaning cycle, which uses anti-bacterial UV-C light to sanitize the environment.

| ATTRIBUTE     | DESCRIPTION                                                            |
| ------------- | ---------------------------------------------------------------------- |
| `duration_s`  | Total duration of the cycle in seconds **TYPE:** `int`                 |
| `remaining_s` | Remaining time in the current cycle (0 if not running) **TYPE:** `int` |
| `last_power`  | Whether the light was on during the last cycle **TYPE:** `bool`        |

Example

```python
# Check if HEV cycle is running
state = await hev_light.get_hev_cycle()
if state.remaining_s > 0:
    print(f"Cleaning in progress: {state.remaining_s}s remaining")
```

##### Attributes

###### is_running

```python
is_running: bool
```

Check if a HEV cycle is currently running.

### HEV Configuration

HEV cycle configuration:

#### HevConfig

```python
HevConfig(indication: bool, duration_s: int)
```

HEV cycle configuration.

Configuration settings for HEV cleaning cycles.

| ATTRIBUTE    | DESCRIPTION                                                        |
| ------------ | ------------------------------------------------------------------ |
| `indication` | Whether to show visual indication during cleaning **TYPE:** `bool` |
| `duration_s` | Default duration for cleaning cycles in seconds **TYPE:** `int`    |

Example

```python
# Configure HEV cycle with 2-hour duration and visual indication
await hev_light.set_hev_config(indication=True, duration_seconds=7200)
```

## Code Generator

The protocol generator reads `protocol.yml` and generates Python code.

### generator

Code generator for LIFX protocol structures.

Downloads the official protocol.yml from the LIFX GitHub repository and generates Python types and packet classes. The YAML is never stored locally, only parsed and converted into protocol classes.

| CLASS          | DESCRIPTION                                    |
| -------------- | ---------------------------------------------- |
| `TypeRegistry` | Registry of all protocol types for validation. |

| FUNCTION                                 | DESCRIPTION                                                                       |
| ---------------------------------------- | --------------------------------------------------------------------------------- |
| `to_snake_case`                          | Convert PascalCase or camelCase to snake_case.                                    |
| `apply_field_name_quirks`                | Apply quirks to field names to avoid Python built-ins and reserved words.         |
| `apply_extended_multizone_packet_quirks` | Apply quirks to extended multizone packet names to follow LIFX naming convention. |
| `apply_tile_effect_parameter_quirk`      | Apply local quirk to fix TileEffectParameter structure.                           |
| `format_long_import`                     | Format a long import statement across multiple lines.                             |
| `format_long_list`                       | Format a long list across multiple lines.                                         |
| `parse_field_type`                       | Parse a field type string.                                                        |
| `camel_to_snake_upper`                   | Convert CamelCase to UPPER_SNAKE_CASE.                                            |
| `generate_enum_code`                     | Generate Python Enum definitions with shortened names.                            |
| `convert_type_to_python`                 | Convert a protocol field type to Python type annotation.                          |
| `generate_pack_method`                   | Generate pack() method code for a field structure or packet.                      |
| `generate_unpack_method`                 | Generate unpack() classmethod code for a field structure or packet.               |
| `generate_field_code`                    | Generate Python dataclass definitions for field structures.                       |
| `generate_nested_packet_code`            | Generate nested Python packet class definitions.                                  |
| `generate_types_file`                    | Generate complete types.py file.                                                  |
| `generate_packets_file`                  | Generate complete packets.py file.                                                |
| `download_protocol`                      | Download and parse protocol.yml from LIFX GitHub repository.                      |
| `validate_protocol_spec`                 | Validate protocol specification for missing type references.                      |
| `should_skip_button_relay`               | Check if a name should be skipped (Button or Relay related).                      |
| `filter_button_relay_items`              | Filter out Button and Relay items from a dictionary.                              |
| `filter_button_relay_packets`            | Filter out button and relay category packets.                                     |
| `extract_packets_as_fields`              | Extract packets that are used as field types in other structures.                 |
| `main`                                   | Main generator entry point.                                                       |

#### Classes

##### TypeRegistry

```python
TypeRegistry()
```

Registry of all protocol types for validation.

Tracks all defined types (enums, fields, packets, unions) to validate that all type references in the protocol specification are valid.

| METHOD            | DESCRIPTION                      |
| ----------------- | -------------------------------- |
| `register_enum`   | Register an enum type.           |
| `register_field`  | Register a field structure type. |
| `register_packet` | Register a packet type.          |
| `register_union`  | Register a union type.           |
| `is_enum`         | Check if a type is an enum.      |
| `has_type`        | Check if a type is defined.      |
| `get_all_types`   | Get all registered types.        |

Source code in `src/lifx/protocol/generator.py`

```python
def __init__(self) -> None:
    """Initialize empty type registry."""
    self._enums: set[str] = set()
    self._fields: set[str] = set()
    self._packets: set[str] = set()
    self._unions: set[str] = set()
    self._basic_types: set[str] = {
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "int8",
        "int16",
        "int32",
        "int64",
        "float32",
        "bool",
        "byte",
        "reserved",  # Special type for reserved fields
    }
```

###### Functions

###### register_enum

```python
register_enum(name: str) -> None
```

Register an enum type.

| PARAMETER | DESCRIPTION                    |
| --------- | ------------------------------ |
| `name`    | Enum type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_enum(self, name: str) -> None:
    """Register an enum type.

    Args:
        name: Enum type name
    """
    self._enums.add(name)
```

###### register_field

```python
register_field(name: str) -> None
```

Register a field structure type.

| PARAMETER | DESCRIPTION                               |
| --------- | ----------------------------------------- |
| `name`    | Field structure type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_field(self, name: str) -> None:
    """Register a field structure type.

    Args:
        name: Field structure type name
    """
    self._fields.add(name)
```

###### register_packet

```python
register_packet(name: str) -> None
```

Register a packet type.

| PARAMETER | DESCRIPTION                      |
| --------- | -------------------------------- |
| `name`    | Packet type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_packet(self, name: str) -> None:
    """Register a packet type.

    Args:
        name: Packet type name
    """
    self._packets.add(name)
```

###### register_union

```python
register_union(name: str) -> None
```

Register a union type.

| PARAMETER | DESCRIPTION                     |
| --------- | ------------------------------- |
| `name`    | Union type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_union(self, name: str) -> None:
    """Register a union type.

    Args:
        name: Union type name
    """
    self._unions.add(name)
```

###### is_enum

```python
is_enum(name: str) -> bool
```

Check if a type is an enum.

| PARAMETER | DESCRIPTION                        |
| --------- | ---------------------------------- |
| `name`    | Type name to check **TYPE:** `str` |

| RETURNS | DESCRIPTION                 |
| ------- | --------------------------- |
| `bool`  | True if the type is an enum |

Source code in `src/lifx/protocol/generator.py`

```python
def is_enum(self, name: str) -> bool:
    """Check if a type is an enum.

    Args:
        name: Type name to check

    Returns:
        True if the type is an enum
    """
    return name in self._enums
```

###### has_type

```python
has_type(name: str) -> bool
```

Check if a type is defined.

| PARAMETER | DESCRIPTION                        |
| --------- | ---------------------------------- |
| `name`    | Type name to check **TYPE:** `str` |

| RETURNS | DESCRIPTION                 |
| ------- | --------------------------- |
| `bool`  | True if the type is defined |

Source code in `src/lifx/protocol/generator.py`

```python
def has_type(self, name: str) -> bool:
    """Check if a type is defined.

    Args:
        name: Type name to check

    Returns:
        True if the type is defined
    """
    return (
        name in self._enums
        or name in self._fields
        or name in self._packets
        or name in self._unions
        or name in self._basic_types
    )
```

###### get_all_types

```python
get_all_types() -> set[str]
```

Get all registered types.

| RETURNS    | DESCRIPTION           |
| ---------- | --------------------- |
| `set[str]` | Set of all type names |

Source code in `src/lifx/protocol/generator.py`

```python
def get_all_types(self) -> set[str]:
    """Get all registered types.

    Returns:
        Set of all type names
    """
    return (
        self._enums
        | self._fields
        | self._packets
        | self._unions
        | self._basic_types
    )
```

#### Functions

##### to_snake_case

```python
to_snake_case(name: str) -> str
```

Convert PascalCase or camelCase to snake_case.

| PARAMETER | DESCRIPTION                                    |
| --------- | ---------------------------------------------- |
| `name`    | PascalCase or camelCase string **TYPE:** `str` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `str`   | snake_case string |

Source code in `src/lifx/protocol/generator.py`

```python
def to_snake_case(name: str) -> str:
    """Convert PascalCase or camelCase to snake_case.

    Args:
        name: PascalCase or camelCase string

    Returns:
        snake_case string
    """
    # Insert underscore before uppercase letters (except at start)
    snake = re.sub(r"(?<!^)(?=[A-Z])", "_", name)
    return snake.lower()
```

##### apply_field_name_quirks

```python
apply_field_name_quirks(python_name: str) -> str
```

Apply quirks to field names to avoid Python built-ins and reserved words.

| PARAMETER     | DESCRIPTION                                                        |
| ------------- | ------------------------------------------------------------------ |
| `python_name` | The Python field name (usually from to_snake_case) **TYPE:** `str` |

| RETURNS | DESCRIPTION               |
| ------- | ------------------------- |
| `str`   | Quirk-adjusted field name |

Quirks applied

- "type" -> "effect_type" (avoids Python built-in)

Source code in `src/lifx/protocol/generator.py`

```python
def apply_field_name_quirks(python_name: str) -> str:
    """Apply quirks to field names to avoid Python built-ins and reserved words.

    Args:
        python_name: The Python field name (usually from to_snake_case)

    Returns:
        Quirk-adjusted field name

    Quirks applied:
        - "type" -> "effect_type" (avoids Python built-in)
    """
    if python_name == "type":
        return "effect_type"
    return python_name
```

##### apply_extended_multizone_packet_quirks

```python
apply_extended_multizone_packet_quirks(
    packet_name: str, category_class: str
) -> str
```

Apply quirks to extended multizone packet names to follow LIFX naming convention.

In the LIFX protocol, extended multizone packets should follow the standard naming pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).

| PARAMETER        | DESCRIPTION                                                 |
| ---------------- | ----------------------------------------------------------- |
| `packet_name`    | Packet name (after category prefix removal) **TYPE:** `str` |
| `category_class` | Category class name (e.g., "MultiZone") **TYPE:** `str`     |

| RETURNS | DESCRIPTION                |
| ------- | -------------------------- |
| `str`   | Quirk-adjusted packet name |

Quirks applied

- "ExtendedGetColorZones" -> "GetExtendedColorZones"
- "ExtendedSetColorZones" -> "SetExtendedColorZones"
- "ExtendedStateMultiZone" -> "StateExtendedColorZones"

Source code in `src/lifx/protocol/generator.py`

```python
def apply_extended_multizone_packet_quirks(
    packet_name: str, category_class: str
) -> str:
    """Apply quirks to extended multizone packet names to follow LIFX naming convention.

    In the LIFX protocol, extended multizone packets should follow the standard naming
    pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).

    Args:
        packet_name: Packet name (after category prefix removal)
        category_class: Category class name (e.g., "MultiZone")

    Returns:
        Quirk-adjusted packet name

    Quirks applied:
        - "ExtendedGetColorZones" -> "GetExtendedColorZones"
        - "ExtendedSetColorZones" -> "SetExtendedColorZones"
        - "ExtendedStateMultiZone" -> "StateExtendedColorZones"
    """
    if category_class == "MultiZone":
        if packet_name == "ExtendedGetColorZones":
            return "GetExtendedColorZones"
        elif packet_name == "ExtendedSetColorZones":
            return "SetExtendedColorZones"
        elif packet_name == "ExtendedStateMultiZone":
            return "StateExtendedColorZones"
    return packet_name
```

##### apply_tile_effect_parameter_quirk

```python
apply_tile_effect_parameter_quirk(fields: dict[str, Any]) -> dict[str, Any]
```

Apply local quirk to fix TileEffectParameter structure.

The upstream protocol.yml doesn't provide enough detail for TileEffectParameter. This quirk replaces it with the correct structure:

- TileEffectSkyType (enum, uint8)
- 3 reserved bytes
- cloudSaturationMin (uint8)
- 3 reserved bytes
- cloudSaturationMax (uint8)
- 23 reserved bytes Total: 32 bytes

| PARAMETER | DESCRIPTION                                                |
| --------- | ---------------------------------------------------------- |
| `fields`  | Dictionary of field definitions **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                       |
| ---------------- | ------------------------------------------------- |
| `dict[str, Any]` | Dictionary with TileEffectParameter quirk applied |

Source code in `src/lifx/protocol/generator.py`

```python
def apply_tile_effect_parameter_quirk(
    fields: dict[str, Any],
) -> dict[str, Any]:
    """Apply local quirk to fix TileEffectParameter structure.

    The upstream protocol.yml doesn't provide enough detail for TileEffectParameter.
    This quirk replaces it with the correct structure:
    - TileEffectSkyType (enum, uint8)
    - 3 reserved bytes
    - cloudSaturationMin (uint8)
    - 3 reserved bytes
    - cloudSaturationMax (uint8)
    - 23 reserved bytes
    Total: 32 bytes

    Args:
        fields: Dictionary of field definitions

    Returns:
        Dictionary with TileEffectParameter quirk applied
    """
    if "TileEffectParameter" in fields:
        fields["TileEffectParameter"] = {
            "size_bytes": 32,
            "fields": [
                {"name": "SkyType", "type": "<TileEffectSkyType>"},
                {"size_bytes": 3},
                {"name": "CloudSaturationMin", "type": "uint8"},
                {"size_bytes": 3},
                {"name": "CloudSaturationMax", "type": "uint8"},
                {"size_bytes": 23},
            ],
        }
    return fields
```

##### format_long_import

```python
format_long_import(
    items: list[str], prefix: str = "from lifx.protocol.protocol_types import "
) -> str
```

Format a long import statement across multiple lines.

| PARAMETER | DESCRIPTION                                                                              |
| --------- | ---------------------------------------------------------------------------------------- |
| `items`   | List of import items (e.g., ["Foo", "Bar as BazAlias"]) **TYPE:** `list[str]`            |
| `prefix`  | Import prefix **TYPE:** `str` **DEFAULT:** `'from lifx.protocol.protocol_types import '` |

| RETURNS | DESCRIPTION                                        |
| ------- | -------------------------------------------------- |
| `str`   | Formatted import string with line breaks if needed |

Source code in `src/lifx/protocol/generator.py`

```python
def format_long_import(
    items: list[str], prefix: str = "from lifx.protocol.protocol_types import "
) -> str:
    """Format a long import statement across multiple lines.

    Args:
        items: List of import items (e.g., ["Foo", "Bar as BazAlias"])
        prefix: Import prefix

    Returns:
        Formatted import string with line breaks if needed
    """
    if not items:
        return ""

    # Try single line first
    single_line = prefix + ", ".join(items)
    if len(single_line) <= 120:
        return single_line + "\n"

    # Multi-line format
    lines = [prefix + "("]
    for i, item in enumerate(items):
        if i < len(items) - 1:
            lines.append(f"    {item},")
        else:
            lines.append(f"    {item},")
    lines.append(")")
    return "\n".join(lines) + "\n"
```

##### format_long_list

```python
format_long_list(
    items: list[dict[str, Any]], max_line_length: int = 120
) -> str
```

Format a long list across multiple lines.

| PARAMETER         | DESCRIPTION                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| `items`           | List of dict items to format **TYPE:** `list[dict[str, Any]]`          |
| `max_line_length` | Maximum line length before wrapping **TYPE:** `int` **DEFAULT:** `120` |

| RETURNS | DESCRIPTION           |
| ------- | --------------------- |
| `str`   | Formatted list string |

Source code in `src/lifx/protocol/generator.py`

```python
def format_long_list(items: list[dict[str, Any]], max_line_length: int = 120) -> str:
    """Format a long list across multiple lines.

    Args:
        items: List of dict items to format
        max_line_length: Maximum line length before wrapping

    Returns:
        Formatted list string
    """
    if not items:
        return "[]"

    # Try single line first
    single_line = repr(items)
    if len(single_line) <= max_line_length:
        return single_line

    # Multi-line format with one item per line
    lines = ["["]
    for i, item in enumerate(items):
        item_str = repr(item)
        if i < len(items) - 1:
            lines.append(f"    {item_str},")
        else:
            lines.append(f"    {item_str},")
    lines.append("]")
    return "\n".join(lines)
```

##### parse_field_type

```python
parse_field_type(field_type: str) -> tuple[str, int | None, bool]
```

Parse a field type string.

| PARAMETER    | DESCRIPTION                                                  |
| ------------ | ------------------------------------------------------------ |
| `field_type` | Field type (e.g., 'uint16', '[32]uint8', '') **TYPE:** `str` |

| RETURNS           | DESCRIPTION                                              |
| ----------------- | -------------------------------------------------------- |
| `str`             | Tuple of (base_type, array_count, is_nested)             |
| \`int             | None\`                                                   |
| `bool`            | array_count: Number of elements if array, None otherwise |
| \`tuple\[str, int | None, bool\]\`                                           |

Source code in `src/lifx/protocol/generator.py`

```python
def parse_field_type(field_type: str) -> tuple[str, int | None, bool]:
    """Parse a field type string.

    Args:
        field_type: Field type (e.g., 'uint16', '[32]uint8', '<HSBK>')

    Returns:
        Tuple of (base_type, array_count, is_nested)
        - base_type: The base type name
        - array_count: Number of elements if array, None otherwise
        - is_nested: True if it's a nested structure (<Type>)
    """
    # Check for array: [N]type
    array_match = re.match(r"\[(\d+)\](.+)", field_type)
    if array_match:
        count = int(array_match.group(1))
        inner_type = array_match.group(2)
        # Check if inner type is nested
        if inner_type.startswith("<") and inner_type.endswith(">"):
            return inner_type[1:-1], count, True
        return inner_type, count, False

    # Check for nested structure: <Type>
    if field_type.startswith("<") and field_type.endswith(">"):
        return field_type[1:-1], None, True

    # Simple type
    return field_type, None, False
```

##### camel_to_snake_upper

```python
camel_to_snake_upper(name: str) -> str
```

Convert CamelCase to UPPER_SNAKE_CASE.

| PARAMETER | DESCRIPTION                      |
| --------- | -------------------------------- |
| `name`    | CamelCase string **TYPE:** `str` |

| RETURNS | DESCRIPTION             |
| ------- | ----------------------- |
| `str`   | UPPER_SNAKE_CASE string |

Source code in `src/lifx/protocol/generator.py`

```python
def camel_to_snake_upper(name: str) -> str:
    """Convert CamelCase to UPPER_SNAKE_CASE.

    Args:
        name: CamelCase string

    Returns:
        UPPER_SNAKE_CASE string
    """
    # Insert underscore before uppercase letters (except at start)
    snake = re.sub(r"(?<!^)(?=[A-Z])", "_", name)
    return snake.upper()
```

##### generate_enum_code

```python
generate_enum_code(enums: dict[str, Any]) -> str
```

Generate Python Enum definitions with shortened names.

| PARAMETER | DESCRIPTION                                               |
| --------- | --------------------------------------------------------- |
| `enums`   | Dictionary of enum definitions **TYPE:** `dict[str, Any]` |

| RETURNS | DESCRIPTION        |
| ------- | ------------------ |
| `str`   | Python code string |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_enum_code(enums: dict[str, Any]) -> str:
    """Generate Python Enum definitions with shortened names.

    Args:
        enums: Dictionary of enum definitions

    Returns:
        Python code string
    """
    code: list[str] = []

    for enum_name, enum_def in sorted(enums.items()):
        code.append(f"class {enum_name}(IntEnum):")
        code.append('    """Auto-generated enum."""')
        code.append("")

        # Handle both old format (dict) and new format (list of dicts)
        if isinstance(enum_def, dict) and "values" in enum_def:
            # New format: {type: "uint16", values: [{name: "X", value: 1}, ...]}
            values = enum_def["values"]
            reserved_counter = 0

            # Check if all values share a common prefix (enum name)
            expected_prefix = camel_to_snake_upper(enum_name) + "_"
            non_reserved = [
                item["name"] for item in values if item["name"].lower() != "reserved"
            ]
            has_common_prefix = non_reserved and all(
                name.startswith(expected_prefix) for name in non_reserved
            )

            for item in sorted(values, key=lambda x: x["value"]):
                protocol_name = item["name"]
                member_value = item["value"]

                # Handle reserved fields by making names unique
                if protocol_name.lower() == "reserved":
                    member_name = f"RESERVED_{reserved_counter}"
                    reserved_counter += 1
                # Remove redundant prefix for cleaner Python names
                elif has_common_prefix and protocol_name.startswith(expected_prefix):
                    member_name = protocol_name[len(expected_prefix) :]
                else:
                    member_name = protocol_name

                code.append(f"    {member_name} = {member_value}")
        else:
            # Old format: {MEMBER: value, ...}
            for member_name, member_value in sorted(
                enum_def.items(), key=lambda x: x[1]
            ):
                code.append(f"    {member_name} = {member_value}")

        code.append("")
        code.append("")

    return "\n".join(code)
```

##### convert_type_to_python

```python
convert_type_to_python(
    field_type: str, type_aliases: dict[str, str] | None = None
) -> str
```

Convert a protocol field type to Python type annotation.

| PARAMETER      | DESCRIPTION                                                    |
| -------------- | -------------------------------------------------------------- |
| `field_type`   | Protocol field type string **TYPE:** `str`                     |
| `type_aliases` | Optional dict for type name aliases **TYPE:** \`dict[str, str] |

| RETURNS | DESCRIPTION                   |
| ------- | ----------------------------- |
| `str`   | Python type annotation string |

Source code in `src/lifx/protocol/generator.py`

```python
def convert_type_to_python(
    field_type: str, type_aliases: dict[str, str] | None = None
) -> str:
    """Convert a protocol field type to Python type annotation.

    Args:
        field_type: Protocol field type string
        type_aliases: Optional dict for type name aliases

    Returns:
        Python type annotation string
    """
    if type_aliases is None:
        type_aliases = {}

    base_type, array_count, is_nested = parse_field_type(field_type)

    if array_count:
        if is_nested:
            # Use alias if one exists
            type_name = type_aliases.get(base_type, base_type)
            return f"list[{type_name}]"
        elif base_type in ("uint8", "byte"):
            # Special case: byte arrays
            return "bytes"
        else:
            return "list[int]"
    elif is_nested:
        # Use alias if one exists
        return type_aliases.get(base_type, base_type)
    elif base_type in ("uint8", "uint16", "uint32", "uint64"):
        return "int"
    elif base_type in ("int8", "int16", "int32", "int64"):
        return "int"
    elif base_type == "float32":
        return "float"
    elif base_type == "bool":
        return "bool"
    else:
        return "Any"
```

##### generate_pack_method

```python
generate_pack_method(
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str
```

Generate pack() method code for a field structure or packet.

| PARAMETER     | DESCRIPTION                                                       |
| ------------- | ----------------------------------------------------------------- |
| `fields_data` | List of field definitions **TYPE:** `list[dict[str, Any]]`        |
| `class_type`  | Either "field" or "packet" **TYPE:** `str` **DEFAULT:** `'field'` |
| `enum_types`  | Set of enum type names for detection **TYPE:** \`set[str]         |

| RETURNS | DESCRIPTION               |
| ------- | ------------------------- |
| `str`   | Python method code string |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_pack_method(
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str:
    """Generate pack() method code for a field structure or packet.

    Args:
        fields_data: List of field definitions
        class_type: Either "field" or "packet"
        enum_types: Set of enum type names for detection

    Returns:
        Python method code string
    """
    if enum_types is None:
        enum_types = set()

    code = []
    code.append("    def pack(self) -> bytes:")
    code.append('        """Pack to bytes."""')
    code.append("        from lifx.protocol import serializer")
    code.append('        result = b""')
    code.append("")

    for field_item in fields_data:
        # Handle reserved fields (no name)
        if "name" not in field_item:
            size_bytes = field_item.get("size_bytes", 0)
            code.append(f"        # Reserved {size_bytes} bytes")
            code.append(f"        result += serializer.pack_reserved({size_bytes})")
            continue

        protocol_name = field_item["name"]
        field_type = field_item["type"]
        size_bytes = field_item.get("size_bytes", 0)
        python_name = apply_field_name_quirks(to_snake_case(protocol_name))

        base_type, array_count, is_nested = parse_field_type(field_type)

        # Check if this is an enum (nested but in enum_types)
        is_enum = is_nested and base_type in enum_types

        # Handle different field types
        if array_count:
            if is_enum:
                # Array of enums - pack as array of ints
                code.append(f"        # {python_name}: list[{base_type}] (enum array)")
                code.append(f"        for item in self.{python_name}:")
                code.append(
                    "            result += serializer.pack_value(int(item), 'uint8')"
                )
            elif is_nested:
                # Array of nested structures
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(f"        for item in self.{python_name}:")
                code.append("            result += item.pack()")
            elif base_type in ("uint8", "byte"):
                # Byte array
                code.append(f"        # {python_name}: bytes ({size_bytes} bytes)")
                code.append(
                    f"        result += "
                    f"serializer.pack_bytes(self.{python_name}, {size_bytes})"
                )
            else:
                # Array of primitives
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(
                    f"        result += "
                    f"serializer.pack_array(self.{python_name}, '{base_type}', {array_count})"
                )
        elif is_enum:
            # Enum - pack as int
            code.append(f"        # {python_name}: {base_type} (enum)")
            code.append(
                f"        result += "
                f"serializer.pack_value(int(self.{python_name}), 'uint8')"
            )
        elif is_nested:
            # Nested structure
            code.append(f"        # {python_name}: {base_type}")
            code.append(f"        result += self.{python_name}.pack()")
        else:
            # Primitive type
            code.append(f"        # {python_name}: {base_type}")
            code.append(
                f"        result += "
                f"serializer.pack_value(self.{python_name}, '{base_type}')"
            )

    code.append("")
    code.append("        return result")

    return "\n".join(code)
```

##### generate_unpack_method

```python
generate_unpack_method(
    class_name: str,
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str
```

Generate unpack() classmethod code for a field structure or packet.

| PARAMETER     | DESCRIPTION                                                       |
| ------------- | ----------------------------------------------------------------- |
| `class_name`  | Name of the class **TYPE:** `str`                                 |
| `fields_data` | List of field definitions **TYPE:** `list[dict[str, Any]]`        |
| `class_type`  | Either "field" or "packet" **TYPE:** `str` **DEFAULT:** `'field'` |
| `enum_types`  | Set of enum type names for detection **TYPE:** \`set[str]         |

| RETURNS | DESCRIPTION               |
| ------- | ------------------------- |
| `str`   | Python method code string |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_unpack_method(
    class_name: str,
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str:
    """Generate unpack() classmethod code for a field structure or packet.

    Args:
        class_name: Name of the class
        fields_data: List of field definitions
        class_type: Either "field" or "packet"
        enum_types: Set of enum type names for detection

    Returns:
        Python method code string
    """
    if enum_types is None:
        enum_types = set()

    code = []
    code.append("    @classmethod")
    code.append(
        f"    def unpack(cls, data: bytes, offset: int = 0) -> tuple[{class_name}, int]:"
    )
    code.append('        """Unpack from bytes."""')
    code.append("        from lifx.protocol import serializer")
    code.append("        current_offset = offset")

    # Store field values
    field_vars = []

    for field_item in fields_data:
        # Handle reserved fields (no name)
        if "name" not in field_item:
            size_bytes = field_item.get("size_bytes", 0)
            code.append(f"        # Skip reserved {size_bytes} bytes")
            code.append(f"        current_offset += {size_bytes}")
            continue

        protocol_name = field_item["name"]
        field_type = field_item["type"]
        size_bytes = field_item.get("size_bytes", 0)
        python_name = apply_field_name_quirks(to_snake_case(protocol_name))
        field_vars.append(python_name)

        base_type, array_count, is_nested = parse_field_type(field_type)

        # Check if this is an enum (nested but in enum_types)
        is_enum = is_nested and base_type in enum_types

        # Handle different field types
        if array_count:
            if is_enum:
                # Array of enums
                code.append(f"        # {python_name}: list[{base_type}] (enum array)")
                code.append(f"        {python_name} = []")
                code.append(f"        for _ in range({array_count}):")
                code.append(
                    "            item_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)"
                )
                code.append(f"            {python_name}.append({base_type}(item_raw))")
            elif is_nested:
                # Array of nested structures
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(f"        {python_name} = []")
                code.append(f"        for _ in range({array_count}):")
                code.append(
                    f"            item, current_offset = {base_type}.unpack(data, current_offset)"
                )
                code.append(f"            {python_name}.append(item)")
            elif base_type in ("uint8", "byte"):
                # Byte array
                code.append(f"        # {python_name}: bytes ({size_bytes} bytes)")
                code.append(
                    f"        {python_name}, current_offset = serializer.unpack_bytes("
                )
                code.append(f"            data, {size_bytes}, current_offset")
                code.append("        )")
            else:
                # Array of primitives
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(
                    f"        {python_name}, current_offset = serializer.unpack_array("
                )
                code.append(
                    f"            data, '{base_type}', {array_count}, current_offset"
                )
                code.append("        )")
        elif is_enum:
            # Enum - unpack as int then convert
            code.append(f"        # {python_name}: {base_type} (enum)")
            code.append(
                f"        {python_name}_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)"
            )
            code.append(f"        {python_name} = {base_type}({python_name}_raw)")
        elif is_nested:
            # Nested structure
            code.append(f"        # {python_name}: {base_type}")
            code.append(
                f"        {python_name}, current_offset = {base_type}.unpack(data, current_offset)"
            )
        else:
            # Primitive type
            code.append(f"        # {python_name}: {base_type}")
            code.append(
                f"        {python_name}, current_offset = serializer.unpack_value(data, '{base_type}', current_offset)"
            )

    code.append("")
    # Create instance - format long return statements
    field_args = ", ".join([f"{name}={name}" for name in field_vars])
    return_stmt = f"        return cls({field_args}), current_offset"

    # If too long, break across multiple lines
    if len(return_stmt) > 120:
        code.append("        return (")
        code.append("            cls(")
        for i, name in enumerate(field_vars):
            if i < len(field_vars) - 1:
                code.append(f"                {name}={name},")
            else:
                code.append(f"                {name}={name},")
        code.append("            ),")
        code.append("            current_offset,")
        code.append("        )")
    else:
        code.append(return_stmt)

    return "\n".join(code)
```

##### generate_field_code

```python
generate_field_code(
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enum_types: set[str] | None = None,
) -> tuple[str, dict[str, dict[str, str]]]
```

Generate Python dataclass definitions for field structures.

| PARAMETER           | DESCRIPTION                                                                        |
| ------------------- | ---------------------------------------------------------------------------------- |
| `fields`            | Dictionary of field definitions **TYPE:** `dict[str, Any]`                         |
| `compound_fields`   | Dictionary of compound field definitions **TYPE:** \`dict[str, Any]                |
| `unions`            | Dictionary of union definitions (treated as fields) **TYPE:** \`dict[str, Any]     |
| `packets_as_fields` | Dictionary of packets that are also used as field types **TYPE:** \`dict[str, Any] |
| `enum_types`        | Set of enum type names **TYPE:** \`set[str]                                        |

| RETURNS                     | DESCRIPTION                                               |
| --------------------------- | --------------------------------------------------------- |
| `str`                       | Tuple of (code string, field mappings dict)               |
| `dict[str, dict[str, str]]` | Field mappings: {ClassName: {python_name: protocol_name}} |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_field_code(
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enum_types: set[str] | None = None,
) -> tuple[str, dict[str, dict[str, str]]]:
    """Generate Python dataclass definitions for field structures.

    Args:
        fields: Dictionary of field definitions
        compound_fields: Dictionary of compound field definitions
        unions: Dictionary of union definitions (treated as fields)
        packets_as_fields: Dictionary of packets that are also used as field types
        enum_types: Set of enum type names

    Returns:
        Tuple of (code string, field mappings dict)
        Field mappings: {ClassName: {python_name: protocol_name}}
    """
    if enum_types is None:
        enum_types = set()

    code = []
    field_mappings: dict[str, dict[str, str]] = {}
    all_fields = {**fields}
    if compound_fields:
        all_fields.update(compound_fields)
    if unions:
        all_fields.update(unions)
    if packets_as_fields:
        all_fields.update(packets_as_fields)

    for field_name, field_def in sorted(all_fields.items()):
        code.append("@dataclass")
        code.append(f"class {field_name}:")

        # Check if this is a union (has comment indicating it's a union)
        is_union = isinstance(field_def, dict) and "comment" in field_def
        if is_union:
            code.append(
                f'    """Auto-generated union structure. {field_def.get("comment", "")}"""'
            )
        else:
            code.append('    """Auto-generated field structure."""')
        code.append("")

        field_map: dict[str, str] = {}
        fields_data = []

        # Handle both old format (dict) and new format (list of dicts)
        if isinstance(field_def, dict) and "fields" in field_def:
            # New format: {size_bytes: N, fields: [{name: "X", type: "uint16"}, ...]}
            field_list = field_def["fields"]

            # For unions, treat as a raw bytes field (they overlay, so just store raw data)
            if is_union:
                size_bytes = field_def.get("size_bytes", 16)
                code.append(f"    data: bytes  # Union of {size_bytes} bytes")
                field_map["data"] = "data"
                # For pack/unpack, use bytes field
                fields_data = [
                    {
                        "name": "data",
                        "type": f"[{size_bytes}]byte",
                        "size_bytes": size_bytes,
                    }
                ]
            else:
                # Normal field structure - process all fields
                fields_data = field_list  # Save for pack/unpack generation
                for field_item in field_list:
                    # Skip reserved fields without names (they won't be in dataclass)
                    if "name" not in field_item:
                        continue
                    protocol_name = field_item["name"]
                    attr_type = field_item["type"]
                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))
                    python_type = convert_type_to_python(attr_type)

                    code.append(f"    {python_name}: {python_type}")
                    field_map[python_name] = protocol_name
        else:
            # Old format: {attr_name: type, ...}
            # Convert to new format for pack/unpack generation
            for protocol_name, attr_type in field_def.items():
                python_name = apply_field_name_quirks(to_snake_case(protocol_name))
                python_type = convert_type_to_python(attr_type)
                code.append(f"    {python_name}: {python_type}")
                field_map[python_name] = protocol_name
                # Build fields_data for old format
                fields_data.append({"name": protocol_name, "type": attr_type})

        field_mappings[field_name] = field_map

        # Add pack/unpack methods
        if fields_data:
            code.append("")
            code.append(generate_pack_method(fields_data, "field", enum_types))
            code.append("")
            code.append(
                generate_unpack_method(field_name, fields_data, "field", enum_types)
            )

        code.append("")
        code.append("")

    return "\n".join(code), field_mappings
```

##### generate_nested_packet_code

```python
generate_nested_packet_code(
    packets: dict[str, Any], type_aliases: dict[str, str] | None = None
) -> str
```

Generate nested Python packet class definitions.

| PARAMETER      | DESCRIPTION                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------- |
| `packets`      | Dictionary of packet definitions (grouped by category) **TYPE:** `dict[str, Any]`                       |
| `type_aliases` | Optional dict mapping type names to their aliases (for collision resolution) **TYPE:** \`dict[str, str] |

| RETURNS | DESCRIPTION                                   |
| ------- | --------------------------------------------- |
| `str`   | Python code string with nested packet classes |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_nested_packet_code(
    packets: dict[str, Any], type_aliases: dict[str, str] | None = None
) -> str:
    """Generate nested Python packet class definitions.

    Args:
        packets: Dictionary of packet definitions (grouped by category)
        type_aliases: Optional dict mapping type names to their aliases (for collision resolution)

    Returns:
        Python code string with nested packet classes
    """
    if type_aliases is None:
        type_aliases = {}

    code = []

    # Flatten packets if they're grouped by category
    flat_packets: list[tuple[str, str, dict[str, Any]]] = []

    # Check if packets are grouped by category (new format)
    sample_key = next(iter(packets.keys())) if packets else None
    if sample_key and isinstance(packets[sample_key], dict):
        sample_value = packets[sample_key]
        # Check if this is a category grouping (contains nested packet dicts)
        if any(isinstance(v, dict) and "pkt_type" in v for v in sample_value.values()):
            # New format: grouped by category
            for category, category_packets in packets.items():
                for packet_name, packet_def in category_packets.items():
                    flat_packets.append((category, packet_name, packet_def))
        else:
            # Old format: flat packets with category field
            for packet_name, packet_def in packets.items():
                category = packet_def.get("category", "misc")
                flat_packets.append((category, packet_name, packet_def))

    # Group by category
    categories: dict[str, list[tuple[str, dict[str, Any]]]] = {}
    for category, packet_name, packet_def in flat_packets:
        if category not in categories:
            categories[category] = []
        categories[category].append((packet_name, packet_def))

    # Generate category classes with nested packet classes
    for category in sorted(categories.keys()):
        # Generate category class
        # Quirk: Convert category names to proper camel case (multi_zone -> MultiZone)
        # Split on underscores, capitalize each part, then join
        parts = category.split("_")
        category_class = "".join(part.capitalize() for part in parts)
        code.append("")
        code.append(f"class {category_class}(Packet):")
        code.append(f'    """{category_class} category packets."""')
        code.append("")

        # Generate nested packet classes
        for packet_name, packet_def in sorted(categories[category]):
            pkt_type = packet_def["pkt_type"]
            fields_data = packet_def.get("fields", [])

            # Remove category prefix from packet name (e.g., DeviceGetLabel -> GetLabel)
            # The packet name format is: CategoryActionTarget (e.g., DeviceGetLabel, LightSetColor)
            # Use case-insensitive matching to handle multi_zone -> Multizone -> MultiZone
            short_name = packet_name
            if packet_name.lower().startswith(category_class.lower()):
                short_name = packet_name[len(category_class) :]

            # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor
            # for better clarity (Set and SetColor are different packets)
            if category_class == "Light":
                if short_name == "Get":
                    short_name = "GetColor"
                elif short_name == "State":
                    short_name = "StateColor"

            # Quirk: Rename extended multizone packets to follow standard naming convention
            short_name = apply_extended_multizone_packet_quirks(
                short_name, category_class
            )

            code.append("    @dataclass")
            code.append(f"    class {short_name}(Packet):")
            code.append(f'        """Packet type {pkt_type}."""')
            code.append("")
            code.append(f"        PKT_TYPE: ClassVar[int] = {pkt_type}")

            # Format fields_data - split long lists across multiple lines
            # Account for the prefix "        _fields: ClassVar[list[dict[str, Any]]] = " which is ~50 chars
            fields_repr = format_long_list(fields_data, max_line_length=70)
            if "\n" in fields_repr:
                # Multi-line format - indent properly
                code.append("        _fields: ClassVar[list[dict[str, Any]]] = (")
                for line in fields_repr.split("\n"):
                    if line.strip():
                        code.append(f"        {line}")
                code.append("        )")
            else:
                code.append(
                    f"        _fields: ClassVar[list[dict[str, Any]]] = {fields_repr}"
                )

            # Add packet metadata for smart request handling
            # Classify packet by name pattern: Get*, Set*, State*, or OTHER
            packet_kind = "OTHER"
            if short_name.startswith("Get"):
                packet_kind = "GET"
            elif short_name.startswith("Set"):
                packet_kind = "SET"
            elif short_name.startswith("State"):
                packet_kind = "STATE"

            # Quirk: CopyFrameBuffer is semantically a SET operation
            # It modifies device state without returning data
            if category_class == "Tile" and short_name == "CopyFrameBuffer":
                packet_kind = "SET"

            code.append("")
            code.append("        # Packet metadata for automatic handling")
            code.append(f"        _packet_kind: ClassVar[str] = {repr(packet_kind)}")

            # Requires acknowledgement/response based on packet kind
            # GET requests: ack_required=False, res_required=False (device responds anyway)
            # SET requests: ack_required=True, res_required=False (need acknowledgement)
            requires_ack = packet_kind == "SET"
            requires_response = False
            code.append(f"        _requires_ack: ClassVar[bool] = {requires_ack}")
            code.append(
                f"        _requires_response: ClassVar[bool] = {requires_response}"
            )
            code.append("")

            # Generate dataclass fields (only non-reserved)
            has_fields = False
            if isinstance(fields_data, list):
                for field_item in fields_data:
                    # Skip reserved fields
                    if "name" not in field_item:
                        continue
                    protocol_name = field_item["name"]
                    field_type = field_item["type"]
                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))
                    python_type = convert_type_to_python(field_type, type_aliases)
                    code.append(f"        {python_name}: {python_type}")
                    has_fields = True

            if not has_fields:
                code.append("        pass")

            code.append("")

        code.append("")

    return "\n".join(code)
```

##### generate_types_file

```python
generate_types_file(
    enums: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
) -> str
```

Generate complete types.py file.

| PARAMETER           | DESCRIPTION                                                          |
| ------------------- | -------------------------------------------------------------------- |
| `enums`             | Enum definitions **TYPE:** `dict[str, Any]`                          |
| `fields`            | Field structure definitions **TYPE:** `dict[str, Any]`               |
| `compound_fields`   | Compound field definitions **TYPE:** \`dict[str, Any]                |
| `unions`            | Union definitions **TYPE:** \`dict[str, Any]                         |
| `packets_as_fields` | Packets that are also used as field types **TYPE:** \`dict[str, Any] |

| RETURNS | DESCRIPTION                  |
| ------- | ---------------------------- |
| `str`   | Complete Python file content |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_types_file(
    enums: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
) -> str:
    """Generate complete types.py file.

    Args:
        enums: Enum definitions
        fields: Field structure definitions
        compound_fields: Compound field definitions
        unions: Union definitions
        packets_as_fields: Packets that are also used as field types

    Returns:
        Complete Python file content
    """
    header = '''"""Auto-generated LIFX protocol types.

DO NOT EDIT THIS FILE MANUALLY.
Generated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml
by protocol/generator.py

Uses Pythonic naming conventions (snake_case fields, shortened enums) while
maintaining compatibility with the official LIFX protocol through mappings.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import IntEnum


'''

    code = header
    code += generate_enum_code(enums)
    code += "\n"

    # Extract enum names for pack/unpack generation
    enum_names = set(enums.keys())

    field_code, field_mappings = generate_field_code(
        fields, compound_fields, unions, packets_as_fields, enum_names
    )
    code += field_code
    code += "\n"

    # Add type aliases for common names
    code += "# Type aliases for convenience\n"
    all_field_names = {
        **fields,
        **(compound_fields or {}),
        **(unions or {}),
        **(packets_as_fields or {}),
    }
    if "TileStateDevice" in all_field_names:
        code += "TileDevice = TileStateDevice  # Pythonic alias\n"
    code += "\n"

    # Add field name mappings as module-level constant (formatted for readability)
    code += "# Field name mappings: Python name -> Protocol name\n"
    code += "# Used by serializer to translate between conventions\n"
    code += "FIELD_MAPPINGS: dict[str, dict[str, str]] = {\n"
    for class_name in sorted(field_mappings.keys()):
        mappings = field_mappings[class_name]
        # Format each class mapping - if too long, break it into multiple lines
        mappings_str = repr(mappings)
        line = f"    {repr(class_name)}: {mappings_str},"
        if len(line) > 120:
            # Multi-line format
            code += f"    {repr(class_name)}: {{\n"
            for py_name, proto_name in sorted(mappings.items()):
                code += f"        {repr(py_name)}: {repr(proto_name)},\n"
            code += "    },\n"
        else:
            code += line + "\n"
    code += "}\n"
    code += "\n"

    return code
```

##### generate_packets_file

```python
generate_packets_file(
    packets: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enums: dict[str, Any] | None = None,
) -> str
```

Generate complete packets.py file.

| PARAMETER           | DESCRIPTION                                                                        |
| ------------------- | ---------------------------------------------------------------------------------- |
| `packets`           | Packet definitions **TYPE:** `dict[str, Any]`                                      |
| `fields`            | Field definitions (for imports) **TYPE:** `dict[str, Any]`                         |
| `compound_fields`   | Compound field definitions (for imports) **TYPE:** \`dict[str, Any]                |
| `unions`            | Union definitions (for imports) **TYPE:** \`dict[str, Any]                         |
| `packets_as_fields` | Packets that are also used as field types (for imports) **TYPE:** \`dict[str, Any] |
| `enums`             | Enum definitions for detecting enum types **TYPE:** \`dict[str, Any]               |

| RETURNS | DESCRIPTION                  |
| ------- | ---------------------------- |
| `str`   | Complete Python file content |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_packets_file(
    packets: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enums: dict[str, Any] | None = None,
) -> str:
    """Generate complete packets.py file.

    Args:
        packets: Packet definitions
        fields: Field definitions (for imports)
        compound_fields: Compound field definitions (for imports)
        unions: Union definitions (for imports)
        packets_as_fields: Packets that are also used as field types (for imports)
        enums: Enum definitions for detecting enum types

    Returns:
        Complete Python file content
    """
    # Extract enum names for pack/unpack generation
    enum_names = set(enums.keys()) if enums else set()

    # Collect all field types and enum types used in packets
    used_fields = set()
    used_enums = set()
    all_fields = {**fields}
    if compound_fields:
        all_fields.update(compound_fields)
    if unions:
        all_fields.update(unions)
    if packets_as_fields:
        all_fields.update(packets_as_fields)

    # Flatten packets to scan for used field types
    flat_packets: list[dict[str, Any]] = []
    for value in packets.values():
        if isinstance(value, dict):
            # Check if this is a category grouping
            if any(isinstance(v, dict) and "pkt_type" in v for v in value.values()):
                # New format: grouped by category
                for packet_def in value.values():
                    flat_packets.append(packet_def)
            elif "pkt_type" in value:
                # Old format: direct packet
                flat_packets.append(value)

    for packet_def in flat_packets:
        fields_data = packet_def.get("fields", [])
        # Handle both list and dict formats
        if isinstance(fields_data, list):
            for field_item in fields_data:
                if "type" in field_item:
                    field_type = field_item["type"]
                    base_type, _, is_nested = parse_field_type(field_type)
                    if is_nested:
                        if base_type in all_fields:
                            used_fields.add(base_type)
                        elif base_type in enum_names:
                            used_enums.add(base_type)
        elif isinstance(fields_data, dict):
            for field_type in fields_data.values():
                base_type, _, is_nested = parse_field_type(field_type)
                if is_nested:
                    if base_type in all_fields:
                        used_fields.add(base_type)
                    elif base_type in enum_names:
                        used_enums.add(base_type)

    # Generate imports with collision detection
    imports = ""
    all_imports = sorted(used_fields | used_enums)
    if all_imports:
        # Detect name collisions with packet category names
        category_names = set()
        for category in packets.keys():
            if isinstance(packets[category], dict):
                # Convert category name to class name (same as in generate_nested_packet_code)
                parts = category.split("_")
                category_class = "".join(part.capitalize() for part in parts)
                category_names.add(category_class)

        # Generate import list with aliases for collisions
        import_items = []
        type_aliases = {}  # Map original name to aliased name
        for name in all_imports:
            if name in category_names:
                # Use alias to avoid collision
                aliased_name = f"{name}Field"
                import_items.append(f"{name} as {aliased_name}")
                type_aliases[name] = aliased_name
            else:
                import_items.append(name)

        imports = format_long_import(import_items) + "\n"
    else:
        type_aliases = {}
        imports = ""

    header = f'''"""Auto-generated LIFX protocol packets.

DO NOT EDIT THIS FILE MANUALLY.
Generated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml
by protocol/generator.py

Uses nested packet classes organized by category (Device, Light, etc.).
Each packet inherits from base Packet class which provides generic pack/unpack.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar

from lifx.protocol.base import Packet
{imports}
'''

    code = header
    packet_code = generate_nested_packet_code(packets, type_aliases)
    code += packet_code

    # Generate packet registry for nested classes
    code += "\n\n"
    code += "# Packet Registry - maps packet type to nested packet class\n"
    code += "PACKET_REGISTRY: dict[int, type[Packet]] = {\n"

    # Build registry with nested class paths
    registry_items = []
    for category, value in packets.items():
        if isinstance(value, dict):
            # Check if this is a category grouping
            if any(isinstance(v, dict) and "pkt_type" in v for v in value.values()):
                # New format: grouped by category
                # Quirk: Convert category names to proper camel case (multi_zone -> MultiZone)
                parts = category.split("_")
                category_class = "".join(part.capitalize() for part in parts)
                for packet_name, packet_def in value.items():
                    pkt_type = packet_def.get("pkt_type")
                    if pkt_type is not None:
                        # Remove category prefix to get short name
                        # Use case-insensitive matching to handle multi_zone -> Multizone -> MultiZone
                        short_name = packet_name
                        if packet_name.lower().startswith(category_class.lower()):
                            short_name = packet_name[len(category_class) :]

                        # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor
                        if category_class == "Light":
                            if short_name == "Get":
                                short_name = "GetColor"
                            elif short_name == "State":
                                short_name = "StateColor"

                        # Quirk: Rename extended multizone packets to follow standard naming convention
                        short_name = apply_extended_multizone_packet_quirks(
                            short_name, category_class
                        )

                        # Full path: Category.ShortName
                        full_path = f"{category_class}.{short_name}"
                        registry_items.append((pkt_type, full_path))

    # Sort by packet type for readability
    for pkt_type, full_path in sorted(registry_items):
        code += f"    {pkt_type}: {full_path},\n"

    code += "}\n"
    code += "\n\n"
    code += "def get_packet_class(pkt_type: int) -> type[Packet] | None:\n"
    code += '    """Get packet class for a given packet type.\n'
    code += "\n"
    code += "    Args:\n"
    code += "        pkt_type: Packet type number\n"
    code += "\n"
    code += "    Returns:\n"
    code += "        Nested packet class, or None if unknown\n"
    code += '    """\n'
    code += "    return PACKET_REGISTRY.get(pkt_type)\n"

    return code
```

##### download_protocol

```python
download_protocol() -> dict[str, Any]
```

Download and parse protocol.yml from LIFX GitHub repository.

| RETURNS          | DESCRIPTION                |
| ---------------- | -------------------------- |
| `dict[str, Any]` | Parsed protocol dictionary |

| RAISES      | DESCRIPTION       |
| ----------- | ----------------- |
| `URLError`  | If download fails |
| `YAMLError` | If parsing fails  |

Source code in `src/lifx/protocol/generator.py`

```python
def download_protocol() -> dict[str, Any]:
    """Download and parse protocol.yml from LIFX GitHub repository.

    Returns:
        Parsed protocol dictionary

    Raises:
        URLError: If download fails
        yaml.YAMLError: If parsing fails
    """
    parsed_url = urlparse(PROTOCOL_URL)
    if parsed_url.scheme == "https" and parsed_url.netloc.startswith(
        "raw.githubusercontent.com"
    ):
        print(f"Downloading protocol.yml from {PROTOCOL_URL}...")
        with urlopen(PROTOCOL_URL) as response:  # nosec B310
            protocol_data = response.read()

        print("Parsing protocol specification...")
        protocol = yaml.safe_load(protocol_data)
        return protocol
```

##### validate_protocol_spec

```python
validate_protocol_spec(protocol: dict[str, Any]) -> list[str]
```

Validate protocol specification for missing type references.

| PARAMETER  | DESCRIPTION                                           |
| ---------- | ----------------------------------------------------- |
| `protocol` | Parsed protocol dictionary **TYPE:** `dict[str, Any]` |

| RETURNS     | DESCRIPTION                                         |
| ----------- | --------------------------------------------------- |
| `list[str]` | List of error messages (empty if validation passes) |

Source code in `src/lifx/protocol/generator.py`

```python
def validate_protocol_spec(protocol: dict[str, Any]) -> list[str]:
    """Validate protocol specification for missing type references.

    Args:
        protocol: Parsed protocol dictionary

    Returns:
        List of error messages (empty if validation passes)
    """
    errors: list[str] = []
    registry = TypeRegistry()

    # Register all types
    enums = protocol.get("enums", {})
    fields = protocol.get("fields", {})
    compound_fields = protocol.get("compound_fields", {})
    unions = protocol.get("unions", {})
    packets = protocol.get("packets", {})

    # Register enums
    for enum_name in enums.keys():
        registry.register_enum(enum_name)

    # Register field structures
    for field_name in fields.keys():
        registry.register_field(field_name)

    # Register compound fields
    for field_name in compound_fields.keys():
        registry.register_field(field_name)

    # Register unions
    for union_name in unions.keys():
        registry.register_union(union_name)

    # Register packets (flatten by category)
    for category_packets in packets.values():
        if isinstance(category_packets, dict):
            for packet_name in category_packets.keys():
                registry.register_packet(packet_name)

    # Validate field type references
    def validate_field_types(struct_name: str, struct_def: dict[str, Any]) -> None:
        """Validate all field types in a structure."""
        if isinstance(struct_def, dict) and "fields" in struct_def:
            for field_item in struct_def["fields"]:
                if "type" in field_item:
                    field_type = field_item["type"]
                    field_name = field_item.get("name", "reserved")
                    base_type, _, _ = parse_field_type(field_type)

                    # Check if type is defined
                    if not registry.has_type(base_type):
                        errors.append(
                            f"{struct_name}.{field_name}: Unknown type '{base_type}' in field type '{field_type}'"
                        )

    # Validate fields
    for field_name, field_def in fields.items():
        validate_field_types(f"fields.{field_name}", field_def)

    # Validate compound fields
    for field_name, field_def in compound_fields.items():
        validate_field_types(f"compound_fields.{field_name}", field_def)

    # Validate unions
    for union_name, union_def in unions.items():
        validate_field_types(f"unions.{union_name}", union_def)

    # Validate packets
    for category, category_packets in packets.items():
        if isinstance(category_packets, dict):
            for packet_name, packet_def in category_packets.items():
                if isinstance(packet_def, dict):
                    validate_field_types(
                        f"packets.{category}.{packet_name}", packet_def
                    )

    return errors
```

##### should_skip_button_relay

```python
should_skip_button_relay(name: str) -> bool
```

Check if a name should be skipped (Button or Relay related).

| PARAMETER | DESCRIPTION                                                                  |
| --------- | ---------------------------------------------------------------------------- |
| `name`    | Type name to check (enum, field, union, packet, or category) **TYPE:** `str` |

| RETURNS | DESCRIPTION                                                   |
| ------- | ------------------------------------------------------------- |
| `bool`  | True if the name starts with Button or Relay, False otherwise |

Source code in `src/lifx/protocol/generator.py`

```python
def should_skip_button_relay(name: str) -> bool:
    """Check if a name should be skipped (Button or Relay related).

    Args:
        name: Type name to check (enum, field, union, packet, or category)

    Returns:
        True if the name starts with Button or Relay, False otherwise
    """
    return name.startswith("Button") or name.startswith("Relay")
```

##### filter_button_relay_items

```python
filter_button_relay_items(items: dict[str, Any]) -> dict[str, Any]
```

Filter out Button and Relay items from a dictionary.

| PARAMETER | DESCRIPTION                                              |
| --------- | -------------------------------------------------------- |
| `items`   | Dictionary of items to filter **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                    |
| ---------------- | ---------------------------------------------- |
| `dict[str, Any]` | Filtered dictionary without Button/Relay items |

Source code in `src/lifx/protocol/generator.py`

```python
def filter_button_relay_items(items: dict[str, Any]) -> dict[str, Any]:
    """Filter out Button and Relay items from a dictionary.

    Args:
        items: Dictionary of items to filter

    Returns:
        Filtered dictionary without Button/Relay items
    """
    return {
        name: value
        for name, value in items.items()
        if not should_skip_button_relay(name)
    }
```

##### filter_button_relay_packets

```python
filter_button_relay_packets(packets: dict[str, Any]) -> dict[str, Any]
```

Filter out button and relay category packets.

| PARAMETER | DESCRIPTION                                                                       |
| --------- | --------------------------------------------------------------------------------- |
| `packets` | Dictionary of packet definitions (grouped by category) **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                         |
| ---------------- | --------------------------------------------------- |
| `dict[str, Any]` | Filtered dictionary without button/relay categories |

Source code in `src/lifx/protocol/generator.py`

```python
def filter_button_relay_packets(packets: dict[str, Any]) -> dict[str, Any]:
    """Filter out button and relay category packets.

    Args:
        packets: Dictionary of packet definitions (grouped by category)

    Returns:
        Filtered dictionary without button/relay categories
    """
    return {
        category: category_packets
        for category, category_packets in packets.items()
        if category not in ("button", "relay")
    }
```

##### extract_packets_as_fields

```python
extract_packets_as_fields(
    packets: dict[str, Any], fields: dict[str, Any]
) -> dict[str, Any]
```

Extract packets that are used as field types in other structures.

| PARAMETER | DESCRIPTION                                                        |
| --------- | ------------------------------------------------------------------ |
| `packets` | Dictionary of packet definitions **TYPE:** `dict[str, Any]`        |
| `fields`  | Dictionary of field definitions to scan **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                                         |
| ---------------- | ------------------------------------------------------------------- |
| `dict[str, Any]` | Dictionary of packet definitions that are referenced as field types |

Source code in `src/lifx/protocol/generator.py`

```python
def extract_packets_as_fields(
    packets: dict[str, Any], fields: dict[str, Any]
) -> dict[str, Any]:
    """Extract packets that are used as field types in other structures.

    Args:
        packets: Dictionary of packet definitions
        fields: Dictionary of field definitions to scan

    Returns:
        Dictionary of packet definitions that are referenced as field types
    """
    packets_as_fields = {}

    # Flatten packets first
    flat_packets = {}
    for category, category_packets in packets.items():
        if isinstance(category_packets, dict):
            for packet_name, packet_def in category_packets.items():
                if isinstance(packet_def, dict) and "pkt_type" in packet_def:
                    flat_packets[packet_name] = packet_def

    # Scan all fields for references to packet types
    all_structures = {**fields}

    for struct_def in all_structures.values():
        if isinstance(struct_def, dict) and "fields" in struct_def:
            for field_item in struct_def["fields"]:
                if "type" in field_item:
                    field_type = field_item["type"]
                    base_type, _, is_nested = parse_field_type(field_type)

                    # Check if this references a packet
                    if is_nested and base_type in flat_packets:
                        packets_as_fields[base_type] = flat_packets[base_type]

    return packets_as_fields
```

##### main

```python
main() -> None
```

Main generator entry point.

Source code in `src/lifx/protocol/generator.py`

```python
def main() -> None:
    """Main generator entry point."""
    try:
        # Download and parse protocol from GitHub
        protocol = download_protocol()
    except Exception as e:
        print(f"Error: Failed to download protocol.yml: {e}", file=sys.stderr)
        sys.exit(1)

    # Extract sections
    enums = protocol.get("enums", {})
    fields = protocol.get("fields", {})
    compound_fields = protocol.get("compound_fields", {})
    unions = protocol.get("unions", {})
    packets = protocol.get("packets", {})

    # Filter out Button and Relay items (not relevant for light control)
    print("Filtering out Button and Relay items...")
    enums = filter_button_relay_items(enums)
    fields = filter_button_relay_items(fields)
    compound_fields = filter_button_relay_items(compound_fields)
    unions = filter_button_relay_items(unions)
    packets = filter_button_relay_packets(packets)

    # Apply local quirks to fix protocol issues
    print("Applying local protocol quirks...")
    fields = apply_tile_effect_parameter_quirk(fields)

    # Rebuild protocol dict with filtered items for validation
    filtered_protocol = {
        **protocol,
        "enums": enums,
        "fields": fields,
        "compound_fields": compound_fields,
        "unions": unions,
        "packets": packets,
    }

    # Validate filtered protocol specification
    print("Validating protocol specification...")
    validation_errors = validate_protocol_spec(filtered_protocol)
    if validation_errors:
        print("Validation failed with the following errors:", file=sys.stderr)
        for error in validation_errors:
            print(f"  - {error}", file=sys.stderr)
        sys.exit(1)
    print("Validation passed!")

    # Extract packets that are used as field types (e.g., DeviceStateVersion)
    packets_as_fields = extract_packets_as_fields(packets, fields)

    print(f"Found {len(unions)} unions")
    print(
        f"Found {len(packets_as_fields)} packets used as field types: {list(packets_as_fields.keys())}"
    )

    # Determine output directory
    project_root = Path(__file__).parent.parent.parent.parent
    protocol_dir = project_root / "src" / "lifx" / "protocol"

    # Generate protocol_types.py (avoid conflict with Python's types module)
    types_code = generate_types_file(
        enums, fields, compound_fields, unions, packets_as_fields
    )
    types_file = protocol_dir / "protocol_types.py"
    with open(types_file, "w") as f:
        f.write(types_code)
    print(f"Generated {types_file}")

    # Generate packets.py
    packets_code = generate_packets_file(
        packets, fields, compound_fields, unions, packets_as_fields, enums
    )
    packets_file = protocol_dir / "packets.py"
    with open(packets_file, "w") as f:
        f.write(packets_code)
    print(f"Generated {packets_file}")
```

## Examples

### Working with Serial Numbers

The `Serial` dataclass provides type-safe, immutable serial number handling:

```python
from lifx.protocol.models import Serial

# Create from string (accepts hex with or without separators)
serial = Serial.from_string("d073d5123456")
serial = Serial.from_string("d0:73:d5:12:34:56")  # Also works

# Convert between formats
protocol_bytes = serial.to_protocol()  # 8 bytes with padding
serial_string = serial.to_string()     # "d073d5123456"
serial_bytes = serial.value            # 6 bytes (immutable/frozen)

# Create from protocol format (8 bytes)
serial = Serial.from_protocol(b"\xd0\x73\xd5\x12\x34\x56\x00\x00")
print(serial)  # "d073d5123456"

# String representations
print(str(serial))   # "d073d5123456"
print(repr(serial))  # "Serial('d073d5123456')"
```

### Using Protocol Packets Directly

```python
from lifx.network.connection import DeviceConnection
from lifx.protocol.packets import LightSetColor, LightGet, LightState
from lifx.protocol.protocol_types import LightHsbk
from lifx.protocol.models import Serial


async def main():
    serial = Serial.from_string("d073d5123456")

    async with DeviceConnection(serial.to_string(), "192.168.1.100") as conn:
        # Create a packet
        packet = LightSetColor(
            reserved=0,
            color=LightHsbk(
                hue=240 * 182, saturation=65535, brightness=32768, kelvin=3500
            ),
            duration=1000,  # milliseconds
        )

        # Send without waiting for response
        await conn.send_packet(packet)

        # Request with response
        response = await conn.request_response(LightGet(), LightState)
        print(f"Hue: {response.color.hue / 182}°")
```

### Binary Serialization

```python
from lifx.protocol.packets import DeviceSetLabel
from lifx.protocol.serializer import Serializer

# Create packet
packet = DeviceSetLabel(label=b"Kitchen Light\0" + b"\0" * 19)

# Serialize to bytes
data = packet.pack()
print(f"Packet size: {len(data)} bytes")

# Deserialize from bytes
unpacked = DeviceSetLabel.unpack(data)
print(f"Label: {unpacked.label.decode('utf-8').rstrip('\0')}")
```

### Protocol Header

```python
from lifx.protocol.header import LifxHeader
from lifx.protocol.models import Serial

# Create header with Serial
serial = Serial.from_string("d073d5123456")
header = LifxHeader(
    size=36,
    protocol=1024,
    addressable=True,
    tagged=False,
    origin=0,
    source=0x12345678,
    target=serial.to_protocol(),  # 8 bytes with padding
    reserved1=b"\x00" * 6,
    ack_required=False,
    res_required=True,
    sequence=42,
    reserved2=0,
    pkt_type=101,  # LightGet
    reserved3=0,
)

# Serialize
data = header.pack()
print(f"Header: {data.hex()}")

# Deserialize
unpacked_header = LifxHeader.unpack(data)
print(f"Packet type: {unpacked_header.pkt_type}")
print(f"Target serial: {Serial.from_protocol(unpacked_header.target)}")
```

## Protocol Constants

### Message Types

Each packet class has a `PKT_TYPE` constant defining its protocol message type:

```python
from lifx.protocol.packets import LightSetColor, LightGet, DeviceGetLabel

print(f"LightSetColor type: {LightSetColor.PKT_TYPE}")  # 102
print(f"LightGet type: {LightGet.PKT_TYPE}")  # 101
print(f"DeviceGetLabel type: {DeviceGetLabel.PKT_TYPE}")  # 23
```

### Waveform Types

```python
from lifx.protocol.protocol_types import LightWaveform

# Available waveforms
LightWaveform.SAW
LightWaveform.SINE
LightWaveform.HALF_SINE
LightWaveform.TRIANGLE
LightWaveform.PULSE
```

## Product Registry

The product registry provides automatic device type detection and capability information:

### ProductInfo

```python
ProductInfo(
    pid: int,
    name: str,
    vendor: int,
    capabilities: int,
    temperature_range: TemperatureRange | None,
    min_ext_mz_firmware: int | None,
)
```

Information about a LIFX product.

| ATTRIBUTE             | DESCRIPTION                                                      |
| --------------------- | ---------------------------------------------------------------- |
| `pid`                 | Product ID **TYPE:** `int`                                       |
| `name`                | Product name **TYPE:** `str`                                     |
| `vendor`              | Vendor ID (always 1 for LIFX) **TYPE:** `int`                    |
| `capabilities`        | Bitfield of ProductCapability flags **TYPE:** `int`              |
| `temperature_range`   | Min/max color temperature in Kelvin **TYPE:** \`TemperatureRange |
| `min_ext_mz_firmware` | Minimum firmware version for extended multizone **TYPE:** \`int  |

| METHOD                        | DESCRIPTION                                                          |
| ----------------------------- | -------------------------------------------------------------------- |
| `has_capability`              | Check if product has a specific capability.                          |
| `supports_extended_multizone` | Check if extended multizone is supported for given firmware version. |

#### Attributes

##### has_color

```python
has_color: bool
```

Check if product supports color.

##### has_infrared

```python
has_infrared: bool
```

Check if product supports infrared.

##### has_multizone

```python
has_multizone: bool
```

Check if product supports multizone.

##### has_chain

```python
has_chain: bool
```

Check if product supports chaining.

##### has_matrix

```python
has_matrix: bool
```

Check if product supports matrix (2D grid).

##### has_relays

```python
has_relays: bool
```

Check if product has relays.

##### has_buttons

```python
has_buttons: bool
```

Check if product has buttons.

##### has_hev

```python
has_hev: bool
```

Check if product supports HEV.

##### has_extended_multizone

```python
has_extended_multizone: bool
```

Check if product supports extended multizone.

#### Functions

##### has_capability

```python
has_capability(capability: ProductCapability) -> bool
```

Check if product has a specific capability.

| PARAMETER    | DESCRIPTION                                       |
| ------------ | ------------------------------------------------- |
| `capability` | Capability to check **TYPE:** `ProductCapability` |

| RETURNS | DESCRIPTION                        |
| ------- | ---------------------------------- |
| `bool`  | True if product has the capability |

Source code in `src/lifx/products/registry.py`

```python
def has_capability(self, capability: ProductCapability) -> bool:
    """Check if product has a specific capability.

    Args:
        capability: Capability to check

    Returns:
        True if product has the capability
    """
    return bool(self.capabilities & capability)
```

##### supports_extended_multizone

```python
supports_extended_multizone(firmware_version: int | None = None) -> bool
```

Check if extended multizone is supported for given firmware version.

| PARAMETER          | DESCRIPTION                                          |
| ------------------ | ---------------------------------------------------- |
| `firmware_version` | Firmware version to check (optional) **TYPE:** \`int |

| RETURNS | DESCRIPTION                             |
| ------- | --------------------------------------- |
| `bool`  | True if extended multizone is supported |

Source code in `src/lifx/products/registry.py`

```python
def supports_extended_multizone(self, firmware_version: int | None = None) -> bool:
    """Check if extended multizone is supported for given firmware version.

    Args:
        firmware_version: Firmware version to check (optional)

    Returns:
        True if extended multizone is supported
    """
    if not self.has_extended_multizone:
        return False
    if self.min_ext_mz_firmware is None:
        return True
    if firmware_version is None:
        return True
    return firmware_version >= self.min_ext_mz_firmware
```

### ProductCapability

Bases: `IntEnum`

Product capability flags.

### Using the Product Registry

```python
from lifx.products import get_product, get_device_class_name

# Get product info by product ID
product_info = get_product(product_id=27)

# Get appropriate device class name
class_name = get_device_class_name(product_id=27)  # Returns "Light", "MultiZoneLight", etc.
```

## Protocol Updates

To update to the latest LIFX protocol:

1. Download the latest `protocol.yml` from the [LIFX public-protocol repository](https://github.com/LIFX/public-protocol/blob/main/protocol.yml)
1. Save it to the project root
1. Run the generator: `uv run python -m lifx.protocol.generator`
1. Review the generated code changes
1. Run tests: `uv run pytest`

The generator will automatically:

- Parse the YAML specification
- Generate Python dataclasses for all packet types
- Create enums for protocol constants
- Add serialization/deserialization methods
- Filter out Button/Relay messages (out of scope)

# Exceptions

lifx-async defines a hierarchy of exceptions for different error conditions. All exceptions inherit from `LifxError`.

## Exception Hierarchy

```text
LifxError (base exception)
├── LifxConnectionError
├── LifxTimeoutError
├── LifxDeviceNotFoundError
├── LifxProtocolError
├── LifxNetworkError
└── LifxUnsupportedCommandError
```

## Base Exception

### LifxError

Bases: `Exception`

Base exception for all lifx-async errors.

## Connection Exceptions

### LifxConnectionError

Bases: `LifxError`

Raised when there's a connection error.

### LifxTimeoutError

Bases: `LifxError`

Raised when an operation times out.

### LifxDeviceNotFoundError

Bases: `LifxError`

Raised when a device cannot be found or reached.

## Protocol Exceptions

### LifxProtocolError

Bases: `LifxError`

Raised when there's an error with protocol parsing or validation.

## Network Exceptions

### LifxNetworkError

Bases: `LifxError`

Raised when there's a network-level error.

## Command Exceptions

### LifxUnsupportedCommandError

Bases: `LifxError`

Raised when a device doesn't support the requested command.

## Examples

### Basic Exception Handling

```python
from lifx import discover, LifxError, LifxTimeoutError


async def main():
    try:
        async with discover(timeout=5.0) as group:
            await group.set_color(Colors.BLUE)
    except LifxTimeoutError:
        print("Discovery timed out - no devices found")
    except LifxError as e:
        print(f"LIFX error: {e}")
```

### Specific Exception Handling

```python
from lifx import Light, LifxConnectionError, LifxUnsupportedCommandError


async def main():
    try:
        async with await Light.from_ip("192.168.1.100") as light:
            await light.set_color(Colors.BLUE)
    except LifxConnectionError:
        print("Failed to connect to device")
    except LifxUnsupportedCommandError as e:
        print(f"Device doesn't support this operation: {e}")
```

### Catching All LIFX Exceptions

```python
from lifx import find_lights, LifxError


async def safe_control():
    try:
        async with find_lights() as lights:
            for light in lights:
                await light.set_brightness(0.8)
    except LifxError as e:
        # Catches all LIFX-specific exceptions
        print(f"LIFX operation failed: {e}")
        # Log, retry, or handle gracefully
```

### Timeout Handling

```python
from lifx import DeviceConnection, LifxTimeoutError
from lifx.protocol.packets import LightGet, LightState


async def main():
    try:
        async with DeviceConnection(serial, ip, timeout=2.0) as conn:
            response = await conn.request_response(LightGet(), LightState)
    except LifxTimeoutError:
        print("Device did not respond in time")
        # Device may be offline or unreachable
```

### Protocol Error Handling

```python
from lifx import Light, LifxProtocolError


async def main():
    try:
        async with await Light.from_ip("192.168.1.100") as light:
            await light.set_color(Colors.BLUE)
    except LifxProtocolError:
        print("Protocol-level error occurred")
```

### Unsupported Command Handling

```python
from lifx import find_lights, LifxUnsupportedCommandError


async def main():
    async with find_lights() as lights:
        for light in lights:
            try:
                # Some devices may not support all features
                await light.set_infrared(0.5)
            except LifxUnsupportedCommandError:
                print(f"{light.label} doesn't support this command")
                continue
```

### Device Not Found Handling

```python
from lifx import find_by_serial, LifxDeviceNotFoundError


async def main():
    try:
        device = await find_by_serial("d073d5123456", timeout=3.0)
        if device:
            async with device:
                await device.set_power(True)
    except LifxDeviceNotFoundError:
        print("Device not found on the network")
```

## Best Practices

### Always Catch Specific Exceptions First

```python
# ✅ Good - specific to general
try:
    await light.set_color(Colors.BLUE)
except LifxTimeoutError:
    print("Timeout")
except LifxConnectionError:
    print("Connection failed")
except LifxError:
    print("Other LIFX error")

# ❌ Bad - general exception catches everything
try:
    await light.set_color(Colors.BLUE)
except LifxError:
    print("Error")  # Can't distinguish timeout from other errors
```

### Use Context Managers for Cleanup

```python
# ✅ Good - resources cleaned up even on exception
try:
    async with await Light.from_ip(ip) as light:
        await light.set_color(Colors.BLUE)
except LifxError:
    print("Error occurred but connection was closed properly")

# ❌ Bad - connection may leak on exception
light = Light(serial, ip)
await light.connect()
try:
    await light.set_color(Colors.BLUE)
except LifxError:
    pass  # Connection not closed!
finally:
    await light.disconnect()
```

### Log Exceptions for Debugging

```python
import logging
from lifx import discover, LifxError

logger = logging.getLogger(__name__)


async def main():
    try:
        async with discover() as group:
            await group.set_color(Colors.BLUE)
    except LifxError as e:
        logger.exception("Failed to control lights")
        # Logs full traceback for debugging
```

### Graceful Degradation

```python
from lifx import find_lights, LifxError


async def main():
    async with find_lights() as lights:
        for light in lights:
            try:
                await light.set_color(Colors.BLUE)
            except LifxError as e:
                # Continue with other lights even if one fails
                print(f"Failed to control {light.label}: {e}")
                continue
```

## Common Error Scenarios

### Device Not Responding

```python
# Usually raises: LifxTimeoutError
async with await Light.from_ip("192.168.1.100", timeout=5.0) as light:
    await light.set_color(Colors.BLUE)
```

Causes:

- Device is offline or unpowered
- Wrong IP address
- Network connectivity issues
- Firewall blocking UDP port 56700

### Device Not Found During Discovery

```python
# May raise: LifxTimeoutError or LifxDeviceNotFoundError
async with discover(timeout=3.0) as group:
    if not group.devices:
        print("No devices found")
```

Causes:

- No LIFX devices on the network
- Devices on different subnet
- Discovery timeout too short
- Network doesn't allow broadcast packets

### Connection Failed

```python
# Raises: LifxConnectionError
async with DeviceConnection(serial, ip) as conn:
    await conn.send_packet(packet)
```

Causes:

- Network unreachable
- Device offline
- Port blocked by firewall
- Invalid IP address

### Unsupported Command

```python
# Raises: LifxUnsupportedCommandError
async with await Light.from_ip(ip) as light:
    await light.set_color_zones(0, 5, Colors.RED)  # Not a multizone device
```

Causes:

- Attempting zone control on non-multizone device
- Using tile operations on non-tile device
- Feature not supported by firmware version
- Sending Light commands to non-light devices (e.g., switches)

### Protocol Error

```python
# Raises: LifxProtocolError
```

Causes:

- Invalid packet format received
- Protocol parsing failure
- Corrupted message data
- Unexpected packet type
# Additional Resources

# Frequently Asked Questions

## General

### What is lifx-async?

lifx-async is a modern, async Python library for controlling LIFX smart lighting devices over your local network. It provides a type-safe, high-performance interface for device discovery, color control, effects, and more.

### Which devices are supported?

lifx-async supports all LIFX lighting products:

- **Light**: A19, BR30, Downlight, etc.
- **HEV**: Clean
- **Infrared**: Nightvision
- **Multizone**: LIFX Z, Beam, Neon, String
- **Matrix**: LIFX Tile, Candle, Ceiling, Path, Spot

Button and Relay devices are not currently supported (they are out of scope for this lighting-focused library).

### Do I need cloud access?

No! lifx-async communicates directly with devices over your local network. No cloud connection or LIFX account required.

### What Python versions are supported?

Python 3.11 or higher is required.

## Installation & Setup

### How do I install lifx-async?

```bash
# Using uv (recommended)
uv pip install lifx-async

# Or using pip
pip install lifx-async
```

See the [Installation Guide](../getting-started/installation/) for more options.

### Why can't discovery find my devices?

Common issues:

1. **Same Network**: Ensure your computer and LIFX devices are on the same network
1. **Firewall**: Check firewall settings allow UDP broadcasts
1. **Timeout**: Try increasing timeout: `discover(timeout=10.0)`
1. **Router**: Some routers block broadcast packets - try direct connection

**Workaround** - Connect directly by IP:

```python
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)
```

### Do I need to know my device's IP address?

No! Discovery finds devices automatically:

```python
async with discover() as group:
    # All devices found automatically
    await group.set_color(Colors.BLUE)
```

If you do know the IP, you can connect directly for faster connection.

## Usage

### How do I control multiple lights at once?

Use the `DeviceGroup` returned by `discover()` for batch operations:

```python
from lifx import discover, Colors

async with discover() as group:
    # All lights at once
    await group.set_power(True)
    await group.set_color(Colors.BLUE)
    await group.set_brightness(0.5)
```

### How do I set a specific RGB color?

Use `HSBK.from_rgb()`:

```python
from lifx import HSBK

# Create color from RGB (0-255)
purple = HSBK.from_rgb(128, 0, 128)
await light.set_color(purple)

# Or use hex
color = HSBK.from_rgb(0xFF, 0x00, 0xFF)
```

### Can I control lights concurrently?

Yes! Use `asyncio.gather()`:

```python
import asyncio

# Control multiple lights in parallel
await asyncio.gather(
    light1.set_color(Colors.RED),
    light2.set_color(Colors.GREEN),
    light3.set_color(Colors.BLUE),
)
```

### How do I find a specific device?

By label:

```python
lights = await find_lights(label_contains="Bedroom")
```

By serial number:

```python
device = await find_by_serial("d073d5123456")
```

### What are the available color presets?

See [`Colors`](../api/colors/#lifx.color.Colors) for the complete list:

```python
from lifx import Colors

# Primary colors
Colors.RED, Colors.GREEN, Colors.BLUE

# White variants
Colors.WARM_WHITE, Colors.COOL_WHITE, Colors.DAYLIGHT

# Pastels
Colors.PASTEL_BLUE, Colors.PASTEL_PINK
```

### How do I create smooth transitions?

Use the `duration` parameter (in seconds):

```python
# Fade to blue over 2 seconds
await light.set_color(Colors.BLUE, duration=2.0)

# Fade brightness over 3 seconds
await light.set_brightness(0.5, duration=3.0)
```

### Can I create pulsing effects?

Yes! Use the `pulse()` or `breathe()` methods:

```python
# Pulse red 5 times
await light.pulse(Colors.RED, period=1.0, cycles=5)

# Breathe blue infinitely
await light.breathe(Colors.BLUE, period=2.0, cycles=0)
```

## Performance

### Is lifx-async fast?

Yes! Key performance features:

- **Async I/O**: Non-blocking operations
- **Connection Pooling**: Reuses connections (LRU cache)
- **Rate Limiting**: Prevents overwhelming devices (20 msg/sec)
- **State Caching**: Reduces redundant network requests
- **Concurrent Requests**: Multiple requests per connection

### How is state stored?

Device properties return `(value, timestamp)` tuples with the timestamp reflecting when the value was last retrieved from the device. This gives you explicit control over data freshness:

```python
import time

# Check current stored state
state = light.color
if state:
    color, timestamp = state
    age = time.time() - timestamp
    if age < 5.0:  # Use stored value if less than 5 seconds old
        # Use state color
    else:
        # Data is stale, fetch fresh
        color, _, _ = await light.get_color()
else:
    # Ignore state, fetch from device
    color, _, _ = await light.get_color()
```

To always get fresh data:

```python
# Use get_* methods to always fetch from device
# get_color() returns all three values in one call
color, power, label = await light.get_color()  # Returns (color, power, label)

# Or fetch specific info separately
version = await light.get_version()  # Get firmware and hardware version
```

### Can I control devices from multiple computers?

Yes! lifx-async doesn't require exclusive access. Multiple instances (even on different computers) can control the same devices.

## Troubleshooting

### I get `LifxTimeoutError`

Common causes:

1. **Device offline**: Check device is powered and connected
1. **Network issues**: Verify network connectivity
1. **Firewall**: Ensure UDP port 56700 is open
1. **Timeout too short**: Increase timeout value

### Connection fails with `LifxConnectionError`

Try:

1. **Restart device**: Power cycle the LIFX device
1. **Check IP**: Verify IP address is correct
1. **Firewall**: Check firewall allows UDP 56700
1. **Network**: Ensure same subnet

### Effects don't work as expected

Make sure you're using the correct duration/period values:

```python
# Period is in seconds
await light.pulse(Colors.RED, period=1.0, cycles=5)

# Duration is in seconds (milliseconds * 1000)
await light.set_color(Colors.BLUE, duration=2.0)
```

### Type checker errors

lifx-async is fully type-hinted. If you get type errors:

1. Ensure you're using Python 3.11+
1. Update your type checker (Pyright, mypy)
1. Check you're using correct types

## Development

### How do I contribute?

Quick start:

1. Fork the repository
1. Create a feature branch
1. Make your changes with tests
1. Submit a pull request

### How do I run tests?

```bash
uv run --frozen pytest
```

### How do I generate protocol code?

```bash
uv run python -m lifx.protocol.generator
```

This downloads the latest `protocol.yml` from LIFX and regenerates Python code.

### Where is the protocol specification?

The official LIFX protocol specification is at: https://github.com/LIFX/public-protocol/blob/main/protocol.yml

lifx-async automatically downloads and generates Python code from this specification.

## Advanced

### Can I use lifx-async without async?

No.

### How do I access low-level protocol?

```python
from lifx.protocol.packets import Light
from lifx.protocol.protocol_types import HSBK

# Create a packet directly
packet = Light.SetColor(
    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0
)

# Send via connection
async with DeviceConnection(serial, ip) as conn:
    reply = await conn.request(packet)
```

### How does connection pooling work?

lifx-async maintains an LRU cache of connections. When you open a connection to a device, it's automatically pooled and reused for subsequent operations. Connections are evicted when the cache is full (default maximum: 100 connections).

## Still have questions?

- **Documentation**: Browse the [API Reference](../api/)
- **Issues**: Report bugs on [GitHub Issues](https://github.com/Djelibeybi/lifx-async/issues)
- **Discussions**: Ask questions in [GitHub Discussions](https://github.com/Djelibeybi/lifx-async/discussions)

# CHANGELOG

## v1.3.0 (2025-11-10)

### Features

- Add software effects ([`be768fb`](https://github.com/Djelibeybi/lifx-async/commit/be768fbb4c2984646da4a0ee954b36930ca6261d))

## v1.2.1 (2025-11-08)

### Bug Fixes

- Implement tile effect parameters as local quirk ([`f4ada9b`](https://github.com/Djelibeybi/lifx-async/commit/f4ada9b13f63060459ed80b4961eb9339559a8ea))

## v1.2.0 (2025-11-07)

### Features

- Add theme support ([`82477cd`](https://github.com/Djelibeybi/lifx-async/commit/82477cd078004c37ad5b538ed8a261ac5fbece78))

## v1.1.3 (2025-11-06)

### Performance Improvements

- Reduce network traffic when updating individual color values ([`679b717`](https://github.com/Djelibeybi/lifx-async/commit/679b7176abd7634644e9395281ffa28dde26ebec))

## v1.1.2 (2025-11-05)

### Bug Fixes

- Dummy fix to trigger semantic release ([`86ad8b4`](https://github.com/Djelibeybi/lifx-async/commit/86ad8b442138216974bb65dac130d6ff54bd65a5))

## v1.1.1 (2025-11-05)

### Bug Fixes

- Dummy fix to trigger semantic release ([`12786b5`](https://github.com/Djelibeybi/lifx-async/commit/12786b54e76cd51c023d64f7a23fc963252421f8))

## v1.1.0 (2025-11-05)

### Features

- Replace cache TTL system with timestamped state attributes ([`5ae147a`](https://github.com/Djelibeybi/lifx-async/commit/5ae147a8c1cbbdc0244c9316708bd381269375db))

## v1.0.0 (2025-11-04)

- Initial Release
