# lifx-async

> A modern, type-safe, async Python library for controlling LIFX lights

lifx-async is a modern, type-safe, async Python library for controlling LIFX smart devices
over the local network. Built with Python's built-in asyncio for async/await patterns and
features auto-generated protocol structures from a YAML specification.

Key features:
- Zero runtime dependencies
- Full async/await support with asyncio
- Type-safe with strict Pyright validation
- Auto-generated protocol from official LIFX specification
- Supports all LIFX device types: Light, HevLight, InfraredLight, MultiZoneLight, and TileDevice
- High-level API with device discovery and batch operations
- Concurrent request handling with connection pooling


# Getting Started

# Installation

## System Requirements

- **Python**: 3.11 or higher
- **Network**: Local network access to LIFX devices
- **OS**: Linux, macOS, Windows

## Installation Methods

### Using uv (Recommended)

[`uv`](https://github.com/astral-sh/uv) is a fast Python package installer and resolver written in Rust. It's significantly faster than pip and is the recommended installation method:

```bash
uv pip install lifx-async
```

If you don't have `uv` installed yet:

```bash
# On macOS and Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# On Windows
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"

# Or with pip
pip install uv
```

### Using pip

If you prefer to use pip:

```bash
pip install lifx-async
```

### From Source

For the latest development version:

```bash
git clone https://github.com/Djelibeybi/lifx-async.git
cd lifx

# Using uv (recommended)
uv pip install -e .

# Or using pip
pip install -e .
```

### With Development Dependencies

To install with development tools (recommended for contributors):

```bash
git clone https://github.com/Djelibeybi/lifx-async.git
cd lifx

# Using uv (recommended)
uv sync

# Or using pip
pip install -e ".[dev]"
```

## Verify Installation

Test that lifx-async is installed correctly:

```python
import lifx

print(lifx.__version__)
```

Or run a quick discovery:

```python
import asyncio
from lifx import discover


async def main():
    async with discover(timeout=3.0) as group:
        print(f"Found {len(group)} devices")
        for device in group:
            label = await device.get_label()
            print(f"  - {label}")


asyncio.run(main())
```

## Troubleshooting

### Import Error

If you see `ModuleNotFoundError: No module named 'lifx'`:

1. Ensure lifx-async is installed: `uv pip list | grep lifx-async` or `pip list | grep lifx-async`
1. Check your Python version: `python --version`
1. Verify you're using the correct Python environment

### Network Discovery Issues

If discovery doesn't find devices:

1. Ensure LIFX devices are on the same network
1. Check firewall settings allow UDP broadcasts
1. Try increasing the timeout: `discover(timeout=10.0)`
1. Use direct connection if you know the IP: `Light.from_ip("192.168.1.100")`

### Permission Errors

On some systems, you may need elevated permissions for network operations:

```bash
# Linux/macOS
sudo python your_script.py

# Or add your user to the appropriate group
sudo usermod -a -G netdev $USER  # Linux
```

## Next Steps

- [Quick Start Guide](https://djelibeybi.github.io/lifx-async/getting-started/quickstart/index.md) - Start controlling your lights
- [API Reference](https://djelibeybi.github.io/lifx-async/api/index.md) - Complete API documentation
- [FAQ](https://djelibeybi.github.io/lifx-async/faq/index.md) - Frequently asked questions

# Quick Start

Get up and running with lifx-async in minutes!

## Basic Usage

### 1. Discover Lights

The simplest way to find and control LIFX lights:

```python
import asyncio
from lifx import discover


async def main():
    count = 0
    async for device in discover():
        count += 1
        print(f"Found: {device.serial}")
    print(f"Total: {count} lights")


asyncio.run(main())
```

**Alternative: mDNS Discovery**

For faster discovery with device type detection in a single query:

```python
import asyncio
from lifx import discover_mdns


async def main():
    async for device in discover_mdns():
        async with device:
            color, power, label = await device.get_color()
            print(f"{label}: {type(device).__name__}")


asyncio.run(main())
```

mDNS discovery is faster because it gets device type information directly from the mDNS response, eliminating extra network queries.

### 2. Control a Light

Turn on the first discovered light, then change its color:

```python
import asyncio
from lifx import discover, Colors


async def main():
    async for light in discover():
        await light.set_power(True)
        await light.set_color(Colors.BLUE, duration=1.0)
        break


asyncio.run(main())
```

### 3. Batch Operations

Control multiple lights as a group:

```python
import asyncio
from lifx import discover, DeviceGroup, Colors


async def main():
    devices = []
    async for device in discover():
        devices.append(device)

    # Create DeviceGroup for batch operations
    group = DeviceGroup(devices)
    await group.set_power(True)
    await group.set_color(Colors.BLUE, duration=1.0)
    await group.set_brightness(0.5)




asyncio.run(main())
```

## Common Patterns

### Direct Connection (No Discovery)

If you know the IP:

```python
import asyncio
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        await light.set_color(Colors.RED)


asyncio.run(main())
```

### Find Specific Devices

Find devices by label, IP, or serial:

```python
import asyncio
from lifx import find_by_label, find_by_ip, find_by_serial, Colors


async def main():
    # Find by label (substring match)
    async for device in find_by_label("Bedroom"):  # Matches "Bedroom", "Master Bedroom", etc.
        await device.set_color(Colors.WARM_WHITE)

    # Find by exact label
    async for device in find_by_label("Master Bedroom", exact_match=True):
        await device.set_brightness(0.8)
        break  # exact_match returns at most one device

    # Find by IP address (fastest if you only know the IP)
    device = await find_by_ip("192.168.1.100")
    if device:
        await device.set_power(True)

    # Find by serial number
    device = await find_by_serial("d073d5123456")
    if device:
        await device.set_color(Colors.BLUE)


asyncio.run(main())
```

### Color Presets

Use built-in color presets:

```python
from lifx import Colors

# Primary colors
Colors.RED
Colors.GREEN
Colors.BLUE

# White variants
Colors.WARM_WHITE
Colors.COOL_WHITE
Colors.DAYLIGHT

# Pastels
Colors.PASTEL_BLUE
Colors.PASTEL_PINK
```

### RGB to HSBK

Convert RGB values to HSBK:

```python
from lifx import HSBK

# Create color from RGB
purple = HSBK.from_rgb(128, 0, 128)
await light.set_color(purple)
```

### Effects

Create visual effects:

```python
import asyncio
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Pulse effect
        await light.pulse(Colors.RED, period=1.0, cycles=5)

        # Breathe effect (infinite)
        await light.breathe(Colors.BLUE, period=2.0, cycles=0)


asyncio.run(main())
```

## Error Handling

Always use proper error handling:

```python
import asyncio
from lifx import discover, Colors, LifxError


async def main():
    try:
        async for device in discover():
            await device.set_color(Colors.GREEN)
    except LifxError as e:
        print(f"LIFX error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")


asyncio.run(main())
```

## Next Steps

- [API Reference](https://djelibeybi.github.io/lifx-async/api/index.md) - Complete API documentation
- [Architecture](https://djelibeybi.github.io/lifx-async/architecture/overview/index.md) - How lifx-async works
- [FAQ](https://djelibeybi.github.io/lifx-async/faq/index.md) - Frequently asked questions

# Themes Quick Start

Themes allow you to apply professionally-curated color palettes to your LIFX devices with a single command.

## Apply a Theme

```python
from lifx import discover, DeviceGroup, ThemeLibrary

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

# Get a theme by name
theme = ThemeLibrary.get("evening")

# Apply to all devices
await group.apply_theme(theme)
```

## List Available Themes

```python
from lifx import ThemeLibrary

# Get all 42 theme names
themes = ThemeLibrary.list()
print(themes)

# Get themes by category
seasonal = ThemeLibrary.get_by_category("seasonal")
holidays = ThemeLibrary.get_by_category("holiday")
moods = ThemeLibrary.get_by_category("mood")
```

## Theme Categories

The library includes 42 official LIFX app themes:

- **Seasonal** (3): spring, autumn, winter
- **Holiday** (9): christmas, halloween, hanukkah, kwanzaa, shamrock, thanksgiving, calaveras, pumpkin, santa
- **Mood** (16): peaceful, serene, relaxing, mellow, gentle, soothing, blissful, cheerful, romantic, romance, love, energizing, exciting, epic, intense, powerful
- **Ambient** (6): dream, fantasy, spacey, stardust, zombie, party
- **Functional** (3): focusing, evening, bias_lighting
- **Atmosphere** (3): hygge, tranquil, sports

## Common Options

```python
from lifx import discover, DeviceGroup, ThemeLibrary

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

theme = ThemeLibrary.get("christmas")

# Apply with options
await group.apply_theme(
    theme,
    power_on=True,      # Turn on lights before applying
    duration=1.5        # Transition duration in seconds
)
```

## Create a Custom Theme

```python
from lifx import HSBK, Theme, discover

# Create custom theme with specific colors
custom_theme = Theme([
    HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500),      # Red
    HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500),    # Green
    HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500),    # Blue
])

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await group.apply_theme(custom_theme, power_on=True)
```

## Next Steps

- See [Themes API Reference](https://djelibeybi.github.io/lifx-async/api/themes/index.md) for detailed API documentation
- See [Device Classes](https://djelibeybi.github.io/lifx-async/api/devices/index.md) for device-specific `apply_theme()` methods
- See [Color Utilities](https://djelibeybi.github.io/lifx-async/api/colors/index.md) for HSBK color representation

# Getting Started with Light Effects

The Light Effects Framework provides a comprehensive system for creating and managing visual effects on LIFX devices. This guide will help you get started with the built-in effects and show you common patterns for using the effects system.

## Overview

The effects framework consists of three main components:

- **Conductor**: Central orchestrator that manages effect lifecycle and state
- **Effects**: Pre-built effect classes (EffectPulse, EffectColorloop) and base class for custom effects
- **State Management**: Automatic capture and restoration of device state before and after effects

## Installation

The effects framework is included with lifx-async 1.3.0+. No additional installation is required:

```bash
# Using uv (recommended)
uv pip install lifx-async

# Or using pip
pip install lifx-async
```

## Basic Usage

### Your First Pulse Effect

The simplest way to use the effects framework is with the `EffectPulse` class:

```python
import asyncio
from lifx import discover, DeviceGroup
from lifx.effects import Conductor, EffectPulse

async def main():
    # Discover lights on your network
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    if not group.lights:
        print("No lights found")
        return

    # Create a conductor to manage effects
    conductor = Conductor()

    # Create a blink effect
    effect = EffectPulse(mode='blink', cycles=5)

    # Start the effect on all lights
    await conductor.start(effect, group.lights)

    # Wait for effect to complete (5 cycles * 1 second)
    await asyncio.sleep(6)

    print("Effect complete - lights restored to original state")

asyncio.run(main())
```

### Your First ColorLoop Effect

The `EffectColorloop` creates a continuous rainbow effect:

```python
import asyncio
from lifx import discover, DeviceGroup
from lifx.effects import Conductor, EffectColorloop

async def main():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    if not group.lights:
        print("No lights found")
        return

    conductor = Conductor()

        # Create a rainbow effect
        effect = EffectColorloop(
            period=30,      # 30 seconds per full cycle
            change=20,      # Change hue by 20 degrees each step
            spread=60       # Spread colors across devices
        )

        # Start the effect
        await conductor.start(effect, group.lights)

        # Let it run for 2 minutes
        await asyncio.sleep(120)

        # Stop and restore lights to original state
        await conductor.stop(group.lights)

asyncio.run(main())
```

## Key Concepts

### Conductor

The `Conductor` is the central orchestrator that:

- Captures device state before effects run
- Powers on devices if needed
- Executes effects
- Restores devices to original state when done

You typically create one conductor instance and reuse it for multiple effects.

### Effect State Management

The effects framework automatically:

1. **Captures** current state (power, color, zones) before effect starts
1. **Powers on** devices if they're off (configurable)
1. **Executes** the effect
1. **Restores** all devices to their pre-effect state

This happens completely automatically - you don't need to manage state yourself.

### Effect Completion

There are two ways effects complete:

1. **Automatic** - Pulse effects complete after their cycles finish
1. **Manual** - ColorLoop effects run continuously until `conductor.stop()` is called

## Common Patterns

### Using Specific Lights

You can apply effects to specific lights instead of all discovered devices:

```python
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

conductor = Conductor()

# Get lights by label
bedroom_lights = [
    light for light in group.lights
    if "Bedroom" in await light.get_label()
]

# Apply effect only to bedroom lights
effect = EffectPulse(mode='breathe', cycles=3)
await conductor.start(effect, bedroom_lights)
await asyncio.sleep(4)
```

### Sequential Effects

You can run multiple effects one after another:

```python
conductor = Conductor()

# First effect: blink
effect1 = EffectPulse(mode='blink', cycles=3)
await conductor.start(effect1, group.lights)
await asyncio.sleep(4)

# Second effect: breathe
effect2 = EffectPulse(mode='breathe', cycles=2)
await conductor.start(effect2, group.lights)
await asyncio.sleep(5)
```

Note: The conductor automatically restores state between effects, so each effect starts with the original device state.

### Concurrent Effects on Different Devices

You can run different effects on different groups of lights simultaneously:

```python
conductor = Conductor()

# Split lights into two groups
group1 = group.lights[:len(group.lights)//2]
group2 = group.lights[len(group.lights)//2:]

# Start both effects concurrently
effect1 = EffectPulse(mode='blink')
effect2 = EffectColorloop(period=20)

await conductor.start(effect1, group1)
await conductor.start(effect2, group2)

# Let them run
await asyncio.sleep(30)

# Stop all
await conductor.stop(group.lights)
```

### Custom Colors

Both pulse and colorloop effects support custom colors:

```python
from lifx import HSBK

# Create custom color
red = HSBK.from_rgb(255, 0, 0)
blue = HSBK.from_rgb(0, 0, 255)

# Pulse with custom color
effect = EffectPulse(mode='breathe', cycles=5, color=red)
await conductor.start(effect, group.lights)
await asyncio.sleep(6)
```

### Checking Running Effects

You can check what effect is currently running on a device:

```python
conductor = Conductor()
effect = EffectColorloop(period=30)
await conductor.start(effect, group.lights)

# Check what's running
for light in group.lights:
    current = conductor.effect(light)
    if current:
        print(f"{light.label}: {type(current).__name__}")
    else:
        print(f"{light.label}: idle")
```

## Best Practices

### 1. Use a Single Conductor

Create one conductor instance and reuse it throughout your application:

```python
# Good
conductor = Conductor()
await conductor.start(effect1, lights)
await conductor.start(effect2, lights)

# Not recommended - creates unnecessary overhead
conductor1 = Conductor()
await conductor1.start(effect1, lights)
conductor2 = Conductor()
await conductor2.start(effect2, lights)
```

### 2. Always Wait for Completion

For pulse effects, wait for the effect duration before starting another:

```python
effect = EffectPulse(mode='blink', period=1.0, cycles=5)
await conductor.start(effect, lights)
# Wait for effect to complete
await asyncio.sleep(5 * 1.0 + 0.5)  # cycles * period + buffer
```

### 3. Stop ColorLoop Effects Explicitly

ColorLoop effects run indefinitely, so always call `conductor.stop()`:

```python
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
await asyncio.sleep(60)
# Must explicitly stop
await conductor.stop(lights)
```

### 4. Handle Discovery Failures

Always check if lights were found before attempting effects:

```python
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

if not group.lights:
    print("No lights found on network")
    return

# Safe to use effects
conductor = Conductor()
# ...
```

### 5. Use DeviceGroup for Organization

The DeviceGroup provides convenient access to device collections:

```python
from lifx import discover, DeviceGroup

# Discover devices
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

conductor = Conductor()
await conductor.start(effect, group.lights)
```

## Complete Examples

### Notification Effect

Use effects to create a notification system:

```python
async def notify(lights: list, level: str = 'info'):
    """Flash lights to indicate a notification."""
    conductor = Conductor()

    if level == 'info':
        # Blue breathe
        color = HSBK.from_rgb(0, 0, 255)
        effect = EffectPulse(mode='breathe', cycles=2, color=color)
    elif level == 'warning':
        # Orange blink
        color = HSBK.from_rgb(255, 165, 0)
        effect = EffectPulse(mode='blink', cycles=3, color=color)
    elif level == 'error':
        # Red strobe
        color = HSBK.from_rgb(255, 0, 0)
        effect = EffectPulse(mode='strobe', cycles=10, color=color)

    await conductor.start(effect, lights)
    await asyncio.sleep(4)  # Wait for completion

# Usage
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await notify(group.lights, level='warning')
```

### Party Mode

Cycle through different effects:

```python
async def party_mode(lights: list, duration: int = 60):
    """Run various effects for a party."""
    conductor = Conductor()
    end_time = asyncio.get_event_loop().time() + duration

    effects = [
        EffectColorloop(period=20, change=30, spread=60),
        EffectPulse(mode='strobe', cycles=20),
        EffectColorloop(period=15, change=45, brightness=0.8),
    ]

    effect_idx = 0
    while asyncio.get_event_loop().time() < end_time:
        effect = effects[effect_idx % len(effects)]

        if isinstance(effect, EffectColorloop):
            await conductor.start(effect, lights)
            await asyncio.sleep(20)
            await conductor.stop(lights)
        else:
            await conductor.start(effect, lights)
            await asyncio.sleep(3)

        effect_idx += 1

    # Ensure everything is stopped and restored
    await conductor.stop(lights)

# Usage
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await party_mode(group.lights, duration=120)
```

## Next Steps

- See [Effects Reference](https://djelibeybi.github.io/lifx-async/api/effects/index.md) for detailed documentation on all effect parameters
- See [Custom Effects](https://djelibeybi.github.io/lifx-async/user-guide/effects-custom/index.md) to learn how to create your own effects
- See [Effects Architecture](https://djelibeybi.github.io/lifx-async/architecture/effects-architecture/index.md) to understand how the system works internally
- See [Troubleshooting](https://djelibeybi.github.io/lifx-async/user-guide/effects-troubleshooting/index.md) for common issues and solutions
# User Guide

# Using Themes: Practical Examples

Themes enable coordinated color schemes across your LIFX devices. This guide covers practical examples and patterns.

## Basic Usage

### Apply Theme to All Devices

```python
from lifx import discover, DeviceGroup, ThemeLibrary

async def apply_evening_mode():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    theme = ThemeLibrary.get("evening")
    await group.apply_theme(theme, power_on=True, duration=2.0)
```

### Apply Different Themes to Different Device Types

```python
from lifx import discover, DeviceGroup, ThemeLibrary

async def themed_lighting():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    theme = ThemeLibrary.get("christmas")

    # Single-zone lights get a random color
    for light in group.lights:
        await light.apply_theme(theme)

    # Multi-zone lights get distributed colors
    for strip in group.multizone_lights:
        await strip.apply_theme(theme)

    # Tile devices get smooth interpolation
    for tile in group.tiles:
        await tile.apply_theme(theme)
```

## Time-Based Lighting

### Morning to Night Transition

```python
from lifx import discover, DeviceGroup, ThemeLibrary
import asyncio

async def daily_lighting_schedule():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    schedule = [
        ("06:00", "energizing"),   # Morning
        ("12:00", "focusing"),     # Afternoon
        ("18:00", "evening"),      # Early evening
        ("21:00", "relaxing"),     # Night
        ("23:00", "peaceful"),     # Bedtime
    ]

    for time_str, theme_name in schedule:
        theme = ThemeLibrary.get(theme_name)
        await group.apply_theme(theme, duration=2.0)
        # In production, schedule this with APScheduler or similar
        await asyncio.sleep(2.0)  # Demo delay
```

## Holiday Decorations

### Holiday Mode Manager

```python
from lifx import discover, DeviceGroup, ThemeLibrary
from datetime import datetime

async def activate_holiday_theme():
    """Apply appropriate holiday theme based on current month."""
    month = datetime.now().month

    holiday_map = {
        3: "shamrock",        # March: St. Patrick's Day
        10: "halloween",      # October
        11: "thanksgiving",   # November
        12: "christmas",      # December
    }

    theme_name = holiday_map.get(month)
    if not theme_name:
        return

    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    theme = ThemeLibrary.get(theme_name)
    await group.apply_theme(theme, power_on=True)
```

### Multi-Room Holiday Setup

```python
from lifx import discover, DeviceGroup, ThemeLibrary

async def decorate_house_for_christmas():
    """Apply Christmas theme throughout the house."""
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    theme = ThemeLibrary.get("christmas")

    # Living room: full brightness
    for light in group.lights:
        if "living" in light.label.lower():
            await light.apply_theme(theme, power_on=True, duration=1.0)

    # Bedroom: dimmer
    for light in group.lights:
        if "bedroom" in light.label.lower():
            dim_theme = ThemeLibrary.get("peaceful")
            await light.apply_theme(dim_theme, power_on=True, duration=1.0)

    # Strips and tiles throughout
    for strip in group.multizone_lights:
        await strip.apply_theme(theme, power_on=True, duration=1.5)

    for tile in group.tiles:
        await tile.apply_theme(theme, power_on=True, duration=1.5)
```

## Dynamic Theme Transitions

### Smooth Theme Cycling

```python
from lifx import discover, DeviceGroup, ThemeLibrary
import asyncio

async def cycle_moods():
    """Smoothly transition between mood themes."""
    mood_themes = [
        "peaceful",
        "relaxing",
        "mellow",
        "cheerful",
        "energizing",
    ]

    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    for theme_name in mood_themes:
        theme = ThemeLibrary.get(theme_name)
        await group.apply_theme(theme, duration=2.0)
        await asyncio.sleep(2.5)  # Wait for transition + 0.5s delay
```

### Theme Playlist

```python
from lifx import discover, DeviceGroup, ThemeLibrary
import asyncio

async def theme_playlist(themes: list[str], duration: float = 5.0):
    """Apply a sequence of themes with configurable timing."""
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    for theme_name in themes:
        try:
            theme = ThemeLibrary.get(theme_name)
            await group.apply_theme(theme, duration=1.0)
            await asyncio.sleep(duration)
        except KeyError:
            print(f"Theme '{theme_name}' not found, skipping")

# Usage:
# await theme_playlist(["evening", "relaxing", "peaceful"], duration=10.0)
```

## Room-Specific Themes

### Multi-Room Coordination

```python
from lifx import discover, DeviceGroup, ThemeLibrary
import asyncio

async def set_room_theme(room_name: str, theme_name: str):
    """Apply theme to all lights in a specific room (group)."""
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    theme = ThemeLibrary.get(theme_name)
    groups = await group.organize_by_group()

    if room_name in groups:
        room_lights = groups["room_name"]

    for light in room_lights.lights:
        await light.apply_theme(theme, power_on=True)

    for strip in room_lights.multizone_lights:
        await strip.apply_theme(theme, power_on=True)

# Usage:
# await set_room_theme("bedroom", "peaceful")
# await set_room_theme("kitchen", "focusing")
```

### Home Scene Presets

```python
from lifx import discover, ThemeLibrary

async def activate_scene(scene: str):
    """Activate a pre-defined home scene."""
    scenes = {
        "movie_night": {
            "living_room": "stardust",
            "kitchen": "evening",
            "bedroom": "peaceful",
        },
        "date_night": {
            "living_room": "romantic",
            "bedroom": "romance",
        },
        "party": {
            "living_room": "party",
            "kitchen": "energizing",
        },
        "focus": {
            "home_office": "focusing",
            "kitchen": "energizing",
        },
    }

    if scene not in scenes:
        print(f"Scene '{scene}' not found")
        return

    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    groups = group.organize_by_group()

    for room, theme_name in scenes[scene].items():
        if room not in groups:
            continue

        room_lights = groups["room"]
        theme = ThemeLibrary.get(theme_name)

        for light in room_lights.lights:
            await light.apply_theme(theme, power_on=True, duration=1.5)

        for strip in room_lights.multizone_lights:
            await strip.apply_theme(theme, power_on=True, duration=1.5)

# Usage:
# await activate_scene("movie_night")
# await activate_scene("party")
```

## Custom Themes

### Create Branded Theme

```python
from lifx import HSBK, Theme, discover, DeviceGroup

# Create corporate branding theme
corporate_theme = Theme([
    HSBK(hue=220, saturation=0.8, brightness=0.9, kelvin=4000),  # Professional blue
    HSBK(hue=0, saturation=0.7, brightness=0.8, kelvin=4000),     # Corporate red
    HSBK(hue=200, saturation=0.5, brightness=0.7, kelvin=4000),   # Light blue
])

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await group.apply_theme(corporate_theme)
```

### Sunset Gradient

```python
from lifx import HSBK, Theme, discover, DeviceGroup

# Create sunset-inspired gradient
sunset_theme = Theme([
    HSBK(hue=45, saturation=1.0, brightness=1.0, kelvin=3000),   # Orange
    HSBK(hue=15, saturation=0.9, brightness=0.9, kelvin=2700),   # Deep orange
    HSBK(hue=0, saturation=0.8, brightness=0.8, kelvin=2500),    # Red
    HSBK(hue=320, saturation=0.7, brightness=0.7, kelvin=2400),  # Deep red
])

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await group.apply_theme(sunset_theme, duration=3.0)
```

## Error Handling

### Robust Theme Application

```python
from lifx import discover, DeviceGroup, ThemeLibrary, LifxTimeoutError, LifxDeviceNotFoundError

async def safe_apply_theme(theme_name: str):
    """Apply theme with comprehensive error handling."""
    try:
        # Validate theme exists
        theme = ThemeLibrary.get(theme_name)
    except KeyError as e:
        print(f"Theme error: {e}")
        return False

    try:
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)

        if not group.devices:
            print("No lights found")
            return False

        await group.apply_theme(theme, power_on=True, duration=1.5)
        print(f"Successfully applied '{theme_name}' theme")
        return True

    except LifxTimeoutError:
        print("Timeout: Devices did not respond in time")
        return False
    except LifxDeviceNotFoundError:
        print("Device error: Could not reach device")
        return False
    except Exception as e:
        print(f"Unexpected error: {e}")
        return False
```

## Performance Tips

### Batch Operations

When applying themes to many devices, use `DeviceGroup.apply_theme()` for concurrent execution:

```python
from lifx import discover, DeviceGroup, ThemeLibrary

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

theme = ThemeLibrary.get("evening")
# All devices updated concurrently
await group.apply_theme(theme)
```

### Avoid Rapid Transitions

```python
from lifx import discover, DeviceGroup, ThemeLibrary
import asyncio

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

themes = ["evening", "relaxing", "peaceful"]

for theme_name in themes:
    theme = ThemeLibrary.get(theme_name)
    await group.apply_theme(theme, duration=2.0)
    # Wait for transition to complete
    await asyncio.sleep(2.5)
```

## See Also

- [Themes API Reference](https://djelibeybi.github.io/lifx-async/api/themes/index.md) - Complete API documentation
- [Quick Start: Themes](https://djelibeybi.github.io/lifx-async/getting-started/themes/index.md) - Simple examples
- [Colors Guide](https://djelibeybi.github.io/lifx-async/api/colors/index.md) - Working with HSBK colors
- [Device Classes](https://djelibeybi.github.io/lifx-async/api/devices/index.md) - Device-specific documentation

# Ceiling Lights

LIFX Ceiling lights are unique fixtures that combine two lighting components in one device:

- **Downlight**: Main illumination with multiple addressable zones (63 or 127 zones)
- **Uplight**: Ambient/indirect lighting via a single zone

The `CeilingLight` class provides high-level control over these components while inheriting full matrix functionality from `MatrixLight`.

## Supported Devices

| Product                        | Zones | Layout                        |
| ------------------------------ | ----- | ----------------------------- |
| LIFX Ceiling (US/Intl)         | 64    | 8x8 grid, zone 63 = uplight   |
| LIFX Ceiling Capsule (US/Intl) | 128   | 16x8 grid, zone 127 = uplight |

## Quick Start

```python
from lifx import CeilingLight
from lifx.color import HSBK

async def main():
    async with await CeilingLight.from_ip("192.168.1.100") as ceiling:
        # Set downlight to warm white
        await ceiling.set_downlight_colors(
            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3000)
        )

        # Set uplight to a dim, warm ambient glow
        await ceiling.set_uplight_color(
            HSBK(hue=30, saturation=0.2, brightness=0.3, kelvin=2700)
        )
```

## Component Control

### Setting Colors

#### Downlight

Set all downlight zones to the same color:

```python
# Single color for all zones
await ceiling.set_downlight_colors(
    HSBK(hue=0, saturation=0, brightness=0.8, kelvin=4000)
)
```

Or set each zone individually:

```python
# Create a gradient across all zones
zone_count = len(range(*ceiling.downlight_zones.indices(256)))
colors = [
    HSBK(hue=(i * 360 / zone_count), saturation=1.0, brightness=0.5, kelvin=3500)
    for i in range(zone_count)
]
await ceiling.set_downlight_colors(colors)
```

#### Uplight

```python
await ceiling.set_uplight_color(
    HSBK(hue=30, saturation=0.1, brightness=0.4, kelvin=2700)
)
```

### Reading Current Colors

```python
# Get current uplight color
uplight_color = await ceiling.get_uplight_color()
print(f"Uplight: H={uplight_color.hue}, B={uplight_color.brightness}")

# Get all downlight colors
downlight_colors = await ceiling.get_downlight_colors()
print(f"Downlight zones: {len(downlight_colors)}")
```

### Turning Components On/Off

The `turn_*_on()` and `turn_*_off()` methods provide smart state management:

```python
# Turn off uplight (stores current color for later restoration)
await ceiling.turn_uplight_off()

# Turn uplight back on (restores previous color)
await ceiling.turn_uplight_on()

# Turn on with a specific color
await ceiling.turn_uplight_on(
    color=HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500)
)
```

The same pattern works for downlights:

```python
# Turn off downlight
await ceiling.turn_downlight_off()

# Turn downlight back on
await ceiling.turn_downlight_on()

# Turn on with specific colors
await ceiling.turn_downlight_on(
    colors=HSBK(hue=0, saturation=0, brightness=0.8, kelvin=4000)
)
```

### Checking Component State

```python
# Check if components are on
if ceiling.uplight_is_on:
    print("Uplight is on")

if ceiling.downlight_is_on:
    print("Downlight is on")
```

State Properties Require Recent Data

The `uplight_is_on` and `downlight_is_on` properties rely on cached data. Call `get_uplight_color()` or `get_downlight_colors()` first to ensure accurate state.

## Device State

After connecting to a CeilingLight, you can access the complete device state via the `state` property, which returns a `CeilingLightState` dataclass:

```python
from lifx import CeilingLight, CeilingLightState

async with await CeilingLight.from_ip("192.168.1.100") as ceiling:
    state: CeilingLightState = ceiling.state

    # Access ceiling-specific state
    print(f"Uplight color: {state.uplight_color}")
    print(f"Uplight is on: {state.uplight_is_on}")
    print(f"Downlight zones: {len(state.downlight_colors)}")
    print(f"Downlight is on: {state.downlight_is_on}")

    # Access inherited state from MatrixLightState/LightState
    print(f"Device label: {state.label}")
    print(f"Power: {'on' if state.power else 'off'}")
    print(f"Model: {state.model}")
```

### CeilingLightState Attributes

`CeilingLightState` extends `MatrixLightState` with ceiling-specific attributes:

| Attribute          | Type         | Description                                |
| ------------------ | ------------ | ------------------------------------------ |
| `uplight_color`    | `HSBK`       | Current color of the uplight component     |
| `downlight_colors` | `list[HSBK]` | Colors for each downlight zone (63 or 127) |
| `uplight_is_on`    | `bool`       | True if uplight brightness > 0             |
| `downlight_is_on`  | `bool`       | True if any downlight zone brightness > 0  |
| `uplight_zone`     | `int`        | Zone index for uplight (63 or 127)         |
| `downlight_zones`  | `slice`      | Slice for downlight zones                  |

Plus all attributes inherited from `MatrixLightState`: `chain`, `tile_colors`, `tile_count`, `effect`, and from `LightState`: `color`, `power`, `label`, `model`, `serial`, `mac_address`, `capabilities`, etc.

## Zone Layout

Access the component zone indices directly:

```python
async with await CeilingLight.from_ip("192.168.1.100") as ceiling:
    # Get uplight zone index (63 or 127 depending on model)
    uplight_idx = ceiling.uplight_zone
    print(f"Uplight zone: {uplight_idx}")

    # Get downlight zones as a slice
    downlight_slice = ceiling.downlight_zones
    print(f"Downlight zones: {downlight_slice}")  # slice(0, 63) or slice(0, 127)

    # Calculate number of downlight zones
    zone_count = len(range(*downlight_slice.indices(256)))
    print(f"Number of downlight zones: {zone_count}")
```

## State Persistence

CeilingLight supports optional state persistence to preserve component colors across sessions:

```python
async with await CeilingLight.from_ip(
    "192.168.1.100",
    state_file="~/.lifx/ceiling_state.json"
) as ceiling:
    # Colors are automatically loaded from file on connection
    # and saved when using turn_*_off() methods

    await ceiling.turn_uplight_off()  # Saves current color to file
    # ... later ...
    await ceiling.turn_uplight_on()   # Restores from file if available
```

The state file stores colors per device serial number, supporting multiple devices:

```json
{
  "d073d5123456": {
    "uplight": {
      "hue": 30.0,
      "saturation": 0.2,
      "brightness": 0.4,
      "kelvin": 2700
    },
    "downlight": [
      {"hue": 0.0, "saturation": 0.0, "brightness": 0.8, "kelvin": 4000}
    ]
  }
}
```

## Brightness Determination

When calling `turn_uplight_on()` or `turn_downlight_on()` without a color parameter, CeilingLight uses the following priority to determine brightness:

1. **Stored state**: If a color was previously saved (via `turn_*_off()` or `set_*_color()`)
1. **Infer from other component**: Average brightness of the other component
1. **Default**: 80% brightness

This ensures a reasonable brightness level even when no state is available.

## Transition Duration

All color-setting methods support smooth transitions:

```python
# 2-second transition to new color
await ceiling.set_uplight_color(
    HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500),
    duration=2.0  # seconds
)

# Instant change (default)
await ceiling.set_downlight_colors(
    HSBK(hue=240, saturation=1.0, brightness=0.5, kelvin=3500),
    duration=0.0
)
```

## MatrixLight Compatibility

CeilingLight extends `MatrixLight`, so all matrix operations are available:

```python
async with await CeilingLight.from_ip("192.168.1.100") as ceiling:
    # Use MatrixLight methods directly
    all_colors = await ceiling.get_all_tile_colors()
    tile_chain = await ceiling.get_tile_chain()

    # Set raw matrix colors (bypasses component abstraction)
    await ceiling.set_matrix_colors(0, colors)

    # Apply effects
    from lifx.protocol.protocol_types import TileEffectType
    await ceiling.set_tile_effect(
        effect_type=TileEffectType.MORPH,
        speed=5000,
    )
```

## Example: Night Mode

Create a subtle night light with dim uplight and downlight off:

```python
from lifx import CeilingLight
from lifx.color import HSBK

async def night_mode(ip: str):
    async with await CeilingLight.from_ip(ip) as ceiling:
        # Store current colors before turning off
        await ceiling.turn_downlight_off()

        # Set uplight to very dim warm glow
        await ceiling.set_uplight_color(
            HSBK(hue=30, saturation=0.3, brightness=0.05, kelvin=2200),
            duration=2.0
        )
```

## Example: Daytime Productivity

Bright, cool white for focus:

```python
async def daytime_mode(ip: str):
    async with await CeilingLight.from_ip(ip) as ceiling:
        # Bright cool downlight for task lighting
        await ceiling.set_downlight_colors(
            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=5500),
            duration=1.0
        )

        # Turn off uplight during the day
        await ceiling.turn_uplight_off(duration=1.0)
```

## Example: Evening Ambiance

Warm tones with accent uplight:

```python
async def evening_mode(ip: str):
    async with await CeilingLight.from_ip(ip) as ceiling:
        # Dimmed warm downlight
        await ceiling.set_downlight_colors(
            HSBK(hue=30, saturation=0.1, brightness=0.4, kelvin=2700),
            duration=2.0
        )

        # Colorful uplight accent
        await ceiling.set_uplight_color(
            HSBK(hue=280, saturation=0.6, brightness=0.3, kelvin=3500),
            duration=2.0
        )
```

## API Reference

See [CeilingLight API Reference](https://djelibeybi.github.io/lifx-async/api/devices/#ceiling-light) for complete method documentation.

# Advanced Usage

This guide covers advanced lifx patterns and techniques for building robust LIFX integrations.

## Table of Contents

- [Discovery Methods](#discovery-methods)
- [Storing State](#storing-state)
- [Connection Management](#connection-management)
- [Concurrency Patterns](#concurrency-patterns)
- [Error Handling](#error-handling)
- [Device Capabilities](#device-capabilities)
- [Custom Effects](#custom-effects)
- [Performance Optimization](#performance-optimization)

## Discovery Methods

lifx-async provides two discovery methods with different trade-offs:

### UDP Broadcast Discovery

The traditional discovery method broadcasts to all devices on the network:

```python
from lifx import discover

async def broadcast_discovery():
    async for device in discover(timeout=5.0):
        async with device:
            color, power, label = await device.get_color()
            print(f"Found: {label} ({type(device).__name__})")
```

**Characteristics:**

- Sends 1 broadcast + N queries (one per device for type detection)
- Works on any local network
- May miss devices on other subnets

### mDNS Discovery

mDNS discovery uses DNS-SD to find devices with a single multicast query:

```python
from lifx import discover_mdns

async def mdns_discovery():
    async for device in discover_mdns(timeout=5.0):
        async with device:
            color, power, label = await device.get_color()
            print(f"Found: {label} ({type(device).__name__})")
```

**Characteristics:**

- Single network query (device type in TXT record)
- Faster discovery with immediate type detection
- Can work across subnets with an mDNS reflector
- Zero dependencies (uses Python stdlib only)

### Low-Level mDNS API

For raw mDNS data without device instantiation:

```python
from lifx import discover_lifx_services

async def raw_mdns_discovery():
    async for record in discover_lifx_services(timeout=5.0):
        print(f"Serial: {record.serial}")
        print(f"IP: {record.ip}:{record.port}")
        print(f"Product ID: {record.product_id}")
        print(f"Firmware: {record.firmware}")
```

### Choosing a Discovery Method

| Scenario                      | Recommended Method                |
| ----------------------------- | --------------------------------- |
| General use                   | `discover()` or `discover_mdns()` |
| Fastest discovery             | `discover_mdns()`                 |
| Cross-subnet (with reflector) | `discover_mdns()`                 |
| Maximum compatibility         | `discover()`                      |
| Raw device data               | `discover_lifx_services()`        |

## Storing State

Device properties return cached values that were last retrieved from the device.

lifx-async automatically populates initial state values when a device is used as an async context manager.

### Understanding Stored State

All device state properties return cached values or `None` if not yet fetched:

```python
from lifx import Light

async def check_stored_state():
    async with await Light.from_ip("192.168.1.100") as light:
        # Property returns cached value or None
        label = light.label
        if label:
            print(f"Cached label: {label}")
        else:
            print("No cached label - fetching from device")
            label = await light.get_label()
            print(f"Label: {label}")
```

### Fetching Fresh Data

Use the `get_*()` methods to always fetch from the device:

```python
async def always_fresh():
    async with await Light.from_ip("192.168.1.100") as light:
        # Always fetches from device
        # Note: get_color() returns a tuple of (color, power, label)
        color, power, label = await light.get_color()

        # Get other device info
        version = await light.get_version()

        # Some properties cache semi-static data
        cached_label = light.label  # Updated from get_color()
```

### Working with Cached Data

Use cached values when available for semi-static data, always fetch volatile state:

```python
async def use_cached_or_fetch():
    async with await Light.from_ip("192.168.1.100") as light:
        # Check if we have cached label (semi-static)
        label = light.label
        if label:
            print(f"Using cached label: {label}")
        else:
            print("No cached label, fetching from device")
            label = await light.get_label()
            print(f"Fetched label: {label}")

        # For volatile state (power, color), always fetch fresh data
        # get_color() will only cache the label
        color, power, label = await light.get_color()
        print(f"Current state of {light.label} - Power: {power}, Color: {color}")
```

### Available Properties

#### Device Properties

- `Device.label` - Device name/label
- `Device.version` - Vendor ID and Product ID
- `Device.host_firmware` - Major and minor host firmware version and build number
- `Device.wifi_firmware` - Major and minor wifi firmware version and build number
- `Device.location` - Device location name/label
- `Device.group` - Device group name/label

##### Non-State Properties

- `Device.model` - Device product model

#### Light properties

##### Non-State Properties

- `Light.min_kelvin` - Lowest supported kelvin value
- `Light.max_kelvin` - Highest supported kelvin value

#### InfraredLight properties

- `InfraredLight.infrared` - Infrared brightness

#### HevLight properties:

- `HevLight.hev_config` - HEV configuration
- `HevLight.hev_result` - Last HEV result

#### MultiZoneLight properties:

- `MultiZoneLight.zone_count` - Number of zones
- `MultiZoneLight.multizone_effect` - Either MOVE or OFF

#### MatrixLight properties:

- `MatrixLight.tile_count` - Number of tiles on the chain
- `MatrixLight.device_chain` - Details of each tile on the chain
- `MatrixLight.tile_effect` - Either MORPH, FLAME, SKY or OFF

#### CeilingLight properties:

- `CeilingLight.uplight_zone` - Zone index of the uplight component
- `CeilingLight.downlight_zones` - Slice representing downlight zones
- `CeilingLight.uplight_is_on` - True if uplight has brightness > 0 (requires recent data)
- `CeilingLight.downlight_is_on` - True if any downlight zone has brightness > 0 (requires recent data)

**Note**: Volatile state properties (power, color, hev_cycle, zones, tile_colors) have been removed. Always use `get_*()` methods to fetch these values from devices as they change too frequently to benefit from caching.

All cached properties return `None` if no data has been cached yet, or the cached value if available.

## Connection Management

### Understanding Lazy Connections

Each device owns its own connection that opens lazily on first request:

```python
from lifx import Light

async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Connection opens automatically on first request
        await light.set_power(True)
        # All subsequent operations reuse the same connection
        await light.set_color(Colors.BLUE)
        await light.get_label()
        # Connection automatically closed when exiting context
```

**Benefits:**

- Simple lifecycle: one connection per device
- Lazy opening: connection opens only when needed
- Automatic cleanup on context exit
- Requests are serialized to prevent response mixing

## Concurrency Patterns

### Concurrent Requests (Single Device)

Send multiple requests concurrently to one device:

```python
import asyncio
from lifx import Light

async def concurrent_operations():
    async with await Light.from_ip("192.168.1.100") as light:
        # These execute concurrently!
        # get_color() returns (color, power, label)
        (color, power, label), version = await asyncio.gather(
            light.get_color(),
            light.get_version(),
        )

        print(f"{label}: Power={power}, Color={color}, Firmware={version.firmware}")
```

**Performance Note:** Concurrent requests execute with maximum parallelism. However, per the LIFX protocol specification, devices can handle approximately 20 messages per second. When sending many concurrent requests to a single device, consider implementing rate limiting in your application to avoid overwhelming the device.

### Multi-Device Control

Control multiple devices in parallel:

```python
import asyncio
from lifx import discover, DeviceGroup, Colors

async def multi_device_control():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    # Create different tasks for different devices
    tasks = [
        group.devices[0].set_color(Colors.RED),
        group.devices[1].set_color(Colors.GREEN),
        group.devices[2].set_color(Colors.BLUE),
    ]

    # Execute all at once
    await asyncio.gather(*tasks)
```

### Batched Discovery

Discover devices in batches for large networks:

```python
from lifx.network.discovery import discover_devices

async def discover_in_batches():
    # First batch: quick discovery
    devices_quick = await discover_devices(
        timeout=1.0,
        broadcast_address="255.255.255.255"
    )

    # Second batch: thorough discovery
    if len(devices_quick) < expected_count:
        devices_full = await discover_devices(
            timeout=5.0,
            broadcast_address="255.255.255.255"
        )
        return devices_full

    return devices_quick
```

## Error Handling

### Exception Hierarchy

```python
from lifx import (
    LifxError,              # Base exception
    LifxTimeoutError,       # Request timeout
    LifxConnectionError,    # Connection failed
    LifxProtocolError,      # Invalid protocol response
    LifxDeviceNotFoundError,# Device not discovered
    LifxNetworkError,       # Network issues
    LifxUnsupportedCommandError,  # Device doesn't support operation
)
```

### Robust Error Handling

```python
import asyncio
from lifx import Light, Colors, LifxTimeoutError, LifxConnectionError

async def resilient_control():
    max_retries = 3

    for attempt in range(max_retries):
        try:
            async with await Light.from_ip("192.168.1.100") as light:
                await light.set_color(Colors.BLUE)
                print("Success!")
                return

        except LifxTimeoutError:
            print(f"Timeout (attempt {attempt + 1}/{max_retries})")
            if attempt < max_retries - 1:
                await asyncio.sleep(1.0)  # Wait before retry

        except LifxConnectionError as e:
            print(f"Connection failed: {e}")
            break  # Don't retry connection errors

    print("All retries exhausted")
```

### Graceful Degradation

```python
from lifx import discover, DeviceGroup, LifxError

async def best_effort_control():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    results = []

    # Try to control all lights, continue on errors
    for light in group.lights:
        try:
            await light.set_color(Colors.GREEN)
            results.append((light, "success"))
        except LifxError as e:
            results.append((light, f"failed: {e}"))

    # Report results
    for light, status in results:
        label = await light.get_label() if status == "success" else "Unknown"
        print(f"{label}: {status}")
```

## Device Capabilities

### Detecting Capabilities

Light capabilities are automatically populated:

```python
from lifx import Light
from lifx.products.registry import ProductCapability

async def check_capabilities():
    async with await Light.from_ip("192.168.1.100") as light:

        print(f"Product: {light.model}")
        print(f"Capabilities: {light.capabilities}")

        # Check specific capabilities
        if ProductCapability.COLOR in light.capabilities:
            await light.set_color(Colors.BLUE)

        if ProductCapability.MULTIZONE in light.capabilities:
            print("This is a multizone device!")

        if ProductCapability.INFRARED in light.capabilities:
            print("Supports infrared!")
```

### Capability-Based Logic

```python
from lifx import discover, DeviceGroup
from lifx.products.registry import ProductCapability

async def capability_aware_control():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    for device in group.devices:

        # Color devices
        if ProductCapability.COLOR in device.capabilities:
            await device.set_color(Colors.PURPLE)

        # Multizone devices
        if ProductCapability.MULTIZONE in device.capabilities:
            await device.set_color_zones(0, 8, Colors.RED)
```

## Custom Effects

### Creating Smooth Transitions

```python
import asyncio
from lifx import Light, HSBK

async def smooth_color_cycle():
    async with await Light.from_ip("192.168.1.100") as light:
        hues = [0, 60, 120, 180, 240, 300, 360]

        for hue in hues:
            color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)
            await light.set_color(color, duration=2.0)  # 2 second transition
            await asyncio.sleep(2.0)
```

### Synchronized Multi-Device Effects

```python
import asyncio
from lifx import discover, DeviceGroup, Colors

async def synchronized_flash():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    # Flash all devices simultaneously
    for _ in range(5):
        await group.set_color(Colors.RED, duration=0.0)
        await asyncio.sleep(0.2)
        await group.set_color(Colors.OFF, duration=0.0)
        await asyncio.sleep(0.2)
```

### Wave Effect Across Devices

```python
import asyncio
from lifx import discover, DeviceGroup, Colors

async def wave_effect():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    for i, device in enumerate(group.devices):
        # Each device changes color with a delay
        asyncio.create_task(
            delayed_color_change(device, Colors.BLUE, delay=i * 0.3)
        )

async def delayed_color_change(device, color, delay):
    await asyncio.sleep(delay)
    await device.set_color(color, duration=1.0)
```

## Performance Optimization

### Minimize Network Requests

```python
#  Inefficient: Multiple round-trips
async def inefficient():
    async with await Light.from_ip("192.168.1.100") as light:
        await light.set_power(True)
        await asyncio.sleep(0.1)
        await light.set_color(Colors.BLUE)
        await asyncio.sleep(0.1)
        await light.set_brightness(0.8)

#  Efficient: Set color and brightness together
async def efficient():
    async with await Light.from_ip("192.168.1.100") as light:
        await light.set_power(True)
        # Set color includes brightness
        color = HSBK(hue=240, saturation=1.0, brightness=0.8, kelvin=3500)
        await light.set_color(color, duration=0.0)
```

### Batch Operations

```python
from lifx import discover, DeviceGroup, Colors

#  Sequential: Takes N * latency
async def sequential():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    for device in group.devices:
        await device.set_color(Colors.GREEN)

#  Parallel: Takes ~latency
async def parallel():
    devices = []
    async for device in discover():
        devices.append(device)
    group = DeviceGroup(devices)

    await group.set_color(Colors.GREEN)
```

### Connection Reuse

```python
#  Creates new connection each time
async def no_reuse():
    for _ in range(10):
        async with await Light.from_ip("192.168.1.100") as light:
            await light.set_brightness(0.5)
        # Connection closed here

#  Reuses connection
async def with_reuse():
    async with await Light.from_ip("192.168.1.100") as light:
        for _ in range(10):
            await light.set_brightness(0.5)
        # Connection closed once at end
```

### Fire-and-Forget Mode for High-Frequency Animations

For animations sending more than 20 updates per second, waiting for device acknowledgement creates unacceptable latency. Use the `fast=True` parameter to enable fire-and-forget mode:

```python
import asyncio
from lifx import MultiZoneLight, HSBK

async def rainbow_animation():
    async with await MultiZoneLight.from_ip("192.168.1.100") as light:
        zone_count = await light.get_zone_count()

        # Animation loop at ~30 FPS
        offset = 0
        while True:
            # Generate rainbow colors
            colors = [
                HSBK(hue=(i * 360 / zone_count + offset) % 360,
                     saturation=1.0, brightness=1.0, kelvin=3500)
                for i in range(zone_count)
            ]

            # Fire-and-forget: no waiting for response
            await light.set_extended_color_zones(0, colors, fast=True)

            offset = (offset + 5) % 360
            await asyncio.sleep(0.033)  # ~30 FPS
```

**When to use `fast=True`:**

- High-frequency animations (>20 updates/second)
- Real-time visualizations (music sync, games)
- Smooth color transitions requiring rapid updates

**Trade-offs:**

- No confirmation that the device received or applied the colors
- No error detection (timeouts, unsupported commands)
- Best for visual effects where occasional dropped frames are acceptable

**Note:** `MatrixLight.set64()` is already fire-and-forget by default, making it ideal for tile animations without any additional parameters.

## Next Steps

- [Troubleshooting Guide](https://djelibeybi.github.io/lifx-async/user-guide/troubleshooting/index.md) - Common issues and solutions
- [Protocol Reference](https://djelibeybi.github.io/lifx-async/api/protocol/index.md) - Low-level protocol details
- [API Reference](https://djelibeybi.github.io/lifx-async/api/index.md) - Complete API documentation

# Creating Custom Effects

This guide shows you how to create your own light effects by subclassing the `LIFXEffect` base class. You'll learn the required methods, common patterns, and best practices for building custom effects.

## Table of Contents

- [Overview](#overview)
- [Basic Structure](#basic-structure)
- [Required Methods](#required-methods)
- [Optional Methods](#optional-methods)
- [Common Patterns](#common-patterns)
- [Complete Examples](#complete-examples)
- [Best Practices](#best-practices)

## Overview

Creating a custom effect involves:

1. Subclass `LIFXEffect`
1. Implement `async_play()` with your effect logic
1. Optionally override `from_poweroff_hsbk()` for custom startup colors
1. Optionally override `inherit_prestate()` for state inheritance optimization

The conductor handles all state management automatically - you just focus on the visual effect.

## Basic Structure

Every custom effect follows this pattern:

```python
from lifx import LIFXEffect, Light

class MyCustomEffect(LIFXEffect):
    """Brief description of what this effect does."""

    def __init__(self, param1, param2, power_on: bool = True):
        """Initialize the effect with custom parameters.

        Args:
            param1: Description of parameter 1
            param2: Description of parameter 2
            power_on: Whether to power on devices (default True)
        """
        super().__init__(power_on=power_on)
        self.param1 = param1
        self.param2 = param2

    async def async_play(self) -> None:
        """Execute the effect logic."""
        # Your effect implementation here
        pass
```

### Minimal Example

Here's the simplest possible custom effect:

```python
from lifx.effects import LIFXEffect
import asyncio

class FlashEffect(LIFXEffect):
    """Flash all lights once."""

    async def async_play(self) -> None:
        # Turn all lights on
        tasks = [light.set_brightness(1.0) for light in self.participants]
        await asyncio.gather(*tasks)
        await asyncio.sleep(0.5)

        # Turn all lights off
        tasks = [light.set_brightness(0.0) for light in self.participants]
        await asyncio.gather(*tasks)
        await asyncio.sleep(0.5)

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)
```

Usage:

```python
conductor = Conductor()
effect = FlashEffect()
await conductor.start(effect, lights)
await asyncio.sleep(2)
```

## Required Methods

### `async_play() -> None`

This is the **only required method** you must implement. This is where your effect logic lives.

**Important:** This method is `async` - use `await` for all async operations.

**Available attributes:**

- `self.participants`: List of `Light` instances to apply effect to
- `self.conductor`: Reference to the `Conductor` managing this effect
- `self.power_on`: Whether devices should be powered on (already handled)

**When called:**

After the conductor has:

1. Captured device state
1. Powered on devices (if `power_on=True`)

**Example:**

```python
async def async_play(self) -> None:
    """Cycle through red, green, blue."""
    from lifx import HSBK

    colors = [
        HSBK.from_rgb(255, 0, 0),    # Red
        HSBK.from_rgb(0, 255, 0),    # Green
        HSBK.from_rgb(0, 0, 255),    # Blue
    ]

    for color in colors:
        # Apply color to all lights concurrently
        tasks = [
            light.set_color(color, duration=0.5)
            for light in self.participants
        ]
        await asyncio.gather(*tasks)
        await asyncio.sleep(1.0)

    # Restore original state
    if self.conductor:
        await self.conductor.stop(self.participants)
```

**Key Points:**

- Use `asyncio.gather()` to apply operations to multiple devices concurrently
- Call `self.conductor.stop(self.participants)` when effect is complete to restore state
- Don't forget `await` on async operations

## Optional Methods

### `from_poweroff_hsbk(light: Light) -> HSBK`

Override this to customize the color used when powering on a device.

**Default behavior:** Returns random hue, full saturation, zero brightness, neutral white.

**When called:** When a device needs to be powered on for the effect (if it was off when effect started).

**Example:**

```python
async def from_poweroff_hsbk(self, light: Light) -> HSBK:
    """Always start with soft blue."""
    return HSBK.from_rgb(0, 50, 200, kelvin=KELVIN_NEUTRAL)
```

**Use cases:**

- Effect always starts with specific color
- Effect wants coordinated startup across devices
- Effect wants device-specific startup colors

### `inherit_prestate(other: LIFXEffect) -> bool`

Override this to enable state inheritance optimization.

**Default behavior:** Returns `False` (always capture fresh state).

**When called:** Before starting effect, to check if previous effect's state can be reused.

**Example:**

```python
def inherit_prestate(self, other: LIFXEffect) -> bool:
    """Can inherit from same effect type."""
    return type(self) == type(other)
```

**Returns:**

- `True`: Skip state capture/restore, reuse existing `PreState`
- `False`: Capture fresh state as normal

**Benefits:**

- Faster effect transitions
- No visible reset between compatible effects
- Reduces network traffic

**Use with caution:** Only return `True` if the incoming effect is truly compatible (won't cause visual artifacts).

## Common Patterns

### Pattern 1: Synchronized Actions

All devices do the same thing at the same time:

```python
async def async_play(self) -> None:
    """Pulse all devices together."""
    for cycle in range(self.cycles):
        # All bright
        await asyncio.gather(*[
            light.set_brightness(1.0, duration=0.3)
            for light in self.participants
        ])
        await asyncio.sleep(0.5)

        # All dim
        await asyncio.gather(*[
            light.set_brightness(0.2, duration=0.3)
            for light in self.participants
        ])
        await asyncio.sleep(0.5)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

### Pattern 2: Sequential Actions

Devices act one after another (wave effect):

```python
async def async_play(self) -> None:
    """Light up devices sequentially."""
    for light in self.participants:
        await light.set_color(self.color, duration=0.5)
        await asyncio.sleep(self.delay)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

### Pattern 3: Continuous Loop Until Stopped

Effect runs indefinitely (like ColorLoop):

```python
async def async_play(self) -> None:
    """Continuous random color changes."""
    import random

    self._running = True
    while self._running:
        # Random color for each device
        tasks = []
        for light in self.participants:
            hue = random.randint(0, 360)
            color = HSBK(hue, 1.0, 1.0, KELVIN_NEUTRAL)
            tasks.append(light.set_color(color, duration=1.0))

        await asyncio.gather(*tasks)
        await asyncio.sleep(self.interval)

    if self.conductor:
        await self.conductor.stop(self.participants)

def stop(self) -> None:
    """Stop the effect."""
    self._running = False
```

**Usage:**

```python
effect = RandomColorEffect(interval=2.0)
await conductor.start(effect, lights)
await asyncio.sleep(30)
effect.stop()  # Signal to stop
```

### Pattern 4: Device-Specific Behavior

Different actions based on device properties:

```python
async def async_play(self) -> None:
    """Different colors based on device label."""
    tasks = []
    for light in self.participants:
        label = await light.get_label()

        if "Bedroom" in label:
            color = HSBK.from_rgb(0, 0, 255)  # Blue
        elif "Kitchen" in label:
            color = HSBK.from_rgb(255, 255, 255)  # White
        else:
            color = HSBK.from_rgb(255, 0, 0)  # Red

        tasks.append(light.set_color(color, duration=1.0))

    await asyncio.gather(*tasks)
    await asyncio.sleep(2.0)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

### Pattern 5: State Access

Access current device state during effect:

```python
async def async_play(self) -> None:
    """Pulse brighter than current brightness."""
    for light in self.participants:
        # Get current state
        current_color, _, _ = await light.get_color()

        # Create brighter version
        bright_color = current_color.with_brightness(1.0)

        # Pulse
        await light.set_color(bright_color, duration=0.3)
        await asyncio.sleep(0.5)
        await light.set_color(current_color, duration=0.3)
        await asyncio.sleep(0.5)

    if self.conductor:
        await self.conductor.stop(self.participants)
```

**Note:** Conductor already captured state, so you can also access it via the prestate (though this requires conductor internals access).

## Complete Examples

### Example 1: Flash Effect

Flash all lights in unison with configurable count and duration:

```python
from lifx import LIFXEffect
import asyncio

class FlashEffect(LIFXEffect):
    """Flash all lights in unison.

    Simple effect that demonstrates basic synchronization across devices.
    """

    def __init__(
        self,
        flash_count: int = 5,
        duration: float = 0.5,
        power_on: bool = True
    ) -> None:
        """Initialize flash effect.

        Args:
            flash_count: Number of flashes
            duration: Duration of each flash in seconds
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        self.flash_count = flash_count
        self.duration = duration

    async def async_play(self) -> None:
        """Execute the flash effect on all participants."""
        for i in range(self.flash_count):
            # All devices on
            tasks = [light.set_brightness(1.0) for light in self.participants]
            await asyncio.gather(*tasks)
            await asyncio.sleep(self.duration / 2)

            # All devices off
            tasks = [light.set_brightness(0.0) for light in self.participants]
            await asyncio.gather(*tasks)
            await asyncio.sleep(self.duration / 2)

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)
```

**Usage:**

```python
conductor = Conductor()
effect = FlashEffect(flash_count=10, duration=0.3)
await conductor.start(effect, lights)
await asyncio.sleep(4)
```

### Example 2: Wave Effect

Sequential color wave across multiple lights:

```python
from lifx.effects import LIFXEffect
from lifx import HSBK
import asyncio

class WaveEffect(LIFXEffect):
    """Create a color wave across multiple lights.

    More complex example showing sequential color updates across devices.
    """

    def __init__(
        self,
        wave_count: int = 3,
        wave_speed: float = 0.3,
        power_on: bool = True
    ) -> None:
        """Initialize wave effect.

        Args:
            wave_count: Number of waves to run
            wave_speed: Speed of wave in seconds per light
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        self.wave_count = wave_count
        self.wave_speed = wave_speed

    async def async_play(self) -> None:
        """Execute the wave effect."""
        # Define wave colors
        colors = [
            HSBK.from_rgb(255, 0, 0),      # Red
            HSBK.from_rgb(255, 127, 0),    # Orange
            HSBK.from_rgb(255, 255, 0),    # Yellow
            HSBK.from_rgb(0, 255, 0),      # Green
            HSBK.from_rgb(0, 0, 255),      # Blue
        ]

        for wave in range(self.wave_count):
            # Wave forward
            for i, light in enumerate(self.participants):
                color = colors[i % len(colors)]
                await light.set_color(color, duration=self.wave_speed)
                await asyncio.sleep(self.wave_speed)

            await asyncio.sleep(0.5)  # Pause between waves

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)
```

**Usage:**

```python
conductor = Conductor()
effect = WaveEffect(wave_count=3, wave_speed=0.4)
await conductor.start(effect, lights)
total_time = 3 * (len(lights) * 0.4 + 0.5)
await asyncio.sleep(total_time + 1)
```

### Example 3: Random Color Effect

Continuous random color changes until stopped:

```python
from lifx.effects import LIFXEffect
from lifx import HSBK
import asyncio
import random

class RandomColorEffect(LIFXEffect):
    """Continuously change to random colors.

    Example of continuous effect that runs until stopped.
    """

    def __init__(
        self,
        interval: float = 2.0,
        saturation_min: float = 0.7,
        saturation_max: float = 1.0,
        power_on: bool = True
    ) -> None:
        """Initialize random color effect.

        Args:
            interval: Seconds between color changes
            saturation_min: Minimum saturation (0.0-1.0)
            saturation_max: Maximum saturation (0.0-1.0)
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        self.interval = interval
        self.saturation_min = saturation_min
        self.saturation_max = saturation_max
        self._running = False

    async def async_play(self) -> None:
        """Execute random color changes continuously."""
        self._running = True

        while self._running:
            # Random color for each device
            tasks = []
            for light in self.participants:
                color = HSBK(
                    hue=random.randint(0, 360),
                    saturation=random.uniform(self.saturation_min, self.saturation_max),
                    brightness=1.0,
                    kelvin=KELVIN_NEUTRAL
                )
                tasks.append(light.set_color(color, duration=self.interval * 0.8))

            await asyncio.gather(*tasks)
            await asyncio.sleep(self.interval)

        # Restore state when stopped
        if self.conductor:
            await self.conductor.stop(self.participants)

    def stop(self) -> None:
        """Stop the continuous effect."""
        self._running = False

    def inherit_prestate(self, other: LIFXEffect) -> bool:
        """Can inherit from other RandomColorEffect instances."""
        return isinstance(other, RandomColorEffect)
```

**Usage:**

```python
conductor = Conductor()
effect = RandomColorEffect(interval=3.0, saturation_min=0.8)
await conductor.start(effect, lights)
await asyncio.sleep(30)
effect.stop()  # Signal to stop
await asyncio.sleep(3)  # Wait for current iteration to finish
```

### Example 4: Notification Effect

Different visual patterns based on notification level:

```python
from lifx.effects import LIFXEffect
from lifx import HSBK
import asyncio

class NotificationEffect(LIFXEffect):
    """Visual notification with different levels.

    Example showing how to implement different behaviors in one effect class.
    """

    def __init__(
        self,
        level: str = 'info',
        power_on: bool = True
    ) -> None:
        """Initialize notification effect.

        Args:
            level: Notification level ('info', 'warning', 'error')
            power_on: Whether to power on lights if off
        """
        super().__init__(power_on=power_on)
        if level not in ('info', 'warning', 'error'):
            raise ValueError(f"Invalid level: {level}")
        self.level = level

    async def async_play(self) -> None:
        """Execute notification based on level."""
        if self.level == 'info':
            await self._info_notification()
        elif self.level == 'warning':
            await self._warning_notification()
        elif self.level == 'error':
            await self._error_notification()

        # Restore state
        if self.conductor:
            await self.conductor.stop(self.participants)

    async def _info_notification(self) -> None:
        """Blue breathe - calm information."""
        blue = HSBK.from_rgb(0, 0, 255)
        for _ in range(2):
            await asyncio.gather(*[
                light.set_color(blue, duration=0.5)
                for light in self.participants
            ])
            await asyncio.sleep(0.7)
            await asyncio.gather(*[
                light.set_brightness(0.3, duration=0.5)
                for light in self.participants
            ])
            await asyncio.sleep(0.7)

    async def _warning_notification(self) -> None:
        """Orange blink - attention needed."""
        orange = HSBK.from_rgb(255, 165, 0)
        for _ in range(3):
            await asyncio.gather(*[
                light.set_color(orange, duration=0.1)
                for light in self.participants
            ])
            await asyncio.sleep(0.5)
            await asyncio.gather(*[
                light.set_brightness(0.0, duration=0.1)
                for light in self.participants
            ])
            await asyncio.sleep(0.5)

    async def _error_notification(self) -> None:
        """Red strobe - urgent."""
        red = HSBK.from_rgb(255, 0, 0)
        for _ in range(10):
            await asyncio.gather(*[
                light.set_color(red, duration=0.0)
                for light in self.participants
            ])
            await asyncio.sleep(0.1)
            await asyncio.gather(*[
                light.set_brightness(0.0, duration=0.0)
                for light in self.participants
            ])
            await asyncio.sleep(0.1)

    async def from_poweroff_hsbk(self, light: Light) -> HSBK:
        """Return appropriate startup color based on level."""
        if self.level == 'info':
            return HSBK.from_rgb(0, 0, 255)  # Blue
        elif self.level == 'warning':
            return HSBK.from_rgb(255, 165, 0)  # Orange
        else:
            return HSBK.from_rgb(255, 0, 0)  # Red
```

**Usage:**

```python
conductor = Conductor()

# Different notification levels
await conductor.start(NotificationEffect(level='info'), lights)
await asyncio.sleep(3)

await conductor.start(NotificationEffect(level='warning'), lights)
await asyncio.sleep(3)

await conductor.start(NotificationEffect(level='error'), lights)
await asyncio.sleep(3)
```

## Best Practices

### 1. Always Restore State

Call `conductor.stop()` when your effect is complete:

```python
async def async_play(self) -> None:
    # Effect logic here
    ...

    # Always restore at the end
    if self.conductor:
        await self.conductor.stop(self.participants)
```

### 2. Use Concurrent Operations

Use `asyncio.gather()` for operations on multiple devices:

```python
# Good - concurrent
await asyncio.gather(*[
    light.set_color(color) for light in self.participants
])

# Bad - sequential (much slower)
for light in self.participants:
    await light.set_color(color)
```

### 3. Validate Parameters

Validate constructor parameters early:

```python
def __init__(self, count: int, power_on: bool = True):
    super().__init__(power_on=power_on)

    if count < 1:
        raise ValueError(f"Count must be positive, got {count}")

    self.count = count
```

### 4. Add Type Hints

Full type hints improve IDE support and catch bugs:

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from lifx import Light

class MyEffect(LIFXEffect):
    def __init__(self, duration: float, power_on: bool = True) -> None:
        super().__init__(power_on=power_on)
        self.duration: float = duration

    async def async_play(self) -> None:
        ...

    async def from_poweroff_hsbk(self, light: Light) -> HSBK:
        ...
```

### 5. Document Your Effect

Clear docstrings help users understand your effect:

````python
class MyEffect(LIFXEffect):
    """Brief one-line description.

    Longer description explaining:
    - What the effect does
    - When to use it
    - Any important behavior

    Example:
        ```python
        conductor = Conductor()
        effect = MyEffect(duration=2.0)
        await conductor.start(effect, lights)
        await asyncio.sleep(3)
        ```
    """
````

### 6. Handle Errors Gracefully

Catch and log errors, don't let one device break the effect:

```python
import logging

_LOGGER = logging.getLogger(__name__)

async def async_play(self) -> None:
    for light in self.participants:
        try:
            await light.set_color(self.color)
        except Exception as e:
            _LOGGER.error(f"Failed to set color on {light.serial}: {e}")
            # Continue with other lights
```

### 7. Timing Considerations

Add small buffers to timing for reliability:

```python
# Good - includes buffer
total_duration = self.count * self.period
await asyncio.sleep(total_duration + 0.5)

# Better - exact but requires careful calculation
await asyncio.sleep(self.count * self.period)
```

### 8. Test with Different Device Types

Test your effect with:

- Single color light
- Multiple color lights
- Multizone light (if applicable)
- Powered-off devices
- Mix of on/off devices

### 9. Consider Rate Limiting

For effects with many rapid commands, consider rate limiting:

```python
async def async_play(self) -> None:
    for iteration in range(self.iterations):
        # Send commands
        await self._apply_colors()

        # Rate limit: max 20 messages/second
        await asyncio.sleep(0.05)
```

### 10. Use Descriptive Names

Choose clear, descriptive names for effects and parameters:

```python
# Good
class PulseWaveEffect(LIFXEffect):
    def __init__(self, wave_count: int, wave_period: float):
        ...

# Less clear
class Effect1(LIFXEffect):
    def __init__(self, n: int, t: float):
        ...
```

## See Also

- [Getting Started](https://djelibeybi.github.io/lifx-async/getting-started/effects/index.md) - Basic usage of built-in effects
- [Effects Reference](https://djelibeybi.github.io/lifx-async/api/effects/index.md) - Detailed API documentation
- [Architecture](https://djelibeybi.github.io/lifx-async/architecture/effects-architecture/index.md) - How the system works internally
- [Troubleshooting](https://djelibeybi.github.io/lifx-async/user-guide/effects-troubleshooting/index.md) - Common issues and solutions
- [Examples](https://djelibeybi.github.io/lifx-async/examples/index.md) - Full working examples including `08_custom_effect.py`

# Troubleshooting Guide

Common issues and solutions when working with lifx.

## Table of Contents

- [Discovery Issues](#discovery-issues)
- [Connection Problems](#connection-problems)
- [Timeout Errors](#timeout-errors)
- [Performance Issues](#performance-issues)
- [Debugging Tips](#debugging-tips)

## Discovery Issues

### No Devices Found

**Symptom:** `discover()` returns an empty group

**Common Causes:**

1. **Devices not on same network**

   ```python
   # Check network connectivity
   import asyncio
   from lifx.network.discovery import discover_devices

   devices = await discover_devices(timeout=5.0)
   print(f"Found {len(devices)} devices")
   ```

1. **Firewall blocking UDP port 56700**

   ```bash
   # Linux: Check if port is open
   sudo netstat -an | grep 56700

   # Allow UDP on port 56700
   sudo ufw allow 56700/udp
   ```

1. **Broadcast address incorrect**

Try different broadcast addresses:

```python
from lifx import discover, DeviceGroup

# Default (255.255.255.255)
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

# Network-specific (e.g., 192.168.1.255)
devices = []
async for device in discover(broadcast_address="192.168.1.255"):
    devices.append(device)
group = DeviceGroup(devices)
```

**Solution:**

```python
import asyncio
from lifx.network.discovery import discover_devices

async def diagnose_discovery():
    print("Attempting discovery...")

    # Try with extended timeout
    devices = await discover_devices(
        timeout=10.0,
        broadcast_address="255.255.255.255"
    )

    if not devices:
        print("No devices found. Check:")
        print("1. Devices are powered on")
        print("2. Devices are on the same network")
        print("3. Firewall allows UDP port 56700")
        print("4. Try a network-specific broadcast address")
    else:
        print(f"Found {len(devices)} devices:")
        for device in devices:
            print(f"  - {device.serial} at {device.ip}")

asyncio.run(diagnose_discovery())
```

### Partial Device Discovery

**Symptom:** Only some devices discovered

**Causes:**

- Devices on different subnets
- Network congestion
- Devices slow to respond

**Solution:**

```python
async def thorough_discovery():
    # Multiple discovery passes with different timeouts
    all_devices = set()

    for timeout in [3.0, 5.0, 10.0]:
        devices = await discover_devices(timeout=timeout)
        for device in devices:
            all_devices.add((device.serial, device.ip))

    print(f"Total devices found: {len(all_devices)}")
    return all_devices
```

## Connection Problems

### Connection Refused

**Symptom:** `LifxConnectionError: Connection refused`

**Causes:**

- Incorrect IP address
- Device powered off
- Network unreachable

**Solution:**

```python
from lifx import Light, LifxConnectionError
import asyncio

async def test_connection(ip: str):
    try:
        async with await Light.from_ip(ip) as light:
            label = await light.get_label()
            print(f"Connected to: {label}")
            return True

    except LifxConnectionError as e:
        print(f"Connection failed: {e}")
        print("Check:")
        print("1. Device IP is correct")
        print("2. Device is powered on")
        print("3. Device is reachable (try ping)")
        return False

# Test connectivity
asyncio.run(test_connection("192.168.1.100"))
```

### Connection Drops

**Symptom:** Intermittent `LifxConnectionError` or `LifxNetworkError`

**Causes:**

- WiFi signal weak
- Network congestion
- Device overloaded

**Solution:**

```python
import asyncio
from lifx import Light, LifxError

async def resilient_operation(ip: str, max_retries: int = 3):
    """Retry operations with exponential backoff"""
    async with await Light.from_ip(ip) as light:
        for attempt in range(max_retries):
            try:
                await light.set_power(True)
                print("Success!")
                return
            except LifxError as e:
                wait_time = 2 ** attempt  # 1s, 2s, 4s
                print(f"Attempt {attempt + 1} failed: {e}")

                if attempt < max_retries - 1:
                    print(f"Retrying in {wait_time}s...")
                    await asyncio.sleep(wait_time)

    print("All retries exhausted")
```

## Timeout Errors

### Request Timeouts

**Symptom:** `LifxTimeoutError: Request timed out after X seconds`

**Causes:**

- Device slow to respond
- Network latency high
- Device busy processing other requests

**Solution:**

```python
from lifx import Light

# Increase timeout for slow devices
async with await Light.from_ip(ip, timeout=5.0) as light:
    # get_color() returns (color, power, label)
    color, power, label = await light.get_color()
```

### Discovery Timeout Too Short

**Symptom:** Some devices not found

**Solution:**

```python
from lifx import discover

# Increase discovery timeout
async with discover(timeout=10.0) as group:  # Default is 3.0
    print(f"Found {len(group.devices)} devices")
```

## Performance Issues

### Slow Operations

**Symptom:** Operations take longer than expected

**Diagnosis:**

```python
import time
from lifx import Light

async def measure_latency():
    async with await Light.from_ip("192.168.1.100") as light:
        # Measure single request
        start = time.time()
        await light.get_label()
        elapsed = time.time() - start
        print(f"Single request: {elapsed*1000:.2f}ms")

        # Measure sequential requests
        start = time.time()
        for _ in range(10):
            await light.get_label()
        elapsed = time.time() - start
        print(f"10 sequential: {elapsed*1000:.2f}ms ({elapsed*100:.2f}ms avg)")

        # Measure concurrent requests
        start = time.time()
        await asyncio.gather(*[light.get_label() for _ in range(10)])
        elapsed = time.time() - start
        print(f"10 concurrent: {elapsed*1000:.2f}ms")
```

**Common Causes:**

1. **Sequential instead of concurrent operations**

Slow approach (sequential):

```python
for device in devices:
    await device.set_color(Colors.BLUE)
```

Fast approach (concurrent):

```python
await asyncio.gather(
    *[device.set_color(Colors.BLUE) for device in devices]
)
```

1. **Not reusing connections**

Inefficient (creates new connection each time):

```python
for i in range(10):
    async with await Light.from_ip(ip) as light:
        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)
```

Efficient (reuses connection):

```python
async with await Light.from_ip(ip) as light:
    for i in range(10):
        await light.set_color(HSBK(hue=(360/10)*i), saturation=1.0, brightness=1.0, kelvin=3500)
```

1. **Need fresh data?**

Use `get_*()` methods to always fetch from the device:

```python
# Always fetch fresh data
# get_color() returns all three values in one call
color, power, label = await light.get_color()

# Or fetch other device info
version = await light.get_version()
```

### Docker / Container Networking

**Symptom:** Discovery doesn't work in Docker container

**Cause:** Container network isolation

**Solution:**

```yaml
# docker-compose.yml
services:
  app:
    network_mode: "host"  # Use host network for UDP broadcast
```

Or use manual device specification:

```python
# Don't rely on discovery
from lifx import Light

async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)
```

## Debugging Tips

### Enable Debug Logging

```python
import logging

# Enable DEBUG logging for lifx
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Or for specific modules
logging.getLogger('lifx.network').setLevel(logging.DEBUG)
logging.getLogger('lifx.devices').setLevel(logging.DEBUG)
```

### Check Product Registry

```python
from lifx.products import get_product, get_registry

# List all known products
registry = get_registry()
for product_id, product in registry.items():
    print(f"{product_id}: {product.name}")

# Check specific product
product = get_product(27)  # LIFX A19
if product:
    print(f"Name: {product.name}")
    print(f"Capabilities: {product.capabilities}")
```

### Verify Device Reachability

```bash
# Ping device
ping 192.168.1.100

# Check UDP port (requires nmap)
sudo nmap -sU -p 56700 192.168.1.100

# Test with netcat
echo -n "test" | nc -u 192.168.1.100 56700
```

## Getting Help

If you're still experiencing issues:

1. **Check GitHub Issues**: [github.com/Djelibeybi/lifx-async/issues](https://github.com/Djelibeybi/lifx-async/issues)
1. **Enable debug logging**: Capture logs with `logging.DEBUG`
1. **Provide details**:
1. Python version
1. lifx version
1. Device model and firmware version
1. Network configuration
1. Minimal reproduction code
1. Full error traceback

## Common Error Messages

| Error                                                        | Meaning                        | Solution                           |
| ------------------------------------------------------------ | ------------------------------ | ---------------------------------- |
| `LifxTimeoutError`                                           | Device didn't respond          | Increase timeout, check network    |
| `LifxConnectionError`                                        | Can't connect to device        | Check IP, firewall, device power   |
| `LifxDeviceNotFoundError`                                    | Device not discovered          | Check network, increase timeout    |
| `LifxProtocolError`                                          | Invalid response               | Update firmware, check device type |
| `LifxUnsupportedCommandError`                                | Device doesn't support command | Check device capabilities          |
| `AttributeError: 'Light' has no attribute 'set_color_zones'` | Wrong device class             | Use `MultiZoneLight`               |

## Next Steps

- [Advanced Usage](https://djelibeybi.github.io/lifx-async/user-guide/advanced-usage/index.md) - Optimization patterns
- [API Reference](https://djelibeybi.github.io/lifx-async/api/index.md) - Complete API documentation
- [FAQ](https://djelibeybi.github.io/lifx-async/faq/index.md) - Frequently asked questions

# Effects Troubleshooting

This guide helps you diagnose and resolve common issues when using the Light Effects Framework.

## Table of Contents

- [Common Issues](#common-issues)
- [Device Compatibility](#device-compatibility)
- [Performance Issues](#performance-issues)
- [State Management](#state-management)
- [Debugging Techniques](#debugging-techniques)
- [Known Limitations](#known-limitations)

## Common Issues

### Effects Don't Start

**Symptom:** Calling `conductor.start()` doesn't appear to do anything.

**Possible Causes:**

1. **No await keyword**

```python
# Wrong - missing await
conductor.start(effect, lights)  # Returns immediately, nothing happens

# Correct
await conductor.start(effect, lights)
```

1. **Devices not reachable**

```python
# Check device connectivity first
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

if not group.lights:
    print("No devices found!")
    return

# Now safe to use effects
conductor = Conductor()
await conductor.start(effect, group.lights)
```

1. **Empty participants list**

```python
# Check you have lights
if not lights:
    print("No lights to apply effect to")
    return

await conductor.start(effect, lights)
```

**Solution:** Always use `await` and verify devices are discovered before starting effects.

______________________________________________________________________

### Lights Don't Restore to Original State

**Symptom:** After effect completes, lights stay in effect state instead of returning to original.

**Possible Causes:**

1. **Missing conductor.stop() call**

```python
# ColorLoop requires manual stop
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
await asyncio.sleep(60)
# MISSING: await conductor.stop(lights)
```

**Solution:** Always call `conductor.stop()` for continuous effects:

```python
await conductor.stop(lights)
```

1. **Effect doesn't call conductor.stop() internally**

Custom effects must restore state:

```python
async def async_play(self) -> None:
    # Effect logic
    ...

    # Required for auto-restore
    if self.conductor:
        await self.conductor.stop(self.participants)
```

1. **Network timeout during restoration**

If restoration fails due to network issues, lights may be in inconsistent state.

**Solution:** Check logs for timeout errors, verify network connectivity.

______________________________________________________________________

### Effect Appears to Freeze

**Symptom:** Effect starts but never completes, script hangs.

**Possible Causes:**

1. **ColorLoop running indefinitely**

ColorLoop is designed to run forever:

```python
# This will hang forever
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
# Script hangs here - ColorLoop never completes
```

**Solution:** Call `conductor.stop()` explicitly:

```python
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)
await asyncio.sleep(60)  # Let it run
await conductor.stop(lights)  # Stop it
```

1. **Custom effect with infinite loop**

```python
async def async_play(self) -> None:
    while True:  # Infinite loop!
        await self._do_something()
```

**Solution:** Add stop condition:

```python
async def async_play(self) -> None:
    self._running = True
    while self._running:
        await self._do_something()
```

1. **Missing await in effect logic**

```python
async def async_play(self) -> None:
    # Missing await - blocks event loop
    light.set_color(color)  # Should be: await light.set_color(color)
```

**Solution:** Always use `await` on async operations.

______________________________________________________________________

### Lights Flash/Reset Between Effects

**Symptom:** When starting second effect, lights briefly return to original state before new effect starts.

**Cause:** State inheritance not enabled.

```python
# Each effect resets to original state
effect1 = EffectColorloop(period=30)
await conductor.start(effect1, lights)
await asyncio.sleep(10)

effect2 = EffectColorloop(period=20)  # Lights briefly reset here
await conductor.start(effect2, lights)
```

**Solution:** Effects must implement `inherit_prestate()` to prevent reset:

```python
class EffectColorloop(LIFXEffect):
    def inherit_prestate(self, other: LIFXEffect) -> bool:
        return isinstance(other, EffectColorloop)
```

This is already implemented for `EffectColorloop`, but custom effects may need it.

**Note:** For different effect types, the reset is intentional behavior.

______________________________________________________________________

### Pulse Effect Too Fast/Slow

**Symptom:** Pulse timing doesn't match expectations.

**Cause:** Misunderstanding period vs. total duration.

```python
# This runs for 1 second total (period=1.0, cycles=1)
effect = EffectPulse(mode='blink', period=1.0, cycles=1)

# This runs for 5 seconds total (period=1.0, cycles=5)
effect = EffectPulse(mode='blink', period=1.0, cycles=5)

# This runs for 2 seconds total (period=2.0, cycles=1)
effect = EffectPulse(mode='blink', period=2.0, cycles=1)
```

**Solution:** Total duration = `period * cycles`

```python
# Want 10-second effect?
effect = EffectPulse(mode='breathe', period=2.0, cycles=5)  # 2.0 * 5 = 10s
```

______________________________________________________________________

### ColorLoop Colors Look Wrong

**Symptom:** ColorLoop shows unexpected colors or is too dim/bright.

**Possible Causes:**

1. **Saturation constraints too restrictive**

```python
# Very low saturation = washed out colors
effect = EffectColorloop(saturation_min=0.1, saturation_max=0.3)  # Pastels
```

**Solution:** Use higher saturation for vibrant colors:

```python
effect = EffectColorloop(saturation_min=0.8, saturation_max=1.0)
```

1. **Brightness locked to low value**

```python
# Locked to 30% brightness
effect = EffectColorloop(brightness=0.3)  # Dim!
```

**Solution:** Use higher brightness or `None` to preserve original:

```python
effect = EffectColorloop(brightness=None)  # Preserve original
# or
effect = EffectColorloop(brightness=0.8)  # 80% brightness
```

1. **Monochrome device**

ColorLoop doesn't work on monochrome/white-only lights.

**Solution:** Only use ColorLoop on color-capable devices.

______________________________________________________________________

### Multizone Lights Don't Restore Zones Correctly

**Symptom:** After effect, multizone light zones are wrong color or all same color.

**Possible Causes:**

1. **Device was powered off before effect**

Some older multizone devices report all zones as the same color when powered off.

**Workaround:** Ensure lights are powered on before starting effects:

```python
# Power on first
for light in lights:
    await light.set_power(True)
await asyncio.sleep(0.5)

# Now start effect
await conductor.start(effect, lights)
```

1. **Extended multizone messages not supported**

Older devices may not support efficient extended multizone messages.

**Solution:** Framework automatically falls back to standard messages. No action needed.

1. **Network timeouts during zone restoration**

If restoring many zones times out, state may be incomplete.

**Solution:** Check network stability, reduce concurrent operations.

______________________________________________________________________

## Device Compatibility

### Color Lights

**Full Support:** All effects work as expected.

**Models:** LIFX Color, LIFX+, LIFX Mini Color, LIFX Candle Color

______________________________________________________________________

### Monochrome/White Lights

**Limited Support:** Only brightness-based effects work.

**What Works:**

- EffectPulse: Brightness pulsing (hue/saturation ignored)
- Custom effects using only brightness

**What Doesn't Work:**

- EffectColorloop: No visible effect (can't change hue)
- Color-based custom effects: Only brightness changes visible

**Recommendation:** Avoid ColorLoop on monochrome devices.

**Models:** LIFX White, LIFX Mini White, LIFX Downlight

______________________________________________________________________

### Multizone Lights

**Full Support** with some considerations.

**Works Well:**

- EffectPulse: All zones pulse together
- EffectColorloop: Entire device cycles color

**Special Considerations:**

- Effects apply to entire device, not individual zones
- Zone colors properly restored after effect
- Extended multizone messages used when available

**Potential Enhancement:** Future versions could support per-zone effects.

**Models:** LIFX Z, LIFX Beam

______________________________________________________________________

### Matrix Lights (Tile/Candle/Path)

**Full Support** (treated as single unit).

**Works Well:**

- EffectPulse: All tiles/zones pulse together
- EffectColorloop: All tiles/zones cycle color together

**Limitation:** Current implementation doesn't use per-tile control. All tiles show same color.

**Potential Enhancement:** Future versions could support per-tile effects (similar to theme support).

**Models:** LIFX Tile, LIFX Candle, LIFX Path

______________________________________________________________________

### HEV Lights

**Full Support** (treated like standard color lights).

**Note:** Effects don't interfere with HEV cycle functionality.

**Models:** LIFX Clean

______________________________________________________________________

### Infrared Lights

**Full Support** (treated like standard color lights).

**Note:** Effects control visible light only, infrared LED not affected.

**Models:** LIFX+, LIFX Night Vision

______________________________________________________________________

## Performance Issues

### Slow Effect Startup

**Symptom:** Noticeable delay before effect starts.

**Cause:** State capture requires network round trips.

**Expected Timing:**

- Single device: \<1 second
- 10 devices: \<1 second (concurrent)
- 50 devices: 1-2 seconds

**If Slower:**

- Check network latency (ping devices)
- Verify devices are on local network (not remote)
- Reduce concurrent discovery operations

______________________________________________________________________

### Choppy/Stuttering Effects

**Symptom:** Effects don't run smoothly, visible stuttering.

**Possible Causes:**

1. **Too many concurrent effects**

```python
# 50 devices all running independent effects
for light in lights:
    await conductor.start(effect, [light])  # Too many!
```

**Solution:** Group devices:

```python
# All devices in one effect
await conductor.start(effect, lights)
```

1. **Network congestion**

Too many packets sent too quickly can overwhelm network or devices.

**Solution:** Add rate limiting:

```python
# In custom effect
for iteration in range(self.iterations):
    await self._update_colors()
    await asyncio.sleep(0.05)  # Rate limit: max 20/sec
```

1. **Blocking operations in effect**

```python
# Bad - blocking sleep
import time
time.sleep(1)  # Blocks entire event loop!

# Good - async sleep
await asyncio.sleep(1)
```

**Solution:** Always use async operations.

______________________________________________________________________

### Effects on Many Devices Are Slow

**Symptom:** Effects take much longer with many devices.

**Expected Behavior:** Effects should scale linearly (not exponentially).

**If Slower Than Expected:**

1. Verify concurrent operations are used:

```python
# Good - concurrent
await asyncio.gather(*[
    light.set_color(color) for light in lights
])

# Bad - sequential
for light in lights:
    await light.set_color(color)
```

1. Check for sequential operations in custom effects
1. Verify network capacity isn't saturated

**Recommendation:** For 50+ devices, consider:

- Staggering effect starts
- Using fewer concurrent effects
- Implementing application-level rate limiting

______________________________________________________________________

## State Management

### State Captured Incorrectly

**Symptom:** Restored state doesn't match original state.

**Possible Causes:**

1. **State changed between capture and effect**

```python
# State captured here
await conductor.start(effect, lights)

# Meanwhile, user changes light with app
# Effect completes, restores OLD state (not current state)
```

**Solution:** Effects framework works correctly - this is expected behavior. State is captured at effect start.

1. **Multizone device powered off during capture**

Older devices report inaccurate zone colors when off.

**Workaround:** Power on before effect:

```python
for light in lights:
    await light.set_power(True)
await asyncio.sleep(0.5)
await conductor.start(effect, lights)
```

______________________________________________________________________

### State Restoration Fails Silently

**Symptom:** State restoration errors not visible.

**Cause:** Errors are logged but don't raise exceptions (by design - one failed device shouldn't stop others).

**Solution:** Enable debug logging:

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger('lifx.effects')
logger.setLevel(logging.DEBUG)
```

Check logs for warnings like:

```text
WARNING:lifx.effects.conductor:Failed to restore color for d073d5123456: TimeoutError
```

______________________________________________________________________

## Debugging Techniques

### Enable Debug Logging

See detailed information about effect execution:

```python
import logging

# Enable debug logging for effects
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Just effects module
logger = logging.getLogger('lifx.effects')
logger.setLevel(logging.DEBUG)
```

**Output shows:**

- State capture details
- Prestate inheritance decisions
- State restoration steps
- Error messages

______________________________________________________________________

### Check Current Effect Status

See what's currently running on each device:

```python
conductor = Conductor()

# After starting effects
for light in lights:
    current = conductor.effect(light)
    if current:
        print(f"{light.label}: {type(current).__name__}")
    else:
        print(f"{light.label}: idle")
```

______________________________________________________________________

### Verify Device Connectivity

Before effects, verify all devices are reachable:

```python
async def check_connectivity(lights):
    """Verify all lights respond."""
    for light in lights:
        try:
            label = await light.get_label()
            print(f" {label} reachable")
        except Exception as e:
            print(f" {light.serial} unreachable: {e}")

# Use before effects
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await check_connectivity(group.lights)
```

______________________________________________________________________

### Test with Single Device First

Isolate issues by testing with one device:

```python
# Test with single device first
from lifx import discover, DeviceGroup

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

if group.lights:
    test_light = group.lights[0]

    conductor = Conductor()
    effect = EffectPulse(mode='blink', cycles=3)

    print(f"Testing with {await test_light.get_label()}")
    await conductor.start(effect, [test_light])
    await asyncio.sleep(4)

    print("Test complete - check if light restored correctly")
```

______________________________________________________________________

### Validate Effect Parameters

Check that effect parameters are valid:

```python
# Add parameter validation
class MyEffect(LIFXEffect):
    def __init__(self, count: int, period: float, power_on: bool = True):
        super().__init__(power_on=power_on)

        if count < 1:
            raise ValueError(f"count must be positive, got {count}")
        if period <= 0:
            raise ValueError(f"period must be positive, got {period}")

        self.count = count
        self.period = period
```

______________________________________________________________________

### Measure Effect Timing

Verify effect runs for expected duration:

```python
import time

start = time.time()

effect = EffectPulse(mode='blink', period=1.0, cycles=5)
await conductor.start(effect, lights)

# Expected: 5 seconds
await asyncio.sleep(6)

elapsed = time.time() - start
print(f"Effect took {elapsed:.1f}s (expected ~5s)")
```

______________________________________________________________________

## Known Limitations

### Rate Limiting

The effects framework **does not** implement automatic rate limiting.

**Impact:** Sending too many concurrent commands may overwhelm devices or network.

**LIFX Limit:** ~20 messages per second per device

**Recommendation:** For rapid-fire effects, add your own rate limiting:

```python
async def async_play(self) -> None:
    for i in range(100):
        await self._update_lights()
        await asyncio.sleep(0.05)  # 20/sec max
```

______________________________________________________________________

### Tile Per-Tile Effects

Current implementation treats tiles as a single unit.

**Limitation:** Can't apply different effects to individual tiles within a tile chain.

**Workaround:** Use theme support for per-tile colors, or wait for future enhancement.

**Potential Future:** Per-tile effect logic could be added using `MatrixLight.set_matrix_colors()`.

______________________________________________________________________

### Multizone Per-Zone Effects

Current implementation treats multizone device as a single unit.

**Limitation:** Can't pulse individual zones or create zone-specific effects.

**Workaround:** Manually use `set_color_zones()` in custom effects.

**Example:**

```python
from lifx import MultiZoneLight

async def async_play(self) -> None:
    for light in self.participants:
        if isinstance(light, MultiZoneLight):
            # Control individual zones
            zone_count = await light.get_zone_count()
            for i in range(zone_count):
                color = self._get_zone_color(i)
                await light.set_color_zones(i, i, color)
```

______________________________________________________________________

### Button/Relay/Switch Devices

The effects framework **only supports lighting devices**.

**Not Supported:**

- LIFX Switch
- LIFX Relay
- Button devices

**Reason:** Effects are designed for visual output (lights), not control devices.

______________________________________________________________________

### Network Timeouts with Many Devices

With 50+ devices, state capture/restoration may timeout.

**Symptoms:**

- Some devices don't restore state
- Timeout errors in logs

**Solutions:**

- Increase timeout values (requires lifx-async modification)
- Reduce number of concurrent effects
- Group devices and stagger effect starts
- Verify network infrastructure can handle traffic

______________________________________________________________________

### Prestate Inheritance Limitations

State inheritance is conservative to prevent artifacts.

**Current Behavior:**

- Only `EffectColorloop` supports inheritance (from other `EffectColorloop`)
- Other effect types always reset state

**Enhancement Opportunity:** More effect types could support inheritance with careful design.

______________________________________________________________________

## Still Having Issues?

If you're experiencing issues not covered here:

1. **Check the logs** with debug logging enabled
1. **Test with single device** to isolate the problem
1. **Verify device firmware** is up to date
1. **Check network** connectivity and stability
1. **Review examples** in the `examples/` directory
1. **Report issues** on [GitHub Issues](https://github.com/Djelibeybi/lifx-async/issues)

When reporting issues, include:

- lifx-async version
- Python version
- Device model(s) affected
- Minimal reproduction code
- Full error message and traceback
- Debug logs if applicable

## See Also

- [Getting Started](https://djelibeybi.github.io/lifx-async/getting-started/effects/index.md) - Basic usage patterns
- [Effects Reference](https://djelibeybi.github.io/lifx-async/api/effects/index.md) - Detailed API documentation
- [Custom Effects](https://djelibeybi.github.io/lifx-async/user-guide/effects-custom/index.md) - Creating your own effects
- [Architecture](https://djelibeybi.github.io/lifx-async/architecture/effects-architecture/index.md) - How the system works

# Protocol Deep Dive

Understanding the LIFX protocol and how lifx implements it.

## Table of Contents

- [Protocol Overview](#protocol-overview)
- [Packet Structure](#packet-structure)
- [Message Flow](#message-flow)
- [Protocol Types](#protocol-types)
- [Code Generation](#code-generation)
- [Low-Level Usage](#low-level-usage)

## Protocol Overview

The LIFX LAN Protocol is a binary protocol using UDP for communication:

- **Port:** 56700 (UDP)
- **Packet Size:** Variable (36-byte header + payload)
- **Transport:** Unreliable (UDP) with application-level reliability
- **Discovery:** Broadcast-based (255.255.255.255)

### Protocol Layers

```text

     Application (lifx API)        

  Packet Classes (packets.py)        

  Models (models.py)                 
  Serialization (serializer.py)      

  Header (header.py)                 

  UDP Transport                      

```

## Packet Structure

### Header Format (36 bytes)

Every LIFX packet starts with a 36-byte header:

```python
from lifx.protocol.header import LifxHeader
from lifx.protocol.models import Serial

# Create serial number
serial = Serial.from_string("d073d5123456")

header = LifxHeader(
    size=64,                    # Total packet size (header + payload)
    protocol=1024,              # Protocol version (always 1024)
    addressable=True,           # Addressing mode
    tagged=False,               # Broadcast vs unicast
    source=0x12345678,          # Unique client ID
    target=serial.to_protocol(), # Device serial (8 bytes with padding)
    res_required=True,          # Expects response
    ack_required=False,         # Expects acknowledgment
    sequence=1,                 # Sequence number (0-255)
    pkt_type=101,               # Message type
)
```

### Header Fields

| Field        | Size    | Description                              |
| ------------ | ------- | ---------------------------------------- |
| size         | 2 bytes | Total packet size including header       |
| origin       | 2 bits  | Message origin (always 0)                |
| tagged       | 1 bit   | Broadcast (1) or targeted (0)            |
| addressable  | 1 bit   | Addressing mode (always 1)               |
| protocol     | 12 bits | Protocol number (always 1024)            |
| source       | 4 bytes | Unique client identifier                 |
| target       | 8 bytes | Device MAC address (6 bytes + 2 padding) |
| reserved     | 6 bytes | Reserved for future use                  |
| res_required | 1 bit   | Response required flag                   |
| ack_required | 1 bit   | Acknowledgment required flag             |
| reserved     | 6 bits  | Reserved                                 |
| sequence     | 1 byte  | Wrap-around sequence number              |
| reserved     | 8 bytes | Reserved                                 |
| pkt_type     | 2 bytes | Message type identifier                  |
| reserved     | 2 bytes | Reserved                                 |

### Payload

Variable-length payload following the header:

```python
# Example: SetColor payload (13 bytes)
{
    'reserved': 0,              # 1 byte
    'color': HSBK(...),         # 8 bytes (4  uint16)
    'duration': 1000,           # 4 bytes (uint32, milliseconds)
}
```

## Message Flow

### Discovery Process

```
sequenceDiagram
    participant Client
    participant Network
    participant Device1
    participant Device2

    Client->>Network: Broadcast GetService (tagged=1)
    Network->>Device1: GetService
    Network->>Device2: GetService
    Device1-->>Client: StateService (port 56700)
    Device2-->>Client: StateService (port 56700)
    Client->>Client: Collect responses
```

### Request-Response Pattern

```
sequenceDiagram
    participant Client
    participant Device

    Client->>Device: GetLabel (seq=1, res_required=1)
    Device-->>Client: StateLabel (seq=1, "Living Room")

    Client->>Device: SetColor (seq=2, res_required=0, ack_required=1)
    Device-->>Client: Acknowledgement (seq=2)
```

### Concurrent Requests

lifx-async supports concurrent requests on a single connection:

```
sequenceDiagram
    participant Client
    participant Device

    Client->>Device: Request 1 (seq=1)
    Client->>Device: Request 2 (seq=2)
    Client->>Device: Request 3 (seq=3)

    Device-->>Client: Handle Response 2 (seq=2)
    Device-->>Client: Handle Response 1(seq=1)
    Device-->>Client: Handle Response 3 (seq=3)
```

## Protocol Types

### Color Representation

LIFX uses HSBK color space:

```python
from lifx import HSBK

color = HSBK(
    hue=180.0,         # 0-360 degrees
    saturation=1.0,    # 0.0-1.0
    brightness=0.75,   # 0.0-1.0
    kelvin=3500,       # 1500-9000
)
```

### Packet Categories

Packets are organized by category:

| Category    | Purpose                | Examples                        |
| ----------- | ---------------------- | ------------------------------- |
| `Device`    | Device-wide operations | GetLabel, SetLabel, GetPower    |
| `Light`     | Light control          | SetColor, GetColor, SetWaveform |
| `MultiZone` | Strip/beam control     | SetColorZones, GetColorZones    |
| `Tile`      | Tile device control    | GetTileState64, SetTileState64  |

### Common Packet Types

```python
from lifx.protocol import packets

# Device packets
get_label = packets.Device.GetLabel()              # pkt_type=23
set_label = packets.Device.SetLabel(label="Room")  # pkt_type=24

# Light packets
get_color = packets.Light.Get()                    # pkt_type=101
set_color = packets.Light.SetColor(               # pkt_type=102
    color=HSBK(...),
    duration=1000
)

# MultiZone packets
get_zones = packets.MultiZone.GetColorZones(      # pkt_type=502
    start_index=0,
    end_index=8
)
```

## Code Generation

### From protocol.yml

lifx-async auto-generates protocol code from the official LIFX specification:

```yaml
# protocol.yml excerpt
packets:
  - name: SetColor
    pkt_type: 102
    category: light
    fields:
      - name: reserved
        type: uint8
      - name: color
        type: HSBK
      - name: duration
        type: uint32
```

Generates:

```python
# packets.py (generated)
@dataclass
class SetColor:
    PKT_TYPE: ClassVar[int] = 102
    CATEGORY: ClassVar[str] = "Light"

    reserved: int = 0
    color: HSBK = field(default_factory=HSBK)
    duration: int = 0

    def pack(self) -> bytes:
        # Serialization logic
        ...
```

### Regenerating Protocol Code

```bash
# Regenerate Python code
uv run python -m lifx.protocol.generator
```

### Generator Features

- **Type Safety:** Full type hints for all structures
- **Validation:** Bounds checking for protocol values
- **Documentation:** Docstrings from protocol comments
- **Filtering:** Excludes non-lighting categories (Button, Relay)

## Low-Level Usage

### Direct Protocol Usage

```python
from lifx.network.connection import DeviceConnection
from lifx.protocol import packets
from lifx.protocol.protocol_types import HSBK

async def low_level_control():
    # Create connection
    conn = DeviceConnection(
        serial="d073d5000001",
        ip="192.168.1.100"
    )

    # Create packet
    packet = packets.Light.SetColor(
        reserved=0,
        color=HSBK(hue=32768, saturation=65535, brightness=49151, kelvin=3500),
        duration=1000
    )

    # Send and receive response
    response = await conn.request(
        packet,
        timeout=2.0
    )

    print(f"Response: {response}")
```

## Protocol Constants

### Important Values

```python
# Ports
LIFX_UDP_PORT = 56700

# Protocol version
LIFX_PROTOCOL_VERSION = 1024

# Color limits
HUE_MAX = 65535        # Maps to 360
SATURATION_MAX = 65535 # Maps to 100%
BRIGHTNESS_MAX = 65535 # Maps to 100%
KELVIN_MIN = 1500
KELVIN_MAX = 9000

# Timing
MAX_DURATION = 0xFFFFFFFF  # ~49 days in milliseconds
MIN_DURATION = 0           # Instant
```

## Next Steps

- [Connection Management](https://djelibeybi.github.io/lifx-async/user-guide/advanced-usage/#connection-management) - Connection patterns
- [API Reference](https://djelibeybi.github.io/lifx-async/api/protocol/index.md) - Protocol API documentation
- [Architecture](https://djelibeybi.github.io/lifx-async/architecture/overview/index.md) - System architecture
# Architecture

# Architecture Overview

lifx-async is built as a layered architecture with clear separation of concerns.

## System Architecture

```
graph TB
    subgraph "Layer 4: High-Level API"
        API[api.py<br/>discover, find_lights, etc.]
        DeviceGroup[DeviceGroup<br/>Batch operations]
    end

    subgraph "Layer 3: Device Layer"
        Device[Device<br/>Base class]
        Light[Light<br/>Color control]
        Hev[HevLight<br />HEV support]
        Infrared[InfraredLight<br />Infrared support]
        MultiZone[MultiZoneLight<br/>Linear/1D zones]
        Matrix[MatrixLight<br/>Matrix/2D zones]
    end

    subgraph "Layer 2: Network Layer"
        Discovery[Discovery<br/>UDP broadcast]
        Connection[Connection<br/>Lazy opening]
        Transport[Transport<br/>UDP sockets]
    end

    subgraph "Layer 1: Protocol Layer"
        Generator[Generator<br/>YAML  Python]
        Types[Protocol Types<br/>Enums, HSBK, etc.]
        Packets[Packets<br/>Message classes]
    end

    subgraph "External"
        YAML[protocol.yml<br/>LIFX specification]
        Network[UDP Network<br/>Port 56700]
    end

    API --> DeviceGroup
    DeviceGroup --> Light
    DeviceGroup --> Hev
    DeviceGroup --> Infrared
    DeviceGroup --> MultiZone
    DeviceGroup --> Matrix
    API --> Discovery
    Device --> Connection
    Light --> Device
    Hev --> Light
    Infrared --> Light
    MultiZone --> Light
    Matrix --> Light
    Connection --> Transport
    Connection --> Packets
    Discovery --> Transport
    Packets --> Types
    Transport --> Network
    Generator --> YAML
    Generator -.generates.-> Types
    Generator -.generates.-> Packets

    style API fill:#e1f5e1
    style Device fill:#e1f0ff
    style Connection fill:#fff4e1
    style Generator fill:#ffe1f0
```

## Layer Responsibilities

### Layer 1: Protocol Layer

**Purpose**: Handle LIFX binary protocol

- **Auto-Generated**: All code generated from `protocol.yml`
- **Type-Safe**: Full type hints for all structures
- **Binary Serialization**: Pack/unpack protocol messages
- **No Business Logic**: Pure data structures

**Key Files**:

- `protocol_types.py` - Enums, HSBK, field structures
- `packets.py` - Packet class definitions
- `generator.py` - Code generation from YAML

**Example**:

```python
from lifx.protocol.packets import Light
from lifx import HSBK

# Create a packet
packet = Light.SetColor(
    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0
)

# Serialize to bytes
data = packet.pack()
```

### Layer 2: Network Layer

**Purpose**: Handle network communication

- **UDP Transport**: Async socket operations
- **Discovery**: Broadcast-based device discovery
- **Lazy Connections**: Auto-open on first request
- **Retry Logic**: Automatic retry with exponential backoff

**Key Files**:

- `transport.py` - UDP socket wrapper
- `discovery.py` - Device discovery
- `connection.py` - Connection management
- `message.py` - Message building

**Example**:

```python
from lifx.network.connection import DeviceConnection

conn = DeviceConnection(serial="d073d5123456", ip="192.168.1.100")
# Connection opens lazily on first request
response = await conn.request(packet)
```

### Layer 3: Device Layer

**Purpose**: Device abstractions with high-level operations

- **Device Types**: Base, Light, HevLight, InfraredLight, MultiZoneLight, MatrixLight
- **State Caching**: Cached state properties for efficient access
- **Type Detection**: Automatic capability detection
- **Async Context Managers**: Automatic resource cleanup

**Key Files**:

- `base.py` - Base Device class
- `light.py` - Light class
- `hev.py` - HevLight class
- `infrared.py` - InfraredLight class
- `multizone.py` - MultiZoneLight class
- `matrix.py` - MatrixLight class

**Example**:

```python
from lifx import Light

async with Light(serial, ip) as light:
    # High-level operations
    await light.set_color(Colors.BLUE)
    await light.pulse(Colors.RED, period=1.0, cycles=5)
```

### Layer 4: High-Level API

**Purpose**: Simple, batteries-included API

- **Simplified Discovery**: One-line device discovery
- **Batch Operations**: Control multiple devices
- **Direct Connection**: Connect by IP without discovery
- **Filtered Discovery**: Find devices by label or serial

**Key Files**:

- `api.py` - High-level functions
- `color.py` - Color utilities

**Example**:

```python
from lifx import discover, DeviceGroup, Colors

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

await group.set_color(Colors.BLUE)
```

## Data Flow

### Sending a Command

```
sequenceDiagram
    participant User
    participant Light
    participant Connection
    participant Transport
    participant Device

    User->>Light: set_color(Colors.BLUE)
    Light->>Light: Convert to HSBK
    Light->>Connection: send_packet(SetColor)
    Connection->>Connection: Serialize packet
    Connection->>Transport: send_message(bytes)
    Transport->>Device: UDP packet
    Device-->>Transport: UDP acknowledgment
    Transport-->>Connection: Response
    Connection-->>Connection: Deserialize packet
    Connection-->>Light: Reply
    Light-->>User: Success
```

### Discovery Process

```
sequenceDiagram
    participant User
    participant Discovery
    participant Transport
    participant Network
    participant Devices

    User->>Discovery: discover_devices(timeout=3.0)
    Discovery->>Transport: Open UDP socket
    Discovery->>Transport: Send broadcast (GetService)
    Transport->>Network: Broadcast on 255.255.255.255
    Network->>Devices: Broadcast packet
    Devices-->>Network: StateService responses
    Network-->>Transport: Multiple responses
    Transport-->>Discovery: Parse responses
    Discovery->>Discovery: Collect device info
    Discovery-->>User: List[DiscoveredDevice]
```

## Key Design Decisions

### Async-First

**Why**: LIFX operations involve network I/O which benefits from async

```python
# Multiple devices controlled concurrently
await asyncio.gather(
    light1.set_color(Colors.RED),
    light2.set_color(Colors.BLUE),
    light3.set_color(Colors.GREEN),
)
```

### Lazy Connections

**Why**: Simple lifecycle management with automatic cleanup

```python
# Connection opens lazily on first request
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.RED)  # Opens connection here
    await light.set_brightness(0.5)  # Reuses same connection
    await light.get_label()  # Reuses same connection
# Connection automatically closed on exit
```

### State Caching

**Why**: Reduces network traffic and provides fast access to semi-static device state

```python
# Semi-static properties return cached values:
label = light.label
if label:
    # Use cached label
    print(f"Label: {label}")
else:
    # No cached data yet, fetch from device
    label = await light.get_label()
    print(f"Fetched label: {label}")

# Volatile state (power, color) always requires fresh fetch
# get_color() will cache the label value only
color, power, label = await light.get_color()
print(f"Current state of {light.label} - Power: {power}, Color: {color}")
```

### Code Generation

**Why**: Protocol updates are automatic, reduces errors

```bash
# Regenerate code
uv run python -m lifx.protocol.generator
```

## Performance Characteristics

### Connection Lifecycle

- **Lazy Opening**: Opens on first request, not on creation
- **Explicit Cleanup**: Closes via `close()` or context manager exit
- **Low Overhead**: One UDP socket per device

### State Caching as Properties

- **Format**: Cached values or `None` if not yet fetched
- **Properties**: All device state available as properties
- **Getting Fresh Data**: Use `get_*()` methods to always fetch from device

## Concurrency Model

Each connection serializes requests to prevent response mixing:

```python
conn = DeviceConnection(serial="d073d5123456", ip="192.168.1.100")
# Requests are serialized on the same connection
result1 = await conn.request(packet1)
result2 = await conn.request(packet2)
await conn.close()
```

**How it works**:

- Requests are serialized via `_request_lock` on same connection
- Responses matched to requests by sequence number
- Async generator streaming for efficient multi-response protocols
- Single UDP socket per connection

## Next Steps

- [API Reference](https://djelibeybi.github.io/lifx-async/api/index.md) - Detailed API documentation
- [FAQ](https://djelibeybi.github.io/lifx-async/faq/index.md) - Frequently asked questions

# Effects Architecture

This document provides a comprehensive overview of the Light Effects Framework architecture, including design decisions, implementation details, and lifecycle management.

## Table of Contents

- [High-Level Overview](#high-level-overview)
- [Component Architecture](#component-architecture)
- [Effect Lifecycle](#effect-lifecycle)
- [State Management](#state-management)
- [Concurrency Model](#concurrency-model)
- [Device Type Handling](#device-type-handling)
- [Design Decisions](#design-decisions)

## High-Level Overview

The Light Effects Framework is built on a layered architecture that separates concerns and provides a clean abstraction for effect management:

```text

              Application Layer                       
  (User code, business logic, effect selection)      

                 

              Effects API Layer                       
    Conductor (orchestration)                       
    EffectPulse, EffectColorloop (implementations)  
    LIFXEffect (base class)                         

                 

            Device Layer (lifx.devices)               
    Light, MultiZoneLight, MatrixLight              
    Device state methods (get_color, set_color)     

                 

           Network Layer (lifx.network)               
    DeviceConnection (UDP transport)                
    Message building and parsing                    

                 

          Protocol Layer (lifx.protocol)              
    Binary serialization/deserialization            
    Packet definitions (auto-generated)             

```

### Key Principles

1. **Zero Dependencies**: Uses only Python stdlib and existing lifx-async components
1. **State Preservation**: Automatically captures and restores device state
1. **Type Safety**: Full type hints with strict Pyright validation
1. **Async/Await**: Native asyncio for concurrent operations
1. **Extensibility**: Abstract base class for custom effects

## Component Architecture

### Module Structure

```text
src/lifx/effects/
 __init__.py              # Public API exports
 base.py                  # LIFXEffect abstract base class
 conductor.py             # Conductor orchestrator
 pulse.py                 # EffectPulse implementation
 colorloop.py             # EffectColorloop implementation
 models.py                # PreState, RunningEffect dataclasses
 utils.py                 # Shared utilities (future)
```

### Component Responsibilities

#### Conductor (`conductor.py`)

**Purpose:** Central orchestrator managing effect lifecycle across multiple devices.

**Responsibilities:**

- Track running effects per device (serial  RunningEffect mapping)
- Capture device state before effects
- Power on devices if needed
- Execute effects via `effect.async_perform()`
- Restore device state after effects complete
- Handle concurrent effects on different devices
- Provide thread-safe state management with `asyncio.Lock()`

**Key Data Structures:**

```python
class Conductor:
    _running: dict[str, RunningEffect]  # serial  RunningEffect
    _lock: asyncio.Lock                 # Thread-safe access
```

#### LIFXEffect Base Class (`base.py`)

**Purpose:** Abstract base for all effect implementations.

**Responsibilities:**

- Define effect interface (abstract `async_play()` method)
- Handle power-on logic in `async_perform()`
- Provide startup color via `from_poweroff_hsbk()`
- Enable state inheritance optimization via `inherit_prestate()`
- Store conductor reference and participants

**Key Methods:**

```python
class LIFXEffect(ABC):
    async def async_perform(participants):  # Setup + call async_play()
        ...

    @abstractmethod
    async def async_play():                 # Effect logic (override)
        ...

    async def from_poweroff_hsbk(light):    # Startup color (override)
        ...

    def inherit_prestate(other):            # State inheritance (override)
        ...
```

#### Effect Implementations

**EffectPulse (`pulse.py`):**

- Implements pulse/blink/breathe effects
- Five modes with different timing and waveforms
- Intelligent color selection based on mode
- Auto-completion after configured cycles

**EffectColorloop (`colorloop.py`):**

- Implements continuous hue rotation
- Randomized direction, device order, saturation
- Runs indefinitely until stopped
- Supports state inheritance for seamless transitions

#### Data Models (`models.py`)

**PreState:**

Stores device state before effect:

```python
@dataclass
class PreState:
    power: bool                     # Power state (on/off)
    color: HSBK                     # Current color
    zone_colors: list[HSBK] | None  # Multizone colors (if applicable)
```

**RunningEffect:**

Associates effect with its pre-state:

```python
@dataclass
class RunningEffect:
    effect: LIFXEffect    # Effect instance
    prestate: PreState    # Captured state
```

## Effect Lifecycle

The effect lifecycle consists of five distinct phases:

### 1. Initialization

User creates effect instance with desired parameters:

```python
effect = EffectPulse(mode='blink', cycles=5)
```

**What happens:**

- Effect object created with parameters stored
- No network activity yet
- No conductor association yet

### 2. State Capture

Conductor starts effect and captures current device state:

```python
await conductor.start(effect, [light1, light2])
```

**What happens:**

```text
For each light:
  1. Check if prestate can be inherited from running effect
  2. If not, capture new prestate:
     a. Get power state (get_power)
     b. Get current color (get_color)
     c. Get zone colors if multizone (get_color_zones or get_extended_color_zones)
  3. Store in RunningEffect and register in conductor._running
```

**Timing:** \<1 second per device (mostly network I/O)

**Special Cases:**

- **Prestate Inheritance:** If `effect.inherit_prestate(current_effect)` returns `True`, reuses existing PreState
- **Multizone Devices:** Uses extended messages if supported, falls back to standard messages
- **Powered-off Devices:** All state is still captured (including zone colors that may be inaccurate)

### 3. Power-On (Optional)

If `effect.power_on == True`, devices are powered on:

```python
async def async_perform(self, participants):
    if self.power_on:
        for light in self.participants:
            power_level = await light.get_power()
            if power_level == 0:
                startup_color = await self.from_poweroff_hsbk(light)
                await light.set_color(startup_color, duration=0)
                await light.set_power(True, duration=0.3)
```

**What happens:**

```text
For each powered-off light:
  1. Get startup color from from_poweroff_hsbk()
  2. Set color immediately (duration=0)
  3. Power on with 0.3s fade (duration=0.3)
```

**Timing:** 0.3 seconds per powered-off device

### 4. Effect Execution

Effect logic runs via `async_play()`:

```python
await effect.async_play()
```

**What happens:**

- Subclass-specific effect logic executes
- Can access `self.participants` and `self.conductor`
- Can issue commands to devices
- Pulse effects: Send waveform, wait for completion
- ColorLoop effects: Continuous loop until stopped

**Timing:**

- EffectPulse: `period * cycles` seconds
- EffectColorloop: Runs indefinitely

### 5. State Restoration

Conductor restores devices to pre-effect state:

```python
await conductor.stop([light1, light2])
```

**What happens:**

```text
For each light:
  1. Restore multizone colors (if applicable):
     - Use extended messages if supported
     - Use standard messages with apply=NO_APPLY, then apply=APPLY
     - Wait 0.3s for device processing
  2. Restore color:
     - set_color(prestate.color, duration=0)
     - Wait 0.3s
  3. Restore power:
     - set_power(prestate.power, duration=0)
```

**Timing:** 0.6-1.0 seconds per device (includes delays)

**Special Cases:**

- Multizone devices get zones restored first
- 0.3s delays ensure device processing completes
- Errors are logged but don't stop other devices

## State Management

### State Storage

The conductor maintains a registry of running effects:

```python
_running: dict[str, RunningEffect]
```

**Key:** Device serial number (12-digit hex string) **Value:** `RunningEffect` containing effect instance and captured `PreState`

### State Capture Details

#### Power State

Integer power level captured via `get_power()`:

```python
power_level = await light.get_power()  # Returns int (0 or 65535)
is_on = power_level > 0
```

#### Color State

HSBK color captured via `get_color()`:

```python
color, power, _ = await light.get_color()  # power is int (0 or 65535)
```

Returns:

- `color`: HSBK (hue, saturation, brightness, kelvin)
- `power`: Power level as integer (0 for off, 65535 for on)
- `label`: Device label

#### Multizone State

For `MultiZoneLight` devices, zone colors are captured:

```python
if isinstance(light, MultiZoneLight):
    # Get all zones using the convenience method
    # Automatically uses the best method based on capabilities
    zone_colors = await light.get_all_color_zones()
```

**Extended Multizone:**

- Single message retrieves all zones
- Returns `list[HSBK]` with all zone colors
- More efficient, used when available

**Standard Multizone:**

- Retrieves zones in batches of 8
- Multiple messages required for >8 zones
- Used as fallback for older devices

### State Restoration Details

#### Multizone Restoration

Zones are restored **before** color and power:

**Extended Multizone:**

```python
await light.set_extended_color_zones(
    zone_index=0,
    colors=zone_colors,
    duration=0.0,
    apply=MultiZoneExtendedApplicationRequest.APPLY
)
```

Single message restores all zones.

**Standard Multizone:**

```python
for i, color in enumerate(zone_colors):
    is_last = (i == len(zone_colors) - 1)
    apply = APPLY if is_last else NO_APPLY

    await light.set_color_zones(
        start=i, end=i,
        color=color,
        duration=0.0,
        apply=apply
    )
```

Multiple messages with `apply` logic:

- `NO_APPLY` (0): Update buffer, don't display
- `APPLY` (1): Update buffer and display (used on last zone)

This ensures atomic update visible only when all zones are set.

#### Timing Delays

Critical 0.3-second delays ensure device processing:

```python
# After multizone restoration
await asyncio.sleep(0.3)

# After color restoration
await asyncio.sleep(0.3)

# No delay after power (last operation)
```

Without these delays, subsequent operations may arrive before device finishes processing, causing state corruption.

### Prestate Inheritance

Optimization that skips state capture/restore for compatible consecutive effects:

```python
def inherit_prestate(self, other: LIFXEffect) -> bool:
    """Return True if can skip restoration."""
    return isinstance(other, EffectColorloop)  # Example
```

**When used:**

```python
current_running = self._running.get(serial)
if current_running and effect.inherit_prestate(current_running.effect):
    # Reuse existing prestate
    prestate = current_running.prestate
else:
    # Capture new prestate
    prestate = await self._capture_prestate(light)
```

**Benefits:**

- Eliminates flash/reset between compatible effects
- Reduces network traffic
- Faster effect transitions

**Used by:**

- `EffectColorloop.inherit_prestate()`  Returns `True` for other `EffectColorloop` instances
- `EffectPulse` doesn't use it (returns `False`)

## Concurrency Model

### Thread Safety

The conductor uses an `asyncio.Lock()` for thread-safe state management:

```python
async def start(self, effect, participants):
    async with self._lock:
        # Critical section: state capture and registration
        for light in participants:
            prestate = await self._capture_prestate(light)
            self._running[light.serial] = RunningEffect(effect, prestate)

    # Effect execution happens outside lock (concurrent)
    await effect.async_perform(participants)
```

**Why lock is needed:**

- Prevents race conditions when starting/stopping effects concurrently
- Protects `_running` dictionary modifications
- Ensures atomic state capture and registration

**Why effect execution is outside lock:**

- Allows multiple effects to run concurrently on different devices
- Effect logic doesn't modify conductor state
- Prevents blocking other operations during long-running effects

### Concurrent Device Operations

Effects use `asyncio.gather()` for concurrent device operations:

```python
# Apply waveform to all devices concurrently
tasks = [
    light.set_waveform(color, period, cycles, waveform)
    for light in self.participants
]
await asyncio.gather(*tasks)
```

**Benefits:**

- Multiple devices updated in parallel
- Network latency overlaps
- Total time  single device time (not N  device time)

### Background Response Dispatcher

Each `DeviceConnection` has a background receiver task that routes responses:

```python
# In DeviceConnection
async def _response_receiver(self):
    while self._running:
        packet = await self._receive_packet()
        # Route by sequence number to waiting coroutine
        self._pending[seq_num].set_result(packet)
```

**Implications for effects:**

- Multiple concurrent requests on same device are supported
- Responses are correctly matched even with concurrent operations
- No additional coordination needed in effect code

### Effect Concurrency Patterns

#### Pattern 1: Sequential Effects on Same Devices

```python
# Effect 1 completes before Effect 2 starts
await conductor.start(effect1, lights)
await asyncio.sleep(duration1)
await conductor.start(effect2, lights)  # Captures new state
```

State is automatically restored between effects.

#### Pattern 2: Concurrent Effects on Different Devices

```python
# Different devices, completely independent
await conductor.start(effect1, group1)
await conductor.start(effect2, group2)
# Both run concurrently
```

No locking needed - different devices, different state.

#### Pattern 3: Replacing Running Effect

```python
# Start effect1
await conductor.start(effect1, lights)
await asyncio.sleep(5)

# Replace with effect2
await conductor.start(effect2, lights)  # Prestate may be inherited
```

If `effect2.inherit_prestate(effect1)` returns `True`, no restoration happens.

## Device Type Handling

### Device Capabilities Detection

The effects framework adapts to device capabilities automatically:

```python
# Check if multizone
if isinstance(light, MultiZoneLight):
    # Capture zone colors
    zone_colors = await light.get_color_zones(...)

# Check if extended multizone supported
if light.capabilities and light.capabilities.has_extended_multizone:
    # Use efficient extended messages
    await light.set_extended_color_zones(...)
```

### Device-Specific Behavior

#### Color Lights (`Light`)

- Full HSBK color support
- All effect parameters apply
- No special handling needed

#### Multizone Lights (`MultiZoneLight`)

- **State Capture:** Zone colors captured using extended or standard messages
- **State Restoration:** All zones restored with proper `apply` logic
- **Effect Behavior:** Entire device pulses/cycles together (zones not individually controlled)
- **Timing:** 0.3s delay after zone restoration

#### Matrix Lights (`MatrixLight`)

- **Current Implementation:** Treated like color lights (no matrix-specific logic yet)
- **Future Enhancement:** Could apply effects to individual tiles using device chain

#### HEV Lights (`HevLight`)

- Treated like standard color lights
- HEV cycle not affected by effects
- Effects don't interfere with HEV functionality

#### Infrared Lights (`InfraredLight`)

- Treated like standard color lights
- Infrared LED not affected by color effects
- Effects only control visible light

#### Monochrome/White Lights

- **Color parameters ignored:** Hue and saturation have no effect
- **Brightness works:** Effects can still toggle/fade brightness
- **Kelvin preserved:** Temperature setting maintained
- **Recommendation:** Limited usefulness (only brightness changes visible)

## Design Decisions

### Why Conductor Pattern?

**Decision:** Central conductor manages all effect lifecycle instead of effects managing themselves.

**Rationale:**

1. **Centralized State:** Single source of truth for what's running where
1. **Consistent State Management:** All effects get same capture/restore logic
1. **Concurrency Control:** Single lock protects all state modifications
1. **User Simplicity:** Users don't manage state manually

**Alternative Considered:** Effects self-manage state

**Rejected because:** Would require each effect to duplicate state logic, higher chance of bugs

### Why Abstract Base Class?

**Decision:** `LIFXEffect` is abstract with required `async_play()` override.

**Rationale:**

1. **Type Safety:** Enforces effect interface at type-check time
1. **Code Reuse:** Common setup logic in `async_perform()`
1. **Extensibility:** Users can create custom effects easily
1. **Consistency:** All effects follow same pattern

### Why Two-Phase Effect Execution?

**Decision:** `async_perform()` calls `async_play()` instead of single method.

**Rationale:**

1. **Separation of Concerns:** Setup logic separate from effect logic
1. **User Simplicity:** Users only override `async_play()`, setup is automatic
1. **Consistency:** All effects get same power-on behavior
1. **Flexibility:** Base class can add more setup steps without breaking subclasses

### Why No Rate Limiting?

**Decision:** Effects don't implement rate limiting.

**Rationale:**

1. **Simplicity:** Keeps core library simple and focused
1. **Flexibility:** Applications have different rate limit needs
1. **Transparency:** Users see actual device behavior
1. **Consistency:** Matches lifx-async philosophy (no hidden rate limiting)

**Recommendation:** Applications should implement rate limiting if sending many concurrent requests.

### Why 0.3-Second Delays?

**Decision:** Fixed 0.3-second delays between state restoration operations.

**Rationale:**

1. **Device Processing Time:** LIFX devices need time to process commands
1. **Empirical Testing:** 0.3s works reliably across all device types
1. **State Integrity:** Prevents race conditions and state corruption
1. **Trade-off:** Slightly slower restoration but guaranteed correctness

**Alternative Considered:** No delays, faster restoration

**Rejected because:** Causes state corruption and unpredictable behavior

### Why Prestate Inheritance?

**Decision:** Optional optimization via `inherit_prestate()` method.

**Rationale:**

1. **Performance:** Eliminates unnecessary state reset
1. **User Experience:** No visible flash between compatible effects
1. **Opt-in:** Only used when effect explicitly enables it
1. **Safe Default:** Returns `False` unless overridden

**Use Cases:**

- ColorLoop  ColorLoop: Seamless transition
- Pulse  Pulse: Could enable but currently disabled
- Different types: Should not inherit (different visual intent)

### Why No Tile-Specific Logic (Yet)?

**Decision:** Tiles treated like single-color lights for now.

**Rationale:**

1. **MVP Scope:** Phase 1 focuses on core framework
1. **Complexity:** Tile effects require 2D coordinate system
1. **Future Enhancement:** Architecture supports adding tile-specific effects later
1. **Current Usefulness:** Effects still work on tiles (just not tile-aware)

**Future Work:** Tile-specific effects would use `MatrixLight.set_matrix_colors()` and apply per-tile logic similar to theme support.

## Integration Points

### With Device Layer

Effects use standard device methods:

- `get_power()`, `set_power()`
- `get_color()`, `set_color()`
- `set_waveform()` (EffectPulse)
- `get_color_zones()`, `set_color_zones()` (MultiZoneLight)
- `get_extended_color_zones()`, `set_extended_color_zones()` (MultiZoneLight)

No special device modifications needed.

### With Network Layer

Effects rely on existing lazy connection and concurrent request support:

- Lazy connections open on first request and are reused
- Requests are serialized via lock to prevent response mixing
- No effect-specific network code needed

### With Protocol Layer

Effects use existing protocol structures:

- `HSBK` for color representation
- `LightWaveform` enum for waveform types
- `MultiZoneApplicationRequest` for zone apply logic
- Auto-generated packet classes

## Performance Characteristics

### Memory Usage

- **Conductor:** ~10KB base + running effects
- **Per Effect:** ~1KB per device + effect-specific state
- **PreState:** ~200 bytes per device (~100 bytes + zone colors)

### CPU Usage

- **Minimal:** Async I/O bound, not CPU bound
- **Concurrency:** Multiple devices don't increase CPU significantly
- **Background Tasks:** Requests serialized per connection, concurrent across devices

### Network Traffic

#### State Capture

- Power: 1 request per device
- Color: 1 request per device
- Multizone: 1 request (extended) or N/8 requests (standard)
- **Total:** 3-4 packets per device

#### Effect Execution

- Pulse: 1 waveform packet per device
- ColorLoop: 1 color packet per device per iteration

#### State Restoration

- Multizone: 1 request (extended) or N requests (standard)
- Color: 1 request per device
- Power: 1 request per device
- **Total:** 2-3 packets per device (or N+2 for standard multizone)

### Scalability

- **Tested:** 10+ devices
- **Expected:** 50+ devices in production
- **Limitation:** Network capacity and device response time
- **Recommendation:** For 50+ devices, consider grouping effects or staggering start times

## See Also

- [Getting Started](https://djelibeybi.github.io/lifx-async/getting-started/effects/index.md) - Basic usage
- [Effects Reference](https://djelibeybi.github.io/lifx-async/api/effects/index.md) - Detailed API documentation
- [Custom Effects](https://djelibeybi.github.io/lifx-async/user-guide/effects-custom/index.md) - Creating your own effects
- [Troubleshooting](https://djelibeybi.github.io/lifx-async/user-guide/effects-troubleshooting/index.md) - Common issues
# API Reference

# API Reference

Complete reference documentation for lifx-async.

## Module Structure

```text
lifx/
 __init__.py               # High-level API exports
 api.py                    # Simplified discovery and device group functions
 color.py                  # Color utilities (HSBK, Colors)
 const.py                  # Network constants and URLs
 exceptions.py             # Exception hierarchy
 devices/                  # Device classes
    base.py              # Base Device class
    light.py             # Light device (color control)
    hev.py               # HevLight device (anti-bacterial cleaning)
    infrared.py          # InfraredLight device (night vision)
    multizone.py         # MultiZoneLight (strips/beams)
    matrix.py            # MatrixLight (2D matrix devices: tiles, candle, path)
 network/                  # Network layer
    connection.py        # Device connections with lazy opening
    discovery.py         # Network device discovery (UDP broadcast)
    message.py           # Message building and parsing
    transport.py         # UDP transport
    mdns/                # mDNS/DNS-SD discovery
        discovery.py     # mDNS discovery functions
        dns.py           # DNS wire format parser
        transport.py     # Multicast UDP transport
        types.py         # LifxServiceRecord dataclass
 products/                 # Product registry
    registry.py          # Auto-generated product database
    generator.py         # Generator to download/parse products.json
    __init__.py          # Public API exports
 protocol/                 # Protocol layer (auto-generated)
     base.py              # Base packet class
     generator.py         # Code generator from protocol.yml
     header.py            # Protocol header (36 bytes)
     models.py            # Protocol models (Serial, HEV types)
     packets.py           # Packet definitions
     protocol_types.py    # Type definitions and enums
     serializer.py        # Binary serialization/deserialization
```

## Quick Reference

### High-Level API

Main entry points for most users:

- [`discover()`](https://djelibeybi.github.io/lifx-async/api/high-level/#lifx.api.discover) - Device discovery via UDP broadcast
- [`discover_mdns()`](https://djelibeybi.github.io/lifx-async/api/high-level/#lifx.api.discover_mdns) - Device discovery via mDNS (faster)
- [`find_by_serial()`](https://djelibeybi.github.io/lifx-async/api/high-level/#lifx.api.find_by_serial) - Find device by serial number
- [`find_by_label()`](https://djelibeybi.github.io/lifx-async/api/high-level/#lifx.api.find_by_label) - Find devices by label (exact or substring)
- [`find_by_ip()`](https://djelibeybi.github.io/lifx-async/api/high-level/#lifx.api.find_by_ip) - Find device by IP address
- [`DeviceGroup`](https://djelibeybi.github.io/lifx-async/api/high-level/#lifx.api.DeviceGroup) - Batch operations

### Device Classes

Control your LIFX devices:

- [`Device`](https://djelibeybi.github.io/lifx-async/api/devices/#lifx.devices.base.Device) - Base device operations
- [`Light`](https://djelibeybi.github.io/lifx-async/api/devices/#lifx.devices.light.Light) - Color control
- [`HevLight`](https://djelibeybi.github.io/lifx-async/api/devices/#lifx.devices.hev.HevLight) - Anti-bacterial cleaning cycles
- [`InfraredLight`](https://djelibeybi.github.io/lifx-async/api/devices/#lifx.devices.infrared.InfraredLight) - Night vision infrared LED
- [`MultiZoneLight`](https://djelibeybi.github.io/lifx-async/api/devices/#lifx.devices.multizone.MultiZoneLight) - Strips/beams
- [`MatrixLight`](https://djelibeybi.github.io/lifx-async/api/devices/#lifx.devices.matrix.MatrixLight) - 2D matrix devices (tiles, candle, path)

### Color Utilities

Work with colors:

- [`HSBK`](https://djelibeybi.github.io/lifx-async/api/colors/#lifx.color.HSBK) - Color representation
- [`Colors`](https://djelibeybi.github.io/lifx-async/api/colors/#lifx.color.Colors) - Built-in presets

### Network Layer

Low-level network operations:

- [`discover_devices()`](https://djelibeybi.github.io/lifx-async/api/network/#lifx.network.discovery.discover_devices) - Low-level UDP discovery
- [`discover_lifx_services()`](https://djelibeybi.github.io/lifx-async/api/network/#lifx.network.mdns.discover_lifx_services) - Low-level mDNS discovery
- [`LifxServiceRecord`](https://djelibeybi.github.io/lifx-async/api/network/#lifx.network.mdns.LifxServiceRecord) - mDNS service record
- [`DeviceConnection`](https://djelibeybi.github.io/lifx-async/api/network/#lifx.network.connection.DeviceConnection) - Device connections

### Products Registry

Device capabilities and automatic type detection:

- [`ProductInfo`](https://djelibeybi.github.io/lifx-async/api/protocol/#lifx.products.ProductInfo) - Product information
- [`ProductCapability`](https://djelibeybi.github.io/lifx-async/api/protocol/#lifx.products.ProductCapability) - Device capabilities

### Exceptions

Error handling:

- [`LifxError`](https://djelibeybi.github.io/lifx-async/api/exceptions/#lifx.exceptions.LifxError) - Base exception
- [`LifxTimeoutError`](https://djelibeybi.github.io/lifx-async/api/exceptions/#lifx.exceptions.LifxTimeoutError) - Timeout errors
- [`LifxConnectionError`](https://djelibeybi.github.io/lifx-async/api/exceptions/#lifx.exceptions.LifxConnectionError) - Connection errors

## Usage Patterns

### Async Context Managers

All device classes support async context managers for automatic resource cleanup:

```python
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)
# Connection automatically closed
```

### Batch Operations

Use `DeviceGroup` for efficient batch operations:

```python
from lifx import discover, DeviceGroup, Colors

devices = []
async for device in discover():
    devices.append(device)

group = DeviceGroup(devices)
await group.set_power(True)
await group.set_color(Colors.BLUE)
```

### Connection Lifecycle

Connections open lazily on first request and reuse the same socket:

```python
# Multiple operations reuse the same connection
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.RED)
    await light.set_brightness(0.5)
    await light.get_label()
# Connection automatically closed on exit
```

### Concurrent Requests

Devices support concurrent requests via asyncio.gather:

```python
# Execute multiple operations concurrently
async with await Light.from_ip("192.168.1.100") as light:
    # Note: get_color() returns (color, power, label) tuple
    (color, power, label), version = await asyncio.gather(
        light.get_color(),
        light.get_version()
    )
    brightness = color.brightness
    print(f"{label}: Brightness={brightness}, Firmware={version.firmware}")
```

## Type Hints

lifx-async is fully type-hinted. Use a type checker like Pyright or mypy:

```python
from lifx import Light, HSBK


async def set_custom_color(light: Light, hue: float) -> None:
    color: HSBK = HSBK(hue=hue, saturation=1.0, brightness=0.8, kelvin=3500)
    await light.set_color(color)
```

## API Sections

- **High-Level API**

______________________________________________________________________

Simple, batteries-included API for common tasks

[High-Level API](https://djelibeybi.github.io/lifx-async/api/high-level/index.md)

- **Device Classes**

______________________________________________________________________

Control LIFX lights, strips, tiles, and matrix devices

[Devices](https://djelibeybi.github.io/lifx-async/api/devices/index.md)

- **Color Utilities**

______________________________________________________________________

Work with colors, RGB, and HSBK

[Colors](https://djelibeybi.github.io/lifx-async/api/colors/index.md)

- **Network Layer**

______________________________________________________________________

Low-level network operations

[Network](https://djelibeybi.github.io/lifx-async/api/network/index.md)

- **Protocol Layer**

______________________________________________________________________

Auto-generated protocol structures

[Protocol](https://djelibeybi.github.io/lifx-async/api/protocol/index.md)

- **Exceptions**

______________________________________________________________________

Error handling and exception hierarchy

[Exceptions](https://djelibeybi.github.io/lifx-async/api/exceptions/index.md)

## Best Practices

### Always Use Context Managers

```python
#  Good - automatic cleanup
async with await Light.from_ip("192.168.1.100") as light:
    await light.set_color(Colors.BLUE)

#  Bad - manual cleanup required
light = Light("d073d5123456", "192.168.1.100")
await light.connect()
await light.set_color(Colors.BLUE)
await light.disconnect()
```

### Handle Exceptions

```python
from lifx import discover, Colors, LifxError

try:
    async for device in discover():
        await device.set_color(Colors.GREEN)
except LifxError as e:
    print(f"LIFX error: {e}")
```

### Use Type Hints

```python
from lifx import Light, HSBK


async def control_light(light: Light) -> str:
    label: str = await light.get_label()
    return label
```

## Further Reading

- [Architecture](https://djelibeybi.github.io/lifx-async/architecture/overview/index.md) - How lifx-async works
- [FAQ](https://djelibeybi.github.io/lifx-async/faq/index.md) - Frequently asked questions

# High-Level API

The high-level API provides simplified functions for common LIFX operations. These are the recommended entry points for most users.

## Discovery Functions

### discover

```python
discover(
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> AsyncGenerator[Device, None]
```

Discover LIFX devices and yield them as they are found.

| PARAMETER                 | DESCRIPTION                                                                                           |
| ------------------------- | ----------------------------------------------------------------------------------------------------- |
| `timeout`                 | Discovery timeout in seconds (default 3.0) **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT`         |
| `broadcast_address`       | Broadcast address to use (default "255.255.255.255") **TYPE:** `str` **DEFAULT:** `'255.255.255.255'` |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                      |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                     |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                      |
| `device_timeout`          | request timeout set on discovered devices **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT`    |
| `max_retries`             | max retries per request set on discovered devices **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES`  |

Yields: Device instances as they are discovered

Example

```python
# Process devices as they're discovered
async for device in discover():
    print(f"Found: {device.serial}")
    async with device:
        await device.set_power(True)

# Or collect all devices first
devices = []
async for device in discover():
    devices.append(device)
```

Source code in `src/lifx/api.py`

````python
async def discover(
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> AsyncGenerator[Device, None]:
    """Discover LIFX devices and yield them as they are found.

    Args:
        timeout: Discovery timeout in seconds (default 3.0)
        broadcast_address: Broadcast address to use (default "255.255.255.255")
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier
        device_timeout: request timeout set on discovered devices
        max_retries: max retries per request set on discovered devices
    Yields:
        Device instances as they are discovered

    Example:
        ```python
        # Process devices as they're discovered
        async for device in discover():
            print(f"Found: {device.serial}")
            async with device:
                await device.set_power(True)

        # Or collect all devices first
        devices = []
        async for device in discover():
            devices.append(device)
        ```
    """
    async for discovered in discover_devices(
        timeout=timeout,
        broadcast_address=broadcast_address,
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
        device_timeout=device_timeout,
        max_retries=max_retries,
    ):
        device = await discovered.create_device()
        if device is not None:
            yield device
````

### find_by_serial

```python
find_by_serial(
    serial: str,
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Device | None
```

Find a specific device by serial number.

| PARAMETER                 | DESCRIPTION                                                                                                 |
| ------------------------- | ----------------------------------------------------------------------------------------------------------- |
| `serial`                  | Serial number as hex string (with or without separators) **TYPE:** `str`                                    |
| `timeout`                 | Discovery timeout in seconds (default DISCOVERY_TIMEOUT) **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT` |
| `broadcast_address`       | Broadcast address to use (default "255.255.255.255") **TYPE:** `str` **DEFAULT:** `'255.255.255.255'`       |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                            |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                           |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                            |
| `device_timeout`          | request timeout set on discovered device **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT`           |
| `max_retries`             | max retries per request set on discovered device **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES`         |

| RETURNS  | DESCRIPTION |
| -------- | ----------- |
| \`Device | None\`      |

Example

```python
# Find by serial number
device = await find_by_serial("d073d5123456")
if device:
    async with device:
        await device.set_power(True)
```

Source code in `src/lifx/api.py`

````python
async def find_by_serial(
    serial: str,
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Device | None:
    """Find a specific device by serial number.

    Args:
        serial: Serial number as hex string (with or without separators)
        timeout: Discovery timeout in seconds (default DISCOVERY_TIMEOUT)
        broadcast_address: Broadcast address to use (default "255.255.255.255")
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier
        device_timeout: request timeout set on discovered device
        max_retries: max retries per request set on discovered device

    Returns:
        Device instance if found, None otherwise

    Example:
        ```python
        # Find by serial number
        device = await find_by_serial("d073d5123456")
        if device:
            async with device:
                await device.set_power(True)
        ```
    """
    # Normalize serial to string format (12-digit hex, no separators)
    serial_str = serial.replace(":", "").replace("-", "").lower()

    async for disc in discover_devices(
        timeout=timeout,
        broadcast_address=broadcast_address,
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
        device_timeout=device_timeout,
        max_retries=max_retries,
    ):
        if disc.serial.lower() == serial_str:
            # Detect device type and return appropriate class
            return await disc.create_device()

    return None
````

### find_by_label

```python
find_by_label(
    label: str,
    exact_match: bool = False,
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> AsyncGenerator[Device]
```

Find LIFX devices by label (name).

Uses a protocol trick by broadcasting GetLabel instead of GetService, which returns all device labels in StateLabel responses. This is more efficient than querying each device individually.

| PARAMETER                 | DESCRIPTION                                                                                                                                                               |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `label`                   | Device label to search for (case-insensitive) **TYPE:** `str`                                                                                                             |
| `exact_match`             | If True, match label exactly and yield at most one device; if False, match substring and yield all matching devices (default False) **TYPE:** `bool` **DEFAULT:** `False` |
| `timeout`                 | Discovery timeout in seconds (default DISCOVERY_TIMEOUT) **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT`                                                               |
| `broadcast_address`       | Broadcast address to use (default "255.255.255.255") **TYPE:** `str` **DEFAULT:** `'255.255.255.255'`                                                                     |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                                                                                          |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                                                                                         |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                                                                                          |
| `device_timeout`          | request timeout set on discovered device(s) **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT`                                                                      |
| `max_retries`             | max retries per request set on discovered device(s) **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES`                                                                    |

| YIELDS                   | DESCRIPTION                 |
| ------------------------ | --------------------------- |
| `AsyncGenerator[Device]` | Matching Device instance(s) |

Example

```python
# Find all devices with "Living" in the label
async for device in find_by_label("Living"):
    async with device:
        await device.set_power(True)

# Find device by exact label match (yields at most one)
async for device in find_by_label("Living Room", exact_match=True):
    async with device:
        await device.set_power(True)
    break  # exact_match yields at most one device
```

Source code in `src/lifx/api.py`

````python
async def find_by_label(
    label: str,
    exact_match: bool = False,
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> AsyncGenerator[Device]:
    """Find LIFX devices by label (name).

    Uses a protocol trick by broadcasting GetLabel instead of GetService,
    which returns all device labels in StateLabel responses. This is more
    efficient than querying each device individually.

    Args:
        label: Device label to search for (case-insensitive)
        exact_match: If True, match label exactly and yield at most one device;
                     if False, match substring and yield all matching devices
                     (default False)
        timeout: Discovery timeout in seconds (default DISCOVERY_TIMEOUT)
        broadcast_address: Broadcast address to use (default "255.255.255.255")
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier
        device_timeout: request timeout set on discovered device(s)
        max_retries: max retries per request set on discovered device(s)

    Yields:
        Matching Device instance(s)

    Example:
        ```python
        # Find all devices with "Living" in the label
        async for device in find_by_label("Living"):
            async with device:
                await device.set_power(True)

        # Find device by exact label match (yields at most one)
        async for device in find_by_label("Living Room", exact_match=True):
            async with device:
                await device.set_power(True)
            break  # exact_match yields at most one device
        ```
    """
    async for resp in _discover_with_packet(
        packets.Device.GetLabel(),
        timeout=timeout,
        broadcast_address=broadcast_address,
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
    ):
        device_label = resp.response_payload.get("label", "")
        matched = False

        if exact_match:
            # Exact match - return first match only
            if device_label.lower() == label.lower():
                matched = True
        else:
            # Substring match - return all matches
            if label.lower() in device_label.lower():
                matched = True

        if matched:
            # Create DiscoveredDevice from response
            disc = DiscoveredDevice(
                serial=resp.serial,
                ip=resp.ip,
                port=resp.port,
                response_time=resp.response_time,
                timeout=device_timeout,
                max_retries=max_retries,
            )

            device = await disc.create_device()
            if device is not None:
                yield device
````

### find_by_ip

```python
find_by_ip(
    ip: str,
    timeout: float = DISCOVERY_TIMEOUT,
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Device | None
```

Find a LIFX device by IP address.

Uses a targeted discovery by sending the broadcast to the specific IP address, which means only that device will respond (if it exists). This is more efficient than broadcasting to all devices and filtering.

| PARAMETER                 | DESCRIPTION                                                                                                 |
| ------------------------- | ----------------------------------------------------------------------------------------------------------- |
| `ip`                      | Target device IP address **TYPE:** `str`                                                                    |
| `timeout`                 | Discovery timeout in seconds (default DISCOVERY_TIMEOUT) **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT` |
| `port`                    | Port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                            |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                           |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                            |
| `device_timeout`          | request timeout set on discovered device **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT`           |
| `max_retries`             | max retries per request set on discovered device **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES`         |

| RETURNS  | DESCRIPTION |
| -------- | ----------- |
| \`Device | None\`      |

Example

```python
# Find device at specific IP
device = await find_by_ip("192.168.1.100")
if device:
    async with device:
        print(f"Found: {device.label}")
```

Source code in `src/lifx/api.py`

````python
async def find_by_ip(
    ip: str,
    timeout: float = DISCOVERY_TIMEOUT,
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Device | None:
    """Find a LIFX device by IP address.

    Uses a targeted discovery by sending the broadcast to the specific IP address,
    which means only that device will respond (if it exists). This is more efficient
    than broadcasting to all devices and filtering.

    Args:
        ip: Target device IP address
        timeout: Discovery timeout in seconds (default DISCOVERY_TIMEOUT)
        port: Port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier
        device_timeout: request timeout set on discovered device
        max_retries: max retries per request set on discovered device

    Returns:
        Device instance if found, None otherwise

    Example:
        ```python
        # Find device at specific IP
        device = await find_by_ip("192.168.1.100")
        if device:
            async with device:
                print(f"Found: {device.label}")
        ```
    """
    # Use the target IP as the "broadcast" address - only that device will respond
    async for discovered in discover_devices(
        timeout=timeout,
        broadcast_address=ip,  # Protocol trick: send directly to target IP
        port=port,
        max_response_time=max_response_time,
        idle_timeout_multiplier=idle_timeout_multiplier,
        device_timeout=device_timeout,
        max_retries=max_retries,
    ):
        # Should only get one response (or none)
        return await discovered.create_device()

    return None
````

## Device Group

### DeviceGroup

```python
DeviceGroup(
    devices: Sequence[
        Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight
    ],
)
```

A group of devices for batch operations.

Provides convenient methods to control multiple devices simultaneously.

Example

```python
# Collect devices from discovery
devices = []
async for device in discover():
    devices.append(device)

# Create group and perform batch operations
group = DeviceGroup(devices)
await group.set_power(True)
await group.set_color(Colors.BLUE)
```

| PARAMETER | DESCRIPTION                                           |
| --------- | ----------------------------------------------------- |
| `devices` | List of Device instances **TYPE:** \`Sequence\[Device |

| METHOD                      | DESCRIPTION                                                  |
| --------------------------- | ------------------------------------------------------------ |
| `__aenter__`                | Enter async context manager.                                 |
| `__aexit__`                 | Exit async context manager and close all device connections. |
| `__iter__`                  | Iterate over devices in the group.                           |
| `__len__`                   | Get number of devices in the group.                          |
| `__getitem__`               | Get device by index.                                         |
| `set_power`                 | Set power state for all devices in the group.                |
| `set_color`                 | Set color for all Light devices in the group.                |
| `set_brightness`            | Set brightness for all Light devices in the group.           |
| `pulse`                     | Pulse effect for all Light devices.                          |
| `organize_by_location`      | Organize devices by location label.                          |
| `organize_by_group`         | Organize devices by group label.                             |
| `filter_by_location`        | Filter devices to a specific location.                       |
| `filter_by_group`           | Filter devices to a specific group.                          |
| `get_unassigned_devices`    | Get devices without location or group assigned.              |
| `apply_theme`               | Apply a theme to all devices in the group.                   |
| `invalidate_metadata_cache` | Clear all cached location and group metadata.                |

| ATTRIBUTE          | DESCRIPTION                                                                    |
| ------------------ | ------------------------------------------------------------------------------ |
| `devices`          | Get all the devices in the group. **TYPE:** \`Sequence\[Device                 |
| `lights`           | Get all Light devices in the group. **TYPE:** `list[Light]`                    |
| `hev_lights`       | Get the HEV lights in the group. **TYPE:** `list[HevLight]`                    |
| `infrared_lights`  | Get the Infrared lights in the group. **TYPE:** `list[InfraredLight]`          |
| `multizone_lights` | Get all MultiZone light devices in the group. **TYPE:** `list[MultiZoneLight]` |
| `matrix_lights`    | Get all Matrix light devices in the group. **TYPE:** `list[MatrixLight]`       |

Source code in `src/lifx/api.py`

```python
def __init__(
    self,
    devices: Sequence[
        Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight
    ],
) -> None:
    """Initialize device group.

    Args:
        devices: List of Device instances
    """
    self._devices = devices
    self._lights = [light for light in devices if isinstance(light, Light)]
    self._hev_lights = [light for light in devices if type(light) is HevLight]
    self._infrared_lights = [
        light for light in devices if type(light) is InfraredLight
    ]
    self._multizone_lights = [
        light for light in devices if type(light) is MultiZoneLight
    ]
    self._matrix_lights = [light for light in devices if type(light) is MatrixLight]
    self._locations_cache: dict[str, DeviceGroup] | None = None
    self._groups_cache: dict[str, DeviceGroup] | None = None
    self._location_metadata: dict[str, LocationGrouping] | None = None
    self._group_metadata: dict[str, GroupGrouping] | None = None
```

#### Attributes

##### devices

```python
devices: Sequence[
    Device | HevLight | InfraredLight | Light | MultiZoneLight | MatrixLight
]
```

Get all the devices in the group.

##### lights

```python
lights: list[Light]
```

Get all Light devices in the group.

##### hev_lights

```python
hev_lights: list[HevLight]
```

Get the HEV lights in the group.

##### infrared_lights

```python
infrared_lights: list[InfraredLight]
```

Get the Infrared lights in the group.

##### multizone_lights

```python
multizone_lights: list[MultiZoneLight]
```

Get all MultiZone light devices in the group.

##### matrix_lights

```python
matrix_lights: list[MatrixLight]
```

Get all Matrix light devices in the group.

#### Functions

##### __aenter__

```python
__aenter__() -> DeviceGroup
```

Enter async context manager.

Source code in `src/lifx/api.py`

```python
async def __aenter__(self) -> DeviceGroup:
    """Enter async context manager."""
    return self
```

##### __aexit__

```python
__aexit__(
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: TracebackType | None,
) -> None
```

Exit async context manager and close all device connections.

Source code in `src/lifx/api.py`

```python
async def __aexit__(
    self,
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: TracebackType | None,
) -> None:
    """Exit async context manager and close all device connections."""
    for device in self._devices:
        await device.connection.close()
```

##### __iter__

```python
__iter__() -> Iterator[
    Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight
]
```

Iterate over devices in the group.

Source code in `src/lifx/api.py`

```python
def __iter__(
    self,
) -> Iterator[
    Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight
]:
    """Iterate over devices in the group."""
    return iter(self._devices)
```

##### __len__

```python
__len__() -> int
```

Get number of devices in the group.

Source code in `src/lifx/api.py`

```python
def __len__(self) -> int:
    """Get number of devices in the group."""
    return len(self._devices)
```

##### __getitem__

```python
__getitem__(
    index: int,
) -> Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight
```

Get device by index.

Source code in `src/lifx/api.py`

```python
def __getitem__(
    self, index: int
) -> Device | Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight:
    """Get device by index."""
    return self._devices[index]
```

##### set_power

```python
set_power(on: bool, duration: float = 0.0) -> None
```

Set power state for all devices in the group.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `on`       | True to turn on, False to turn off **TYPE:** `bool`                               |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
await group.set_power(True, duration=1.0)
```

Source code in `src/lifx/api.py`

````python
async def set_power(self, on: bool, duration: float = 0.0) -> None:
    """Set power state for all devices in the group.

    Args:
        on: True to turn on, False to turn off
        duration: Transition duration in seconds (default 0.0)

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        await group.set_power(True, duration=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.set_power(on, duration))
````

##### set_color

```python
set_color(color: HSBK, duration: float = 0.0) -> None
```

Set color for all Light devices in the group.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)
```

Source code in `src/lifx/api.py`

````python
async def set_color(self, color: HSBK, duration: float = 0.0) -> None:
    """Set color for all Light devices in the group.

    Args:
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        await group.set_color(HSBK.from_rgb(255, 0, 0), duration=2.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.set_color(color, duration))
````

##### set_brightness

```python
set_brightness(brightness: float, duration: float = 0.0) -> None
```

Set brightness for all Light devices in the group.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `brightness` | Brightness level (0.0-1.0) **TYPE:** `float`                                      |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
await group.set_brightness(0.5, duration=1.0)
```

Source code in `src/lifx/api.py`

````python
async def set_brightness(self, brightness: float, duration: float = 0.0) -> None:
    """Set brightness for all Light devices in the group.

    Args:
        brightness: Brightness level (0.0-1.0)
        duration: Transition duration in seconds (default 0.0)

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        await group.set_brightness(0.5, duration=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.set_brightness(brightness, duration))
````

##### pulse

```python
pulse(color: HSBK, period: float = 1.0, cycles: float = 1.0) -> None
```

Pulse effect for all Light devices.

| PARAMETER | DESCRIPTION                                                         |
| --------- | ------------------------------------------------------------------- |
| `color`   | Color to pulse to **TYPE:** `HSBK`                                  |
| `period`  | Period of one cycle in seconds **TYPE:** `float` **DEFAULT:** `1.0` |
| `cycles`  | Number of cycles **TYPE:** `float` **DEFAULT:** `1.0`               |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
await group.pulse(Colors.RED, period=1.0, cycles=1.0)
```

Source code in `src/lifx/api.py`

````python
async def pulse(
    self, color: HSBK, period: float = 1.0, cycles: float = 1.0
) -> None:
    """Pulse effect for all Light devices.

    Args:
        color: Color to pulse to
        period: Period of one cycle in seconds
        cycles: Number of cycles

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        await group.pulse(Colors.RED, period=1.0, cycles=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        for light in self.lights:
            tg.create_task(light.pulse(color, period, cycles))
````

##### organize_by_location

```python
organize_by_location(
    include_unassigned: bool = False,
) -> dict[str, DeviceGroup]
```

Organize devices by location label.

Fetches location metadata if not cached and groups devices by location label.

| PARAMETER            | DESCRIPTION                                                      |
| -------------------- | ---------------------------------------------------------------- |
| `include_unassigned` | Include "Unassigned" group **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS                  | DESCRIPTION                                                 |
| ------------------------ | ----------------------------------------------------------- |
| `dict[str, DeviceGroup]` | Dictionary mapping location labels to DeviceGroup instances |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
by_location = await group.organize_by_location()
kitchen = by_location["Kitchen"]
await kitchen.set_color(Colors.BLUE)
```

Source code in `src/lifx/api.py`

````python
async def organize_by_location(
    self, include_unassigned: bool = False
) -> dict[str, DeviceGroup]:
    """Organize devices by location label.

    Fetches location metadata if not cached and groups devices by location label.

    Args:
        include_unassigned: Include "Unassigned" group

    Returns:
        Dictionary mapping location labels to DeviceGroup instances

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        by_location = await group.organize_by_location()
        kitchen = by_location["Kitchen"]
        await kitchen.set_color(Colors.BLUE)
        ```
    """
    # Fetch metadata if not cached
    if self._location_metadata is None:
        await self._fetch_location_metadata()

    # Build and cache groups
    if self._locations_cache is None:
        self._locations_cache = self._build_location_groups(include_unassigned)

    return self._locations_cache
````

##### organize_by_group

```python
organize_by_group(include_unassigned: bool = False) -> dict[str, DeviceGroup]
```

Organize devices by group label.

Fetches group metadata if not cached and groups devices by group label.

| PARAMETER            | DESCRIPTION                                                      |
| -------------------- | ---------------------------------------------------------------- |
| `include_unassigned` | Include "Unassigned" group **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS                  | DESCRIPTION                                              |
| ------------------------ | -------------------------------------------------------- |
| `dict[str, DeviceGroup]` | Dictionary mapping group labels to DeviceGroup instances |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
by_group = await group.organize_by_group()
bedroom = by_group["Bedroom Lights"]
await bedroom.set_power(False)
```

Source code in `src/lifx/api.py`

````python
async def organize_by_group(
    self, include_unassigned: bool = False
) -> dict[str, DeviceGroup]:
    """Organize devices by group label.

    Fetches group metadata if not cached and groups devices by group label.

    Args:
        include_unassigned: Include "Unassigned" group

    Returns:
        Dictionary mapping group labels to DeviceGroup instances

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        by_group = await group.organize_by_group()
        bedroom = by_group["Bedroom Lights"]
        await bedroom.set_power(False)
        ```
    """
    # Fetch metadata if not cached
    if self._group_metadata is None:
        await self._fetch_group_metadata()

    # Build and cache groups
    if self._groups_cache is None:
        self._groups_cache = self._build_group_groups(include_unassigned)

    return self._groups_cache
````

##### filter_by_location

```python
filter_by_location(label: str, case_sensitive: bool = False) -> DeviceGroup
```

Filter devices to a specific location.

| PARAMETER        | DESCRIPTION                                                                                     |
| ---------------- | ----------------------------------------------------------------------------------------------- |
| `label`          | Location label to filter by **TYPE:** `str`                                                     |
| `case_sensitive` | If True, performs case-sensitive matching (default False) **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS       | DESCRIPTION                                              |
| ------------- | -------------------------------------------------------- |
| `DeviceGroup` | DeviceGroup containing devices in the specified location |

| RAISES     | DESCRIPTION                 |
| ---------- | --------------------------- |
| `KeyError` | If location label not found |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
living_room = await group.filter_by_location("Living Room")
await living_room.set_brightness(0.7)
```

Source code in `src/lifx/api.py`

````python
async def filter_by_location(
    self, label: str, case_sensitive: bool = False
) -> DeviceGroup:
    """Filter devices to a specific location.

    Args:
        label: Location label to filter by
        case_sensitive: If True, performs case-sensitive matching (default False)

    Returns:
        DeviceGroup containing devices in the specified location

    Raises:
        KeyError: If location label not found

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        living_room = await group.filter_by_location("Living Room")
        await living_room.set_brightness(0.7)
        ```
    """
    locations = await self.organize_by_location(include_unassigned=False)

    # Find matching label
    if case_sensitive:
        if label not in locations:
            raise KeyError(f"Location '{label}' not found")
        return locations[label]
    else:
        label_lower = label.lower()
        for loc_label, device_group in locations.items():
            if loc_label.lower() == label_lower:
                return device_group
        raise KeyError(f"Location '{label}' not found")
````

##### filter_by_group

```python
filter_by_group(label: str, case_sensitive: bool = False) -> DeviceGroup
```

Filter devices to a specific group.

| PARAMETER        | DESCRIPTION                                                                                     |
| ---------------- | ----------------------------------------------------------------------------------------------- |
| `label`          | Group label to filter by **TYPE:** `str`                                                        |
| `case_sensitive` | If True, performs case-sensitive matching (default False) **TYPE:** `bool` **DEFAULT:** `False` |

| RETURNS       | DESCRIPTION                                           |
| ------------- | ----------------------------------------------------- |
| `DeviceGroup` | DeviceGroup containing devices in the specified group |

| RAISES     | DESCRIPTION              |
| ---------- | ------------------------ |
| `KeyError` | If group label not found |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
bedroom = await group.filter_by_group("Bedroom Lights")
await bedroom.set_color(Colors.WARM_WHITE)
```

Source code in `src/lifx/api.py`

````python
async def filter_by_group(
    self, label: str, case_sensitive: bool = False
) -> DeviceGroup:
    """Filter devices to a specific group.

    Args:
        label: Group label to filter by
        case_sensitive: If True, performs case-sensitive matching (default False)

    Returns:
        DeviceGroup containing devices in the specified group

    Raises:
        KeyError: If group label not found

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        bedroom = await group.filter_by_group("Bedroom Lights")
        await bedroom.set_color(Colors.WARM_WHITE)
        ```
    """
    groups = await self.organize_by_group(include_unassigned=False)

    # Find matching label
    if case_sensitive:
        if label not in groups:
            raise KeyError(f"Group '{label}' not found")
        return groups[label]
    else:
        label_lower = label.lower()
        for grp_label, device_group in groups.items():
            if grp_label.lower() == label_lower:
                return device_group
        raise KeyError(f"Group '{label}' not found")
````

##### get_unassigned_devices

```python
get_unassigned_devices(
    metadata_type: Literal["location", "group"] = "location",
) -> list[Device]
```

Get devices without location or group assigned.

| PARAMETER       | DESCRIPTION                                                                                                          |
| --------------- | -------------------------------------------------------------------------------------------------------------------- |
| `metadata_type` | Type of metadata to check ("location" or "group") **TYPE:** `Literal['location', 'group']` **DEFAULT:** `'location'` |

| RETURNS        | DESCRIPTION                                         |
| -------------- | --------------------------------------------------- |
| `list[Device]` | List of devices without the specified metadata type |

| RAISES         | DESCRIPTION                         |
| -------------- | ----------------------------------- |
| `RuntimeError` | If metadata hasn't been fetched yet |

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
await group.organize_by_location()
unassigned = group.get_unassigned_devices(metadata_type="location")
print(f"Found {len(unassigned)} devices without location")
```

Source code in `src/lifx/api.py`

````python
def get_unassigned_devices(
    self, metadata_type: Literal["location", "group"] = "location"
) -> list[Device]:
    """Get devices without location or group assigned.

    Args:
        metadata_type: Type of metadata to check ("location" or "group")

    Returns:
        List of devices without the specified metadata type

    Raises:
        RuntimeError: If metadata hasn't been fetched yet

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        await group.organize_by_location()
        unassigned = group.get_unassigned_devices(metadata_type="location")
        print(f"Found {len(unassigned)} devices without location")
        ```
    """
    if metadata_type == "location":
        if self._location_metadata is None:
            raise RuntimeError(
                "Location metadata not fetched. Call organize_by_location() first."
            )
        return [d for d in self._devices if not self._has_location(d)]
    else:
        if self._group_metadata is None:
            raise RuntimeError(
                "Group metadata not fetched. Call organize_by_group() first."
            )
        return [d for d in self._devices if not self._has_group(d)]
````

##### apply_theme

```python
apply_theme(
    theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None
```

Apply a theme to all devices in the group.

Each device applies the theme according to its capabilities:

- Light: Selects random color from theme
- MultiZoneLight: Distributes colors evenly across zones
- MatrixLight: Uses interpolation for smooth gradients
- Other devices: No action (themes only apply to color devices)

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                    |
| `power_on` | Turn on devices if True **TYPE:** `bool` **DEFAULT:** `False`       |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
from lifx.theme import get_theme

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)
evening = get_theme("evening")
await group.apply_theme(evening, power_on=True, duration=1.0)
```

Source code in `src/lifx/api.py`

````python
async def apply_theme(
    self, theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None:
    """Apply a theme to all devices in the group.

    Each device applies the theme according to its capabilities:
    - Light: Selects random color from theme
    - MultiZoneLight: Distributes colors evenly across zones
    - MatrixLight: Uses interpolation for smooth gradients
    - Other devices: No action (themes only apply to color devices)

    Args:
        theme: Theme to apply
        power_on: Turn on devices if True
        duration: Transition duration in seconds

    Example:
        ```python
        from lifx.theme import get_theme

        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        evening = get_theme("evening")
        await group.apply_theme(evening, power_on=True, duration=1.0)
        ```
    """
    async with asyncio.TaskGroup() as tg:
        # Apply theme to all lights
        for light in self.lights:
            tg.create_task(light.apply_theme(theme, power_on, duration))

        # Apply theme to all multizone lights
        for multizone in self.multizone_lights:
            tg.create_task(multizone.apply_theme(theme, power_on, duration))

        # Apply theme to all matrix light devices
        for matrix in self.matrix_lights:
            tg.create_task(matrix.apply_theme(theme, power_on, duration))
````

##### invalidate_metadata_cache

```python
invalidate_metadata_cache() -> None
```

Clear all cached location and group metadata.

Use this if you've changed device locations/groups and want to re-fetch.

Example

```python
devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

# First organization
by_location = await group.organize_by_location()

# ... change device locations ...

# Clear cache and re-organize
group.invalidate_metadata_cache()
by_location = await group.organize_by_location()
```

Source code in `src/lifx/api.py`

````python
def invalidate_metadata_cache(self) -> None:
    """Clear all cached location and group metadata.

    Use this if you've changed device locations/groups and want to re-fetch.

    Example:
        ```python
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)

        # First organization
        by_location = await group.organize_by_location()

        # ... change device locations ...

        # Clear cache and re-organize
        group.invalidate_metadata_cache()
        by_location = await group.organize_by_location()
        ```
    """
    self._locations_cache = None
    self._groups_cache = None
    self._location_metadata = None
    self._group_metadata = None
````

## Organizational Groupings

Dataclasses for organizing devices by location or group. Returned by `DeviceGroup.organize_by_location()` and `DeviceGroup.organize_by_group()`.

### LocationGrouping

Location-based device grouping returned by `DeviceGroup.organize_by_location()`.

#### LocationGrouping

```python
LocationGrouping(uuid: str, label: str, devices: list[Device], updated_at: int)
```

Organizational structure for location-based grouping.

| METHOD            | DESCRIPTION                                  |
| ----------------- | -------------------------------------------- |
| `to_device_group` | Convert to DeviceGroup for batch operations. |

##### Functions

###### to_device_group

```python
to_device_group() -> DeviceGroup
```

Convert to DeviceGroup for batch operations.

Source code in `src/lifx/api.py`

```python
def to_device_group(self) -> DeviceGroup:
    """Convert to DeviceGroup for batch operations."""
    return DeviceGroup(self.devices)
```

### GroupGrouping

Group-based device grouping returned by `DeviceGroup.organize_by_group()`.

#### GroupGrouping

```python
GroupGrouping(uuid: str, label: str, devices: list[Device], updated_at: int)
```

Organizational structure for group-based grouping.

| METHOD            | DESCRIPTION                                  |
| ----------------- | -------------------------------------------- |
| `to_device_group` | Convert to DeviceGroup for batch operations. |

##### Functions

###### to_device_group

```python
to_device_group() -> DeviceGroup
```

Convert to DeviceGroup for batch operations.

Source code in `src/lifx/api.py`

```python
def to_device_group(self) -> DeviceGroup:
    """Convert to DeviceGroup for batch operations."""
    return DeviceGroup(self.devices)
```

## Examples

### Simple Discovery

```python
from lifx import discover, DeviceGroup, Colors


async def main():
    count: int = 0
    async for device in discover():
        count += 1
        await device.set_power(True)
        await device.set_color(Colors.BLUE)

    print(f"Found {count} devices")
```

### Find by Serial Number

```python
from lifx import find_by_serial


async def main():
    # Find specific device by serial number
    device = await find_by_serial("d073d5123456")
    if device:
        async with device:
            await device.set_power(True)
```

### Find by Label

```python
from lifx import find_by_label, Colors


async def main():
    # Find all devices with "Living" in the label (substring match)
    async for device in find_by_label("Living"):  # May match "Living Room", "Living Area", etc.

        await device.set_power(True)

    # Find device with exact label match
    async for device in find_by_label("Living Room", exact_match=True):
        await device.set_color(Colors.WARM_WHITE)
        break  # exact_match returns at most one device
```

### Find by IP Address

```python
from lifx import find_by_ip


async def main():
    # Find device at specific IP address
    device = await find_by_ip("192.168.1.100")
    if device:
        async with device:
            await device.set_power(True)
```

# Themes API Reference

The theme system provides professionally-curated color palettes for coordinated lighting across LIFX devices.

## Theme Class

The `Theme` class represents a collection of HSBK colors forming a coordinated palette.

### Theme

```python
Theme(colors: list[HSBK] | None = None)
```

A collection of colors representing a theme or color palette.

Themes can be applied to LIFX devices to coordinate colors across multiple lights. Supports both single-zone and multi-zone devices.

| ATTRIBUTE | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `colors`  | List of HSBK colors in the theme **TYPE:** `list[HSBK]` |

Example

```python
# Create a theme with specific colors
theme = Theme(
    [
        HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500),  # Red
        HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500),  # Green
        HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500),  # Blue
    ]
)

# Access colors
for color in theme:
    print(f"Color: {color.hue}")

# Get a specific color
first_color = theme[0]

# Add more colors
theme.add_color(HSBK(hue=180, saturation=1.0, brightness=1.0, kelvin=3500))
```

| PARAMETER | DESCRIPTION                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| `colors`  | List of HSBK colors (defaults to white if None or empty) **TYPE:** \`list[HSBK] |

Example

```python
# Create from list of colors
theme = Theme([color1, color2, color3])

# Create with default white color
theme = Theme()
```

| METHOD                    | DESCRIPTION                                                 |
| ------------------------- | ----------------------------------------------------------- |
| `add_color`               | Add a color to the theme.                                   |
| `random`                  | Get a random color from the theme.                          |
| `shuffled`                | Get a new theme with colors in random order.                |
| `get_next_bounds_checked` | Get the next color after index or the last color if at end. |
| `ensure_color`            | Ensure the theme has at least one color.                    |
| `__len__`                 | Get the number of colors in the theme.                      |
| `__iter__`                | Iterate over colors in the theme.                           |
| `__getitem__`             | Get a color by index.                                       |
| `__contains__`            | Check if a color is in the theme.                           |
| `__repr__`                | Return a string representation of the theme.                |

Source code in `src/lifx/theme/theme.py`

````python
def __init__(self, colors: list[HSBK] | None = None) -> None:
    """Create a new theme with the given colors.

    Args:
        colors: List of HSBK colors (defaults to white if None or empty)

    Example:
        ```python
        # Create from list of colors
        theme = Theme([color1, color2, color3])

        # Create with default white color
        theme = Theme()
        ```
    """
    if colors and len(colors) > 0:
        self.colors: list[HSBK] = colors
    else:
        # Default to white if no colors provided
        self.colors = [Colors.WHITE_NEUTRAL]
````

#### Functions

##### add_color

```python
add_color(color: HSBK) -> None
```

Add a color to the theme.

| PARAMETER | DESCRIPTION                        |
| --------- | ---------------------------------- |
| `color`   | HSBK color to add **TYPE:** `HSBK` |

Example

```python
theme = Theme()
theme.add_color(HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500))
```

Source code in `src/lifx/theme/theme.py`

````python
def add_color(self, color: HSBK) -> None:
    """Add a color to the theme.

    Args:
        color: HSBK color to add

    Example:
        ```python
        theme = Theme()
        theme.add_color(HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500))
        ```
    """
    self.colors.append(color)
````

##### random

```python
random() -> HSBK
```

Get a random color from the theme.

| RETURNS | DESCRIPTION                        |
| ------- | ---------------------------------- |
| `HSBK`  | A random HSBK color from the theme |

Example

```python
theme = Theme([red, green, blue])
color = theme.random()
```

Source code in `src/lifx/theme/theme.py`

````python
def random(self) -> HSBK:
    """Get a random color from the theme.

    Returns:
        A random HSBK color from the theme

    Example:
        ```python
        theme = Theme([red, green, blue])
        color = theme.random()
        ```
    """
    return random.choice(self.colors)  # nosec
````

##### shuffled

```python
shuffled() -> Theme
```

Get a new theme with colors in random order.

| RETURNS | DESCRIPTION                             |
| ------- | --------------------------------------- |
| `Theme` | New Theme instance with shuffled colors |

Example

```python
theme = Theme([color1, color2, color3])
shuffled_theme = theme.shuffled()
```

Source code in `src/lifx/theme/theme.py`

````python
def shuffled(self) -> Theme:
    """Get a new theme with colors in random order.

    Returns:
        New Theme instance with shuffled colors

    Example:
        ```python
        theme = Theme([color1, color2, color3])
        shuffled_theme = theme.shuffled()
        ```
    """
    shuffled_colors = self.colors.copy()
    random.shuffle(shuffled_colors)
    return Theme(shuffled_colors)
````

##### get_next_bounds_checked

```python
get_next_bounds_checked(index: int) -> HSBK
```

Get the next color after index or the last color if at end.

| PARAMETER | DESCRIPTION                            |
| --------- | -------------------------------------- |
| `index`   | Index of current color **TYPE:** `int` |

| RETURNS | DESCRIPTION                                              |
| ------- | -------------------------------------------------------- |
| `HSBK`  | Next HSBK color or the last color if index is at the end |

Example

```python
theme = Theme([red, green, blue])
color = theme.get_next_bounds_checked(0)  # green
color = theme.get_next_bounds_checked(2)  # blue (last color)
```

Source code in `src/lifx/theme/theme.py`

````python
def get_next_bounds_checked(self, index: int) -> HSBK:
    """Get the next color after index or the last color if at end.

    Args:
        index: Index of current color

    Returns:
        Next HSBK color or the last color if index is at the end

    Example:
        ```python
        theme = Theme([red, green, blue])
        color = theme.get_next_bounds_checked(0)  # green
        color = theme.get_next_bounds_checked(2)  # blue (last color)
        ```
    """
    if index + 1 < len(self.colors):
        return self.colors[index + 1]
    return self.colors[-1]
````

##### ensure_color

```python
ensure_color() -> None
```

Ensure the theme has at least one color.

If the theme is empty, adds a default white color.

Source code in `src/lifx/theme/theme.py`

```python
def ensure_color(self) -> None:
    """Ensure the theme has at least one color.

    If the theme is empty, adds a default white color.
    """
    if not self.colors:
        self.colors.append(
            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=3500)
        )  # pragma: no cover
```

##### __len__

```python
__len__() -> int
```

Get the number of colors in the theme.

Source code in `src/lifx/theme/theme.py`

```python
def __len__(self) -> int:
    """Get the number of colors in the theme."""
    return len(self.colors)
```

##### __iter__

```python
__iter__() -> Iterator[HSBK]
```

Iterate over colors in the theme.

Source code in `src/lifx/theme/theme.py`

```python
def __iter__(self) -> Iterator[HSBK]:
    """Iterate over colors in the theme."""
    return iter(self.colors)
```

##### __getitem__

```python
__getitem__(index: int) -> HSBK
```

Get a color by index.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `index`   | Index of the color (0-based) **TYPE:** `int` |

| RETURNS | DESCRIPTION                   |
| ------- | ----------------------------- |
| `HSBK`  | HSBK color at the given index |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `IndexError` | If index is out of range |

Example

```python
theme = Theme([red, green, blue])
color = theme[1]  # green
```

Source code in `src/lifx/theme/theme.py`

````python
def __getitem__(self, index: int) -> HSBK:
    """Get a color by index.

    Args:
        index: Index of the color (0-based)

    Returns:
        HSBK color at the given index

    Raises:
        IndexError: If index is out of range

    Example:
        ```python
        theme = Theme([red, green, blue])
        color = theme[1]  # green
        ```
    """
    return self.colors[index]
````

##### __contains__

```python
__contains__(color: HSBK) -> bool
```

Check if a color is in the theme.

| PARAMETER | DESCRIPTION                          |
| --------- | ------------------------------------ |
| `color`   | HSBK color to check **TYPE:** `HSBK` |

| RETURNS | DESCRIPTION                                     |
| ------- | ----------------------------------------------- |
| `bool`  | True if color is in theme (by value comparison) |

Example

```python
theme = Theme([red, green, blue])
if red in theme:
    print("Red is in the theme")
```

Source code in `src/lifx/theme/theme.py`

````python
def __contains__(self, color: HSBK) -> bool:
    """Check if a color is in the theme.

    Args:
        color: HSBK color to check

    Returns:
        True if color is in theme (by value comparison)

    Example:
        ```python
        theme = Theme([red, green, blue])
        if red in theme:
            print("Red is in the theme")
        ```
    """
    return any(
        c.hue == color.hue
        and c.saturation == color.saturation
        and c.brightness == color.brightness
        and c.kelvin == color.kelvin
        for c in self.colors
    )
````

##### __repr__

```python
__repr__() -> str
```

Return a string representation of the theme.

Source code in `src/lifx/theme/theme.py`

```python
def __repr__(self) -> str:
    """Return a string representation of the theme."""
    color_count = len(self.colors)
    return f"Theme({color_count} colors)"
```

## ThemeLibrary Class

The `ThemeLibrary` provides access to 42 official LIFX app themes organized into 6 categories.

### ThemeLibrary

Collection of built-in color themes for LIFX devices.

Provides access to 60+ professionally designed themes organized by mood, season, occasion, and time of day.

Example

```python
# Get a specific theme
evening_theme = ThemeLibrary.get("evening")

# List all available themes
all_themes = ThemeLibrary.list()

# Get themes by category
seasonal = ThemeLibrary.get_by_category("seasonal")

# Apply to a light
await light.apply_theme(evening_theme, power_on=True)
```

| METHOD            | DESCRIPTION                     |
| ----------------- | ------------------------------- |
| `get`             | Get a theme by name.            |
| `list`            | List all available theme names. |
| `get_by_category` | Get all themes in a category.   |

#### Functions

##### get

```python
get(name: str) -> Theme
```

Get a theme by name.

| PARAMETER | DESCRIPTION                                   |
| --------- | --------------------------------------------- |
| `name`    | Theme name (case-insensitive) **TYPE:** `str` |

| RETURNS | DESCRIPTION  |
| ------- | ------------ |
| `Theme` | Theme object |

| RAISES     | DESCRIPTION                |
| ---------- | -------------------------- |
| `KeyError` | If theme name is not found |

Example

```python
from lifx.theme import ThemeLibrary

evening_theme = ThemeLibrary.get("evening")
await light.apply_theme(evening_theme, power_on=True)
```

Source code in `src/lifx/theme/library.py`

````python
@classmethod
def get(cls, name: str) -> Theme:
    """Get a theme by name.

    Args:
        name: Theme name (case-insensitive)

    Returns:
        Theme object

    Raises:
        KeyError: If theme name is not found

    Example:
        ```python
        from lifx.theme import ThemeLibrary

        evening_theme = ThemeLibrary.get("evening")
        await light.apply_theme(evening_theme, power_on=True)
        ```
    """
    normalized_name = name.lower()
    if normalized_name not in cls._THEMES:
        available = ", ".join(sorted(cls._THEMES.keys()))
        raise KeyError(f"Theme '{name}' not found. Available themes: {available}")
    return Theme(cls._THEMES[normalized_name])
````

##### list

```python
list() -> list[str]
```

List all available theme names.

| RETURNS     | DESCRIPTION                |
| ----------- | -------------------------- |
| `list[str]` | Sorted list of theme names |

Example

```python
from lifx.theme import ThemeLibrary

all_themes = ThemeLibrary.list()
for theme_name in all_themes:
    print(f"- {theme_name}")
```

Source code in `src/lifx/theme/library.py`

````python
@classmethod
def list(cls) -> list[str]:
    """List all available theme names.

    Returns:
        Sorted list of theme names

    Example:
        ```python
        from lifx.theme import ThemeLibrary

        all_themes = ThemeLibrary.list()
        for theme_name in all_themes:
            print(f"- {theme_name}")
        ```
    """
    return sorted(cls._THEMES.keys())
````

##### get_by_category

```python
get_by_category(category: str) -> dict[str, Theme]
```

Get all themes in a category.

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `category` | Category name (seasonal, mood, holiday, time, etc.) **TYPE:** `str` |

| RETURNS            | DESCRIPTION                                 |
| ------------------ | ------------------------------------------- |
| `dict[str, Theme]` | Dictionary of Theme objects in the category |

| RAISES       | DESCRIPTION                   |
| ------------ | ----------------------------- |
| `ValueError` | If category is not recognized |

Source code in `src/lifx/theme/library.py`

```python
@classmethod
def get_by_category(cls, category: str) -> dict[str, Theme]:
    """Get all themes in a category.

    Args:
        category: Category name (seasonal, mood, holiday, time, etc.)

    Returns:
        Dictionary of Theme objects in the category

    Raises:
        ValueError: If category is not recognized
    """
    category_lower = category.lower()

    categories = {
        "seasonal": [
            "spring",
            "autumn",
            "winter",
        ],
        "holiday": [
            "christmas",
            "halloween",
            "hanukkah",
            "kwanzaa",
            "shamrock",
            "thanksgiving",
            "calaveras",
            "pumpkin",
            "santa",
            "holly",
            "independence",
            "proud",
        ],
        "mood": [
            "peaceful",
            "serene",
            "relaxing",
            "mellow",
            "gentle",
            "soothing",
            "blissful",
            "cheerful",
            "romantic",
            "romance",
            "love",
            "energizing",
            "exciting",
            "epic",
            "intense",
            "powerful",
            "dramatic",
            "warming",
        ],
        "ambient": [
            "dream",
            "fantasy",
            "spacey",
            "stardust",
            "zombie",
            "party",
        ],
        "functional": [
            "focusing",
            "evening",
            "bias_lighting",
        ],
        "atmosphere": [
            "hygge",
            "tranquil",
            "sports",
        ],
    }

    if category_lower not in categories:
        available = ", ".join(sorted(categories.keys()))
        raise ValueError(
            f"Category '{category}' not recognized. "
            f"Available categories: {available}"
        )

    return {
        name: cls.get(name)
        for name in categories[category_lower]
        if name in cls._THEMES
    }
```

## Canvas Class

The `Canvas` class provides 2D sparse grid functionality for tile device color interpolation.

### Canvas

```python
Canvas()
```

A Canvas is a collection of points with methods for interacting with those points

The points are stored as (i, j) in a dictionary. The value for each point is an HSBK color.

| METHOD                | DESCRIPTION                                                                   |
| --------------------- | ----------------------------------------------------------------------------- |
| `add_points_for_tile` | Create points on the canvas around where a tile is.                           |
| `surrounding_colors`  | Return the colors that surround this (i, j) point.                            |
| `has_neighbour`       | Return whether there are any points around this (i, j) position.              |
| `shuffle_points`      | Take all the points and move them around a random amount.                     |
| `blur`                | For each point, find the average colour of that point plus all surrounding    |
| `blur_by_distance`    | Similar to blur but will find the 8 closest points as opposed to the 8        |
| `points_for_tile`     | Return a list of HSBK values for this tile.                                   |
| `fill_in_points`      | Fill in the gaps on this canvas by blurring the points on the provided canvas |
| `closest_points`      | Return [(distance, color), ...] for the closest consider amount of            |
| `__iter__`            | Yield ((i, j), color) pairs for all our points.                               |
| `__getitem__`         | Return the color at point where point is (i, j).                              |
| `__setitem__`         | Set the color at point where point is (i, j).                                 |
| `__contains__`        | Return whether this point has a color where point is (i, j).                  |
| `__repr__`            | Return string representation.                                                 |

Source code in `src/lifx/theme/canvas.py`

```python
def __init__(self) -> None:
    """Initialize the canvas."""
    self.points: dict[tuple[int, int], HSBK] = {}
```

#### Functions

##### add_points_for_tile

```python
add_points_for_tile(tile: tuple[int, int] | None, theme: Theme) -> None
```

Create points on the canvas around where a tile is.

We create an area that's half the tile width/height beyond the boundary of the tile. We also spread the points out in a random manner and try to avoid having points next to each other.

Multiple calls to this function will not override existing points on the canvas.

| PARAMETER | DESCRIPTION                                                                 |
| --------- | --------------------------------------------------------------------------- |
| `tile`    | Tile coordinates (x, y) or None for single tile **TYPE:** \`tuple[int, int] |
| `theme`   | Theme containing colors to distribute **TYPE:** `Theme`                     |

Source code in `src/lifx/theme/canvas.py`

```python
def add_points_for_tile(self, tile: tuple[int, int] | None, theme: Theme) -> None:
    """Create points on the canvas around where a tile is.

    We create an area that's half the tile width/height beyond the boundary
    of the tile. We also spread the points out in a random manner and try to avoid
    having points next to each other.

    Multiple calls to this function will not override existing points on the canvas.

    Args:
        tile: Tile coordinates (x, y) or None for single tile
        theme: Theme containing colors to distribute
    """
    tile_x, tile_y = tile if tile else (0, 0)
    tile_width = 8  # Standard tile width
    tile_height = 8  # Standard tile height

    from_x = int(tile_x - tile_width * 1.5)
    to_x = int(tile_x + tile_width * 1.5)
    from_y = int(tile_y - tile_height * 1.5)
    to_y = int(tile_y + tile_height * 1.5)

    i = from_x
    while i < to_x:
        j = from_y
        while j < to_y:
            if (i, j) not in self.points:
                if not self.has_neighbour(i, j):
                    random_color = theme.random()
                    self[(i, j)] = random_color
            j += random.choice([1, 2, 3])  # nosec
        i += random.choice([1, 2, 3])  # nosec
```

##### surrounding_colors

```python
surrounding_colors(i: int, j: int) -> list[HSBK]
```

Return the colors that surround this (i, j) point.

This will only return points that exist.

Source code in `src/lifx/theme/canvas.py`

```python
def surrounding_colors(self, i: int, j: int) -> list[HSBK]:
    """Return the colors that surround this (i, j) point.

    This will only return points that exist.
    """
    return [self[(x, y)] for x, y in surrounding_points(i, j) if (x, y) in self]
```

##### has_neighbour

```python
has_neighbour(i: int, j: int) -> bool
```

Return whether there are any points around this (i, j) position.

Source code in `src/lifx/theme/canvas.py`

```python
def has_neighbour(self, i: int, j: int) -> bool:
    """Return whether there are any points around this (i, j) position."""
    return any(self.surrounding_colors(i, j))
```

##### shuffle_points

```python
shuffle_points() -> None
```

Take all the points and move them around a random amount.

Source code in `src/lifx/theme/canvas.py`

```python
def shuffle_points(self) -> None:
    """Take all the points and move them around a random amount."""
    new_points = {}
    for (i, j), color in self:
        new_points[shuffle_point(i, j)] = color

    self.points = new_points
```

##### blur

```python
blur() -> None
```

For each point, find the average colour of that point plus all surrounding points.

Source code in `src/lifx/theme/canvas.py`

```python
def blur(self) -> None:
    """
    For each point, find the average colour of that point plus all surrounding
    points.
    """
    new_points = {}
    for (i, j), original in self:
        colors = [original for _ in range(2)]
        for color in self.surrounding_colors(i, j):
            colors.append(color)
        new_points[(i, j)] = HSBK.average(colors)
    self.points = new_points
```

##### blur_by_distance

```python
blur_by_distance() -> None
```

Similar to blur but will find the 8 closest points as opposed to the 8 surrounding points.

Source code in `src/lifx/theme/canvas.py`

```python
def blur_by_distance(self) -> None:
    """Similar to blur but will find the 8 closest points as opposed to the 8
    surrounding points."""
    new_points = {}
    for (i, j), _ in self:
        distances = self.closest_points(i, j, 8)
        weighted = list(color_weighting(distances))
        if weighted:
            new_points[(i, j)] = HSBK.average(weighted)
    self.points = new_points
```

##### points_for_tile

```python
points_for_tile(
    tile: tuple[int, int] | None, width: int = 8, height: int = 8
) -> list[HSBK]
```

Return a list of HSBK values for this tile.

For any point on the tile that doesn't have a corresponding point on the canvas return a grey value. This is useful for when we tell the applier to not fill in the gaps.

| PARAMETER | DESCRIPTION                                                                 |
| --------- | --------------------------------------------------------------------------- |
| `tile`    | Tile coordinates (x, y) or None for single tile **TYPE:** \`tuple[int, int] |
| `width`   | Grid width (typically 8) **TYPE:** `int` **DEFAULT:** `8`                   |
| `height`  | Grid height (typically 8) **TYPE:** `int` **DEFAULT:** `8`                  |

| RETURNS      | DESCRIPTION                            |
| ------------ | -------------------------------------- |
| `list[HSBK]` | List of HSBK colors in row-major order |

Source code in `src/lifx/theme/canvas.py`

```python
def points_for_tile(
    self, tile: tuple[int, int] | None, width: int = 8, height: int = 8
) -> list[HSBK]:
    """Return a list of HSBK values for this tile.

    For any point on the tile that doesn't have a corresponding point on the
    canvas return a grey value. This is useful for when we tell the applier
    to not fill in the gaps.

    Args:
        tile: Tile coordinates (x, y) or None for single tile
        width: Grid width (typically 8)
        height: Grid height (typically 8)

    Returns:
        List of HSBK colors in row-major order
    """
    tile_x, tile_y = tile if tile else (0, 0)
    result = []
    grey = HSBK(hue=0, saturation=0, brightness=0.3, kelvin=3500)

    for j in range(tile_y, tile_y + height):
        for i in range(tile_x, tile_x + width):
            if (i, j) in self.points:
                result.append(self.points[(i, j)])
            else:
                result.append(grey)

    return result
```

##### fill_in_points

```python
fill_in_points(
    canvas: Canvas, left_x: int, top_y: int, tile_width: int, tile_height: int
) -> None
```

Fill in the gaps on this canvas by blurring the points on the provided canvas

We blur by finding the 4 closest points for each point on our tile and averaging them.

| PARAMETER     | DESCRIPTION                                          |
| ------------- | ---------------------------------------------------- |
| `canvas`      | Source canvas to interpolate from **TYPE:** `Canvas` |
| `left_x`      | Left x coordinate of tile **TYPE:** `int`            |
| `top_y`       | Top y coordinate of tile **TYPE:** `int`             |
| `tile_width`  | Width of tile **TYPE:** `int`                        |
| `tile_height` | Height of tile **TYPE:** `int`                       |

Source code in `src/lifx/theme/canvas.py`

```python
def fill_in_points(
    self, canvas: Canvas, left_x: int, top_y: int, tile_width: int, tile_height: int
) -> None:
    """Fill in the gaps on this canvas by blurring the points on the provided canvas

    We blur by finding the 4 closest points for each point on our tile and
    averaging them.

    Args:
        canvas: Source canvas to interpolate from
        left_x: Left x coordinate of tile
        top_y: Top y coordinate of tile
        tile_width: Width of tile
        tile_height: Height of tile
    """
    for j in range(top_y, top_y + tile_height):
        for i in range(left_x, left_x + tile_width):
            distances = canvas.closest_points(i, j, 4)
            weighted = list(color_weighting(distances))
            if weighted:
                self[(i, j)] = HSBK.average(weighted)
```

##### closest_points

```python
closest_points(i: int, j: int, consider: int) -> list[tuple[int, HSBK]]
```

Return [(distance, color), ...] for the closest consider amount of points to (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def closest_points(self, i: int, j: int, consider: int) -> list[tuple[int, HSBK]]:
    """Return [(distance, color), ...] for the closest consider amount of
    points to (i, j)."""
    distances: list[tuple[int, HSBK]] = []

    for (x, y), color in self:
        distances.append(((x - i) ** 2 + (y - j) ** 2, color))

    def get_key(
        dc: tuple[int, HSBK],
    ) -> tuple[int, tuple[float, float, float, int]]:
        return (
            dc[0],
            (dc[1].hue, dc[1].saturation, dc[1].brightness, dc[1].kelvin),
        )

    distances = sorted(distances, key=get_key)
    return distances[:consider]
```

##### __iter__

```python
__iter__() -> Iterator[tuple[tuple[int, int], HSBK]]
```

Yield ((i, j), color) pairs for all our points.

Source code in `src/lifx/theme/canvas.py`

```python
def __iter__(self) -> Iterator[tuple[tuple[int, int], HSBK]]:
    """Yield ((i, j), color) pairs for all our points."""
    yield from self.points.items()
```

##### __getitem__

```python
__getitem__(point: tuple[int, int]) -> HSBK
```

Return the color at point where point is (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def __getitem__(self, point: tuple[int, int]) -> HSBK:
    """Return the color at point where point is (i, j)."""
    return self.points[point]
```

##### __setitem__

```python
__setitem__(key: tuple[int, int], color: HSBK) -> None
```

Set the color at point where point is (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def __setitem__(self, key: tuple[int, int], color: HSBK) -> None:
    """Set the color at point where point is (i, j)."""
    self.points[key] = color
```

##### __contains__

```python
__contains__(point: tuple[int, int]) -> bool
```

Return whether this point has a color where point is (i, j).

Source code in `src/lifx/theme/canvas.py`

```python
def __contains__(self, point: tuple[int, int]) -> bool:
    """Return whether this point has a color where point is (i, j)."""
    return point in self.points
```

##### __repr__

```python
__repr__() -> str
```

Return string representation.

Source code in `src/lifx/theme/canvas.py`

```python
def __repr__(self) -> str:
    """Return string representation."""
    return f"Canvas({len(self.points)} points)"
```

## Convenience Function

### get_theme

```python
get_theme(name: str) -> Theme
```

Get a theme by name.

Convenience function equivalent to ThemeLibrary.get(name).

| PARAMETER | DESCRIPTION                                   |
| --------- | --------------------------------------------- |
| `name`    | Theme name (case-insensitive) **TYPE:** `str` |

| RETURNS | DESCRIPTION  |
| ------- | ------------ |
| `Theme` | Theme object |

Example

```python
from lifx.theme import get_theme

evening = get_theme("evening")
await light.apply_theme(evening, power_on=True)
```

Source code in `src/lifx/theme/library.py`

````python
def get_theme(name: str) -> Theme:
    """Get a theme by name.

    Convenience function equivalent to ThemeLibrary.get(name).

    Args:
        name: Theme name (case-insensitive)

    Returns:
        Theme object

    Example:
        ```python
        from lifx.theme import get_theme

        evening = get_theme("evening")
        await light.apply_theme(evening, power_on=True)
        ```
    """
    return ThemeLibrary.get(name)
````

## Available Themes (42 Total)

### Seasonal (3 themes)

- spring, autumn, winter

### Holiday (9 themes)

- christmas, halloween, hanukkah, kwanzaa, shamrock, thanksgiving, calaveras, pumpkin, santa

### Mood (16 themes)

- peaceful, serene, relaxing, mellow, gentle, soothing, blissful, cheerful, romantic, romance, love, energizing, exciting, epic, intense, powerful, warming

### Ambient (6 themes)

- dream, fantasy, spacey, stardust, zombie, party

### Functional (3 themes)

- focusing, evening, bias_lighting

### Atmosphere (3 themes)

- hygge, tranquil, sports

# Effects Reference

This reference guide provides comprehensive documentation for all built-in effect classes in the Light Effects Framework.

## Table of Contents

- [Conductor](#conductor)
- [EffectPulse](#effectpulse)
- [EffectColorloop](#effectcolorloop)
- [LIFXEffect (Base Class)](#lifxeffect-base-class)

## Conductor

The `Conductor` class is the central orchestrator for managing light effects across multiple devices.

### Class Definition

```python
from lifx import Conductor

conductor = Conductor()
```

### Methods

#### `effect(light: Light) -> LIFXEffect | None`

Return the effect currently running on a device, or None if idle.

**Parameters:**

- `light` (Light): The device to check

**Returns:**

- `LIFXEffect | None`: Currently running effect instance, or None

**Example:**

```python
current_effect = conductor.effect(light)
if current_effect:
    print(f"Running: {type(current_effect).__name__}")
else:
    print("No effect running")
```

#### `start(effect: LIFXEffect, participants: list[Light]) -> None`

Start an effect on one or more lights.

Captures current light state, powers on if needed, and launches the effect. State is automatically restored when effect completes or `stop()` is called.

**Parameters:**

- `effect` (LIFXEffect): The effect instance to execute
- `participants` (list[Light]): List of Light instances to apply effect to

**Raises:**

- `LifxTimeoutError`: If light state capture times out
- `LifxDeviceNotFoundError`: If light becomes unreachable

**Example:**

```python
effect = EffectPulse(mode='blink', cycles=5)
await conductor.start(effect, [light1, light2])
```

#### `stop(lights: list[Light]) -> None`

Stop effects and restore light state.

Halts any running effects on the specified lights and restores them to their pre-effect state (power, color, zones).

**Parameters:**

- `lights` (list[Light]): List of lights to stop

**Example:**

```python
# Stop specific lights
await conductor.stop([light1, light2])

# Stop all lights in a group
await conductor.stop(group.lights)
```

### State Management

The conductor automatically handles:

1. **State Capture**: Power state, current color (HSBK), and multizone colors (if applicable)
1. **Power Management**: Powers on devices if needed for effect visibility
1. **Effect Execution**: Runs effect logic on all participants
1. **State Restoration**: Restores all captured state after effect completes

### Timing Considerations

- State capture: \<1 second per device (mostly network I/O)
- State restoration: 0.6-1.0 seconds per device (includes required 0.3s delays)
- All operations use concurrent execution for multiple devices

______________________________________________________________________

## EffectPulse

Pulse/blink/breathe effects using LIFX waveform modes. Supports five distinct modes with configurable timing and colors.

### Class Definition

```python
from lifx import EffectPulse, HSBK

effect = EffectPulse(
    power_on=True,
    mode='blink',
    period=None,
    cycles=None,
    hsbk=None
)
```

### Parameters

#### `power_on` (bool, default: `True`)

Whether to power on devices during effect. If `True`, devices that are off will be powered on before the effect starts.

#### `mode` (str, default: `'blink'`)

Pulse mode to use. Must be one of:

- `'blink'`: Standard on/off toggle
- `'strobe'`: Rapid flashing
- `'breathe'`: Smooth breathing effect
- `'ping'`: Single pulse with asymmetric duty cycle
- `'solid'`: Minimal brightness variation

#### `period` (float | None, default: mode-dependent)

Effect period in seconds. If not specified, uses mode default:

- `'strobe'`: 0.1 seconds
- All others: 1.0 second

#### `cycles` (int | None, default: mode-dependent)

Number of cycles to execute. If not specified, uses mode default:

- `'strobe'`: 10 cycles
- All others: 1 cycle

#### `hsbk` (HSBK | None, default: `None`)

Optional color override. If provided, this color is used instead of automatic color selection. If `None`, the effect intelligently selects colors based on mode and device capabilities.

### Pulse Modes

#### Blink Mode

Standard on/off toggle effect.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: PULSE
- Behavior: Toggles between current color and off

**Example:**

```python
# Basic blink - 5 cycles
effect = EffectPulse(mode='blink', cycles=5)
await conductor.start(effect, lights)
await asyncio.sleep(6)  # 5 cycles * 1s + buffer
```

**Best for:** Notifications, alerts, attention-getting

#### Strobe Mode

Rapid flashing effect.

**Defaults:**

- Period: 0.1 second
- Cycles: 10
- Waveform: PULSE
- Behavior: Rapid flashing from dark (cold white)

**Example:**

```python
# Rapid strobe - 20 flashes
effect = EffectPulse(mode='strobe', cycles=20)
await conductor.start(effect, lights)
await asyncio.sleep(3)  # 20 * 0.1s + buffer
```

**Best for:** Emergency notifications, dramatic effects

**Note:** Strobe mode starts from dark (0 brightness, cold white) for maximum impact.

#### Breathe Mode

Smooth, gentle breathing effect using SINE waveform.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: SINE (smooth)
- Behavior: Smooth fade in and out

**Example:**

```python
# Slow breathing effect
effect = EffectPulse(mode='breathe', period=2.0, cycles=5)
await conductor.start(effect, lights)
await asyncio.sleep(11)  # 5 * 2s + buffer
```

**Best for:** Relaxation, meditation, ambient effects

#### Ping Mode

Single pulse with asymmetric duty cycle.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: PULSE
- Skew: 0.1 (10% on, 90% off)
- Behavior: Quick flash followed by longer off period

**Example:**

```python
# Quick ping notification
red = HSBK.from_rgb(255, 0, 0)
effect = EffectPulse(mode='ping', color=red)
await conductor.start(effect, lights)
await asyncio.sleep(2)
```

**Best for:** Quick notifications, heartbeat effects

#### Solid Mode

Minimal brightness variation, almost solid color.

**Defaults:**

- Period: 1.0 second
- Cycles: 1
- Waveform: PULSE
- Skew: 0.0 (minimum variation)
- Behavior: Very subtle brightness change

**Example:**

```python
# Subtle solid pulse
green = HSBK.from_rgb(0, 255, 0)
effect = EffectPulse(mode='solid', period=3.0, cycles=2, color=green)
await conductor.start(effect, lights)
await asyncio.sleep(7)
```

**Best for:** Subtle ambient effects, status indicators

### Color Selection

#### With `color` Parameter

When you provide a `color` parameter, that exact color is used:

```python
# Always use red
red = HSBK.from_rgb(255, 0, 0)
effect = EffectPulse(mode='blink', color=red)
```

#### Without `color` Parameter (Automatic)

The effect intelligently selects colors based on mode and device:

- **Strobe mode**: Starts from dark (cold white, 0 brightness)
- **Other modes**: Preserves current device color
- **Color devices**: Full HSBK color used
- **Monochrome devices**: Brightness toggled, kelvin preserved

### Device Type Behavior

#### Color Lights

All modes work as expected with full color support.

#### Multizone Lights

Pulse effects apply to entire device, not individual zones. All zones pulse together.

#### Tile Devices

Pulse effects apply to all tiles uniformly.

#### Monochrome/White Lights

Effects adapt to brightness changes only:

- Color components are ignored
- Brightness is toggled or faded
- Kelvin temperature is preserved

### Examples

#### Custom Color Pulse

```python
from lifx import HSBK

# Purple breathe effect
purple = HSBK.from_rgb(128, 0, 128)
effect = EffectPulse(
    mode='breathe',
    period=2.0,
    cycles=3,
    hsbk=purple
)
await conductor.start(effect, lights)
await asyncio.sleep(7)
```

#### Emergency Alert

```python
# Rapid red strobe
red = HSBK.from_rgb(255, 0, 0)
effect = EffectPulse(
    mode='strobe',
    period=0.1,
    cycles=30,
    hsbk=red
)
await conductor.start(effect, lights)
await asyncio.sleep(4)
```

#### Meditation Breathing

```python
# Slow blue breathing
blue = HSBK.from_rgb(0, 50, 200)
effect = EffectPulse(
    mode='breathe',
    period=4.0,  # 4 second cycle
    cycles=10,
    hsbk=blue
)
await conductor.start(effect, lights)
await asyncio.sleep(42)  # 10 * 4s + buffer
```

### Performance Notes

- Effect starts within 100ms
- Duration is precisely `period * cycles`
- State restoration adds 0.6-1.0 seconds after completion
- Multiple devices execute concurrently

______________________________________________________________________

## EffectColorloop

Continuous color rotation effect cycling through the hue spectrum. Runs indefinitely until manually stopped.

### Class Definition

```python
from lifx import EffectColorloop

effect = EffectColorloop(
    power_on=True,
    period=60,
    change=20,
    spread=30,
    brightness=None,
    saturation_min=0.8,
    saturation_max=1.0,
    transition=None
)
```

### Parameters

#### `power_on` (bool, default: `True`)

Whether to power on devices if they're off.

#### `period` (float, default: `60`)

Seconds per full 360-degree hue cycle. Lower values = faster color changes.

**Range:** Must be positive

**Examples:**

- `period=60`: One full rainbow per minute (slow)
- `period=30`: Two full rainbows per minute (medium)
- `period=15`: Four full rainbows per minute (fast)

#### `change` (float, default: `20`)

Hue degrees to shift per iteration. Larger values = larger color jumps.

**Range:** 0-360 degrees

**Examples:**

- `change=10`: Small, smooth color transitions
- `change=20`: Medium color steps (default)
- `change=45`: Large, dramatic color jumps

**Calculation:** iterations_per_cycle = 360 / change

#### `spread` (float, default: `30`)

Hue degrees spread across devices. Creates rainbow effect across multiple lights.

**Range:** 0-360 degrees

**Examples:**

- `spread=0`: All lights same color
- `spread=30`: Slight color variation (default)
- `spread=60`: Rainbow spread across devices
- `spread=120`: Wide spectrum spread

#### `brightness` (float | None, default: `None`)

Fixed brightness level. If `None`, preserves current brightness for each device.

**Range:** 0.0-1.0

**Examples:**

- `brightness=None`: Keeps original brightness (default)
- `brightness=0.5`: Locks to 50% brightness
- `brightness=1.0`: Full brightness

#### `saturation_min` (float, default: `0.8`)

Minimum saturation for random saturation selection.

**Range:** 0.0-1.0

Must be  `saturation_max`

#### `saturation_max` (float, default: `1.0`)

Maximum saturation for random saturation selection.

**Range:** 0.0-1.0

Must be  `saturation_min`

**Note:** Each iteration randomly selects saturation within this range.

#### `transition` (float | None, default: `None`)

Color transition time in seconds. If `None`, uses random transition time per device.

**Range:** Non-negative

**Examples:**

- `transition=None`: Random transitions (0 to 2x iteration period)
- `transition=0.5`: Quick 0.5-second transitions
- `transition=2.0`: Slow 2-second transitions

### Behavior

#### Continuous Operation

ColorLoop effects run **indefinitely** until explicitly stopped:

```python
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)

# Runs forever until you call:
await conductor.stop(lights)
```

#### Random Elements

For visual variety, ColorLoop randomizes:

1. **Initial direction**: Forward or backward through hue spectrum
1. **Device order**: Shuffled each cycle
1. **Saturation**: Random value between saturation_min and saturation_max
1. **Transition time**: Random if `transition=None`

#### Hue Calculation

For each device at each iteration:

```python
new_hue = (base_hue + iteration_offset + device_spread_offset) % 360

# Where:
# - base_hue: Initial hue when effect started
# - iteration_offset: iteration * change * direction
# - device_spread_offset: device_index * spread
```

### Device Type Behavior

#### Color Lights

Full color cycling with all parameters supported.

#### Multizone Lights

Entire device cycles as one unit (all zones same color at each iteration).

#### Tile Devices

All tiles cycle together with same color.

#### Monochrome/White Lights

- Hue changes are ignored (monochrome devices can't display colors)
- Brightness and saturation parameters are ignored
- Effect still runs but with no visible changes
- **Recommendation**: Don't use ColorLoop on monochrome devices

### Examples

#### Classic Rainbow

```python
# Slow rainbow across multiple lights
effect = EffectColorloop(
    period=60,      # Full rainbow per minute
    change=20,      # Smooth color steps
    spread=60       # Spread colors across devices
)
await conductor.start(effect, lights)
await asyncio.sleep(120)  # Run for 2 minutes
await conductor.stop(lights)
```

#### Fast Party Mode

```python
# Fast, dramatic color changes
effect = EffectColorloop(
    period=15,          # Fast rotation
    change=45,          # Large color jumps
    spread=120,         # Wide spread
    brightness=0.8,     # Fixed brightness
    saturation_min=0.9, # High saturation only
    transition=0.5      # Quick transitions
)
await conductor.start(effect, lights)
await asyncio.sleep(60)
await conductor.stop(lights)
```

#### Ambient Pastels

```python
# Subtle pastel color cycling
effect = EffectColorloop(
    period=90,          # Very slow
    change=15,          # Small steps
    spread=30,          # Slight variation
    brightness=0.4,     # Dim
    saturation_min=0.3, # Low saturation (pastels)
    saturation_max=0.6,
    transition=3.0      # Very slow transitions
)
await conductor.start(effect, lights)
# Let it run indefinitely
```

### Stopping ColorLoop

Always explicitly stop ColorLoop effects:

```python
# Start effect
effect = EffectColorloop(period=30)
await conductor.start(effect, lights)

# Do other things...
await asyncio.sleep(60)

# Must stop manually
await conductor.stop(lights)
```

The `conductor.stop()` call will:

1. Signal the effect to stop
1. Wait for current iteration to complete
1. Restore all lights to pre-effect state (power, color, zones)

### Prestate Inheritance

ColorLoop effects support state inheritance optimization. If you start a ColorLoop while another ColorLoop is already running, the new effect inherits the existing prestate instead of resetting:

```python
# Start first colorloop
effect1 = EffectColorloop(period=30, change=20)
await conductor.start(effect1, lights)
await asyncio.sleep(10)

# Switch to different colorloop - no reset, seamless transition
effect2 = EffectColorloop(period=20, change=30)
await conductor.start(effect2, lights)  # Inherits state, no flash
```

This prevents the lights from briefly returning to their original state between consecutive ColorLoop effects.

### Performance Notes

- Iteration period: `period / (360 / change)`
- State capture: \<1 second per device
- Effect startup: \<100ms
- Multiple devices update concurrently
- No cycle limit - runs until stopped

______________________________________________________________________

## LIFXEffect (Base Class)

Abstract base class for all light effects. Subclass this to create custom effects.

### Class Definition

```python
from lifx import LIFXEffect

class MyEffect(LIFXEffect):
    def __init__(self, power_on: bool = True):
        super().__init__(power_on=power_on)

    async def async_play(self) -> None:
        # Custom effect logic here
        pass
```

### Attributes

#### `power_on` (bool)

Whether to power on devices during effect.

#### `conductor` (Conductor | None)

Reference to the conductor managing this effect. Set automatically by conductor.

#### `participants` (list[Light])

List of lights participating in the effect. Set automatically by conductor.

### Methods

#### `async_perform(participants: list[Light]) -> None`

Perform common setup and play the effect. Called by conductor.

**Do not override this method.** Override `async_play()` instead.

#### `async_play() -> None` (abstract)

Play the effect logic. **Override this in subclasses.**

This is where you implement your custom effect behavior.

**Example:**

```python
async def async_play(self) -> None:
    # Flash all lights 3 times
    for _ in range(3):
        await asyncio.gather(*[
            light.set_brightness(1.0) for light in self.participants
        ])
        await asyncio.sleep(0.3)
        await asyncio.gather(*[
            light.set_brightness(0.0) for light in self.participants
        ])
        await asyncio.sleep(0.3)

    # Restore via conductor
    if self.conductor:
        await self.conductor.stop(self.participants)
```

#### `from_poweroff_hsbk(light: Light) -> HSBK`

Return startup color when light is powered off.

**Override this** to customize the color used when powering on a light.

**Default behavior:** Returns random hue, full saturation, zero brightness, neutral white.

**Example:**

```python
async def from_poweroff_hsbk(self, light: Light) -> HSBK:
    # Always start with red
    return HSBK.from_rgb(255, 0, 0, kelvin=KELVIN_NEUTRAL)
```

#### `inherit_prestate(other: LIFXEffect) -> bool`

Whether this effect can skip device state restoration.

**Override this** if your effect can run without resetting when following certain other effects.

**Default behavior:** Returns `False` (always reset)

**Example:**

```python
def inherit_prestate(self, other: LIFXEffect) -> bool:
    # Can inherit from same effect type
    return type(self) == type(other)
```

### Creating Custom Effects

See the [Custom Effects Guide](https://djelibeybi.github.io/lifx-async/user-guide/effects-custom/index.md) for detailed instructions on creating your own effects.

______________________________________________________________________

## See Also

- [Getting Started](https://djelibeybi.github.io/lifx-async/getting-started/effects/index.md) - Basic usage and common patterns
- [Custom Effects](https://djelibeybi.github.io/lifx-async/user-guide/effects-custom/index.md) - Creating your own effects
- [Architecture](https://djelibeybi.github.io/lifx-async/architecture/effects-architecture/index.md) - How the system works
- [Troubleshooting](https://djelibeybi.github.io/lifx-async/user-guide/effects-troubleshooting/index.md) - Common issues and solutions

# Color Utilities

lifx-async provides comprehensive color utilities for working with LIFX's HSBK color model and converting to/from RGB.

## HSBK Class

The `HSBK` class represents colors in the Hue, Saturation, Brightness, Kelvin color model used by LIFX devices.

### HSBK

```python
HSBK(hue: int, saturation: float, brightness: float, kelvin: int)
```

User-friendly HSBK color representation.

LIFX devices use HSBK (Hue, Saturation, Brightness, Kelvin) color space. This class provides a convenient interface with normalized values and conversion to/from RGB.

| ATTRIBUTE    | DESCRIPTION                                                                           |
| ------------ | ------------------------------------------------------------------------------------- |
| `hue`        | Hue value in degrees (0-360) **TYPE:** `int`                                          |
| `saturation` | Saturation (0.0-1.0, where 0 is white and 1 is fully saturated) **TYPE:** `float`     |
| `brightness` | Brightness (0.0-1.0, where 0 is off and 1 is full brightness) **TYPE:** `float`       |
| `kelvin`     | Color temperature in Kelvin (1500-9000, typically 2500-9000 for LIFX) **TYPE:** `int` |

Example

```python
# Create a red color
red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)

# Create from RGB
purple = HSBK.from_rgb(128, 0, 128)

# Convert to RGB
r, g, b = purple.to_rgb()
```

| METHOD              | DESCRIPTION                                                           |
| ------------------- | --------------------------------------------------------------------- |
| `__eq__`            | Two colors are equal if they have the same HSBK values.               |
| `__hash__`          | Returns a hash of this color as an integer.                           |
| `__str__`           | Return a string representation of the HSBK values for this color.     |
| `__repr__`          | Return a string representation of the HSBK values for this color.     |
| `from_rgb`          | Create HSBK from RGB values.                                          |
| `to_rgb`            | Convert HSBK to RGB values.                                           |
| `to_protocol`       | Convert to protocol HSBK for packet serialization.                    |
| `from_protocol`     | Create HSBK from protocol HSBK.                                       |
| `with_hue`          | Create a new HSBK with modified hue.                                  |
| `with_saturation`   | Create a new HSBK with modified saturation.                           |
| `with_brightness`   | Create a new HSBK with modified brightness.                           |
| `with_kelvin`       | Create a new HSBK with modified color temperature.                    |
| `clone`             | Create a copy of this color.                                          |
| `as_tuple`          | Return HSBK values as a tuple of protocol uint16 values.              |
| `as_dict`           | Return HSBK values as a dictionary of user-friendly values.           |
| `limit_distance_to` | Return a new color with hue limited to 90 degrees from another color. |
| `average`           | Calculate the average color of a list of HSBK colors.                 |

Source code in `src/lifx/color.py`

```python
def __init__(
    self, hue: int, saturation: float, brightness: float, kelvin: int
) -> None:
    """Instantiate a color using hue, saturation, brightness and kelvin."""

    validate_hue(hue)
    validate_saturation(saturation)
    validate_brightness(brightness)
    validate_kelvin(kelvin)

    self._hue = hue
    self._saturation = saturation
    self._brightness = brightness
    self._kelvin = kelvin
```

#### Attributes

##### hue

```python
hue: int
```

Return hue.

##### saturation

```python
saturation: float
```

Return saturation.

##### brightness

```python
brightness: float
```

Return brightness.

##### kelvin

```python
kelvin: int
```

Return kelvin.

#### Functions

##### __eq__

```python
__eq__(other: object) -> bool
```

Two colors are equal if they have the same HSBK values.

Source code in `src/lifx/color.py`

```python
def __eq__(self, other: object) -> bool:
    """Two colors are equal if they have the same HSBK values."""
    if not isinstance(other, HSBK):  # pragma: no cover
        return NotImplemented
    return (
        other.hue == self.hue
        and other.saturation == self.saturation
        and other.brightness == self.brightness
        and other.kelvin == self.kelvin
    )
```

##### __hash__

```python
__hash__() -> int
```

Returns a hash of this color as an integer.

Source code in `src/lifx/color.py`

```python
def __hash__(self) -> int:
    """Returns a hash of this color as an integer."""
    return hash(
        (self.hue, self.saturation, self.brightness, self.kelvin)
    )  # pragma: no cover
```

##### __str__

```python
__str__() -> str
```

Return a string representation of the HSBK values for this color.

Source code in `src/lifx/color.py`

```python
def __str__(self) -> str:
    """Return a string representation of the HSBK values for this color."""
    string = (
        f"Hue: {self.hue}, Saturation: {self.saturation:.4f}, "
        f"Brightness: {self.brightness:.4f}, Kelvin: {self.kelvin}"
    )
    return string
```

##### __repr__

```python
__repr__() -> str
```

Return a string representation of the HSBK values for this color.

Source code in `src/lifx/color.py`

```python
def __repr__(self) -> str:
    """Return a string representation of the HSBK values for this color."""
    repr = (
        f"HSBK(hue={self.hue}, saturation={self.saturation:.2f}, "
        f"brightness={self.brightness:.2f}, kelvin={self.kelvin})"
    )
    return repr
```

##### from_rgb

```python
from_rgb(red: int, green: int, blue: int) -> HSBK
```

Create HSBK from RGB values.

| PARAMETER | DESCRIPTION                             |
| --------- | --------------------------------------- |
| `red`     | Red component (0-255) **TYPE:** `int`   |
| `green`   | Green component (0-255) **TYPE:** `int` |
| `blue`    | Blue component (0-255) **TYPE:** `int`  |

| RETURNS | DESCRIPTION   |
| ------- | ------------- |
| `HSBK`  | HSBK instance |

| RAISES       | DESCRIPTION                            |
| ------------ | -------------------------------------- |
| `ValueError` | If RGB values are out of range (0-255) |

Example

```python
# Pure red
red = HSBK.from_rgb(255, 0, 0)

# Purple with warm white
purple = HSBK.from_rgb(128, 0, 128, kelvin=2500)
```

Source code in `src/lifx/color.py`

````python
@classmethod
def from_rgb(cls, red: int, green: int, blue: int) -> HSBK:
    """Create HSBK from RGB values.

    Args:
        red: Red component (0-255)
        green: Green component (0-255)
        blue: Blue component (0-255)

    Returns:
        HSBK instance

    Raises:
        ValueError: If RGB values are out of range (0-255)

    Example:
        ```python
        # Pure red
        red = HSBK.from_rgb(255, 0, 0)

        # Purple with warm white
        purple = HSBK.from_rgb(128, 0, 128, kelvin=2500)
        ```
    """

    def _validate_rgb_component(value: int, name: str) -> None:
        if not (0 <= value <= 255):
            raise ValueError(f"{name} must be between 0 and 255, got {value}")

    _validate_rgb_component(red, "Red")
    _validate_rgb_component(green, "Green")
    _validate_rgb_component(blue, "Blue")

    # Normalize to 0-1
    red_norm = red / 255
    green_norm = green / 255
    blue_norm = blue / 255

    # Convert to HSV using colorsys
    h, s, v = colorsys.rgb_to_hsv(red_norm, green_norm, blue_norm)

    # Convert to LIFX ranges
    hue = round(h * 360)  # 0-1 -> 0-360
    saturation = round(s, 2)  # Already 0-1
    brightness = round(v, 2)  # Already 0-1

    return cls(
        hue=hue,
        saturation=saturation,
        brightness=brightness,
        kelvin=KELVIN_NEUTRAL,
    )
````

##### to_rgb

```python
to_rgb() -> tuple[int, int, int]
```

Convert HSBK to RGB values.

Color temperature (kelvin) is not considered in this conversion, as it only affects the white point of the device.

| RETURNS                | DESCRIPTION                                   |
| ---------------------- | --------------------------------------------- |
| `tuple[int, int, int]` | Tuple of (red, green, blue) with values 0-255 |

Example

```python
color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
r, g, b = color.to_rgb()  # Returns (0, 255, 0) - green
```

Source code in `src/lifx/color.py`

````python
def to_rgb(self) -> tuple[int, int, int]:
    """Convert HSBK to RGB values.

    Color temperature (kelvin) is not considered in this conversion,
    as it only affects the white point of the device.

    Returns:
        Tuple of (red, green, blue) with values 0-255

    Example:
        ```python
        color = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
        r, g, b = color.to_rgb()  # Returns (0, 255, 0) - green
        ```
    """
    # Convert to colorsys ranges
    h = self._hue / 360  # 0-360 -> 0-1
    s = self._saturation  # Already 0-1
    v = self._brightness  # Already 0-1

    # Convert using colorsys
    red_norm, green_norm, blue_norm = colorsys.hsv_to_rgb(h, s, v)

    # Scale to 0-255 and round
    red = int(round(red_norm * 255))
    green = int(round(green_norm * 255))
    blue = int(round(blue_norm * 255))

    return red, green, blue
````

##### to_protocol

```python
to_protocol() -> LightHsbk
```

Convert to protocol HSBK for packet serialization.

LIFX protocol uses uint16 values for all HSBK components:

- Hue: 0-65535 (represents 0-360 degrees)
- Saturation: 0-65535 (represents 0-100%)
- Brightness: 0-65535 (represents 0-100%)
- Kelvin: Direct value in Kelvin

| RETURNS     | DESCRIPTION                                 |
| ----------- | ------------------------------------------- |
| `LightHsbk` | LightHsbk instance for packet serialization |

Example

```python
color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
protocol_color = color.to_protocol()
# Use in packet: LightSetColor(color=protocol_color, ...)
```

Source code in `src/lifx/color.py`

````python
def to_protocol(self) -> LightHsbk:
    """Convert to protocol HSBK for packet serialization.

    LIFX protocol uses uint16 values for all HSBK components:
    - Hue: 0-65535 (represents 0-360 degrees)
    - Saturation: 0-65535 (represents 0-100%)
    - Brightness: 0-65535 (represents 0-100%)
    - Kelvin: Direct value in Kelvin

    Returns:
        LightHsbk instance for packet serialization

    Example:
        ```python
        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
        protocol_color = color.to_protocol()
        # Use in packet: LightSetColor(color=protocol_color, ...)
        ```
    """
    hue_u16 = int(round(0x10000 * self._hue) / 360) % 0x10000
    saturation_u16 = int(round(0xFFFF * self._saturation))
    brightness_u16 = int(round(0xFFFF * self._brightness))

    return LightHsbk(
        hue=hue_u16,
        saturation=saturation_u16,
        brightness=brightness_u16,
        kelvin=self._kelvin,
    )
````

##### from_protocol

```python
from_protocol(protocol: LightHsbk) -> HSBK
```

Create HSBK from protocol HSBK.

| PARAMETER  | DESCRIPTION                                                          |
| ---------- | -------------------------------------------------------------------- |
| `protocol` | LightHsbk instance from packet deserialization **TYPE:** `LightHsbk` |

| RETURNS | DESCRIPTION                 |
| ------- | --------------------------- |
| `HSBK`  | User-friendly HSBK instance |

Example

```python
# After receiving LightState packet
state = await device.get_state()
color = HSBK.from_protocol(state.color)
print(f"Hue: {color.hue}, Brightness: {color.brightness * 100}%")
```

Source code in `src/lifx/color.py`

````python
@classmethod
def from_protocol(cls, protocol: LightHsbk) -> HSBK:
    """Create HSBK from protocol HSBK.

    Args:
        protocol: LightHsbk instance from packet deserialization

    Returns:
        User-friendly HSBK instance

    Example:
        ```python
        # After receiving LightState packet
        state = await device.get_state()
        color = HSBK.from_protocol(state.color)
        print(f"Hue: {color.hue}, Brightness: {color.brightness * 100}%")
        ```
    """
    # Convert from uint16 ranges to user-friendly ranges
    hue = round(float(protocol.hue) * 360 / 0x10000)
    saturation = round(float(protocol.saturation) / 0xFFFF, 2)
    brightness = round(float(protocol.brightness) / 0xFFFF, 2)

    return cls(
        hue=hue,
        saturation=saturation,
        brightness=brightness,
        kelvin=protocol.kelvin,
    )
````

##### with_hue

```python
with_hue(hue: int) -> HSBK
```

Create a new HSBK with modified hue.

| PARAMETER | DESCRIPTION                           |
| --------- | ------------------------------------- |
| `hue`     | New hue value (0-360) **TYPE:** `int` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_hue(self, hue: int) -> HSBK:
    """Create a new HSBK with modified hue.

    Args:
        hue: New hue value (0-360)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=hue,
        saturation=self.saturation,
        brightness=self.brightness,
        kelvin=self.kelvin,
    )
```

##### with_saturation

```python
with_saturation(saturation: float) -> HSBK
```

Create a new HSBK with modified saturation.

| PARAMETER    | DESCRIPTION                                      |
| ------------ | ------------------------------------------------ |
| `saturation` | New saturation value (0.0-1.0) **TYPE:** `float` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_saturation(self, saturation: float) -> HSBK:
    """Create a new HSBK with modified saturation.

    Args:
        saturation: New saturation value (0.0-1.0)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=self.hue,
        saturation=saturation,
        brightness=self.brightness,
        kelvin=self.kelvin,
    )
```

##### with_brightness

```python
with_brightness(brightness: float) -> HSBK
```

Create a new HSBK with modified brightness.

| PARAMETER    | DESCRIPTION                                      |
| ------------ | ------------------------------------------------ |
| `brightness` | New brightness value (0.0-1.0) **TYPE:** `float` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_brightness(self, brightness: float) -> HSBK:
    """Create a new HSBK with modified brightness.

    Args:
        brightness: New brightness value (0.0-1.0)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=self.hue,
        saturation=self.saturation,
        brightness=brightness,
        kelvin=self.kelvin,
    )
```

##### with_kelvin

```python
with_kelvin(kelvin: int) -> HSBK
```

Create a new HSBK with modified color temperature.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `kelvin`  | New kelvin value (1500-9000) **TYPE:** `int` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `HSBK`  | New HSBK instance |

Source code in `src/lifx/color.py`

```python
def with_kelvin(self, kelvin: int) -> HSBK:
    """Create a new HSBK with modified color temperature.

    Args:
        kelvin: New kelvin value (1500-9000)

    Returns:
        New HSBK instance
    """
    return HSBK(
        hue=self.hue,
        saturation=self.saturation,
        brightness=self.brightness,
        kelvin=kelvin,
    )
```

##### clone

```python
clone() -> HSBK
```

Create a copy of this color.

| RETURNS | DESCRIPTION                            |
| ------- | -------------------------------------- |
| `HSBK`  | New HSBK instance with the same values |

Source code in `src/lifx/color.py`

```python
def clone(self) -> HSBK:
    """Create a copy of this color.

    Returns:
        New HSBK instance with the same values
    """
    return HSBK(
        hue=self.hue,
        saturation=self.saturation,
        brightness=self.brightness,
        kelvin=self.kelvin,
    )
```

##### as_tuple

```python
as_tuple() -> tuple[int, int, int, int]
```

Return HSBK values as a tuple of protocol uint16 values.

| RETURNS | DESCRIPTION                                                |
| ------- | ---------------------------------------------------------- |
| `int`   | Tuple of (hue_u16, saturation_u16, brightness_u16, kelvin) |
| `int`   | where u16 values are in range 0-65535                      |

Example

```python
color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
hue, sat, bri, kel = color.as_tuple()
# Use in protocol operations
```

Source code in `src/lifx/color.py`

````python
def as_tuple(self) -> tuple[int, int, int, int]:
    """Return HSBK values as a tuple of protocol uint16 values.

    Returns:
        Tuple of (hue_u16, saturation_u16, brightness_u16, kelvin)
        where u16 values are in range 0-65535

    Example:
        ```python
        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
        hue, sat, bri, kel = color.as_tuple()
        # Use in protocol operations
        ```
    """
    protocol = self.to_protocol()
    return (protocol.hue, protocol.saturation, protocol.brightness, protocol.kelvin)
````

##### as_dict

```python
as_dict() -> dict[str, float | int]
```

Return HSBK values as a dictionary of user-friendly values.

| RETURNS            | DESCRIPTION |
| ------------------ | ----------- |
| \`dict\[str, float | int\]\`     |
| \`dict\[str, float | int\]\`     |

Example

```python
color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
color_dict = color.as_dict()
# {'hue': 180.0, 'saturation': 0.5, 'brightness': 0.75, 'kelvin': 3500}
```

Source code in `src/lifx/color.py`

````python
def as_dict(self) -> dict[str, float | int]:
    """Return HSBK values as a dictionary of user-friendly values.

    Returns:
        Dictionary with keys: hue (float), saturation (float),
        brightness (float), kelvin (int)

    Example:
        ```python
        color = HSBK(hue=180, saturation=0.5, brightness=0.75, kelvin=3500)
        color_dict = color.as_dict()
        # {'hue': 180.0, 'saturation': 0.5, 'brightness': 0.75, 'kelvin': 3500}
        ```
    """
    return {
        "hue": self.hue,
        "saturation": self.saturation,
        "brightness": self.brightness,
        "kelvin": self.kelvin,
    }
````

##### limit_distance_to

```python
limit_distance_to(other: HSBK) -> HSBK
```

Return a new color with hue limited to 90 degrees from another color.

This is useful for preventing large hue jumps when interpolating between colors. If the hue difference is greater than 90 degrees, the hue is adjusted to be within 90 degrees of the target hue.

| PARAMETER | DESCRIPTION                                           |
| --------- | ----------------------------------------------------- |
| `other`   | Reference color to limit distance to **TYPE:** `HSBK` |

| RETURNS | DESCRIPTION                                 |
| ------- | ------------------------------------------- |
| `HSBK`  | New HSBK instance with limited hue distance |

Example

```python
red = HSBK(hue=10, saturation=1.0, brightness=1.0, kelvin=3500)
blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

# Limit red's hue to be within 90 degrees of blue's hue
adjusted = red.limit_distance_to(blue)
# Result: hue is adjusted to be within 90 degrees of 240
```

Source code in `src/lifx/color.py`

````python
def limit_distance_to(self, other: HSBK) -> HSBK:
    """Return a new color with hue limited to 90 degrees from another color.

    This is useful for preventing large hue jumps when interpolating between colors.
    If the hue difference is greater than 90 degrees, the hue is adjusted to be
    within 90 degrees of the target hue.

    Args:
        other: Reference color to limit distance to

    Returns:
        New HSBK instance with limited hue distance

    Example:
        ```python
        red = HSBK(hue=10, saturation=1.0, brightness=1.0, kelvin=3500)
        blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

        # Limit red's hue to be within 90 degrees of blue's hue
        adjusted = red.limit_distance_to(blue)
        # Result: hue is adjusted to be within 90 degrees of 240
        ```
    """
    raw_dist = (
        self.hue - other.hue if self.hue > other.hue else other.hue - self.hue
    )
    dist = 360 - raw_dist if raw_dist > 180 else raw_dist
    if abs(dist) > 90:
        h = self.hue + 90 if (other.hue + dist) % 360 == self.hue else self.hue - 90
        h = h + 360 if h < 0 else h
        return HSBK(h, self.saturation, self.brightness, self.kelvin)
    else:
        return self
````

##### average

```python
average(colors: list[HSBK]) -> HSBK
```

Calculate the average color of a list of HSBK colors.

Uses circular mean for hue to correctly handle hue wraparound (e.g., average of 10 and 350 is 0, not 180).

| PARAMETER | DESCRIPTION                                                               |
| --------- | ------------------------------------------------------------------------- |
| `colors`  | List of HSBK colors to average (must not be empty) **TYPE:** `list[HSBK]` |

| RETURNS | DESCRIPTION                            |
| ------- | -------------------------------------- |
| `HSBK`  | New HSBK instance with averaged values |

| RAISES       | DESCRIPTION             |
| ------------ | ----------------------- |
| `ValueError` | If colors list is empty |

Example

```python
red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)
green = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

avg_color = HSBK.average([red, green, blue])
# Result: average of the three primary colors
```

Source code in `src/lifx/color.py`

````python
@classmethod
def average(cls, colors: list[HSBK]) -> HSBK:
    """Calculate the average color of a list of HSBK colors.

    Uses circular mean for hue to correctly handle hue wraparound
    (e.g., average of 10 and 350 is 0, not 180).

    Args:
        colors: List of HSBK colors to average (must not be empty)

    Returns:
        New HSBK instance with averaged values

    Raises:
        ValueError: If colors list is empty

    Example:
        ```python
        red = HSBK(hue=0, saturation=1.0, brightness=1.0, kelvin=3500)
        green = HSBK(hue=120, saturation=1.0, brightness=1.0, kelvin=3500)
        blue = HSBK(hue=240, saturation=1.0, brightness=1.0, kelvin=3500)

        avg_color = HSBK.average([red, green, blue])
        # Result: average of the three primary colors
        ```
    """
    if not colors:
        raise ValueError("Cannot average an empty list of colors")

    hue_x_total = 0.0
    hue_y_total = 0.0
    saturation_total = 0.0
    brightness_total = 0.0
    kelvin_total = 0.0

    for color in colors:
        hue_x_total += math.sin(color.hue * 2.0 * math.pi / 360)
        hue_y_total += math.cos(color.hue * 2.0 * math.pi / 360)
        saturation_total += color.saturation
        brightness_total += color.brightness
        kelvin_total += color.kelvin

    hue = math.atan2(hue_x_total, hue_y_total) / (2.0 * math.pi)
    if hue < 0.0:
        hue += 1.0
    hue *= 360
    hue = round(hue)
    saturation = round(saturation_total / len(colors), 2)
    brightness = round(brightness_total / len(colors), 2)
    kelvin = round(kelvin_total / len(colors))

    return cls(hue, saturation, brightness, kelvin)
````

## Colors Class

The `Colors` class provides convenient color presets for common colors.

### Colors

Common color presets for convenience.

## Examples

### Creating Colors

```python
from lifx import HSBK, Colors

# Use built-in color presets
color = Colors.BLUE

# Create custom colors
custom = HSBK(hue=180.0, saturation=1.0, brightness=0.8, kelvin=3500)

# Create from RGB
red = HSBK.from_rgb(255, 0, 0, kelvin=3500)

# Convert to RGB
r, g, b = Colors.BLUE.to_rgb()
print(f"RGB: ({r}, {g}, {b})")
```

### Color Components

```python
from lifx import HSBK

color = HSBK(hue=240.0, saturation=1.0, brightness=0.5, kelvin=3500)

# Hue: 0-360 degrees (0=red, 120=green, 240=blue)
print(f"Hue: {color.hue}")

# Saturation: 0.0-1.0 (0=white, 1=full color)
print(f"Saturation: {color.saturation * 100}%")

# Brightness: 0.0-1.0 (0=off, 1=full brightness)
print(f"Brightness: {color.brightness * 100}%")

# Kelvin: 1500-9000 (warm white to cool white)
print(f"Temperature: {color.kelvin}K")
```

### Color Manipulation

```python
from lifx import HSBK, Light


async def cycle_hue(light: Light):
    """Cycle through the color spectrum"""
    for hue in range(0, 360, 10):
        color = HSBK(hue=float(hue), saturation=1.0, brightness=0.8, kelvin=3500)
        await light.set_color(color, duration=0.1)
```

### White Balance

```python
from lifx import HSBK

# Warm white (sunset, candlelight)
warm = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=2500)

# Neutral white (daylight)
neutral = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=4000)

# Cool white (overcast, shade)
cool = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=6500)
```

## Available Color Presets

The `Colors` class provides these preset colors:

- `Colors.WHITE` - Pure white (3500K)
- `Colors.RED` - Red
- `Colors.ORANGE` - Orange
- `Colors.YELLOW` - Yellow
- `Colors.GREEN` - Green
- `Colors.CYAN` - Cyan
- `Colors.BLUE` - Blue
- `Colors.PURPLE` - Purple
- `Colors.PINK` - Pink
- `Colors.WARM_WHITE` - Warm white (2500K)
- `Colors.COOL_WHITE` - Cool white (6500K)

## Color Conversion Notes

### RGB to HSBK

When converting from RGB to HSBK, note that:

- RGB values are 0-255
- The Kelvin value must be specified (default: 3500K)
- Some RGB colors may not have exact HSBK equivalents
- Conversion uses standard HSV formulas with brightness mapping

### HSBK to RGB

When converting from HSBK to RGB:

- Returns tuple of (r, g, b) with values 0-255
- Kelvin temperature is not represented in RGB
- White colors (saturation=0) will be pure gray values
- Conversion is lossy - converting back may not yield the same HSBK

# Device Classes

Device classes provide direct control over LIFX devices. All device classes support async context managers for automatic resource cleanup.

## State and Info Classes

Device state and information dataclasses returned by device methods.

### DeviceState

Base device state dataclass returned by `Device.state`.

#### DeviceState

```python
DeviceState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
)
```

Base device state.

| ATTRIBUTE       | DESCRIPTION                                                               |
| --------------- | ------------------------------------------------------------------------- |
| `model`         | Friendly product name (e.g., "LIFX A19") **TYPE:** `str`                  |
| `label`         | Device label (user-assigned name) **TYPE:** `str`                         |
| `serial`        | Device serial number (6 bytes) **TYPE:** `str`                            |
| `mac_address`   | Device MAC address (formatted string) **TYPE:** `str`                     |
| `capabilities`  | Device capabilities from product registry **TYPE:** `DeviceCapabilities`  |
| `power`         | Power level (0 = off, 65535 = on) **TYPE:** `int`                         |
| `host_firmware` | Host firmware version **TYPE:** `FirmwareInfo`                            |
| `wifi_firmware` | WiFi firmware version **TYPE:** `FirmwareInfo`                            |
| `location`      | Location tuple (UUID bytes, label, updated_at) **TYPE:** `CollectionInfo` |
| `group`         | Group tuple (UUID bytes, label, updated_at) **TYPE:** `CollectionInfo`    |
| `last_updated`  | Timestamp of last state refresh **TYPE:** `float`                         |

| METHOD     | DESCRIPTION                                 |
| ---------- | ------------------------------------------- |
| `is_fresh` | Check if state is fresh (recently updated). |

##### Attributes

###### as_dict

```python
as_dict: dict[
    str, str | int | float | dict[str, bool | int] | dict[str, str | int]
]
```

Return DeviceState as a dictionary.

###### is_on

```python
is_on: bool
```

Check if device is powered on.

###### location_name

```python
location_name: str
```

Get location label.

###### group_name

```python
group_name: str
```

Get group label.

###### age

```python
age: float
```

Get age of state in seconds.

##### Functions

###### is_fresh

```python
is_fresh(max_age: float = 5.0) -> bool
```

Check if state is fresh (recently updated).

| PARAMETER | DESCRIPTION                                                                |
| --------- | -------------------------------------------------------------------------- |
| `max_age` | Maximum age in seconds (default: 5.0) **TYPE:** `float` **DEFAULT:** `5.0` |

| RETURNS | DESCRIPTION                            |
| ------- | -------------------------------------- |
| `bool`  | True if state age is less than max_age |

Source code in `src/lifx/devices/base.py`

```python
def is_fresh(self, max_age: float = 5.0) -> bool:
    """Check if state is fresh (recently updated).

    Args:
        max_age: Maximum age in seconds (default: 5.0)

    Returns:
        True if state age is less than max_age
    """
    return self.age < max_age
```

### DeviceVersion

Device version information returned by `Device.get_version()`.

#### DeviceVersion

```python
DeviceVersion(vendor: int, product: int)
```

Device version information.

| ATTRIBUTE | DESCRIPTION                                                   |
| --------- | ------------------------------------------------------------- |
| `vendor`  | Vendor ID (typically 1 for LIFX) **TYPE:** `int`              |
| `product` | Product ID (identifies specific device model) **TYPE:** `int` |

### DeviceInfo

Device runtime information returned by `Device.get_info()`.

#### DeviceInfo

```python
DeviceInfo(time: int, uptime: int, downtime: int)
```

Device runtime information.

| ATTRIBUTE  | DESCRIPTION                                                   |
| ---------- | ------------------------------------------------------------- |
| `time`     | Current device time (nanoseconds since epoch) **TYPE:** `int` |
| `uptime`   | Time since last power on (nanoseconds) **TYPE:** `int`        |
| `downtime` | Time device was powered off (nanoseconds) **TYPE:** `int`     |

### WifiInfo

WiFi module information returned by `Device.get_wifi_info()`.

#### WifiInfo

```python
WifiInfo(signal: float)
```

Device WiFi module information.

| ATTRIBUTE | DESCRIPTION                            |
| --------- | -------------------------------------- |
| `signal`  | WiFi signal strength **TYPE:** `float` |
| `rssi`    | WiFi RSSI **TYPE:** `int`              |

| METHOD          | DESCRIPTION                 |
| --------------- | --------------------------- |
| `__post_init__` | Calculate RSSI from signal. |

##### Functions

###### __post_init__

```python
__post_init__() -> None
```

Calculate RSSI from signal.

Source code in `src/lifx/devices/base.py`

```python
def __post_init__(self) -> None:
    """Calculate RSSI from signal."""
    self.rssi = int(floor(10 * log10(self.signal) + 0.5))
```

### FirmwareInfo

Firmware version information returned by `Device.get_host_firmware()` and `Device.get_wifi_firmware()`.

#### FirmwareInfo

```python
FirmwareInfo(build: int, version_major: int, version_minor: int)
```

Device firmware version information.

| ATTRIBUTE       | DESCRIPTION                              |
| --------------- | ---------------------------------------- |
| `build`         | Firmware build timestamp **TYPE:** `int` |
| `version_major` | Major version number **TYPE:** `int`     |
| `version_minor` | Minor version number **TYPE:** `int`     |

##### Attributes

###### as_dict

```python
as_dict: dict[str, int]
```

Return firmware info as dict.

### CollectionInfo

Location and group collection information returned by `Device.get_location()` and `Device.get_group()`.

#### CollectionInfo

```python
CollectionInfo(uuid: str, label: str, updated_at: int)
```

Device location and group collection information.

| ATTRIBUTE    | DESCRIPTION                                                         |
| ------------ | ------------------------------------------------------------------- |
| `uuid`       | Collection UUID (16 hexadecimal characters) **TYPE:** `str`         |
| `label`      | Collection label (up to 32 characters) **TYPE:** `str`              |
| `updated_at` | Timestamp when group was last updated (nanoseconds) **TYPE:** `int` |

##### Attributes

###### as_dict

```python
as_dict: dict[str, str | int]
```

Return group info as dict.

### DeviceCapabilities

Device capabilities from product registry, available via `Device.capabilities`.

#### DeviceCapabilities

```python
DeviceCapabilities(
    has_color: bool,
    has_multizone: bool,
    has_chain: bool,
    has_matrix: bool,
    has_infrared: bool,
    has_hev: bool,
    has_extended_multizone: bool,
    kelvin_min: int | None,
    kelvin_max: int | None,
)
```

Device capabilities from product registry.

| ATTRIBUTE                | DESCRIPTION                                                         |
| ------------------------ | ------------------------------------------------------------------- |
| `has_color`              | Supports color control **TYPE:** `bool`                             |
| `has_multizone`          | Supports multizone control (strips, beams) **TYPE:** `bool`         |
| `has_chain`              | Supports chaining (tiles) **TYPE:** `bool`                          |
| `has_matrix`             | Supports 2D matrix control (tiles, candle, path) **TYPE:** `bool`   |
| `has_infrared`           | Supports infrared LED **TYPE:** `bool`                              |
| `has_hev`                | Supports HEV (High Energy Visible) cleaning cycles **TYPE:** `bool` |
| `has_extended_multizone` | Supports extended multizone protocol **TYPE:** `bool`               |
| `kelvin_min`             | Minimum color temperature (Kelvin) **TYPE:** \`int                  |
| `kelvin_max`             | Maximum color temperature (Kelvin) **TYPE:** \`int                  |

##### Attributes

###### has_variable_color_temp

```python
has_variable_color_temp: bool
```

Check if device supports variable color temperature.

###### as_dict

```python
as_dict: dict[str, bool | int]
```

Return DeviceCapabilities as a dict.

## Base Device

The `Device` class provides common operations available on all LIFX devices.

### Device

```python
Device(
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
)
```

Bases: `Generic[StateT]`

Base class for LIFX devices.

This class provides common functionality for all LIFX devices:

- Connection management
- Basic device queries (label, power, version, info)
- State caching for reduced network traffic

Properties return cached values or None if never fetched. Use get\_\*() methods to fetch fresh data from the device.

Example

```python
device = Device(serial="d073d5123456", ip="192.168.1.100")

async with device:
    # Get device label
    label = await device.get_label()
    print(f"Device: {label}")

    # Use cached label value
    if device.label is not None:
        print(f"Cached label: {device.label}")

    # Turn on device
    await device.set_power(True)

    # Get power state
    is_on = await device.get_power()
    if is_on is not None:
        print(f"Power: {'ON' if is_on else 'OFF'}")
```

| PARAMETER     | DESCRIPTION                                                                                              |
| ------------- | -------------------------------------------------------------------------------------------------------- |
| `serial`      | Device serial number as 12-digit hex string (e.g., "d073d5123456") **TYPE:** `str`                       |
| `ip`          | Device IP address **TYPE:** `str`                                                                        |
| `port`        | Device UDP port **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                                             |
| `timeout`     | Overall timeout for network requests in seconds **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT` |
| `max_retries` | Maximum number of retry attempts for network requests **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES` |

| RAISES       | DESCRIPTION                 |
| ------------ | --------------------------- |
| `ValueError` | If any parameter is invalid |

| METHOD              | DESCRIPTION                                             |
| ------------------- | ------------------------------------------------------- |
| `from_ip`           | Create and return an instance for the given IP address. |
| `connect`           | Create and return a fully initialized device instance.  |
| `get_mac_address`   | Calculate and return the MAC address for this device.   |
| `get_label`         | Get device label/name.                                  |
| `set_label`         | Set device label/name.                                  |
| `get_power`         | Get device power state.                                 |
| `set_power`         | Set device power state.                                 |
| `get_version`       | Get device version information.                         |
| `get_info`          | Get device runtime information.                         |
| `get_wifi_info`     | Get device WiFi module information.                     |
| `get_host_firmware` | Get device host (WiFi module) firmware information.     |
| `get_wifi_firmware` | Get device WiFi module firmware information.            |
| `get_location`      | Get device location information.                        |
| `set_location`      | Set device location information.                        |
| `get_group`         | Get device group information.                           |
| `set_group`         | Set device group information.                           |
| `set_reboot`        | Reboot the device.                                      |
| `close`             | Close device connection and cleanup resources.          |
| `refresh_state`     | Refresh device state from hardware.                     |

| ATTRIBUTE       | DESCRIPTION                                                     |
| --------------- | --------------------------------------------------------------- |
| `capabilities`  | Get device product capabilities. **TYPE:** \`ProductInfo        |
| `state`         | Get device state if available. **TYPE:** \`StateT               |
| `label`         | Get cached label if available. **TYPE:** \`str                  |
| `version`       | Get cached version if available. **TYPE:** \`DeviceVersion      |
| `host_firmware` | Get cached host firmware if available. **TYPE:** \`FirmwareInfo |
| `wifi_firmware` | Get cached wifi firmware if available. **TYPE:** \`FirmwareInfo |
| `location`      | Get cached location name if available. **TYPE:** \`str          |
| `group`         | Get cached group name if available. **TYPE:** \`str             |
| `model`         | Get LIFX friendly model name if available. **TYPE:** \`str      |
| `mac_address`   | Get cached MAC address if available. **TYPE:** \`str            |

Source code in `src/lifx/devices/base.py`

```python
def __init__(
    self,
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> None:
    """Initialize device.

    Args:
        serial: Device serial number as 12-digit hex string (e.g., "d073d5123456")
        ip: Device IP address
        port: Device UDP port
        timeout: Overall timeout for network requests in seconds
        max_retries: Maximum number of retry attempts for network requests

    Raises:
        ValueError: If any parameter is invalid
    """
    # Parse and validate serial number
    try:
        serial_obj = Serial.from_string(serial)
    except (ValueError, TypeError) as e:
        raise ValueError(f"Invalid serial number: {e}") from e

    serial_bytes = serial_obj.value

    # Validate serial number
    # Check for all-zeros (invalid)
    if serial_bytes == b"\x00" * 6:
        raise ValueError("Serial number cannot be all zeros")  # pragma: no cover

    # Check for all-ones/broadcast (invalid for unicast)
    if serial_bytes == b"\xff" * 6:
        raise ValueError(  # pragma: no cover
            "Broadcast serial number not allowed for device connection"
        )

    # Validate IP address
    try:
        addr = ipaddress.ip_address(ip)
    except ValueError as e:  # pragma: no cover
        raise ValueError(f"Invalid IP address format: {e}")

    # Check for localhost
    if addr.is_loopback:
        # raise ValueError("Localhost IP address not allowed")  # pragma: no cover
        _LOGGER.warning(
            {
                "class": "Device",
                "method": "__init__",
                "action": "is_loopback",
                "ip": ip,
            }
        )

    # Check for unspecified (0.0.0.0)
    if addr.is_unspecified:
        raise ValueError(
            "Unspecified IP address (0.0.0.0) not allowed"
        )  # pragma: no cover

    # Warn for non-private IPs (LIFX should be on local network)
    if not addr.is_private:
        _LOGGER.warning(
            {
                "class": "Device",
                "method": "__init__",
                "action": "non_private_ip",
                "ip": ip,
            }
        )

    # LIFX uses IPv4 only (protocol limitation)
    if addr.version != 4:
        raise ValueError("Only IPv4 addresses are supported")  # pragma: no cover

    # Validate port
    if not (1024 <= port <= 65535):
        raise ValueError(
            f"Port must be between 1 and 65535, got {port}"
        )  # pragma: no cover

    # Warn for non-standard ports
    if port != LIFX_UDP_PORT:
        _LOGGER.warning(
            {
                "class": "Device",
                "method": "__init__",
                "action": "non_standard_port",
                "port": port,
                "default_port": LIFX_UDP_PORT,
            }
        )

    # Store normalized serial as 12-digit hex string
    self.serial = serial_obj.to_string()
    self.ip = ip
    self.port = port
    self._timeout = timeout
    self._max_retries = max_retries

    # Create lightweight connection handle - connection pooling is internal
    self.connection = DeviceConnection(
        serial=self.serial,
        ip=self.ip,
        port=self.port,
        timeout=timeout,
        max_retries=max_retries,
    )

    # State storage: Cached values from device
    self._label: str | None = None
    self._version: DeviceVersion | None = None
    self._host_firmware: FirmwareInfo | None = None
    self._wifi_firmware: FirmwareInfo | None = None
    self._location: CollectionInfo | None = None
    self._group: CollectionInfo | None = None
    self._mac_address: str | None = None

    # Product capabilities for device features (populated on first use)
    self._capabilities: ProductInfo | None = None

    # State management (populated by connect() factory or _initialize_state())
    self._state: StateT | None = None
    self._refresh_task: asyncio.Task[None] | None = None
    self._refresh_lock = asyncio.Lock()
    self._is_closed = False
```

#### Attributes

##### capabilities

```python
capabilities: ProductInfo | None
```

Get device product capabilities.

Returns product information including supported features like:

- color, infrared, multizone, extended_multizone
- matrix (for tiles), chain, relays, buttons, hev
- temperature_range

Capabilities are automatically loaded when using device as context manager.

| RETURNS       | DESCRIPTION |
| ------------- | ----------- |
| \`ProductInfo | None\`      |

Example

```python
async with device:
    if device.capabilities and device.capabilities.has_multizone:
        print("Device supports multizone")
    if device.capabilities and device.capabilities.has_extended_multizone:
        print("Device supports extended multizone")
```

##### state

```python
state: StateT | None
```

Get device state if available.

State is populated by the connect() factory method or by calling \_initialize_state() directly. Returns None if state has not been initialized.

| RETURNS  | DESCRIPTION |
| -------- | ----------- |
| \`StateT | None\`      |

##### label

```python
label: str | None
```

Get cached label if available.

Use get_label() to fetch from device.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`str   | None\`      |

##### version

```python
version: DeviceVersion | None
```

Get cached version if available.

Use get_version() to fetch from device.

| RETURNS         | DESCRIPTION |
| --------------- | ----------- |
| \`DeviceVersion | None\`      |

##### host_firmware

```python
host_firmware: FirmwareInfo | None
```

Get cached host firmware if available.

Use get_host_firmware() to fetch from device.

| RETURNS        | DESCRIPTION |
| -------------- | ----------- |
| \`FirmwareInfo | None\`      |

##### wifi_firmware

```python
wifi_firmware: FirmwareInfo | None
```

Get cached wifi firmware if available.

Use get_wifi_firmware() to fetch from device.

| RETURNS        | DESCRIPTION |
| -------------- | ----------- |
| \`FirmwareInfo | None\`      |

##### location

```python
location: str | None
```

Get cached location name if available.

Use get_location() to fetch from device.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`str   | None\`      |

##### group

```python
group: str | None
```

Get cached group name if available.

Use get_group() to fetch from device.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`str   | None\`      |

##### model

```python
model: str | None
```

Get LIFX friendly model name if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`str   | None\`      |

##### mac_address

```python
mac_address: str | None
```

Get cached MAC address if available.

Use get_host_firmware() to calculate MAC address from device firmware.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`str   | None\`      |
| \`str   | None\`      |

#### Functions

##### from_ip

```python
from_ip(
    ip: str,
    port: int = LIFX_UDP_PORT,
    serial: str | None = None,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Self
```

Create and return an instance for the given IP address.

This is a convenience class method for connecting to a known device by IP address. The returned instance can be used as a context manager.

| PARAMETER | DESCRIPTION                                                                                       |
| --------- | ------------------------------------------------------------------------------------------------- |
| `ip`      | IP address of the device **TYPE:** `str`                                                          |
| `port`    | Port number (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                  |
| `serial`  | Serial number as 12-digit hex string **TYPE:** \`str                                              |
| `timeout` | Request timeout for this device instance **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT` |

| RETURNS | DESCRIPTION                                             |
| ------- | ------------------------------------------------------- |
| `Self`  | Device instance ready to use with async context manager |

Example

```python
async with await Device.from_ip(ip="192.168.1.100") as device:
    label = await device.get_label()
```

Source code in `src/lifx/devices/base.py`

````python
@classmethod
async def from_ip(
    cls,
    ip: str,
    port: int = LIFX_UDP_PORT,
    serial: str | None = None,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Self:
    """Create and return an instance for the given IP address.

    This is a convenience class method for connecting to a known device
    by IP address. The returned instance can be used as a context manager.

    Args:
        ip: IP address of the device
        port: Port number (default LIFX_UDP_PORT)
        serial: Serial number as 12-digit hex string
        timeout: Request timeout for this device instance

    Returns:
        Device instance ready to use with async context manager

    Example:
        ```python
        async with await Device.from_ip(ip="192.168.1.100") as device:
            label = await device.get_label()
        ```
    """
    if serial is None:
        temp_conn = DeviceConnection(
            serial="000000000000",
            ip=ip,
            port=port,
            timeout=timeout,
            max_retries=max_retries,
        )
        try:
            response = await temp_conn.request(
                packets.Device.GetService(), timeout=timeout
            )
            if response and isinstance(response, packets.Device.StateService):
                if temp_conn.serial and temp_conn.serial != "000000000000":
                    return cls(
                        serial=temp_conn.serial,
                        ip=ip,
                        port=port,
                        timeout=timeout,
                        max_retries=max_retries,
                    )
        finally:
            # Always close the temporary connection to prevent resource leaks
            await temp_conn.close()
    else:
        return cls(
            serial=serial,
            ip=ip,
            port=port,
            timeout=timeout,
            max_retries=max_retries,
        )

    raise LifxDeviceNotFoundError()
````

##### connect

```python
connect(
    ip: str,
    serial: str | None = None,
    port: int = LIFX_UDP_PORT,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> (
    Light
    | HevLight
    | InfraredLight
    | MultiZoneLight
    | MatrixLight
    | CeilingLight
)
```

Create and return a fully initialized device instance.

This factory method creates the appropriate device type (Light, etc) based on the device's capabilities and initializes its state. The returned device MUST be used with an async context manager.

The returned device subclass has guaranteed initialized state - the state property will never be None for devices created via this method.

| PARAMETER     | DESCRIPTION                                                                                                           |
| ------------- | --------------------------------------------------------------------------------------------------------------------- |
| `ip`          | IP address of the device **TYPE:** `str`                                                                              |
| `serial`      | Optional serial number (12-digit hex, with or without colons). If None, queries device to get serial. **TYPE:** \`str |
| `port`        | Port number (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                                      |
| `timeout`     | Request timeout for this device instance **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT`                     |
| `max_retries` | Maximum number of retry attempts **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES`                                   |

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`Light | HevLight    |
| \`Light | HevLight    |

| RAISES                    | DESCRIPTION                            |
| ------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError` | If device cannot be found or contacted |
| `LifxTimeoutError`        | If device does not respond             |
| `ValueError`              | If serial format is invalid            |

Example

```python
# Connect by IP (serial auto-detected)
device = await Device.connect(ip="192.168.1.100")
async with device:
    # device.state is guaranteed to be initialized
    print(f"{device.state.model}: {device.state.label}")
    if device.state.is_on:
        print("Device is on")

# Connect with known serial
device = await Device.connect(ip="192.168.1.100", serial="d073d5123456")
async with device:
    await device.set_power(True)
```

Source code in `src/lifx/devices/base.py`

````python
@classmethod
async def connect(
    cls,
    ip: str,
    serial: str | None = None,
    port: int = LIFX_UDP_PORT,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> Light | HevLight | InfraredLight | MultiZoneLight | MatrixLight | CeilingLight:
    """Create and return a fully initialized device instance.

    This factory method creates the appropriate device type (Light, etc)
    based on the device's capabilities and initializes its state. The returned
    device MUST be used with an async context manager.

    The returned device subclass has guaranteed initialized state - the state
    property will never be None for devices created via this method.

    Args:
        ip: IP address of the device
        serial: Optional serial number (12-digit hex, with or without colons).
                If None, queries device to get serial.
        port: Port number (default LIFX_UDP_PORT)
        timeout: Request timeout for this device instance
        max_retries: Maximum number of retry attempts

    Returns:
        Fully initialized device instance (Light, MultiZoneLight, MatrixLight, etc.)
        with complete state loaded and guaranteed non-None state property.

    Raises:
        LifxDeviceNotFoundError: If device cannot be found or contacted
        LifxTimeoutError: If device does not respond
        ValueError: If serial format is invalid

    Example:
        ```python
        # Connect by IP (serial auto-detected)
        device = await Device.connect(ip="192.168.1.100")
        async with device:
            # device.state is guaranteed to be initialized
            print(f"{device.state.model}: {device.state.label}")
            if device.state.is_on:
                print("Device is on")

        # Connect with known serial
        device = await Device.connect(ip="192.168.1.100", serial="d073d5123456")
        async with device:
            await device.set_power(True)
        ```
    """
    # Step 1: Get serial if not provided
    if serial is None:
        temp_conn = DeviceConnection(
            serial="000000000000",
            ip=ip,
            port=port,
            timeout=timeout,
            max_retries=max_retries,
        )
        try:
            response = await temp_conn.request(
                packets.Device.GetService(), timeout=timeout
            )
            if response and isinstance(response, packets.Device.StateService):
                if temp_conn.serial and temp_conn.serial != "000000000000":
                    serial = temp_conn.serial
                else:
                    raise LifxDeviceNotFoundError(
                        "Could not determine device serial"
                    )
            else:
                raise LifxDeviceNotFoundError("No response from device")
        finally:
            await temp_conn.close()

    # Step 2: Normalize serial (accept with or without colons)
    serial = serial.replace(":", "")

    # Step 3: Create temporary device to get product info
    temp_device = cls(
        serial=serial,
        ip=ip,
        port=port,
        timeout=timeout,
        max_retries=max_retries,
    )

    try:
        # Get version to determine product
        version = await temp_device.get_version()
        product_info = get_product(version.product)

        if product_info is None:
            raise LifxDeviceNotFoundError(f"Unknown product ID: {version.product}")

        # Step 4: Determine correct device class based on capabilities
        # Import device classes here to avoid circular imports
        from typing import TYPE_CHECKING

        if TYPE_CHECKING:
            from lifx.devices.hev import HevLight
            from lifx.devices.infrared import InfraredLight
            from lifx.devices.light import Light
            from lifx.devices.matrix import MatrixLight
            from lifx.devices.multizone import MultiZoneLight

        device_class: type[Device] = cls

        # Check for ceiling products first (subset of matrix devices)
        from lifx.products import is_ceiling_product

        if is_ceiling_product(version.product):
            from lifx.devices.ceiling import CeilingLight

            device_class = CeilingLight
        elif product_info.has_matrix:
            from lifx.devices.matrix import MatrixLight

            device_class = MatrixLight
        elif product_info.has_multizone:
            from lifx.devices.multizone import MultiZoneLight

            device_class = MultiZoneLight
        elif product_info.has_infrared:
            from lifx.devices.infrared import InfraredLight

            device_class = InfraredLight
        elif product_info.has_hev:
            from lifx.devices.hev import HevLight

            device_class = HevLight
        elif product_info.has_color:
            from lifx.devices.light import Light

            device_class = Light

        # Step 5: Create instance of correct device class
        device = device_class(
            serial=serial,
            ip=ip,
            port=port,
            timeout=timeout,
            max_retries=max_retries,
        )

        # Type system note: device._state is guaranteed non-None after
        # _initialize_state().
        # Each subclass overrides _state to be non-optional
        return device  # type: ignore[return-value]

    finally:
        # Clean up temporary device
        await temp_device.connection.close()
````

##### get_mac_address

```python
get_mac_address() -> str
```

Calculate and return the MAC address for this device.

Source code in `src/lifx/devices/base.py`

```python
async def get_mac_address(self) -> str:
    """Calculate and return the MAC address for this device."""
    if self._mac_address is None:
        firmware = (
            self._host_firmware
            if self._host_firmware is not None
            else await self.get_host_firmware()
        )
        octets = [
            int(self.serial[i : i + 2], 16) for i in range(0, len(self.serial), 2)
        ]

        if firmware.version_major == 3:
            octets[5] = (octets[5] + 1) % 256

        self._mac_address = ":".join(f"{octet:02x}" for octet in octets)

    return self._mac_address
```

##### get_label

```python
get_label() -> str
```

Get device label/name.

Always fetches from device. Use the `label` property to access stored value.

| RETURNS | DESCRIPTION                                 |
| ------- | ------------------------------------------- |
| `str`   | Device label as string (max 32 bytes UTF-8) |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
label = await device.get_label()
print(f"Device name: {label}")

# Or use cached value
if device.label:
    print(f"Cached label: {device.label}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_label(self) -> str:
    """Get device label/name.

    Always fetches from device. Use the `label` property to access stored value.

    Returns:
        Device label as string (max 32 bytes UTF-8)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        label = await device.get_label()
        print(f"Device name: {label}")

        # Or use cached value
        if device.label:
            print(f"Cached label: {device.label}")
        ```
    """
    # Request automatically unpacks and decodes label
    state = await self.connection.request(packets.Device.GetLabel())
    self._raise_if_unhandled(state)

    # Store label
    label_value = state.label
    self._label = label_value
    # Update state if it exists
    if self._state is not None:
        self._state.label = label_value
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_label",
            "action": "query",
            "reply": {"label": label_value},
        }
    )
    return label_value
````

##### set_label

```python
set_label(label: str) -> None
```

Set device label/name.

| PARAMETER | DESCRIPTION                                           |
| --------- | ----------------------------------------------------- |
| `label`   | New device label (max 32 bytes UTF-8) **TYPE:** `str` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If label is too long                   |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Set label
await device.set_label("Living Room Light")
```

Source code in `src/lifx/devices/base.py`

````python
async def set_label(self, label: str) -> None:
    """Set device label/name.

    Args:
        label: New device label (max 32 bytes UTF-8)

    Raises:
        ValueError: If label is too long
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Set label
        await device.set_label("Living Room Light")
        ```
    """
    # Encode and pad to 32 bytes
    label_bytes = label.encode("utf-8")
    if len(label_bytes) > 32:
        raise ValueError(f"Label too long: {len(label_bytes)} bytes (max 32)")

    # Pad with zeros
    label_bytes = label_bytes.ljust(32, b"\x00")

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Device.SetLabel(label=label_bytes),
    )
    self._raise_if_unhandled(result)

    if result:
        self._label = label

        if self._state is not None:
            self._state.label = label
            await self._schedule_refresh()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_label",
            "action": "change",
            "values": {"label": label},
        }
    )
````

##### get_power

```python
get_power() -> int
```

Get device power state.

Always fetches from device.

| RETURNS | DESCRIPTION                                      |
| ------- | ------------------------------------------------ |
| `int`   | Power level as integer (0 for off, 65535 for on) |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
level = await device.get_power()
print(f"Power: {'ON' if level > 0 else 'OFF'}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_power(self) -> int:
    """Get device power state.

    Always fetches from device.

    Returns:
        Power level as integer (0 for off, 65535 for on)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        level = await device.get_power()
        print(f"Power: {'ON' if level > 0 else 'OFF'}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetPower())
    self._raise_if_unhandled(state)

    # Power level is uint16 (0 or 65535)
    power_level = state.level
    # Update state if it exists
    if self._state is not None:
        self._state.power = power_level
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_power",
            "action": "query",
            "reply": {"level": power_level},
        }
    )
    return power_level
````

##### set_power

```python
set_power(level: bool | int) -> None
```

Set device power state.

| PARAMETER | DESCRIPTION                                                 |
| --------- | ----------------------------------------------------------- |
| `level`   | True/65535 to turn on, False/0 to turn off **TYPE:** \`bool |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If integer value is not 0 or 65535     |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Turn on device with boolean
await device.set_power(True)

# Turn on device with integer
await device.set_power(65535)

# Turn off device
await device.set_power(False)
await device.set_power(0)
```

Source code in `src/lifx/devices/base.py`

````python
async def set_power(self, level: bool | int) -> None:
    """Set device power state.

    Args:
        level: True/65535 to turn on, False/0 to turn off

    Raises:
        ValueError: If integer value is not 0 or 65535
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Turn on device with boolean
        await device.set_power(True)

        # Turn on device with integer
        await device.set_power(65535)

        # Turn off device
        await device.set_power(False)
        await device.set_power(0)
        ```
    """
    # Power level: 0 for off, 65535 for on
    if isinstance(level, bool):
        power_level = 65535 if level else 0
    elif isinstance(level, int):
        if level not in (0, 65535):
            raise ValueError(f"Power level must be 0 or 65535, got {level}")
        power_level = level

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Device.SetPower(level=power_level),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_power",
            "action": "change",
            "values": {"level": power_level},
        }
    )

    if result and self._state is not None:
        await self._schedule_refresh()
````

##### get_version

```python
get_version() -> DeviceVersion
```

Get device version information.

Always fetches from device.

| RETURNS         | DESCRIPTION                                  |
| --------------- | -------------------------------------------- |
| `DeviceVersion` | DeviceVersion with vendor and product fields |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
version = await device.get_version()
print(f"Vendor: {version.vendor}, Product: {version.product}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_version(self) -> DeviceVersion:
    """Get device version information.

    Always fetches from device.

    Returns:
        DeviceVersion with vendor and product fields

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        version = await device.get_version()
        print(f"Vendor: {version.vendor}, Product: {version.product}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetVersion())
    self._raise_if_unhandled(state)

    version = DeviceVersion(
        vendor=state.vendor,
        product=state.product,
    )

    self._version = version

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_version",
            "action": "query",
            "reply": {"vendor": state.vendor, "product": state.product},
        }
    )
    return version
````

##### get_info

```python
get_info() -> DeviceInfo
```

Get device runtime information.

Always fetches from device.

| RETURNS      | DESCRIPTION                                |
| ------------ | ------------------------------------------ |
| `DeviceInfo` | DeviceInfo with time, uptime, and downtime |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
info = await device.get_info()
uptime_hours = info.uptime / 1e9 / 3600
print(f"Uptime: {uptime_hours:.1f} hours")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_info(self) -> DeviceInfo:
    """Get device runtime information.

    Always fetches from device.

    Returns:
        DeviceInfo with time, uptime, and downtime

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        info = await device.get_info()
        uptime_hours = info.uptime / 1e9 / 3600
        print(f"Uptime: {uptime_hours:.1f} hours")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetInfo())  # type: ignore
    self._raise_if_unhandled(state)

    info = DeviceInfo(time=state.time, uptime=state.uptime, downtime=state.downtime)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_info",
            "action": "query",
            "reply": {
                "time": state.time,
                "uptime": state.uptime,
                "downtime": state.downtime,
            },
        }
    )
    return info
````

##### get_wifi_info

```python
get_wifi_info() -> WifiInfo
```

Get device WiFi module information.

Always fetches from device.

| RETURNS    | DESCRIPTION                            |
| ---------- | -------------------------------------- |
| `WifiInfo` | WifiInfo with signal strength and RSSI |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
wifi_info = await device.get_wifi_info()
print(f"WiFi signal: {wifi_info.signal}")
print(f"WiFi RSSI: {wifi_info.rssi}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_wifi_info(self) -> WifiInfo:
    """Get device WiFi module information.

    Always fetches from device.

    Returns:
        WifiInfo with signal strength and RSSI

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        wifi_info = await device.get_wifi_info()
        print(f"WiFi signal: {wifi_info.signal}")
        print(f"WiFi RSSI: {wifi_info.rssi}")
        ```
    """
    # Request WiFi info from device
    state = await self.connection.request(packets.Device.GetWifiInfo())
    self._raise_if_unhandled(state)

    # Extract WiFi info from response
    wifi_info = WifiInfo(signal=state.signal)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_wifi_info",
            "action": "query",
            "reply": {"signal": state.signal},
        }
    )
    return wifi_info
````

##### get_host_firmware

```python
get_host_firmware() -> FirmwareInfo
```

Get device host (WiFi module) firmware information.

Always fetches from device.

| RETURNS        | DESCRIPTION                                   |
| -------------- | --------------------------------------------- |
| `FirmwareInfo` | FirmwareInfo with build timestamp and version |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
firmware = await device.get_host_firmware()
print(f"Firmware: v{firmware.version_major}.{firmware.version_minor}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_host_firmware(self) -> FirmwareInfo:
    """Get device host (WiFi module) firmware information.

    Always fetches from device.

    Returns:
        FirmwareInfo with build timestamp and version

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        firmware = await device.get_host_firmware()
        print(f"Firmware: v{firmware.version_major}.{firmware.version_minor}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetHostFirmware())  # type: ignore
    self._raise_if_unhandled(state)

    firmware = FirmwareInfo(
        build=state.build,
        version_major=state.version_major,
        version_minor=state.version_minor,
    )

    self._host_firmware = firmware

    # Calculate MAC address now that we have firmware info
    if self.mac_address is None:
        await self.get_mac_address()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_host_firmware",
            "action": "query",
            "reply": {
                "build": state.build,
                "version_major": state.version_major,
                "version_minor": state.version_minor,
            },
        }
    )
    return firmware
````

##### get_wifi_firmware

```python
get_wifi_firmware() -> FirmwareInfo
```

Get device WiFi module firmware information.

Always fetches from device.

| RETURNS        | DESCRIPTION                                   |
| -------------- | --------------------------------------------- |
| `FirmwareInfo` | FirmwareInfo with build timestamp and version |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
wifi_fw = await device.get_wifi_firmware()
print(f"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_wifi_firmware(self) -> FirmwareInfo:
    """Get device WiFi module firmware information.

    Always fetches from device.

    Returns:
        FirmwareInfo with build timestamp and version

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        wifi_fw = await device.get_wifi_firmware()
        print(f"WiFi Firmware: v{wifi_fw.version_major}.{wifi_fw.version_minor}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetWifiFirmware())  # type: ignore
    self._raise_if_unhandled(state)

    firmware = FirmwareInfo(
        build=state.build,
        version_major=state.version_major,
        version_minor=state.version_minor,
    )

    self._wifi_firmware = firmware

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_wifi_firmware",
            "action": "query",
            "reply": {
                "build": state.build,
                "version_major": state.version_major,
                "version_minor": state.version_minor,
            },
        }
    )
    return firmware
````

##### get_location

```python
get_location() -> CollectionInfo
```

Get device location information.

Always fetches from device.

| RETURNS          | DESCRIPTION                                                     |
| ---------------- | --------------------------------------------------------------- |
| `CollectionInfo` | CollectionInfo with location UUID, label, and updated timestamp |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
location = await device.get_location()
print(f"Location: {location.label}")
print(f"Location ID: {location.uuid}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_location(self) -> CollectionInfo:
    """Get device location information.

    Always fetches from device.

    Returns:
        CollectionInfo with location UUID, label, and updated timestamp

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        location = await device.get_location()
        print(f"Location: {location.label}")
        print(f"Location ID: {location.uuid}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetLocation())  # type: ignore
    self._raise_if_unhandled(state)

    location = CollectionInfo(
        uuid=state.location.hex(),
        label=state.label,
        updated_at=state.updated_at,
    )

    self._location = location
    if self._state is not None:
        self._state.location = location

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_location",
            "action": "query",
            "reply": {
                "location": state.location.hex(),
                "label": state.label,
                "updated_at": state.updated_at,
            },
        }
    )
    return location
````

##### set_location

```python
set_location(
    label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT
) -> None
```

Set device location information.

Automatically discovers devices on the network to check if any device already has the target location label. If found, reuses that existing UUID to ensure devices with the same label share the same location UUID. If not found, generates a new UUID for this label.

| PARAMETER          | DESCRIPTION                                                                                |
| ------------------ | ------------------------------------------------------------------------------------------ |
| `label`            | Location label (max 32 characters) **TYPE:** `str`                                         |
| `discover_timeout` | Timeout for device discovery in seconds **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `ValueError`                  | If label is invalid                    |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Set device location
await device.set_location("Living Room")

# If another device already has "Kitchen" location, this device will
# join that existing location UUID
await device.set_location("Kitchen")
```

Source code in `src/lifx/devices/base.py`

````python
async def set_location(
    self, label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT
) -> None:
    """Set device location information.

    Automatically discovers devices on the network to check if any device already
    has the target location label. If found, reuses that existing UUID to ensure
    devices with the same label share the same location UUID. If not found,
    generates a new UUID for this label.

    Args:
        label: Location label (max 32 characters)
        discover_timeout: Timeout for device discovery in seconds

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        ValueError: If label is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Set device location
        await device.set_location("Living Room")

        # If another device already has "Kitchen" location, this device will
        # join that existing location UUID
        await device.set_location("Kitchen")
        ```
    """
    # Validate label
    if not label:
        raise ValueError("Label cannot be empty")
    if len(label) > 32:
        raise ValueError(f"Label must be max 32 characters, got {len(label)}")

    # Import here to avoid circular dependency
    from lifx.network.discovery import discover_devices

    # Discover all devices to check for existing label
    location_uuid_to_use: bytes | None = None

    try:
        # Check each device for the target label
        async for disc in discover_devices(
            timeout=discover_timeout,
            device_timeout=self._timeout,
            max_retries=self._max_retries,
        ):
            temp_conn = DeviceConnection(
                serial=disc.serial,
                ip=disc.ip,
                port=disc.port,
                timeout=self._timeout,
                max_retries=self._max_retries,
            )

            try:
                # Get location info using new request() API
                state_packet = await temp_conn.request(packets.Device.GetLocation())  # type: ignore

                # Check if this device has the target label
                if (
                    state_packet.label == label
                    and state_packet.location is not None
                    and isinstance(state_packet.location, bytes)
                ):
                    location_uuid_to_use = state_packet.location
                    assert location_uuid_to_use is not None
                    # Type narrowing: we know location_uuid_to_use is not None here
                    _LOGGER.debug(
                        {
                            "action": "device.set_location",
                            "location_found": True,
                            "label": label,
                            "uuid": location_uuid_to_use.hex(),
                        }
                    )
                    break

            except Exception as e:
                _LOGGER.debug(
                    {
                        "action": "device.set_location",
                        "discovery_query_failed": True,
                        "reason": str(e),
                    }
                )
                continue

            finally:
                # Always close the temporary connection to prevent resource leaks
                await temp_conn.close()

    except Exception as e:
        _LOGGER.warning(
            {
                "warning": "Discovery failed, will generate new UUID",
                "reason": str(e),
            }
        )

    # If no existing location with target label found, generate new UUID
    if location_uuid_to_use is None:
        location_uuid = uuid.uuid5(LIFX_LOCATION_NAMESPACE, label)
        location_uuid_to_use = location_uuid.bytes

    # Encode label for protocol
    label_bytes = label.encode("utf-8")[:32].ljust(32, b"\x00")

    # Always use current time as updated_at timestamp
    updated_at = int(time.time() * 1e9)

    # Update this device
    result = await self.connection.request(
        packets.Device.SetLocation(
            location=location_uuid_to_use, label=label_bytes, updated_at=updated_at
        ),
    )
    self._raise_if_unhandled(result)

    if result:
        self._location = CollectionInfo(
            uuid=location_uuid_to_use.hex(), label=label, updated_at=updated_at
        )

    if result and self._state is not None:
        self._state.location.uuid = location_uuid_to_use.hex()
        self._state.location.label = label
        self._state.location.updated_at = updated_at
        await self._schedule_refresh()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_location",
            "action": "change",
            "values": {
                "location": location_uuid_to_use.hex(),
                "label": label,
                "updated_at": updated_at,
            },
        }
    )
````

##### get_group

```python
get_group() -> CollectionInfo
```

Get device group information.

Always fetches from device.

| RETURNS          | DESCRIPTION                                                  |
| ---------------- | ------------------------------------------------------------ |
| `CollectionInfo` | CollectionInfo with group UUID, label, and updated timestamp |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
group = await device.get_group()
print(f"Group: {group.label}")
print(f"Group ID: {group.uuid}")
```

Source code in `src/lifx/devices/base.py`

````python
async def get_group(self) -> CollectionInfo:
    """Get device group information.

    Always fetches from device.

    Returns:
        CollectionInfo with group UUID, label, and updated timestamp

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        group = await device.get_group()
        print(f"Group: {group.label}")
        print(f"Group ID: {group.uuid}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Device.GetGroup())  # type: ignore
    self._raise_if_unhandled(state)

    group = CollectionInfo(
        uuid=state.group.hex(),
        label=state.label,
        updated_at=state.updated_at,
    )

    self._group = group
    if self._state is not None:
        self._state.group = group

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_group",
            "action": "query",
            "reply": {
                "uuid": state.group.hex(),
                "label": state.label,
                "updated_at": state.updated_at,
            },
        }
    )
    return group
````

##### set_group

```python
set_group(label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT) -> None
```

Set device group information.

Automatically discovers devices on the network to check if any device already has the target group label. If found, reuses that existing UUID to ensure devices with the same label share the same group UUID. If not found, generates a new UUID for this label.

| PARAMETER          | DESCRIPTION                                                                                |
| ------------------ | ------------------------------------------------------------------------------------------ |
| `label`            | Group label (max 32 characters) **TYPE:** `str`                                            |
| `discover_timeout` | Timeout for device discovery in seconds **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `ValueError`                  | If label is invalid                    |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Set device group
await device.set_group("Bedroom Lights")

# If another device already has "Upstairs" group, this device will
# join that existing group UUID
await device.set_group("Upstairs")
```

Source code in `src/lifx/devices/base.py`

````python
async def set_group(
    self, label: str, *, discover_timeout: float = DISCOVERY_TIMEOUT
) -> None:
    """Set device group information.

    Automatically discovers devices on the network to check if any device already
    has the target group label. If found, reuses that existing UUID to ensure
    devices with the same label share the same group UUID. If not found,
    generates a new UUID for this label.

    Args:
        label: Group label (max 32 characters)
        discover_timeout: Timeout for device discovery in seconds

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        ValueError: If label is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Set device group
        await device.set_group("Bedroom Lights")

        # If another device already has "Upstairs" group, this device will
        # join that existing group UUID
        await device.set_group("Upstairs")
        ```
    """
    # Validate label
    if not label:
        raise ValueError("Label cannot be empty")
    if len(label) > 32:
        raise ValueError(f"Label must be max 32 characters, got {len(label)}")

    # Import here to avoid circular dependency
    from lifx.network.discovery import discover_devices

    # Discover all devices to check for existing label
    group_uuid_to_use: bytes | None = None

    try:
        # Check each device for the target label
        async for disc in discover_devices(
            timeout=discover_timeout,
            device_timeout=self._timeout,
            max_retries=self._max_retries,
        ):
            temp_conn = DeviceConnection(
                serial=disc.serial,
                ip=disc.ip,
                port=disc.port,
                timeout=self._timeout,
                max_retries=self._max_retries,
            )

            try:
                # Get group info using new request() API
                state_packet = await temp_conn.request(packets.Device.GetGroup())  # type: ignore

                # Check if this device has the target label
                if (
                    state_packet.label == label
                    and state_packet.group is not None
                    and isinstance(state_packet.group, bytes)
                ):
                    group_uuid_to_use = state_packet.group
                    assert group_uuid_to_use is not None
                    # Type narrowing: we know group_uuid_to_use is not None here
                    _LOGGER.debug(
                        {
                            "action": "device.set_group",
                            "group_found": True,
                            "label": label,
                            "uuid": group_uuid_to_use.hex(),
                        }
                    )
                    break

            except Exception as e:
                _LOGGER.debug(
                    {
                        "action": "device.set_group",
                        "discovery_query_failed": True,
                        "reason": str(e),
                    }
                )
                continue

            finally:
                # Always close the temporary connection to prevent resource leaks
                await temp_conn.close()

    except Exception as e:
        _LOGGER.warning(
            {
                "warning": "Discovery failed, will generate new UUID",
                "reason": str(e),
            }
        )

    # If no existing group with target label found, generate new UUID
    if group_uuid_to_use is None:
        group_uuid = uuid.uuid5(LIFX_GROUP_NAMESPACE, label)
        group_uuid_to_use = group_uuid.bytes

    # Encode label for protocol
    label_bytes = label.encode("utf-8")[:32].ljust(32, b"\x00")

    # Always use current time as updated_at timestamp
    updated_at = int(time.time() * 1e9)

    # Update this device
    result = await self.connection.request(
        packets.Device.SetGroup(
            group=group_uuid_to_use, label=label_bytes, updated_at=updated_at
        ),
    )
    self._raise_if_unhandled(result)

    if result:
        self._group = CollectionInfo(
            uuid=group_uuid_to_use.hex(), label=label, updated_at=updated_at
        )

    if result and self._state is not None:
        self._state.location.uuid = group_uuid_to_use.hex()
        self._state.location.label = label
        self._state.location.updated_at = updated_at
        await self._schedule_refresh()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_group",
            "action": "change",
            "values": {
                "group": group_uuid_to_use.hex(),
                "label": label,
                "updated_at": updated_at,
            },
        }
    )
````

##### set_reboot

```python
set_reboot() -> None
```

Reboot the device.

This sends a reboot command to the device. The device will disconnect and restart. You should disconnect from the device after calling this method.

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
async with device:
    await device.set_reboot()
    # Device will reboot, connection will be lost
```

Note

After rebooting, you may need to wait 10-30 seconds before the device comes back online and is discoverable again.

Source code in `src/lifx/devices/base.py`

````python
async def set_reboot(self) -> None:
    """Reboot the device.

    This sends a reboot command to the device. The device will disconnect
    and restart. You should disconnect from the device after calling this method.

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        async with device:
            await device.set_reboot()
            # Device will reboot, connection will be lost
        ```

    Note:
        After rebooting, you may need to wait 10-30 seconds before the device
        comes back online and is discoverable again.
    """
    # Send reboot request
    result = await self.connection.request(
        packets.Device.SetReboot(),
    )
    self._raise_if_unhandled(result)
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_reboot",
            "action": "change",
            "values": {},
        }
    )
````

##### close

```python
close() -> None
```

Close device connection and cleanup resources.

Cancels any pending refresh tasks and closes the network connection. Called automatically when exiting the async context manager.

Source code in `src/lifx/devices/base.py`

```python
async def close(self) -> None:
    """Close device connection and cleanup resources.

    Cancels any pending refresh tasks and closes the network connection.
    Called automatically when exiting the async context manager.
    """
    self._is_closed = True
    if self._refresh_task and not self._refresh_task.done():
        self._refresh_task.cancel()
        try:
            await self._refresh_task
        except asyncio.CancelledError:
            pass
    await self.connection.close()
```

##### refresh_state

```python
refresh_state() -> None
```

Refresh device state from hardware.

Fetches current state from device and updates the state instance. Base implementation fetches label, power, and updates timestamp. Subclasses override to add device-specific state updates.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/base.py`

```python
async def refresh_state(self) -> None:
    """Refresh device state from hardware.

    Fetches current state from device and updates the state instance.
    Base implementation fetches label, power, and updates timestamp.
    Subclasses override to add device-specific state updates.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    if not self._state:
        await self._initialize_state()
        return
```

## Light

The `Light` class provides color control and effects for standard LIFX lights.

### Light

```python
Light(*args, **kwargs)
```

Bases: `Device[LightState]`

LIFX light device with color control.

Extends the base Device class with light-specific functionality:

- Color control (HSBK)
- Brightness control
- Color temperature control
- Waveform effects

Example

```python
light = Light(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Set color
    await light.set_color(HSBK.from_rgb(255, 0, 0))

    # Set brightness
    await light.set_brightness(0.5)

    # Set temperature
    await light.set_temperature(3500)
```

Using the simplified connect method (without knowing the serial):

```python
async with await Light.from_ip(ip="192.168.1.100") as light:
    await light.set_color(HSBK.from_rgb(255, 0, 0))
```

| METHOD                    | DESCRIPTION                                                             |
| ------------------------- | ----------------------------------------------------------------------- |
| `get_color`               | Get current light color, power, and label.                              |
| `set_color`               | Set light color.                                                        |
| `set_brightness`          | Set light brightness only, preserving hue, saturation, and temperature. |
| `set_kelvin`              | Set light color temperature, preserving brightness. Saturation is       |
| `set_hue`                 | Set light hue only, preserving saturation, brightness, and temperature. |
| `set_saturation`          | Set light saturation only, preserving hue, brightness, and temperature. |
| `get_power`               | Get light power state (specific to light, not device).                  |
| `get_ambient_light_level` | Get ambient light level from device sensor.                             |
| `set_power`               | Set light power state (specific to light, not device).                  |
| `set_waveform`            | Apply a waveform effect to the light.                                   |
| `set_waveform_optional`   | Apply a waveform effect with selective color component control.         |
| `pulse`                   | Pulse the light to a specific color.                                    |
| `breathe`                 | Make the light breathe to a specific color.                             |
| `apply_theme`             | Apply a theme to this light.                                            |
| `refresh_state`           | Refresh light state from hardware.                                      |

| ATTRIBUTE    | DESCRIPTION                                                                                        |
| ------------ | -------------------------------------------------------------------------------------------------- |
| `state`      | Get light state (guaranteed to be initialized when using Device.connect()). **TYPE:** `LightState` |
| `min_kelvin` | Get the minimum supported kelvin value if available. **TYPE:** \`int                               |
| `max_kelvin` | Get the maximum supported kelvin value if available. **TYPE:** \`int                               |

Source code in `src/lifx/devices/light.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize Light with additional state attributes."""
    super().__init__(*args, **kwargs)
```

#### Attributes

##### state

```python
state: LightState
```

Get light state (guaranteed to be initialized when using Device.connect()).

| RETURNS      | DESCRIPTION                         |
| ------------ | ----------------------------------- |
| `LightState` | LightState with current light state |

| RAISES         | DESCRIPTION                             |
| -------------- | --------------------------------------- |
| `RuntimeError` | If accessed before state initialization |

##### min_kelvin

```python
min_kelvin: int | None
```

Get the minimum supported kelvin value if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`int   | None\`      |

##### max_kelvin

```python
max_kelvin: int | None
```

Get the maximum supported kelvin value if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`int   | None\`      |

#### Functions

##### get_color

```python
get_color() -> tuple[HSBK, int, str]
```

Get current light color, power, and label.

Always fetches from device. Use the `color` property to access stored value.

Returns a tuple containing:

- color: HSBK color
- power: Power level as integer (0 for off, 65535 for on)
- label: Device label/name

| RETURNS                 | DESCRIPTION                    |
| ----------------------- | ------------------------------ |
| `tuple[HSBK, int, str]` | Tuple of (color, power, label) |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
color, power, label = await light.get_color()
print(f"{label}: Hue: {color.hue}, Power: {'ON' if power > 0 else 'OFF'}")
```

Source code in `src/lifx/devices/light.py`

````python
async def get_color(self) -> tuple[HSBK, int, str]:
    """Get current light color, power, and label.

    Always fetches from device. Use the `color` property to access stored value.

    Returns a tuple containing:
    - color: HSBK color
    - power: Power level as integer (0 for off, 65535 for on)
    - label: Device label/name

    Returns:
        Tuple of (color, power, label)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        color, power, label = await light.get_color()
        print(f"{label}: Hue: {color.hue}, Power: {'ON' if power > 0 else 'OFF'}")
        ```
    """
    # Request automatically unpacks response and decodes labels
    state = await self.connection.request(packets.Light.GetColor())
    self._raise_if_unhandled(state)

    # Convert from protocol HSBK to user-friendly HSBK
    color = HSBK.from_protocol(state.color)
    power = state.power
    label = state.label

    # Store label from StateColor response
    self._label = label  # Already decoded to string

    # Update state if it exists (including all subclasses)
    if self._state is not None:
        # Update base fields available on all device states
        self._state.power = power
        self._state.label = label

        if hasattr(self._state, "color"):
            self._state.color = color

        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_color",
            "action": "query",
            "reply": {
                "hue": state.color.hue,
                "saturation": state.color.saturation,
                "brightness": state.color.brightness,
                "kelvin": state.color.kelvin,
                "power": state.power,
                "label": state.label,
            },
        }
    )

    return color, power, label
````

##### set_color

```python
set_color(color: HSBK, duration: float = 0.0) -> None
```

Set light color.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Set to red instantly
await light.set_color(HSBK.from_rgb(255, 0, 0))

# Fade to blue over 2 seconds
await light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_color(
    self,
    color: HSBK,
    duration: float = 0.0,
) -> None:
    """Set light color.

    Args:
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Set to red instantly
        await light.set_color(HSBK.from_rgb(255, 0, 0))

        # Fade to blue over 2 seconds
        await light.set_color(HSBK.from_rgb(0, 0, 255), duration=2.0)
        ```
    """
    # Convert to protocol HSBK
    protocol_color = color.to_protocol()

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Light.SetColor(
            color=protocol_color,
            duration=duration_ms,
        ),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "Light",
            "method": "set_color",
            "action": "change",
            "values": {
                "hue": protocol_color.hue,
                "saturation": protocol_color.saturation,
                "brightness": protocol_color.brightness,
                "kelvin": protocol_color.kelvin,
                "duration": duration_ms,
            },
        }
    )

    # Update state on acknowledgement
    if result and self._state is not None:
        self._state.color = color
        await self._schedule_refresh()
````

##### set_brightness

```python
set_brightness(brightness: float, duration: float = 0.0) -> None
```

Set light brightness only, preserving hue, saturation, and temperature.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `brightness` | Brightness level (0.0-1.0) **TYPE:** `float`                                      |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                   |
| ------------------------- | ----------------------------- |
| `ValueError`              | If brightness is out of range |
| `LifxDeviceNotFoundError` | If device is not connected    |
| `LifxTimeoutError`        | If device does not respond    |

Example

```python
# Set to 50% brightness
await light.set_brightness(0.5)

# Fade to full brightness over 1 second
await light.set_brightness(1.0, duration=1.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_brightness(self, brightness: float, duration: float = 0.0) -> None:
    """Set light brightness only, preserving hue, saturation, and temperature.

    Args:
        brightness: Brightness level (0.0-1.0)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If brightness is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to 50% brightness
        await light.set_brightness(0.5)

        # Fade to full brightness over 1 second
        await light.set_brightness(1.0, duration=1.0)
        ```
    """
    if not (MIN_BRIGHTNESS <= brightness <= MAX_BRIGHTNESS):
        raise ValueError(
            f"Brightness must be between {MIN_BRIGHTNESS} "
            f"and {MAX_BRIGHTNESS}, got {brightness}"
        )

    # Use set_waveform_optional with HALF_SINE waveform to set brightness
    # without needing to query current color values. Convert duration to seconds.
    color = HSBK(hue=0, saturation=0, brightness=brightness, kelvin=3500)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=False,
        set_saturation=False,
        set_brightness=True,
        set_kelvin=False,
    )
````

##### set_kelvin

```python
set_kelvin(kelvin: int, duration: float = 0.0) -> None
```

Set light color temperature, preserving brightness. Saturation is automatically set to 0 to switch the light to color temperature mode.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `kelvin`   | Color temperature in Kelvin (1500-9000) **TYPE:** `int`                           |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If kelvin is out of range  |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set to warm white
await light.set_kelvin(2500)

# Fade to cool white over 2 seconds
await light.set_kelvin(6500, duration=2.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_kelvin(self, kelvin: int, duration: float = 0.0) -> None:
    """Set light color temperature, preserving brightness. Saturation is
       automatically set to 0 to switch the light to color temperature mode.

    Args:
        kelvin: Color temperature in Kelvin (1500-9000)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If kelvin is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to warm white
        await light.set_kelvin(2500)

        # Fade to cool white over 2 seconds
        await light.set_kelvin(6500, duration=2.0)
        ```
    """
    if not (MIN_KELVIN <= kelvin <= MAX_KELVIN):
        raise ValueError(
            f"Kelvin must be between {MIN_KELVIN} and {MAX_KELVIN}, got {kelvin}"
        )

    # Use set_waveform_optional with HALF_SINE waveform to set kelvin
    # and saturation without needing to query current color values
    color = HSBK(hue=0, saturation=0, brightness=1.0, kelvin=kelvin)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=False,
        set_saturation=True,
        set_brightness=False,
        set_kelvin=True,
    )
````

##### set_hue

```python
set_hue(hue: int, duration: float = 0.0) -> None
```

Set light hue only, preserving saturation, brightness, and temperature.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `hue`      | Hue in degrees (0-360) **TYPE:** `int`                                            |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `ValueError`              | If hue is out of range     |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |

Example

```python
# Set to red (0 degrees)
await light.set_hue(0)

# Cycle through rainbow
for hue in range(0, 360, 10):
    await light.set_hue(hue, duration=0.5)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_hue(self, hue: int, duration: float = 0.0) -> None:
    """Set light hue only, preserving saturation, brightness, and temperature.

    Args:
        hue: Hue in degrees (0-360)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If hue is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to red (0 degrees)
        await light.set_hue(0)

        # Cycle through rainbow
        for hue in range(0, 360, 10):
            await light.set_hue(hue, duration=0.5)
        ```
    """
    if not (MIN_HUE <= hue <= MAX_HUE):
        raise ValueError(f"Hue must be between {MIN_HUE} and {MAX_HUE}, got {hue}")

    # Use set_waveform_optional with HALF_SINE waveform to set hue
    # without needing to query current color values
    color = HSBK(hue=hue, saturation=1.0, brightness=1.0, kelvin=3500)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=True,
        set_saturation=False,
        set_brightness=False,
        set_kelvin=False,
    )
````

##### set_saturation

```python
set_saturation(saturation: float, duration: float = 0.0) -> None
```

Set light saturation only, preserving hue, brightness, and temperature.

| PARAMETER    | DESCRIPTION                                                                       |
| ------------ | --------------------------------------------------------------------------------- |
| `saturation` | Saturation level (0.0-1.0) **TYPE:** `float`                                      |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                    | DESCRIPTION                   |
| ------------------------- | ----------------------------- |
| `ValueError`              | If saturation is out of range |
| `LifxDeviceNotFoundError` | If device is not connected    |
| `LifxTimeoutError`        | If device does not respond    |

Example

```python
# Set to fully saturated
await light.set_saturation(1.0)

# Fade to white (no saturation) over 2 seconds
await light.set_saturation(0.0, duration=2.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_saturation(self, saturation: float, duration: float = 0.0) -> None:
    """Set light saturation only, preserving hue, brightness, and temperature.

    Args:
        saturation: Saturation level (0.0-1.0)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If saturation is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond

    Example:
        ```python
        # Set to fully saturated
        await light.set_saturation(1.0)

        # Fade to white (no saturation) over 2 seconds
        await light.set_saturation(0.0, duration=2.0)
        ```
    """
    if not (MIN_SATURATION <= saturation <= MAX_SATURATION):
        raise ValueError(
            f"Saturation must be between {MIN_SATURATION} "
            f"and {MAX_SATURATION}, got {saturation}"
        )

    # Use set_waveform_optional with HALF_SINE waveform to set saturation
    # without needing to query current color values
    color = HSBK(hue=0, saturation=saturation, brightness=1.0, kelvin=3500)

    await self.set_waveform_optional(
        color=color,
        period=max(duration, 0.001),
        cycles=1,
        waveform=LightWaveform.HALF_SINE,
        transient=False,
        set_hue=False,
        set_saturation=True,
        set_brightness=False,
        set_kelvin=False,
    )
````

##### get_power

```python
get_power() -> int
```

Get light power state (specific to light, not device).

Always fetches from device.

This overrides Device.get_power() as it queries the light-specific power state (packet type 116/118) instead of device power (packet type 20/22).

| RETURNS | DESCRIPTION                                      |
| ------- | ------------------------------------------------ |
| `int`   | Power level as integer (0 for off, 65535 for on) |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
level = await light.get_power()
print(f"Light power: {'ON' if level > 0 else 'OFF'}")
```

Source code in `src/lifx/devices/light.py`

````python
async def get_power(self) -> int:
    """Get light power state (specific to light, not device).

    Always fetches from device.

    This overrides Device.get_power() as it queries the light-specific
    power state (packet type 116/118) instead of device power (packet type 20/22).

    Returns:
        Power level as integer (0 for off, 65535 for on)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        level = await light.get_power()
        print(f"Light power: {'ON' if level > 0 else 'OFF'}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Light.GetPower())
    self._raise_if_unhandled(state)

    # Power level is uint16 (0 or 65535)
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_power",
            "action": "query",
            "reply": {"level": state.level},
        }
    )

    return state.level
````

##### get_ambient_light_level

```python
get_ambient_light_level() -> float
```

Get ambient light level from device sensor.

Always fetches from device (volatile property, not cached).

This method queries the device's ambient light sensor to get the current lux reading. Devices without ambient light sensors will return 0.0.

| RETURNS | DESCRIPTION                                              |
| ------- | -------------------------------------------------------- |
| `float` | Ambient light level in lux (0.0 if device has no sensor) |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
lux = await light.get_ambient_light_level()
if lux > 0:
    print(f"Ambient light: {lux} lux")
else:
    print("No ambient light sensor or completely dark")
```

Source code in `src/lifx/devices/light.py`

````python
async def get_ambient_light_level(self) -> float:
    """Get ambient light level from device sensor.

    Always fetches from device (volatile property, not cached).

    This method queries the device's ambient light sensor to get the current
    lux reading. Devices without ambient light sensors will return 0.0.

    Returns:
        Ambient light level in lux (0.0 if device has no sensor)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        lux = await light.get_ambient_light_level()
        if lux > 0:
            print(f"Ambient light: {lux} lux")
        else:
            print("No ambient light sensor or completely dark")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.Sensor.GetAmbientLight())
    self._raise_if_unhandled(state)

    _LOGGER.debug(
        {
            "class": "Light",
            "method": "get_ambient_light_level",
            "action": "query",
            "reply": {"lux": state.lux},
        }
    )

    return state.lux
````

##### set_power

```python
set_power(level: bool | int, duration: float = 0.0) -> None
```

Set light power state (specific to light, not device).

This overrides Device.set_power() as it uses the light-specific power packet (type 117) which supports transition duration.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `level`    | True/65535 to turn on, False/0 to turn off **TYPE:** \`bool                       |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If integer value is not 0 or 65535     |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Turn on instantly with boolean
await light.set_power(True)

# Turn on with integer
await light.set_power(65535)

# Fade off over 3 seconds
await light.set_power(False, duration=3.0)
await light.set_power(0, duration=3.0)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_power(self, level: bool | int, duration: float = 0.0) -> None:
    """Set light power state (specific to light, not device).

    This overrides Device.set_power() as it uses the light-specific
    power packet (type 117) which supports transition duration.

    Args:
        level: True/65535 to turn on, False/0 to turn off
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If integer value is not 0 or 65535
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Turn on instantly with boolean
        await light.set_power(True)

        # Turn on with integer
        await light.set_power(65535)

        # Fade off over 3 seconds
        await light.set_power(False, duration=3.0)
        await light.set_power(0, duration=3.0)
        ```
    """
    # Power level: 0 for off, 65535 for on
    if isinstance(level, bool):
        power_level = 65535 if level else 0
    elif isinstance(level, int):
        if level not in (0, 65535):
            raise ValueError(f"Power level must be 0 or 65535, got {level}")
        power_level = level
    else:
        raise TypeError(f"Expected bool or int, got {type(level).__name__}")

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Light.SetPower(level=power_level, duration=duration_ms),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "Light",
            "method": "set_power",
            "action": "change",
            "values": {"level": power_level, "duration": duration_ms},
        }
    )

    # Update state on acknowledgement
    if result and self._state is not None:
        self._state.power = power_level

    # Schedule refresh to validate state
    if self._state is not None:
        await self._schedule_refresh()
````

##### set_waveform

```python
set_waveform(
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
) -> None
```

Apply a waveform effect to the light.

Waveforms create repeating color transitions. Useful for effects like pulsing, breathing, or blinking.

| PARAMETER    | DESCRIPTION                                                                                        |
| ------------ | -------------------------------------------------------------------------------------------------- |
| `color`      | Target color for the waveform **TYPE:** `HSBK`                                                     |
| `period`     | Period of one cycle in seconds **TYPE:** `float`                                                   |
| `cycles`     | Number of cycles **TYPE:** `float`                                                                 |
| `waveform`   | Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE) **TYPE:** `LightWaveform`                    |
| `transient`  | If True, return to original color after effect (default True) **TYPE:** `bool` **DEFAULT:** `True` |
| `skew_ratio` | Waveform skew (0.0-1.0, default 0.5 for symmetric) **TYPE:** `float` **DEFAULT:** `0.5`            |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If parameters are out of range         |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
from lifx.protocol.protocol_types import LightWaveform

# Pulse red 5 times
await light.set_waveform(
    color=HSBK.from_rgb(255, 0, 0),
    period=1.0,
    cycles=5,
    waveform=LightWaveform.SINE,
)

# Breathe white once
await light.set_waveform(
    color=HSBK(0, 0, 1.0, 3500),
    period=2.0,
    cycles=1,
    waveform=LightWaveform.SINE,
    transient=False,
)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_waveform(
    self,
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
) -> None:
    """Apply a waveform effect to the light.

    Waveforms create repeating color transitions. Useful for effects like
    pulsing, breathing, or blinking.

    Args:
        color: Target color for the waveform
        period: Period of one cycle in seconds
        cycles: Number of cycles
        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)
        transient: If True, return to original color after effect (default True)
        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)

    Raises:
        ValueError: If parameters are out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        from lifx.protocol.protocol_types import LightWaveform

        # Pulse red 5 times
        await light.set_waveform(
            color=HSBK.from_rgb(255, 0, 0),
            period=1.0,
            cycles=5,
            waveform=LightWaveform.SINE,
        )

        # Breathe white once
        await light.set_waveform(
            color=HSBK(0, 0, 1.0, 3500),
            period=2.0,
            cycles=1,
            waveform=LightWaveform.SINE,
            transient=False,
        )
        ```
    """
    if period <= 0:
        raise ValueError(f"Period must be positive, got {period}")
    if cycles < 1:
        raise ValueError(f"Cycles must be 1 or higher, got {cycles}")
    if not (0.0 <= skew_ratio <= 1.0):
        raise ValueError(
            f"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}"
        )

    # Convert to protocol values
    protocol_color = color.to_protocol()
    period_ms = int(period * 1000)
    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range

    # Send request
    result = await self.connection.request(
        packets.Light.SetWaveform(
            transient=bool(transient),
            color=protocol_color,
            period=period_ms,
            cycles=cycles,
            skew_ratio=skew_ratio_i16,
            waveform=waveform,
        ),
    )
    self._raise_if_unhandled(result)
    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_waveform",
            "action": "change",
            "values": {
                "transient": transient,
                "hue": protocol_color.hue,
                "saturation": protocol_color.saturation,
                "brightness": protocol_color.brightness,
                "kelvin": protocol_color.kelvin,
                "period": period_ms,
                "cycles": cycles,
                "skew_ratio": skew_ratio_i16,
                "waveform": waveform.value,
            },
        }
    )

    # Schedule refresh to update state
    if self._state is not None:
        await self._schedule_refresh()
````

##### set_waveform_optional

```python
set_waveform_optional(
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
    set_hue: bool = True,
    set_saturation: bool = True,
    set_brightness: bool = True,
    set_kelvin: bool = True,
) -> None
```

Apply a waveform effect with selective color component control.

Similar to set_waveform() but allows fine-grained control over which color components (hue, saturation, brightness, kelvin) are affected by the waveform. This enables effects like pulsing brightness while keeping hue constant, or cycling hue while maintaining brightness.

| PARAMETER        | DESCRIPTION                                                                                        |
| ---------------- | -------------------------------------------------------------------------------------------------- |
| `color`          | Target color for the waveform **TYPE:** `HSBK`                                                     |
| `period`         | Period of one cycle in seconds **TYPE:** `float`                                                   |
| `cycles`         | Number of cycles **TYPE:** `float`                                                                 |
| `waveform`       | Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE) **TYPE:** `LightWaveform`                    |
| `transient`      | If True, return to original color after effect (default True) **TYPE:** `bool` **DEFAULT:** `True` |
| `skew_ratio`     | Waveform skew (0.0-1.0, default 0.5 for symmetric) **TYPE:** `float` **DEFAULT:** `0.5`            |
| `set_hue`        | Apply waveform to hue component (default True) **TYPE:** `bool` **DEFAULT:** `True`                |
| `set_saturation` | Apply waveform to saturation component (default True) **TYPE:** `bool` **DEFAULT:** `True`         |
| `set_brightness` | Apply waveform to brightness component (default True) **TYPE:** `bool` **DEFAULT:** `True`         |
| `set_kelvin`     | Apply waveform to kelvin component (default True) **TYPE:** `bool` **DEFAULT:** `True`             |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If parameters are out of range         |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
from lifx.protocol.protocol_types import LightWaveform

# Pulse brightness only, keeping hue/saturation constant
await light.set_waveform_optional(
    color=HSBK(0, 1.0, 1.0, 3500),
    period=1.0,
    cycles=5,
    waveform=LightWaveform.SINE,
    set_hue=False,
    set_saturation=False,
    set_brightness=True,
    set_kelvin=False,
)

# Cycle hue while maintaining brightness
await light.set_waveform_optional(
    color=HSBK(180, 1.0, 1.0, 3500),
    period=5.0,
    cycles=0,  # Infinite
    waveform=LightWaveform.SAW,
    set_hue=True,
    set_saturation=False,
    set_brightness=False,
    set_kelvin=False,
)
```

Source code in `src/lifx/devices/light.py`

````python
async def set_waveform_optional(
    self,
    color: HSBK,
    period: float,
    cycles: float,
    waveform: LightWaveform,
    transient: bool = True,
    skew_ratio: float = 0.5,
    set_hue: bool = True,
    set_saturation: bool = True,
    set_brightness: bool = True,
    set_kelvin: bool = True,
) -> None:
    """Apply a waveform effect with selective color component control.

    Similar to set_waveform() but allows fine-grained control over which
    color components (hue, saturation, brightness, kelvin) are affected
    by the waveform. This enables effects like pulsing brightness while
    keeping hue constant, or cycling hue while maintaining brightness.

    Args:
        color: Target color for the waveform
        period: Period of one cycle in seconds
        cycles: Number of cycles
        waveform: Waveform type (SAW, SINE, HALF_SINE, TRIANGLE, PULSE)
        transient: If True, return to original color after effect (default True)
        skew_ratio: Waveform skew (0.0-1.0, default 0.5 for symmetric)
        set_hue: Apply waveform to hue component (default True)
        set_saturation: Apply waveform to saturation component (default True)
        set_brightness: Apply waveform to brightness component (default True)
        set_kelvin: Apply waveform to kelvin component (default True)

    Raises:
        ValueError: If parameters are out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        from lifx.protocol.protocol_types import LightWaveform

        # Pulse brightness only, keeping hue/saturation constant
        await light.set_waveform_optional(
            color=HSBK(0, 1.0, 1.0, 3500),
            period=1.0,
            cycles=5,
            waveform=LightWaveform.SINE,
            set_hue=False,
            set_saturation=False,
            set_brightness=True,
            set_kelvin=False,
        )

        # Cycle hue while maintaining brightness
        await light.set_waveform_optional(
            color=HSBK(180, 1.0, 1.0, 3500),
            period=5.0,
            cycles=0,  # Infinite
            waveform=LightWaveform.SAW,
            set_hue=True,
            set_saturation=False,
            set_brightness=False,
            set_kelvin=False,
        )
        ```
    """
    if period <= 0:
        raise ValueError(f"Period must be positive, got {period}")
    if cycles < 0:
        raise ValueError(f"Cycles must be non-negative, got {cycles}")
    if not (0.0 <= skew_ratio <= 1.0):
        raise ValueError(
            f"Skew ratio must be between 0.0 and 1.0, got {skew_ratio}"
        )

    # Convert to protocol values
    protocol_color = color.to_protocol()
    period_ms = int(period * 1000)
    skew_ratio_i16 = int(skew_ratio * 65535) - 32768  # Convert to int16 range

    # Send request
    result = await self.connection.request(
        packets.Light.SetWaveformOptional(
            transient=bool(transient),
            color=protocol_color,
            period=period_ms,
            cycles=cycles,
            skew_ratio=skew_ratio_i16,
            waveform=waveform,
            set_hue=set_hue,
            set_saturation=set_saturation,
            set_brightness=set_brightness,
            set_kelvin=set_kelvin,
        ),
    )
    self._raise_if_unhandled(result)
    _LOGGER.debug(
        {
            "class": "Light",
            "method": "set_waveform_optional",
            "action": "change",
            "values": {
                "transient": transient,
                "hue": protocol_color.hue,
                "saturation": protocol_color.saturation,
                "brightness": protocol_color.brightness,
                "kelvin": protocol_color.kelvin,
                "period": period_ms,
                "cycles": cycles,
                "skew_ratio": skew_ratio_i16,
                "waveform": waveform.value,
                "set_hue": set_hue,
                "set_saturation": set_saturation,
                "set_brightness": set_brightness,
                "set_kelvin": set_kelvin,
            },
        }
    )

    # Update state on acknowledgement (only if non-transient)
    if result and not transient and self._state is not None:
        # Create a new color with only the specified components updated
        current = self._state.color
        new_color = HSBK(
            hue=color.hue if set_hue else current.hue,
            saturation=color.saturation if set_saturation else current.saturation,
            brightness=color.brightness if set_brightness else current.brightness,
            kelvin=color.kelvin if set_kelvin else current.kelvin,
        )
        self._state.color = new_color

    # Schedule refresh to validate state
    if self._state is not None:
        await self._schedule_refresh()
````

##### pulse

```python
pulse(
    color: HSBK, period: float = 1.0, cycles: float = 1, transient: bool = True
) -> None
```

Pulse the light to a specific color.

Convenience method for creating a pulse effect using SINE waveform.

| PARAMETER   | DESCRIPTION                                                                                        |
| ----------- | -------------------------------------------------------------------------------------------------- |
| `color`     | Target color to pulse to **TYPE:** `HSBK`                                                          |
| `period`    | Period of one pulse in seconds (default 1.0) **TYPE:** `float` **DEFAULT:** `1.0`                  |
| `cycles`    | Number of pulses (default 1) **TYPE:** `float` **DEFAULT:** `1`                                    |
| `transient` | If True, return to original color after effect (default True) **TYPE:** `bool` **DEFAULT:** `True` |

Example

```python
# Pulse red once
await light.pulse(HSBK.from_rgb(255, 0, 0))

# Pulse blue 3 times, 2 seconds per pulse
await light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)
```

Source code in `src/lifx/devices/light.py`

````python
async def pulse(
    self,
    color: HSBK,
    period: float = 1.0,
    cycles: float = 1,
    transient: bool = True,
) -> None:
    """Pulse the light to a specific color.

    Convenience method for creating a pulse effect using SINE waveform.

    Args:
        color: Target color to pulse to
        period: Period of one pulse in seconds (default 1.0)
        cycles: Number of pulses (default 1)
        transient: If True, return to original color after effect (default True)

    Example:
        ```python
        # Pulse red once
        await light.pulse(HSBK.from_rgb(255, 0, 0))

        # Pulse blue 3 times, 2 seconds per pulse
        await light.pulse(HSBK.from_rgb(0, 0, 255), period=2.0, cycles=3)
        ```
    """
    await self.set_waveform(
        color=color,
        period=period,
        cycles=cycles,
        waveform=LightWaveform.PULSE,
        transient=transient,
    )
````

##### breathe

```python
breathe(color: HSBK, period: float = 2.0, cycles: float = 1) -> None
```

Make the light breathe to a specific color.

Convenience method for creating a breathing effect using SINE waveform.

| PARAMETER | DESCRIPTION                                                                        |
| --------- | ---------------------------------------------------------------------------------- |
| `color`   | Target color to breathe to **TYPE:** `HSBK`                                        |
| `period`  | Period of one breath in seconds (default 2.0) **TYPE:** `float` **DEFAULT:** `2.0` |
| `cycles`  | Number of breaths (default 1) **TYPE:** `float` **DEFAULT:** `1`                   |

Example

```python
# Breathe white once
await light.breathe(HSBK(0, 0, 1.0, 3500))

# Breathe purple 10 times
await light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)
```

Source code in `src/lifx/devices/light.py`

````python
async def breathe(
    self,
    color: HSBK,
    period: float = 2.0,
    cycles: float = 1,
) -> None:
    """Make the light breathe to a specific color.

    Convenience method for creating a breathing effect using SINE waveform.

    Args:
        color: Target color to breathe to
        period: Period of one breath in seconds (default 2.0)
        cycles: Number of breaths (default 1)

    Example:
        ```python
        # Breathe white once
        await light.breathe(HSBK(0, 0, 1.0, 3500))

        # Breathe purple 10 times
        await light.breathe(HSBK.from_rgb(128, 0, 128), cycles=10)
        ```
    """
    await self.set_waveform(
        color=color,
        period=period,
        cycles=cycles,
        waveform=LightWaveform.SINE,
        transient=True,
    )
````

##### apply_theme

```python
apply_theme(
    theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None
```

Apply a theme to this light.

Selects a random color from the theme and applies it to the light.

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                    |
| `power_on` | Turn on the light **TYPE:** `bool` **DEFAULT:** `False`             |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
from lifx.theme import get_theme

theme = get_theme("evening")
await light.apply_theme(theme, power_on=True, duration=0.5)
```

Source code in `src/lifx/devices/light.py`

````python
async def apply_theme(
    self,
    theme: Theme,
    power_on: bool = False,
    duration: float = 0.0,
) -> None:
    """Apply a theme to this light.

    Selects a random color from the theme and applies it to the light.

    Args:
        theme: Theme to apply
        power_on: Turn on the light
        duration: Transition duration in seconds

    Example:
        ```python
        from lifx.theme import get_theme

        theme = get_theme("evening")
        await light.apply_theme(theme, power_on=True, duration=0.5)
        ```
    """
    if self.capabilities is None:
        await self._ensure_capabilities()

    if self.capabilities and not self.capabilities.has_color:
        return

    # Select a random color from theme
    color = theme.random()

    # Check if light is on
    is_on = await self.get_power()

    # Apply color to light
    # If light is off and we're turning it on, set color immediately then fade on
    if power_on and not is_on:
        await self.set_color(color, duration=0)
        await self.set_power(True, duration=duration)
    else:
        # Light is already on, or we're not turning it on - apply with duration
        await self.set_color(color, duration=duration)
````

##### refresh_state

```python
refresh_state() -> None
```

Refresh light state from hardware.

Fetches color (which includes power and label) and updates state.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/light.py`

```python
async def refresh_state(self) -> None:
    """Refresh light state from hardware.

    Fetches color (which includes power and label) and updates state.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    import time

    if self._state is None:
        await self._initialize_state()
        return

    # GetColor returns color, power, and label in one request
    color, power, label = await self.get_color()

    self._state.color = color
    self._state.power = power
    self._state.label = label
    self._state.last_updated = time.time()
```

### LightState

Light device state dataclass returned by `Light.state`.

#### LightState

```python
LightState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
    color: HSBK,
)
```

Bases: `DeviceState`

Light device state with color control.

| ATTRIBUTE | DESCRIPTION                         |
| --------- | ----------------------------------- |
| `color`   | Current HSBK color **TYPE:** `HSBK` |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return LightState as a dict.

## HEV Light

The `HevLight` class extends `Light` with anti-bacterial cleaning cycle control for LIFX HEV devices.

### HevLight

```python
HevLight(*args, **kwargs)
```

Bases: `Light`

LIFX HEV light with anti-bacterial cleaning capabilities.

Extends the Light class with HEV (High Energy Visible) cycle control. HEV uses UV-C light to sanitize surfaces and air with anti-bacterial properties.

Example

```python
light = HevLight(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Start a 2-hour cleaning cycle
    await light.set_hev_cycle(enable=True, duration_seconds=7200)

    # Check cycle status
    state = await light.get_hev_cycle()
    if state.is_running:
        print(f"Cleaning: {state.remaining_s}s remaining")

    # Configure defaults
    await light.set_hev_config(indication=True, duration_seconds=7200)
```

Using the simplified connect method:

```python
async with await HevLight.from_ip(ip="192.168.1.100") as light:
    await light.set_hev_cycle(enable=True, duration_seconds=3600)
```

| METHOD                | DESCRIPTION                                |
| --------------------- | ------------------------------------------ |
| `get_hev_cycle`       | Get current HEV cycle state.               |
| `set_hev_cycle`       | Start or stop a HEV cleaning cycle.        |
| `get_hev_config`      | Get HEV cycle configuration.               |
| `set_hev_config`      | Configure HEV cycle defaults.              |
| `get_last_hev_result` | Get result of the last HEV cleaning cycle. |
| `refresh_state`       | Refresh HEV light state from hardware.     |

| ATTRIBUTE    | DESCRIPTION                                                                             |
| ------------ | --------------------------------------------------------------------------------------- |
| `state`      | Get HEV light state (guaranteed when using Device.connect()). **TYPE:** `HevLightState` |
| `hev_config` | Get cached HEV configuration if available. **TYPE:** \`HevConfig                        |
| `hev_result` | Get cached last HEV cycle result if available. **TYPE:** \`LightLastHevCycleResult      |

Source code in `src/lifx/devices/hev.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize HevLight with additional state attributes."""
    super().__init__(*args, **kwargs)
    # HEV-specific state storage
    self._hev_config: HevConfig | None = None
    self._hev_result: LightLastHevCycleResult | None = None
```

#### Attributes

##### state

```python
state: HevLightState
```

Get HEV light state (guaranteed when using Device.connect()).

| RETURNS         | DESCRIPTION                                |
| --------------- | ------------------------------------------ |
| `HevLightState` | HevLightState with current HEV light state |

| RAISES         | DESCRIPTION                             |
| -------------- | --------------------------------------- |
| `RuntimeError` | If accessed before state initialization |

##### hev_config

```python
hev_config: HevConfig | None
```

Get cached HEV configuration if available.

| RETURNS     | DESCRIPTION |
| ----------- | ----------- |
| \`HevConfig | None\`      |
| \`HevConfig | None\`      |

##### hev_result

```python
hev_result: LightLastHevCycleResult | None
```

Get cached last HEV cycle result if available.

| RETURNS                   | DESCRIPTION |
| ------------------------- | ----------- |
| \`LightLastHevCycleResult | None\`      |
| \`LightLastHevCycleResult | None\`      |

#### Functions

##### get_hev_cycle

```python
get_hev_cycle() -> HevCycleState
```

Get current HEV cycle state.

Always fetches from device. Use the `hev_cycle` property to access stored value.

| RETURNS         | DESCRIPTION                                                       |
| --------------- | ----------------------------------------------------------------- |
| `HevCycleState` | HevCycleState with duration, remaining time, and last power state |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
state = await light.get_hev_cycle()
if state.is_running:
    print(f"HEV cleaning in progress: {state.remaining_s}s left")
else:
    print("No active cleaning cycle")
```

Source code in `src/lifx/devices/hev.py`

````python
async def get_hev_cycle(self) -> HevCycleState:
    """Get current HEV cycle state.

    Always fetches from device. Use the `hev_cycle` property to access stored value.

    Returns:
        HevCycleState with duration, remaining time, and last power state

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        state = await light.get_hev_cycle()
        if state.is_running:
            print(f"HEV cleaning in progress: {state.remaining_s}s left")
        else:
            print("No active cleaning cycle")
        ```
    """
    # Request HEV cycle state
    state = await self.connection.request(packets.Light.GetHevCycle())
    self._raise_if_unhandled(state)

    # Create state object
    cycle_state = HevCycleState(
        duration_s=state.duration_s,
        remaining_s=state.remaining_s,
        last_power=state.last_power,
    )

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "hev_cycle"):
        self._state.hev_cycle = cycle_state
        self._state.last_updated = __import__("time").time()

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "hev_cycle"):
        self._state.hev_cycle = cycle_state
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_hev_cycle",
            "action": "query",
            "reply": {
                "duration_s": state.duration_s,
                "remaining_s": state.remaining_s,
                "last_power": state.last_power,
            },
        }
    )

    return cycle_state
````

##### set_hev_cycle

```python
set_hev_cycle(enable: bool, duration_seconds: int) -> None
```

Start or stop a HEV cleaning cycle.

| PARAMETER          | DESCRIPTION                                               |
| ------------------ | --------------------------------------------------------- |
| `enable`           | True to start cycle, False to stop **TYPE:** `bool`       |
| `duration_seconds` | Duration of the cleaning cycle in seconds **TYPE:** `int` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If duration is negative                |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Start a 1-hour cleaning cycle
await light.set_hev_cycle(enable=True, duration_seconds=3600)

# Stop the current cycle
await light.set_hev_cycle(enable=False, duration_seconds=0)
```

Source code in `src/lifx/devices/hev.py`

````python
async def set_hev_cycle(self, enable: bool, duration_seconds: int) -> None:
    """Start or stop a HEV cleaning cycle.

    Args:
        enable: True to start cycle, False to stop
        duration_seconds: Duration of the cleaning cycle in seconds

    Raises:
        ValueError: If duration is negative
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Start a 1-hour cleaning cycle
        await light.set_hev_cycle(enable=True, duration_seconds=3600)

        # Stop the current cycle
        await light.set_hev_cycle(enable=False, duration_seconds=0)
        ```
    """
    if duration_seconds < 0:
        raise ValueError(f"Duration must be non-negative, got {duration_seconds}")

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Light.SetHevCycle(
            enable=enable,
            duration_s=duration_seconds,
        ),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "HevLight",
            "method": "set_hev_cycle",
            "action": "change",
            "values": {"enable": enable, "duration_s": duration_seconds},
        }
    )

    # Schedule debounced refresh to update HEV cycle state
    # (No optimistic update - cycle state is complex)
    if self._state is not None:
        await self._schedule_refresh()
````

##### get_hev_config

```python
get_hev_config() -> HevConfig
```

Get HEV cycle configuration.

| RETURNS     | DESCRIPTION                                             |
| ----------- | ------------------------------------------------------- |
| `HevConfig` | HevConfig with indication and default duration settings |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
config = await light.get_hev_config()
print(f"Default duration: {config.duration_s}s")
print(f"Visual indication: {config.indication}")
```

Source code in `src/lifx/devices/hev.py`

````python
async def get_hev_config(self) -> HevConfig:
    """Get HEV cycle configuration.

    Returns:
        HevConfig with indication and default duration settings

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        config = await light.get_hev_config()
        print(f"Default duration: {config.duration_s}s")
        print(f"Visual indication: {config.indication}")
        ```
    """
    # Request HEV configuration
    state = await self.connection.request(packets.Light.GetHevCycleConfiguration())
    self._raise_if_unhandled(state)

    # Create config object
    config = HevConfig(
        indication=state.indication,
        duration_s=state.duration_s,
    )

    # Store cached state
    self._hev_config = config

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "hev_config"):
        self._state.hev_config = config
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_hev_config",
            "action": "query",
            "reply": {
                "indication": state.indication,
                "duration_s": state.duration_s,
            },
        }
    )

    return config
````

##### set_hev_config

```python
set_hev_config(indication: bool, duration_seconds: int) -> None
```

Configure HEV cycle defaults.

| PARAMETER          | DESCRIPTION                                                        |
| ------------------ | ------------------------------------------------------------------ |
| `indication`       | Whether to show visual indication during cleaning **TYPE:** `bool` |
| `duration_seconds` | Default duration for cleaning cycles in seconds **TYPE:** `int`    |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If duration is negative                |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Configure 2-hour default with visual indication
await light.set_hev_config(indication=True, duration_seconds=7200)
```

Source code in `src/lifx/devices/hev.py`

````python
async def set_hev_config(self, indication: bool, duration_seconds: int) -> None:
    """Configure HEV cycle defaults.

    Args:
        indication: Whether to show visual indication during cleaning
        duration_seconds: Default duration for cleaning cycles in seconds

    Raises:
        ValueError: If duration is negative
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Configure 2-hour default with visual indication
        await light.set_hev_config(indication=True, duration_seconds=7200)
        ```
    """
    if duration_seconds < 0:
        raise ValueError(f"Duration must be non-negative, got {duration_seconds}")

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Light.SetHevCycleConfiguration(
            indication=indication,
            duration_s=duration_seconds,
        ),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "HevLight",
            "method": "set_hev_config",
            "action": "change",
            "values": {"indication": indication, "duration_s": duration_seconds},
        }
    )

    # Update cache and state on acknowledgement
    if result:
        hev_config = HevConfig(indication=indication, duration_s=duration_seconds)
        self._hev_config = hev_config
        if self._state is not None:
            self._state.hev_config = hev_config

    # Schedule refresh to validate state
    if self._state is not None:
        await self._schedule_refresh()
````

##### get_last_hev_result

```python
get_last_hev_result() -> LightLastHevCycleResult
```

Get result of the last HEV cleaning cycle.

| RETURNS                   | DESCRIPTION                                                                  |
| ------------------------- | ---------------------------------------------------------------------------- |
| `LightLastHevCycleResult` | LightLastHevCycleResult enum value indicating success or interruption reason |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
result = await light.get_last_hev_result()
if result == LightLastHevCycleResult.SUCCESS:
    print("Last cleaning cycle completed successfully")
elif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:
    print("Cycle was interrupted by network command")
```

Source code in `src/lifx/devices/hev.py`

````python
async def get_last_hev_result(
    self,
) -> LightLastHevCycleResult:
    """Get result of the last HEV cleaning cycle.

    Returns:
        LightLastHevCycleResult enum value indicating success or interruption reason

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        result = await light.get_last_hev_result()
        if result == LightLastHevCycleResult.SUCCESS:
            print("Last cleaning cycle completed successfully")
        elif result == LightLastHevCycleResult.INTERRUPTED_BY_LAN:
            print("Cycle was interrupted by network command")
        ```
    """
    # Request last HEV result
    state = await self.connection.request(packets.Light.GetLastHevCycleResult())
    self._raise_if_unhandled(state)

    # Store cached state
    result = state.result
    self._hev_result = result

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "hev_result"):
        self._state.hev_result = result
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_last_hev_result",
            "action": "query",
            "reply": {"result": result.value},
        }
    )

    return result
````

##### refresh_state

```python
refresh_state() -> None
```

Refresh HEV light state from hardware.

Fetches color, HEV cycle, config, and last result.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/hev.py`

```python
async def refresh_state(self) -> None:
    """Refresh HEV light state from hardware.

    Fetches color, HEV cycle, config, and last result.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    await super().refresh_state()

    # Fetch all HEV light state
    async with asyncio.TaskGroup() as tg:
        hev_cycle_task = tg.create_task(self.get_hev_cycle())
        hev_result_task = tg.create_task(self.get_last_hev_result())

    hev_cycle = hev_cycle_task.result()
    hev_result = hev_result_task.result()

    self._state.hev_cycle = hev_cycle
    self._state.hev_result = hev_result
```

### HevLightState

HEV light device state dataclass returned by `HevLight.state`.

#### HevLightState

```python
HevLightState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
    color: HSBK,
    hev_cycle: HevCycleState,
    hev_config: HevConfig,
    hev_result: LightLastHevCycleResult,
)
```

Bases: `LightState`

HEV light device state with anti-bacterial capabilities.

| ATTRIBUTE    | DESCRIPTION                                               |
| ------------ | --------------------------------------------------------- |
| `hev_cycle`  | Current HEV cycle state **TYPE:** `HevCycleState`         |
| `hev_config` | Default HEV configuration **TYPE:** `HevConfig`           |
| `hev_result` | Last HEV cycle result **TYPE:** `LightLastHevCycleResult` |

| METHOD             | DESCRIPTION                           |
| ------------------ | ------------------------------------- |
| `from_light_state` | Create HevLightState from LightState. |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return HevLightState as dict.

##### Functions

###### from_light_state

```python
from_light_state(
    light_state: LightState,
    hev_cycle: HevCycleState,
    hev_config: HevConfig,
    hev_result: LightLastHevCycleResult,
) -> HevLightState
```

Create HevLightState from LightState.

Source code in `src/lifx/devices/hev.py`

```python
@classmethod
def from_light_state(
    cls,
    light_state: LightState,
    hev_cycle: HevCycleState,
    hev_config: HevConfig,
    hev_result: LightLastHevCycleResult,
) -> HevLightState:
    """Create HevLightState from LightState."""
    return cls(
        model=light_state.model,
        label=light_state.label,
        serial=light_state.serial,
        mac_address=light_state.mac_address,
        power=light_state.power,
        capabilities=light_state.capabilities,
        host_firmware=light_state.host_firmware,
        wifi_firmware=light_state.wifi_firmware,
        location=light_state.location,
        group=light_state.group,
        color=light_state.color,
        hev_config=hev_config,
        hev_cycle=hev_cycle,
        hev_result=hev_result,
        last_updated=time.time(),
    )
```

## Infrared Light

The `InfraredLight` class extends `Light` with infrared LED control for night vision on LIFX A19 + Night Vision devices.

### InfraredLight

```python
InfraredLight(*args, **kwargs)
```

Bases: `Light`

LIFX infrared light with IR LED control.

Extends the Light class with infrared brightness control. Infrared LEDs automatically activate in low-light conditions to provide illumination for night vision cameras.

Example

```python
light = InfraredLight(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Set infrared brightness to 50%
    await light.set_infrared(0.5)

    # Get current infrared brightness
    brightness = await light.get_infrared()
    print(f"IR brightness: {brightness * 100}%")
```

Using the simplified connect method:

```python
async with await InfraredLight.from_ip(ip="192.168.1.100") as light:
    await light.set_infrared(0.8)
```

| METHOD          | DESCRIPTION                                 |
| --------------- | ------------------------------------------- |
| `get_infrared`  | Get current infrared brightness.            |
| `set_infrared`  | Set infrared brightness.                    |
| `refresh_state` | Refresh infrared light state from hardware. |

| ATTRIBUTE  | DESCRIPTION                                                                                       |
| ---------- | ------------------------------------------------------------------------------------------------- |
| `state`    | Get infrared light state (guaranteed when using Device.connect()). **TYPE:** `InfraredLightState` |
| `infrared` | Get cached infrared brightness if available. **TYPE:** \`float                                    |

Source code in `src/lifx/devices/infrared.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize InfraredLight with additional state attributes."""
    super().__init__(*args, **kwargs)
    # Infrared-specific state storage
    self._infrared: float | None = None
```

#### Attributes

##### state

```python
state: InfraredLightState
```

Get infrared light state (guaranteed when using Device.connect()).

| RETURNS              | DESCRIPTION                                          |
| -------------------- | ---------------------------------------------------- |
| `InfraredLightState` | InfraredLightState with current infrared light state |

| RAISES         | DESCRIPTION                             |
| -------------- | --------------------------------------- |
| `RuntimeError` | If accessed before state initialization |

##### infrared

```python
infrared: float | None
```

Get cached infrared brightness if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`float | None\`      |
| \`float | None\`      |

#### Functions

##### get_infrared

```python
get_infrared() -> float
```

Get current infrared brightness.

| RETURNS | DESCRIPTION                   |
| ------- | ----------------------------- |
| `float` | Infrared brightness (0.0-1.0) |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
brightness = await light.get_infrared()
if brightness > 0:
    print(f"IR LEDs active at {brightness * 100}%")
```

Source code in `src/lifx/devices/infrared.py`

````python
async def get_infrared(self) -> float:
    """Get current infrared brightness.

    Returns:
        Infrared brightness (0.0-1.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        brightness = await light.get_infrared()
        if brightness > 0:
            print(f"IR LEDs active at {brightness * 100}%")
        ```
    """
    # Request infrared state
    state = await self.connection.request(packets.Light.GetInfrared())
    self._raise_if_unhandled(state)

    # Convert from uint16 (0-65535) to float (0.0-1.0)
    brightness = state.brightness / 65535.0

    # Store cached state
    self._infrared = brightness

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "infrared"):
        self._state.infrared = brightness
        self._state.last_updated = __import__("time").time()

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "infrared"):
        self._state.infrared = brightness
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_infrared",
            "action": "query",
            "reply": {"brightness": state.brightness},
        }
    )

    return brightness
````

##### set_infrared

```python
set_infrared(brightness: float) -> None
```

Set infrared brightness.

| PARAMETER    | DESCRIPTION                                     |
| ------------ | ----------------------------------------------- |
| `brightness` | Infrared brightness (0.0-1.0) **TYPE:** `float` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If brightness is out of range          |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Set to 75% infrared brightness
await light.set_infrared(0.75)

# Turn off infrared
await light.set_infrared(0.0)
```

Source code in `src/lifx/devices/infrared.py`

````python
async def set_infrared(self, brightness: float) -> None:
    """Set infrared brightness.

    Args:
        brightness: Infrared brightness (0.0-1.0)

    Raises:
        ValueError: If brightness is out of range
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Set to 75% infrared brightness
        await light.set_infrared(0.75)

        # Turn off infrared
        await light.set_infrared(0.0)
        ```
    """
    if not (0.0 <= brightness <= 1.0):
        raise ValueError(
            f"Brightness must be between 0.0 and 1.0, got {brightness}"
        )

    # Convert from float (0.0-1.0) to uint16 (0-65535)
    brightness_u16 = max(0, min(65535, int(round(brightness * 65535))))

    # Request automatically handles acknowledgement
    result = await self.connection.request(
        packets.Light.SetInfrared(brightness=brightness_u16),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "InfraredLight",
            "method": "set_infrared",
            "action": "change",
            "values": {"brightness": brightness_u16},
        }
    )

    # Update cache and state on acknowledgement
    if result:
        self._infrared = brightness
        if self._state is not None:
            self._state.infrared = brightness

    # Schedule refresh to validate state
    if self._state is not None:
        await self._schedule_refresh()
````

##### refresh_state

```python
refresh_state() -> None
```

Refresh infrared light state from hardware.

Fetches color and infrared brightness.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/infrared.py`

```python
async def refresh_state(self) -> None:
    """Refresh infrared light state from hardware.

    Fetches color and infrared brightness.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    await super().refresh_state()

    infrared = await self.get_infrared()
    self._state.infrared = infrared
```

### InfraredLightState

Infrared light device state dataclass returned by `InfraredLight.state`.

#### InfraredLightState

```python
InfraredLightState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
    color: HSBK,
    infrared: float,
)
```

Bases: `LightState`

Infrared light device state with IR control.

| ATTRIBUTE  | DESCRIPTION                                     |
| ---------- | ----------------------------------------------- |
| `infrared` | Infrared brightness (0.0-1.0) **TYPE:** `float` |

| METHOD             | DESCRIPTION                                |
| ------------------ | ------------------------------------------ |
| `from_light_state` | Create InfraredLightState from LightState. |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return InfraredLightState as dict.

##### Functions

###### from_light_state

```python
from_light_state(
    light_state: LightState, infrared: float
) -> InfraredLightState
```

Create InfraredLightState from LightState.

Source code in `src/lifx/devices/infrared.py`

```python
@classmethod
def from_light_state(
    cls, light_state: LightState, infrared: float
) -> InfraredLightState:
    """Create InfraredLightState from LightState."""
    return cls(
        model=light_state.model,
        label=light_state.label,
        serial=light_state.serial,
        mac_address=light_state.mac_address,
        power=light_state.power,
        capabilities=light_state.capabilities,
        host_firmware=light_state.host_firmware,
        wifi_firmware=light_state.wifi_firmware,
        location=light_state.location,
        group=light_state.group,
        color=light_state.color,
        infrared=infrared,
        last_updated=time.time(),
    )
```

## MultiZone Light

The `MultiZoneLight` class controls LIFX strips and beams with multiple color zones.

### MultiZoneLight

```python
MultiZoneLight(*args, **kwargs)
```

Bases: `Light`

LIFX MultiZone light device (strips, beams).

Extends the Light class with zone-specific functionality:

- Individual zone color control
- Multi-zone effects (move, etc.)
- Extended color zone support for efficient bulk updates

Example

```python
light = MultiZoneLight(serial="d073d5123456", ip="192.168.1.100")

async with light:
    # Get number of zones
    zone_count = await light.get_zone_count()
    print(f"Device has {zone_count} zones")

    # Set all zones to red
    await light.set_color_zones(
        start=0, end=zone_count - 1, color=HSBK.from_rgb(255, 0, 0)
    )

    # Get colors for first 5 zones
    colors = await light.get_color_zones(0, 4)

    # Apply a moving effect
    await light.set_move_effect(speed=5.0, direction="forward")
```

Using the simplified connect method:

```python
async with await MultiZoneLight.from_ip(ip="192.168.1.100") as light:
    await light.set_move_effect(speed=5.0, direction="forward")
```

| METHOD                     | DESCRIPTION                                                          |
| -------------------------- | -------------------------------------------------------------------- |
| `get_zone_count`           | Get the number of zones in the device.                               |
| `get_color_zones`          | Get colors for a range of zones using GetColorZones.                 |
| `get_extended_color_zones` | Get colors for a range of zones using GetExtendedColorZones.         |
| `get_all_color_zones`      | Get colors for all zones, automatically using the best method.       |
| `set_color_zones`          | Set color for a range of zones.                                      |
| `set_extended_color_zones` | Set colors for multiple zones efficiently (up to 82 zones per call). |
| `get_effect`               | Get current multizone effect.                                        |
| `set_effect`               | Set multizone effect.                                                |
| `stop_effect`              | Stop any running multizone effect.                                   |
| `apply_theme`              | Apply a theme across zones.                                          |
| `refresh_state`            | Refresh multizone light state from hardware.                         |

| ATTRIBUTE          | DESCRIPTION                                                                                         |
| ------------------ | --------------------------------------------------------------------------------------------------- |
| `state`            | Get multizone light state (guaranteed when using Device.connect()). **TYPE:** `MultiZoneLightState` |
| `zone_count`       | Get cached zone count if available. **TYPE:** \`int                                                 |
| `multizone_effect` | Get cached multizone effect if available. **TYPE:** \`MultiZoneEffect                               |

Source code in `src/lifx/devices/multizone.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize MultiZoneLight with additional state attributes."""
    super().__init__(*args, **kwargs)
    # MultiZone-specific state storage
    self._zone_count: int | None = None
    self._multizone_effect: MultiZoneEffect | None | None = None
```

#### Attributes

##### state

```python
state: MultiZoneLightState
```

Get multizone light state (guaranteed when using Device.connect()).

| RETURNS               | DESCRIPTION                                            |
| --------------------- | ------------------------------------------------------ |
| `MultiZoneLightState` | MultiZoneLightState with current multizone light state |

| RAISES         | DESCRIPTION                             |
| -------------- | --------------------------------------- |
| `RuntimeError` | If accessed before state initialization |

##### zone_count

```python
zone_count: int | None
```

Get cached zone count if available.

| RETURNS | DESCRIPTION |
| ------- | ----------- |
| \`int   | None\`      |
| \`int   | None\`      |

##### multizone_effect

```python
multizone_effect: MultiZoneEffect | None | None
```

Get cached multizone effect if available.

| RETURNS           | DESCRIPTION |
| ----------------- | ----------- |
| \`MultiZoneEffect | None        |
| \`MultiZoneEffect | None        |

#### Functions

##### get_zone_count

```python
get_zone_count() -> int
```

Get the number of zones in the device.

Always fetches from device. Use the `zone_count` property to access stored value.

| RETURNS | DESCRIPTION     |
| ------- | --------------- |
| `int`   | Number of zones |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
zone_count = await light.get_zone_count()
print(f"Device has {zone_count} zones")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_zone_count(self) -> int:
    """Get the number of zones in the device.

    Always fetches from device.
    Use the `zone_count` property to access stored value.

    Returns:
        Number of zones

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        zone_count = await light.get_zone_count()
        print(f"Device has {zone_count} zones")
        ```
    """
    # Request automatically unpacks response
    if self.capabilities and self.capabilities.has_extended_multizone:
        state = await self.connection.request(
            packets.MultiZone.GetExtendedColorZones()
        )
    else:
        state = await self.connection.request(
            packets.MultiZone.GetColorZones(start_index=0, end_index=0)
        )
    self._raise_if_unhandled(state)

    count = state.count

    self._zone_count = count

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_zone_count",
            "action": "query",
            "reply": {
                "count": state.count,
            },
        }
    )

    return count
````

##### get_color_zones

```python
get_color_zones(start: int = 0, end: int = 255) -> list[HSBK]
```

Get colors for a range of zones using GetColorZones.

Always fetches from device. Use `zones` property to access stored values.

| PARAMETER | DESCRIPTION                                                                |
| --------- | -------------------------------------------------------------------------- |
| `start`   | Start zone index (inclusive, default 0) **TYPE:** `int` **DEFAULT:** `0`   |
| `end`     | End zone index (inclusive, default 255) **TYPE:** `int` **DEFAULT:** `255` |

| RETURNS      | DESCRIPTION                       |
| ------------ | --------------------------------- |
| `list[HSBK]` | List of HSBK colors, one per zone |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If zone indices are invalid            |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Get colors for all zones (default)
colors = await light.get_color_zones()

# Get colors for first 10 zones
colors = await light.get_color_zones(0, 9)
for i, color in enumerate(colors):
    print(f"Zone {i}: {color}")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_color_zones(
    self,
    start: int = 0,
    end: int = 255,
) -> list[HSBK]:
    """Get colors for a range of zones using GetColorZones.

    Always fetches from device.
    Use `zones` property to access stored values.

    Args:
        start: Start zone index (inclusive, default 0)
        end: End zone index (inclusive, default 255)

    Returns:
        List of HSBK colors, one per zone

    Raises:
        ValueError: If zone indices are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Get colors for all zones (default)
        colors = await light.get_color_zones()

        # Get colors for first 10 zones
        colors = await light.get_color_zones(0, 9)
        for i, color in enumerate(colors):
            print(f"Zone {i}: {color}")
        ```
    """
    if start < 0 or end < start:
        raise ValueError(f"Invalid zone range: {start}-{end}")

    # Ensure capabilities are loaded
    if self.capabilities is None:
        await self._ensure_capabilities()

    zone_count = await self.get_zone_count()
    end = min(zone_count - 1, end)

    colors = []
    current_start = start

    while current_start <= end:
        current_end = min(current_start + 7, end)  # Max 8 zones per request

        # Stream responses - break after first (single response per request)
        async for state in self.connection.request_stream(
            packets.MultiZone.GetColorZones(
                start_index=current_start, end_index=current_end
            )
        ):
            self._raise_if_unhandled(state)
            # Extract colors from response (up to 8 colors)
            zones_in_response = min(8, current_end - current_start + 1)
            for i in range(zones_in_response):
                if i >= len(state.colors):
                    break
                protocol_hsbk = state.colors[i]
                colors.append(HSBK.from_protocol(protocol_hsbk))
            break  # Single response per request

        current_start += 8

    result = colors

    # Update state if it exists and we fetched all zones
    if self._state is not None and hasattr(self._state, "zones"):
        if start == 0 and len(result) == zone_count:
            self._state.zones = result
            self._state.last_updated = __import__("time").time()

    # Update state if it exists and we fetched all zones
    if self._state is not None and hasattr(self._state, "zones"):
        if start == 0 and len(result) == zone_count:
            self._state.zones = result
            self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_color_zones",
            "action": "query",
            "reply": {
                "start": start,
                "end": end,
                "zone_count": len(result),
                "colors": [
                    {
                        "hue": c.hue,
                        "saturation": c.saturation,
                        "brightness": c.brightness,
                        "kelvin": c.kelvin,
                    }
                    for c in result
                ],
            },
        }
    )

    return result
````

##### get_extended_color_zones

```python
get_extended_color_zones(start: int = 0, end: int = 255) -> list[HSBK]
```

Get colors for a range of zones using GetExtendedColorZones.

Always fetches from device. Use `zones` property to access stored values.

| PARAMETER | DESCRIPTION                                                                |
| --------- | -------------------------------------------------------------------------- |
| `start`   | Start zone index (inclusive, default 0) **TYPE:** `int` **DEFAULT:** `0`   |
| `end`     | End zone index (inclusive, default 255) **TYPE:** `int` **DEFAULT:** `255` |

| RETURNS      | DESCRIPTION                       |
| ------------ | --------------------------------- |
| `list[HSBK]` | List of HSBK colors, one per zone |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If zone indices are invalid            |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Get colors for all zones (default)
colors = await light.get_extended_color_zones()

# Get colors for first 10 zones
colors = await light.get_extended_color_zones(0, 9)
for i, color in enumerate(colors):
    print(f"Zone {i}: {color}")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_extended_color_zones(
    self, start: int = 0, end: int = 255
) -> list[HSBK]:
    """Get colors for a range of zones using GetExtendedColorZones.

    Always fetches from device.
    Use `zones` property to access stored values.

    Args:
        start: Start zone index (inclusive, default 0)
        end: End zone index (inclusive, default 255)

    Returns:
        List of HSBK colors, one per zone

    Raises:
        ValueError: If zone indices are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Get colors for all zones (default)
        colors = await light.get_extended_color_zones()

        # Get colors for first 10 zones
        colors = await light.get_extended_color_zones(0, 9)
        for i, color in enumerate(colors):
            print(f"Zone {i}: {color}")
        ```
    """
    if start < 0 or end < start:
        raise ValueError(f"Invalid zone range: {start}-{end}")

    zone_count = await self.get_zone_count()
    end = min(zone_count - 1, end)

    colors: list[HSBK] = []

    # Stream all responses until timeout
    async for packet in self.connection.request_stream(
        packets.MultiZone.GetExtendedColorZones(),
        timeout=2.0,  # Allow time for multiple responses
    ):
        self._raise_if_unhandled(packet)
        # Only process valid colors based on colors_count
        for i in range(packet.colors_count):
            if i >= len(packet.colors):
                break
            protocol_hsbk = packet.colors[i]
            colors.append(HSBK.from_protocol(protocol_hsbk))

        # Early exit if we have all zones
        if len(colors) >= zone_count:
            break

    # Return only the requested range to caller
    result = colors[start : end + 1]

    # Update state if it exists and we fetched all zones
    if self._state is not None and hasattr(self._state, "zones"):
        if start == 0 and len(result) == zone_count:
            self._state.zones = result
            self._state.last_updated = __import__("time").time()

    # Update state if it exists and we fetched all zones
    if self._state is not None and hasattr(self._state, "zones"):
        if start == 0 and len(result) == zone_count:
            self._state.zones = result
            self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_extended_color_zones",
            "action": "query",
            "reply": {
                "total_zones": len(colors),
                "requested_start": start,
                "requested_end": end,
                "returned_count": len(result),
            },
        }
    )

    return result
````

##### get_all_color_zones

```python
get_all_color_zones() -> list[HSBK]
```

Get colors for all zones, automatically using the best method.

This method automatically chooses between get_extended_color_zones() and get_color_zones() based on device capabilities. Always returns all zones on the device.

Always fetches from device.

| RETURNS      | DESCRIPTION                       |
| ------------ | --------------------------------- |
| `list[HSBK]` | List of HSBK colors for all zones |

| RAISES                    | DESCRIPTION                |
| ------------------------- | -------------------------- |
| `LifxDeviceNotFoundError` | If device is not connected |
| `LifxTimeoutError`        | If device does not respond |
| `LifxProtocolError`       | If response is invalid     |

Example

```python
# Get all zones (automatically uses best method)
colors = await light.get_all_color_zones()
print(f"Device has {len(colors)} zones")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_all_color_zones(self) -> list[HSBK]:
    """Get colors for all zones, automatically using the best method.

    This method automatically chooses between get_extended_color_zones()
    and get_color_zones() based on device capabilities. Always returns
    all zones on the device.

    Always fetches from device.

    Returns:
        List of HSBK colors for all zones

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid

    Example:
        ```python
        # Get all zones (automatically uses best method)
        colors = await light.get_all_color_zones()
        print(f"Device has {len(colors)} zones")
        ```
    """
    # Ensure capabilities are loaded
    if self.capabilities is None:
        await self._ensure_capabilities()

    # Use extended multizone if available, otherwise fall back to standard
    if self.capabilities and self.capabilities.has_extended_multizone:
        return await self.get_extended_color_zones()
    else:
        return await self.get_color_zones()
````

##### set_color_zones

```python
set_color_zones(
    start: int,
    end: int,
    color: HSBK,
    duration: float = 0.0,
    apply: MultiZoneApplicationRequest = APPLY,
) -> None
```

Set color for a range of zones.

| PARAMETER  | DESCRIPTION                                                                                                                                                                                                                                  |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `start`    | Start zone index (inclusive) **TYPE:** `int`                                                                                                                                                                                                 |
| `end`      | End zone index (inclusive) **TYPE:** `int`                                                                                                                                                                                                   |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                                                                                                                                                                           |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                                                                                                            |
| `apply`    | Application mode (default APPLY) - NO_APPLY: Don't apply immediately (use for batching) - APPLY: Apply this change and any pending changes - APPLY_ONLY: Apply only this change **TYPE:** `MultiZoneApplicationRequest` **DEFAULT:** `APPLY` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If zone indices are invalid            |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Set zones 0-9 to red
await light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))

# Set with transition
await light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)

# Batch updates
await light.set_color_zones(
    0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY
)
await light.set_color_zones(
    5, 9, color2, apply=MultiZoneApplicationRequest.APPLY
)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_color_zones(
    self,
    start: int,
    end: int,
    color: HSBK,
    duration: float = 0.0,
    apply: MultiZoneApplicationRequest = MultiZoneApplicationRequest.APPLY,
) -> None:
    """Set color for a range of zones.

    Args:
        start: Start zone index (inclusive)
        end: End zone index (inclusive)
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)
        apply: Application mode (default APPLY)
               - NO_APPLY: Don't apply immediately (use for batching)
               - APPLY: Apply this change and any pending changes
               - APPLY_ONLY: Apply only this change

    Raises:
        ValueError: If zone indices are invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Set zones 0-9 to red
        await light.set_color_zones(0, 9, HSBK.from_rgb(255, 0, 0))

        # Set with transition
        await light.set_color_zones(0, 9, HSBK.from_rgb(0, 255, 0), duration=2.0)

        # Batch updates
        await light.set_color_zones(
            0, 4, color1, apply=MultiZoneApplicationRequest.NO_APPLY
        )
        await light.set_color_zones(
            5, 9, color2, apply=MultiZoneApplicationRequest.APPLY
        )
        ```
    """
    if start < 0 or end < start:
        raise ValueError(
            f"Invalid zone range: {start}-{end}"
        )  # Convert to protocol HSBK
    protocol_color = color.to_protocol()

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    # Send request
    result = await self.connection.request(
        packets.MultiZone.SetColorZones(
            start_index=start,
            end_index=end,
            color=protocol_color,
            duration=duration_ms,
            apply=apply,
        ),
    )
    self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_color_zones",
            "action": "change",
            "values": {
                "start": start,
                "end": end,
                "color": {
                    "hue": color.hue,
                    "saturation": color.saturation,
                    "brightness": color.brightness,
                    "kelvin": color.kelvin,
                },
                "duration": duration_ms,
                "apply": apply.name,
            },
        }
    )
````

##### set_extended_color_zones

```python
set_extended_color_zones(
    zone_index: int,
    colors: list[HSBK],
    duration: float = 0.0,
    apply: MultiZoneApplicationRequest = APPLY,
    *,
    fast: bool = False,
) -> None
```

Set colors for multiple zones efficiently (up to 82 zones per call).

This is more efficient than set_color_zones when setting different colors for many zones at once.

| PARAMETER    | DESCRIPTION                                                                                                                                               |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `zone_index` | Starting zone index **TYPE:** `int`                                                                                                                       |
| `colors`     | List of HSBK colors to set (max 82) **TYPE:** `list[HSBK]`                                                                                                |
| `duration`   | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                         |
| `apply`      | Application mode (default APPLY) **TYPE:** `MultiZoneApplicationRequest` **DEFAULT:** `APPLY`                                                             |
| `fast`       | If True, send fire-and-forget without waiting for response. Use for high-frequency animations (>20 updates/second). **TYPE:** `bool` **DEFAULT:** `False` |

| RAISES                        | DESCRIPTION                                                   |
| ----------------------------- | ------------------------------------------------------------- |
| `ValueError`                  | If colors list is too long or zone index is invalid           |
| `LifxDeviceNotFoundError`     | If device is not connected                                    |
| `LifxTimeoutError`            | If device does not respond (only when fast=False)             |
| `LifxUnsupportedCommandError` | If device doesn't support this command (only when fast=False) |

Example

```python
# Create a rainbow effect across zones
colors = [
    HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)
    for i in range(10)
]
await light.set_extended_color_zones(0, colors)

# High-speed animation loop
for frame in animation_frames:
    await light.set_extended_color_zones(0, frame, fast=True)
    await asyncio.sleep(0.033)  # ~30 FPS
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_extended_color_zones(
    self,
    zone_index: int,
    colors: list[HSBK],
    duration: float = 0.0,
    apply: ExtendedAppReq = ExtendedAppReq.APPLY,
    *,
    fast: bool = False,
) -> None:
    """Set colors for multiple zones efficiently (up to 82 zones per call).

    This is more efficient than set_color_zones when setting different colors
    for many zones at once.

    Args:
        zone_index: Starting zone index
        colors: List of HSBK colors to set (max 82)
        duration: Transition duration in seconds (default 0.0)
        apply: Application mode (default APPLY)
        fast: If True, send fire-and-forget without waiting for response.
              Use for high-frequency animations (>20 updates/second).

    Raises:
        ValueError: If colors list is too long or zone index is invalid
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond (only when fast=False)
        LifxUnsupportedCommandError: If device doesn't support this command
            (only when fast=False)

    Example:
        ```python
        # Create a rainbow effect across zones
        colors = [
            HSBK(hue=i * 36, saturation=1.0, brightness=1.0, kelvin=3500)
            for i in range(10)
        ]
        await light.set_extended_color_zones(0, colors)

        # High-speed animation loop
        for frame in animation_frames:
            await light.set_extended_color_zones(0, frame, fast=True)
            await asyncio.sleep(0.033)  # ~30 FPS
        ```
    """
    if zone_index < 0:
        raise ValueError(f"Invalid zone index: {zone_index}")
    if len(colors) > 82:
        raise ValueError(f"Too many colors: {len(colors)} (max 82 per request)")
    if len(colors) == 0:
        raise ValueError("Colors list cannot be empty")

    # Convert to protocol HSBK
    protocol_colors = [color.to_protocol() for color in colors]

    # Pad to 82 colors if needed
    while len(protocol_colors) < 82:
        protocol_colors.append(HSBK(0, 0, 0, 3500).to_protocol())

    # Convert duration to milliseconds
    duration_ms = int(duration * 1000)

    packet = packets.MultiZone.SetExtendedColorZones(
        duration=duration_ms,
        apply=apply,
        index=zone_index,
        colors_count=len(colors),
        colors=protocol_colors,
    )

    if fast:
        # Fire-and-forget: no ack, no response, no waiting
        await self.connection.send_packet(
            packet,
            ack_required=False,
            res_required=False,
        )
    else:
        # Standard: wait for response and check for errors
        result = await self.connection.request(packet)
        self._raise_if_unhandled(result)

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_extended_color_zones",
            "action": "change",
            "values": {
                "zone_index": zone_index,
                "colors_count": len(colors),
                "colors": [
                    {
                        "hue": c.hue,
                        "saturation": c.saturation,
                        "brightness": c.brightness,
                        "kelvin": c.kelvin,
                    }
                    for c in colors
                ],
                "duration": duration_ms,
                "apply": apply.name,
                "fast": fast,
            },
        }
    )
````

##### get_effect

```python
get_effect() -> MultiZoneEffect
```

Get current multizone effect.

Always fetches from device. Use the `multizone_effect` property to access stored value.

| RETURNS           | DESCRIPTION                                                           |
| ----------------- | --------------------------------------------------------------------- |
| `MultiZoneEffect` | MultiZoneEffect with either FirmwareEffect.OFF or FirmwareEffect.MOVE |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxProtocolError`           | If response is invalid                 |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
from lifx.protocol.protocol_types import Direction, FirmwareEffect

effect = await light.get_effect()
if effect:
    print(f"Effect: {effect.effect_type.name}, Speed: {effect.speed}ms")
    if effect.effect_type == FirmwareEffect.MOVE:
        print(f"Direction: {effect.direction.name}")
```

Source code in `src/lifx/devices/multizone.py`

````python
async def get_effect(self) -> MultiZoneEffect:
    """Get current multizone effect.

    Always fetches from device.
    Use the `multizone_effect` property to access stored value.

    Returns:
        MultiZoneEffect with either FirmwareEffect.OFF or FirmwareEffect.MOVE

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxProtocolError: If response is invalid
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        from lifx.protocol.protocol_types import Direction, FirmwareEffect

        effect = await light.get_effect()
        if effect:
            print(f"Effect: {effect.effect_type.name}, Speed: {effect.speed}ms")
            if effect.effect_type == FirmwareEffect.MOVE:
                print(f"Direction: {effect.direction.name}")
        ```
    """
    # Request automatically unpacks response
    state = await self.connection.request(packets.MultiZone.GetEffect())
    self._raise_if_unhandled(state)

    settings = state.settings
    effect_type = settings.effect_type

    # Extract parameters from the settings parameter field
    parameters = [
        settings.parameter.parameter0,
        settings.parameter.parameter1,
        settings.parameter.parameter2,
        settings.parameter.parameter3,
        settings.parameter.parameter4,
        settings.parameter.parameter5,
        settings.parameter.parameter6,
        settings.parameter.parameter7,
    ]

    result = MultiZoneEffect(
        effect_type=effect_type,
        speed=settings.speed,
        duration=settings.duration,
        parameters=parameters,
    )

    self._multizone_effect = result

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "effect"):
        self._state.effect = result.effect_type
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "get_effect",
            "action": "query",
            "reply": {
                "effect_type": effect_type.name,
                "speed": settings.speed,
                "duration": settings.duration,
                "parameters": parameters,
            },
        }
    )

    return result
````

##### set_effect

```python
set_effect(effect: MultiZoneEffect) -> None
```

Set multizone effect.

| PARAMETER | DESCRIPTION                                                |
| --------- | ---------------------------------------------------------- |
| `effect`  | MultiZone effect configuration **TYPE:** `MultiZoneEffect` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
from lifx.protocol.protocol_types import Direction, FirmwareEffect

# Apply a move effect moving forward
effect = MultiZoneEffect(
    effect_type=FirmwareEffect.MOVE,
    speed=5000,  # 5 seconds per cycle
    duration=0,  # Infinite
)
effect.direction = Direction.FORWARD
await light.set_effect(effect)

# Or use parameters directly
effect = MultiZoneEffect(
    effect_type=FirmwareEffect.MOVE,
    speed=5000,
    parameters=[0, int(Direction.REVERSED), 0, 0, 0, 0, 0, 0],
)
await light.set_effect(effect)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def set_effect(
    self,
    effect: MultiZoneEffect,
) -> None:
    """Set multizone effect.

    Args:
        effect: MultiZone effect configuration

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        from lifx.protocol.protocol_types import Direction, FirmwareEffect

        # Apply a move effect moving forward
        effect = MultiZoneEffect(
            effect_type=FirmwareEffect.MOVE,
            speed=5000,  # 5 seconds per cycle
            duration=0,  # Infinite
        )
        effect.direction = Direction.FORWARD
        await light.set_effect(effect)

        # Or use parameters directly
        effect = MultiZoneEffect(
            effect_type=FirmwareEffect.MOVE,
            speed=5000,
            parameters=[0, int(Direction.REVERSED), 0, 0, 0, 0, 0, 0],
        )
        await light.set_effect(effect)
        ```
    """  # Ensure parameters list is 8 elements
    parameters = effect.parameters or [0] * 8
    if len(parameters) < 8:
        parameters.extend([0] * (8 - len(parameters)))
    parameters = parameters[:8]

    # Send request
    result = await self.connection.request(
        packets.MultiZone.SetEffect(
            settings=MultiZoneEffectSettings(
                instanceid=0,  # 0 for new effect
                effect_type=effect.effect_type,
                speed=effect.speed,
                duration=effect.duration,
                parameter=MultiZoneEffectParameter(
                    parameter0=parameters[0],
                    parameter1=parameters[1],
                    parameter2=parameters[2],
                    parameter3=parameters[3],
                    parameter4=parameters[4],
                    parameter5=parameters[5],
                    parameter6=parameters[6],
                    parameter7=parameters[7],
                ),
            ),
        ),
    )
    self._raise_if_unhandled(result)

    # Update cached state
    cached_effect = effect if effect.effect_type != FirmwareEffect.OFF else None
    self._multizone_effect = cached_effect

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "set_effect",
            "action": "change",
            "values": {
                "effect_type": effect.effect_type.name,
                "speed": effect.speed,
                "duration": effect.duration,
                "parameters": parameters,
            },
        }
    )
````

##### stop_effect

```python
stop_effect() -> None
```

Stop any running multizone effect.

Example

```python
await light.stop_effect()
```

Source code in `src/lifx/devices/multizone.py`

````python
async def stop_effect(self) -> None:
    """Stop any running multizone effect.

    Example:
        ```python
        await light.stop_effect()
        ```
    """
    await self.set_effect(
        MultiZoneEffect(
            effect_type=FirmwareEffect.OFF,
            speed=0,
            duration=0,
        )
    )

    _LOGGER.debug(
        {
            "class": "Device",
            "method": "stop_effect",
            "action": "change",
            "values": {},
        }
    )
````

##### apply_theme

```python
apply_theme(
    theme: Theme,
    power_on: bool = False,
    duration: float = 0,
    strategy: str | None = None,
) -> None
```

Apply a theme across zones.

Distributes theme colors evenly across the light's zones with smooth color blending between theme colors.

| PARAMETER  | DESCRIPTION                                                            |
| ---------- | ---------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                       |
| `power_on` | Turn on the light **TYPE:** `bool` **DEFAULT:** `False`                |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0`      |
| `strategy` | Color distribution strategy (not used yet, for future) **TYPE:** \`str |

Example

```python
from lifx.theme import get_theme

theme = get_theme("evening")
await strip.apply_theme(theme, power_on=True, duration=0.5)
```

Source code in `src/lifx/devices/multizone.py`

````python
async def apply_theme(
    self,
    theme: Theme,
    power_on: bool = False,
    duration: float = 0,
    strategy: str | None = None,
) -> None:
    """Apply a theme across zones.

    Distributes theme colors evenly across the light's zones with smooth
    color blending between theme colors.

    Args:
        theme: Theme to apply
        power_on: Turn on the light
        duration: Transition duration in seconds
        strategy: Color distribution strategy (not used yet, for future)

    Example:
        ```python
        from lifx.theme import get_theme

        theme = get_theme("evening")
        await strip.apply_theme(theme, power_on=True, duration=0.5)
        ```
    """
    from lifx.theme.generators import MultiZoneGenerator

    # Get number of zones
    zone_count = await self.get_zone_count()

    # Use proper multizone generator with blending
    generator = MultiZoneGenerator()
    colors = generator.get_theme_colors(theme, zone_count)

    # Check if light is on
    is_on = await self.get_power()

    # Apply colors to zones using extended format for efficiency
    # If light is off and we're turning it on, set colors immediately then fade on
    if power_on and not is_on:
        await self.set_extended_color_zones(0, colors, duration=0)
        await self.set_power(True, duration=duration)
    else:
        # Light is already on, or we're not turning it on - apply with duration
        await self.set_extended_color_zones(0, colors, duration=duration)
````

##### refresh_state

```python
refresh_state() -> None
```

Refresh multizone light state from hardware.

Fetches color, zones, and effect.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/multizone.py`

```python
async def refresh_state(self) -> None:
    """Refresh multizone light state from hardware.

    Fetches color, zones, and effect.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    await super().refresh_state()

    async with asyncio.TaskGroup() as tg:
        zones_task = tg.create_task(self.get_all_color_zones())
        effect_task = tg.create_task(self.get_effect())

    zones = zones_task.result()
    effect = effect_task.result()

    self._state.zones = zones
    self._state.effect = effect.effect_type
```

### MultiZoneLightState

MultiZone light device state dataclass returned by `MultiZoneLight.state`.

#### MultiZoneLightState

```python
MultiZoneLightState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
    color: HSBK,
    zones: list[HSBK],
    zone_count: int,
    effect: FirmwareEffect,
)
```

Bases: `LightState`

MultiZone light device state with zone-based control.

| ATTRIBUTE    | DESCRIPTION                                                       |
| ------------ | ----------------------------------------------------------------- |
| `zones`      | List of HSBK colors for each zone **TYPE:** `list[HSBK]`          |
| `zone_count` | Total number of zones **TYPE:** `int`                             |
| `effect`     | Current multizone effect configuration **TYPE:** `FirmwareEffect` |

| METHOD             | DESCRIPTION                              |
| ------------------ | ---------------------------------------- |
| `from_light_state` | Create MatrixLightState from LightState. |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return MultiZoneLightState as dict.

##### Functions

###### from_light_state

```python
from_light_state(
    light_state: LightState, zones: list[HSBK], effect: FirmwareEffect
) -> MultiZoneLightState
```

Create MatrixLightState from LightState.

Source code in `src/lifx/devices/multizone.py`

```python
@classmethod
def from_light_state(
    cls,
    light_state: LightState,
    zones: list[HSBK],
    effect: FirmwareEffect,
) -> MultiZoneLightState:
    """Create MatrixLightState from LightState."""
    return cls(
        model=light_state.model,
        label=light_state.label,
        serial=light_state.serial,
        mac_address=light_state.mac_address,
        power=light_state.power,
        capabilities=light_state.capabilities,
        host_firmware=light_state.host_firmware,
        wifi_firmware=light_state.wifi_firmware,
        location=light_state.location,
        group=light_state.group,
        color=light_state.color,
        zones=zones,
        zone_count=len(zones),
        effect=effect,
        last_updated=time.time(),
    )
```

### MultiZoneEffect

Configuration dataclass for multizone effects (MOVE). Used with `MultiZoneLight.set_effect()` and returned by `MultiZoneLight.get_effect()`.

#### MultiZoneEffect

```python
MultiZoneEffect(
    effect_type: FirmwareEffect,
    speed: int,
    duration: int = 0,
    parameters: list[int] | None = None,
)
```

MultiZone effect configuration.

| ATTRIBUTE     | DESCRIPTION                                                        |
| ------------- | ------------------------------------------------------------------ |
| `effect_type` | Type of effect (OFF, MOVE) **TYPE:** `FirmwareEffect`              |
| `speed`       | Effect speed in milliseconds **TYPE:** `int`                       |
| `duration`    | Total effect duration (0 for infinite) **TYPE:** `int`             |
| `parameters`  | Effect-specific parameters (8 uint32 values) **TYPE:** \`list[int] |

##### Attributes

###### direction

```python
direction: Direction | None
```

Get direction for MOVE effect.

| RETURNS     | DESCRIPTION |
| ----------- | ----------- |
| \`Direction | None\`      |

## Matrix Light

The `MatrixLight` class controls LIFX matrix devices (tiles, candle, path) with 2D zone control.

### MatrixLight

```python
MatrixLight(*args, **kwargs)
```

Bases: `Light`

LIFX Matrix Light Device.

MatrixLight devices have 2D arrays of controllable color zones arranged in tiles. Most MatrixLight devices (LIFX Candle, LIFX Path) have a single tile. The discontinued LIFX Tile product supported up to 5 tiles in a chain (has_chain).

Zone Addressing:

- Colors are applied row-by-row starting at top-left (0,0)
- For tiles 64 zones: Single set64() call to frame buffer 0
- For tiles >64 zones (e.g., 16x8 = 128 zones):

1. First set64(): rect=(0,0), 64 colors, frame buffer 1
1. Second set64(): rect=(0,4), 64 colors, frame buffer 1
1. copy_frame_buffer(): Copy buffer 1  buffer 0

Example

> > > async with await MatrixLight.from_ip("192.168.1.100") as matrix: ... # Get device chain info ... chain = await matrix.get_device_chain() ... print(f"Device has {len(chain)} tile(s)") ... ... # Set colors on first tile (8x8 = 64 zones) ... colors = [HSBK.from_rgb(255, 0, 0)] * 64 ... await matrix.set64(tile_index=0, colors=colors, width=8)

See :class:`Light` for parameter documentation.

| METHOD                | DESCRIPTION                                                               |
| --------------------- | ------------------------------------------------------------------------- |
| `get_device_chain`    | Get device chain details (list of Tile objects).                          |
| `set_user_position`   | Position tiles in the chain (only for devices with has_chain capability). |
| `get64`               | Get up to 64 zones of color state from a tile.                            |
| `get_all_tile_colors` | Get colors for all tiles in the chain.                                    |
| `set64`               | Set up to 64 zones of color on a tile.                                    |
| `copy_frame_buffer`   | Copy frame buffer (for tiles with >64 zones).                             |
| `set_matrix_colors`   | Convenience method to set all colors on a tile.                           |
| `get_effect`          | Get current running matrix effect.                                        |
| `set_effect`          | Set matrix effect with configuration.                                     |
| `apply_theme`         | Apply a theme across matrix tiles using Canvas interpolation.             |
| `refresh_state`       | Refresh matrix light state from hardware.                                 |

| ATTRIBUTE      | DESCRIPTION                                                                                   |
| -------------- | --------------------------------------------------------------------------------------------- |
| `state`        | Get matrix light state (guaranteed when using Device.connect()). **TYPE:** `MatrixLightState` |
| `device_chain` | Get cached device chain. **TYPE:** \`list[TileInfo]                                           |
| `tile_count`   | Get number of tiles in the chain. **TYPE:** \`int                                             |
| `tile_effect`  | Get cached tile effect. **TYPE:** \`MatrixEffect                                              |

Source code in `src/lifx/devices/matrix.py`

```python
def __init__(self, *args, **kwargs) -> None:
    """Initialize MatrixLight device.

    See :class:`Light` for parameter documentation.
    """
    super().__init__(*args, **kwargs)
    # Matrix specific properties
    self._device_chain: list[TileInfo] | None = None
    self._tile_effect: MatrixEffect | None = None
```

#### Attributes

##### state

```python
state: MatrixLightState
```

Get matrix light state (guaranteed when using Device.connect()).

| RETURNS            | DESCRIPTION                                      |
| ------------------ | ------------------------------------------------ |
| `MatrixLightState` | MatrixLightState with current matrix light state |

| RAISES         | DESCRIPTION                             |
| -------------- | --------------------------------------- |
| `RuntimeError` | If accessed before state initialization |

##### device_chain

```python
device_chain: list[TileInfo] | None
```

Get cached device chain.

Returns None if not yet fetched. Use get_device_chain() to fetch.

##### tile_count

```python
tile_count: int | None
```

Get number of tiles in the chain.

Returns None if device chain not yet fetched.

##### tile_effect

```python
tile_effect: MatrixEffect | None
```

Get cached tile effect.

Returns None if not yet fetched. Use get_tile_effect() to fetch.

#### Functions

##### get_device_chain

```python
get_device_chain() -> list[TileInfo]
```

Get device chain details (list of Tile objects).

This method fetches the device chain information and caches it.

| RETURNS          | DESCRIPTION                                                |
| ---------------- | ---------------------------------------------------------- |
| `list[TileInfo]` | List of TileInfo objects describing each tile in the chain |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

> > > chain = await matrix.get_device_chain() for tile in chain: ... print(f"Tile {tile.tile_index}: {tile.width}x{tile.height}")

Source code in `src/lifx/devices/matrix.py`

```python
async def get_device_chain(self) -> list[TileInfo]:
    """Get device chain details (list of Tile objects).

    This method fetches the device chain information and caches it.

    Returns:
        List of TileInfo objects describing each tile in the chain

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        >>> chain = await matrix.get_device_chain()
        >>> for tile in chain:
        ...     print(f"Tile {tile.tile_index}: {tile.width}x{tile.height}")
    """
    _LOGGER.debug("Getting device chain for %s", self.label or self.serial)

    response: packets.Tile.StateDeviceChain = await self.connection.request(
        packets.Tile.GetDeviceChain()
    )
    self._raise_if_unhandled(response)

    # Parse tiles from response
    tiles = []
    for i, protocol_tile in enumerate(response.tile_devices):
        # Stop at first zero-width tile (indicates end of chain)
        if protocol_tile.width == 0:
            break
        tiles.append(TileInfo.from_protocol(i, protocol_tile))

    self._device_chain = tiles

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "chain"):
        self._state.chain = tiles
        self._state.tile_count = len(tiles)
        self._state.last_updated = __import__("time").time()

    _LOGGER.debug("Device chain has %d tile(s)", len(tiles))
    return tiles
```

##### set_user_position

```python
set_user_position(tile_index: int, user_x: float, user_y: float) -> None
```

Position tiles in the chain (only for devices with has_chain capability).

| PARAMETER    | DESCRIPTION                                             |
| ------------ | ------------------------------------------------------- |
| `tile_index` | Index of the tile to position (0-based) **TYPE:** `int` |
| `user_x`     | User-defined X position **TYPE:** `float`               |
| `user_y`     | User-defined Y position **TYPE:** `float`               |

Note

Only applicable for multi-tile devices (has_chain capability). Most MatrixLight devices have a single tile and don't need positioning.

Example

> > > ###### Position second tile at coordinates (1.0, 0.0)
> > >
> > > await matrix.set_user_position(tile_index=1, user_x=1.0, user_y=0.0)

Source code in `src/lifx/devices/matrix.py`

```python
async def set_user_position(
    self, tile_index: int, user_x: float, user_y: float
) -> None:
    """Position tiles in the chain (only for devices with has_chain capability).

    Args:
        tile_index: Index of the tile to position (0-based)
        user_x: User-defined X position
        user_y: User-defined Y position

    Note:
        Only applicable for multi-tile devices (has_chain capability).
        Most MatrixLight devices have a single tile and don't need positioning.

    Example:
        >>> # Position second tile at coordinates (1.0, 0.0)
        >>> await matrix.set_user_position(tile_index=1, user_x=1.0, user_y=0.0)
    """
    _LOGGER.debug(
        "Setting tile %d position to (%f, %f) for %s",
        tile_index,
        user_x,
        user_y,
        self.label or self.serial,
    )

    await self.connection.send_packet(
        packets.Tile.SetUserPosition(
            tile_index=tile_index,
            user_x=user_x,
            user_y=user_y,
        )
    )
```

##### get64

```python
get64(
    tile_index: int = 0,
    length: int = 1,
    x: int = 0,
    y: int = 0,
    width: int | None = None,
) -> list[HSBK]
```

Get up to 64 zones of color state from a tile.

For devices with 64 zones, returns all zones. For devices with >64 zones, returns up to 64 zones due to protocol limitations.

| PARAMETER    | DESCRIPTION                                                                              |
| ------------ | ---------------------------------------------------------------------------------------- |
| `tile_index` | Index of the tile (0-based). Defaults to 0. **TYPE:** `int` **DEFAULT:** `0`             |
| `length`     | Number of tiles to query (usually 1). Defaults to 1. **TYPE:** `int` **DEFAULT:** `1`    |
| `x`          | X coordinate of the rectangle (0-based). Defaults to 0. **TYPE:** `int` **DEFAULT:** `0` |
| `y`          | Y coordinate of the rectangle (0-based). Defaults to 0. **TYPE:** `int` **DEFAULT:** `0` |
| `width`      | Width of the rectangle in zones. Defaults to tile width. **TYPE:** \`int                 |

| RETURNS      | DESCRIPTION                                                               |
| ------------ | ------------------------------------------------------------------------- |
| `list[HSBK]` | List of HSBK colors for the requested zones. For tiles with 64 zones,    |
| `list[HSBK]` | returns the actual zone count (e.g., 64 for 8x8, 16 for 4x4). For tiles   |
| `list[HSBK]` | with >64 zones (e.g., 128 for 16x8 Ceiling), returns 64 (protocol limit). |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

> > > ###### Get all colors from first tile (no parameters needed)
> > >
> > > colors = await matrix.get64()
> > >
> > > ###### Get colors from specific region
> > >
> > > colors = await matrix.get64(y=4) # Start at row 4

Source code in `src/lifx/devices/matrix.py`

```python
async def get64(
    self,
    tile_index: int = 0,
    length: int = 1,
    x: int = 0,
    y: int = 0,
    width: int | None = None,
) -> list[HSBK]:
    """Get up to 64 zones of color state from a tile.

    For devices with 64 zones, returns all zones. For devices with >64 zones,
    returns up to 64 zones due to protocol limitations.

    Args:
        tile_index: Index of the tile (0-based). Defaults to 0.
        length: Number of tiles to query (usually 1). Defaults to 1.
        x: X coordinate of the rectangle (0-based). Defaults to 0.
        y: Y coordinate of the rectangle (0-based). Defaults to 0.
        width: Width of the rectangle in zones. Defaults to tile width.

    Returns:
        List of HSBK colors for the requested zones. For tiles with 64 zones,
        returns the actual zone count (e.g., 64 for 8x8, 16 for 4x4). For tiles
        with >64 zones (e.g., 128 for 16x8 Ceiling), returns 64 (protocol limit).

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        >>> # Get all colors from first tile (no parameters needed)
        >>> colors = await matrix.get64()
        >>>
        >>> # Get colors from specific region
        >>> colors = await matrix.get64(y=4)  # Start at row 4
    """
    # Validate parameters
    if x < 0:
        raise ValueError(f"x coordinate must be non-negative, got {x}")
    if y < 0:
        raise ValueError(f"y coordinate must be non-negative, got {y}")
    if width is not None and width <= 0:
        raise ValueError(f"width must be positive, got {width}")

    if self._device_chain is None:
        device_chain = await self.get_device_chain()
    else:
        device_chain = self._device_chain

    if width is None:
        width = device_chain[0].width

    _LOGGER.debug(
        "Getting 64 zones from tile %d (x=%d, y=%d, width=%d) for %s",
        tile_index,
        x,
        y,
        width,
        self.label or self.serial,
    )

    response: packets.Tile.State64 = await self.connection.request(
        packets.Tile.Get64(
            tile_index=tile_index,
            length=length,
            rect=TileBufferRect(fb_index=0, x=x, y=y, width=width),
        )
    )
    self._raise_if_unhandled(response)

    max_colors = device_chain[0].width * device_chain[0].height

    # Convert protocol colors to HSBK
    result = [
        HSBK.from_protocol(proto_color)
        for proto_color in response.colors[:max_colors]
    ]

    # Update state if it exists and we fetched all colors from tile 0
    if self._state is not None and hasattr(self._state, "tile_colors"):
        if tile_index == 0 and x == 0 and y == 0 and len(result) == max_colors:
            self._state.tile_colors = result
            self._state.last_updated = __import__("time").time()

    return result
```

##### get_all_tile_colors

```python
get_all_tile_colors() -> list[list[HSBK]]
```

Get colors for all tiles in the chain.

Fetches colors from each tile in the device chain and returns them as a list of color lists (one per tile). This is the matrix equivalent of MultiZoneLight's get_all_color_zones().

For tiles with >64 zones (e.g., 16x8 Ceiling with 128 zones), makes multiple Get64 requests to fetch all colors.

Always fetches from device. Tiles are queried sequentially to avoid overwhelming the device with concurrent requests.

| RETURNS            | DESCRIPTION                                                        |
| ------------------ | ------------------------------------------------------------------ |
| `list[list[HSBK]]` | List of color lists, one per tile. Each inner list contains        |
| `list[list[HSBK]]` | all colors for that tile (64 for 8x8 tiles, 128 for 16x8 Ceiling). |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Get colors for all tiles
all_colors = await matrix.get_all_tile_colors()
print(f"Device has {len(all_colors)} tiles")
for i, tile_colors in enumerate(all_colors):
    print(f"Tile {i}: {len(tile_colors)} colors")

# Flatten to single list if needed
flat_colors = [c for tile in all_colors for c in tile]
```

Source code in `src/lifx/devices/matrix.py`

````python
async def get_all_tile_colors(self) -> list[list[HSBK]]:
    """Get colors for all tiles in the chain.

    Fetches colors from each tile in the device chain and returns them
    as a list of color lists (one per tile). This is the matrix equivalent
    of MultiZoneLight's get_all_color_zones().

    For tiles with >64 zones (e.g., 16x8 Ceiling with 128 zones), makes
    multiple Get64 requests to fetch all colors.

    Always fetches from device. Tiles are queried sequentially to avoid
    overwhelming the device with concurrent requests.

    Returns:
        List of color lists, one per tile. Each inner list contains
        all colors for that tile (64 for 8x8 tiles, 128 for 16x8 Ceiling).

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Get colors for all tiles
        all_colors = await matrix.get_all_tile_colors()
        print(f"Device has {len(all_colors)} tiles")
        for i, tile_colors in enumerate(all_colors):
            print(f"Tile {i}: {len(tile_colors)} colors")

        # Flatten to single list if needed
        flat_colors = [c for tile in all_colors for c in tile]
        ```
    """
    # Get device chain (use cached if available)
    if self._device_chain is None:
        device_chain = await self.get_device_chain()
    else:
        device_chain = self._device_chain

    # Fetch colors from each tile sequentially
    all_colors: list[list[HSBK]] = []
    for tile in device_chain:
        tile_zone_count = tile.width * tile.height

        if tile_zone_count <= 64:
            # Single request for tiles with 64 zones
            tile_colors = await self.get64(tile_index=tile.tile_index)
            all_colors.append(tile_colors)
        else:
            # Multiple requests for tiles with >64 zones (e.g., 16x8 Ceiling)
            # Split into multiple 64-zone requests by row
            tile_colors = []
            rows_per_request = 64 // tile.width  # e.g., 64/16 = 4 rows

            for y_offset in range(0, tile.height, rows_per_request):
                chunk = await self.get64(
                    tile_index=tile.tile_index,
                    x=0,
                    y=y_offset,
                    width=tile.width,
                )
                tile_colors.extend(chunk)

            all_colors.append(tile_colors)

    # Update state if it exists (flatten for state storage)
    if self._state is not None and hasattr(self._state, "tile_colors"):
        flat_colors = [c for tile_colors in all_colors for c in tile_colors]
        self._state.tile_colors = flat_colors
        self._state.last_updated = time.time()

    return all_colors
````

##### set64

```python
set64(
    tile_index: int,
    length: int,
    x: int,
    y: int,
    width: int,
    duration: int,
    colors: list[HSBK],
    fb_index: int = 0,
) -> None
```

Set up to 64 zones of color on a tile.

Colors are applied row-by-row starting at position (x, y). For tiles >64 zones, use multiple set64() calls with copy_frame_buffer().

| PARAMETER    | DESCRIPTION                                                                            |
| ------------ | -------------------------------------------------------------------------------------- |
| `tile_index` | Index of the tile (0-based) **TYPE:** `int`                                            |
| `length`     | Number of tiles to update (usually 1) **TYPE:** `int`                                  |
| `x`          | X coordinate of the rectangle (0-based) **TYPE:** `int`                                |
| `y`          | Y coordinate of the rectangle (0-based) **TYPE:** `int`                                |
| `width`      | Width of the rectangle in zones **TYPE:** `int`                                        |
| `duration`   | Transition duration in milliseconds **TYPE:** `int`                                    |
| `colors`     | List of HSBK colors (up to 64) **TYPE:** `list[HSBK]`                                  |
| `fb_index`   | Frame buffer index (0 for display, 1 for temp buffer) **TYPE:** `int` **DEFAULT:** `0` |

Example

> > > ###### Set 8x8 tile to red
> > >
> > > colors = [HSBK.from_rgb(255, 0, 0)] * 64 await matrix.set64( ... tile_index=0, length=1, x=0, y=0, width=8, duration=0, colors=colors ... )

Source code in `src/lifx/devices/matrix.py`

```python
async def set64(
    self,
    tile_index: int,
    length: int,
    x: int,
    y: int,
    width: int,
    duration: int,
    colors: list[HSBK],
    fb_index: int = 0,
) -> None:
    """Set up to 64 zones of color on a tile.

    Colors are applied row-by-row starting at position (x, y).
    For tiles >64 zones, use multiple set64() calls with copy_frame_buffer().

    Args:
        tile_index: Index of the tile (0-based)
        length: Number of tiles to update (usually 1)
        x: X coordinate of the rectangle (0-based)
        y: Y coordinate of the rectangle (0-based)
        width: Width of the rectangle in zones
        duration: Transition duration in milliseconds
        colors: List of HSBK colors (up to 64)
        fb_index: Frame buffer index (0 for display, 1 for temp buffer)

    Example:
        >>> # Set 8x8 tile to red
        >>> colors = [HSBK.from_rgb(255, 0, 0)] * 64
        >>> await matrix.set64(
        ...     tile_index=0, length=1, x=0, y=0, width=8, duration=0, colors=colors
        ... )
    """
    # Validate parameters
    if x < 0:
        raise ValueError(f"x coordinate must be non-negative, got {x}")
    if y < 0:
        raise ValueError(f"y coordinate must be non-negative, got {y}")
    if width <= 0:
        raise ValueError(f"width must be positive, got {width}")

    _LOGGER.debug(
        "Setting 64 zones on tile %d (x=%d, y=%d, width=%d, fb=%d, "
        "duration=%d) for %s",
        tile_index,
        x,
        y,
        width,
        fb_index,
        duration,
        self.label or self.serial,
    )

    # Convert HSBK colors to protocol format
    proto_colors = []
    for color in colors:
        proto_colors.append(
            LightHsbk(
                hue=int(color.hue / 360 * 65535),
                saturation=int(color.saturation * 65535),
                brightness=int(color.brightness * 65535),
                kelvin=color.kelvin,
            )
        )

    # Pad to 64 colors if needed
    while len(proto_colors) < 64:
        proto_colors.append(LightHsbk(0, 0, 0, 3500))

    await self.connection.send_packet(
        packets.Tile.Set64(
            tile_index=tile_index,
            length=length,
            rect=TileBufferRect(fb_index=fb_index, x=x, y=y, width=width),
            duration=duration,
            colors=proto_colors,
        )
    )
```

##### copy_frame_buffer

```python
copy_frame_buffer(
    tile_index: int,
    source_fb: int = 1,
    target_fb: int = 0,
    duration: float = 0.0,
    length: int = 1,
) -> None
```

Copy frame buffer (for tiles with >64 zones).

This is used for tiles with more than 64 zones. After setting colors in the temporary buffer (fb=1), copy to the display buffer (fb=0).

| PARAMETER    | DESCRIPTION                                                                                     |
| ------------ | ----------------------------------------------------------------------------------------------- |
| `tile_index` | Index of the tile (0-based) **TYPE:** `int`                                                     |
| `source_fb`  | Source frame buffer index (usually 1) **TYPE:** `int` **DEFAULT:** `1`                          |
| `target_fb`  | Target frame buffer index (usually 0) **TYPE:** `int` **DEFAULT:** `0`                          |
| `duration`   | time in seconds to transition if target_fb is 0 **TYPE:** `float` **DEFAULT:** `0.0`            |
| `length`     | Number of tiles to update starting from tile_index (default 1) **TYPE:** `int` **DEFAULT:** `1` |

Example

> > > ###### For 16x8 tile (128 zones):
> > >
> > > ###### 1. Set first 64 zones to buffer 1
> > >
> > > await matrix.set64( ... tile_index=0, ... length=1, ... x=0, ... y=0, ... width=16, ... duration=0, ... colors=colors[:64], ... fb_index=1, ... )
> > >
> > > ###### 2. Set second 64 zones to buffer 1
> > >
> > > await matrix.set64( ... tile_index=0, ... length=1, ... x=0, ... y=4, ... width=16, ... duration=0, ... colors=colors[64:], ... fb_index=1, ... )
> > >
> > > ###### 3. Copy buffer 1 to buffer 0 (display)
> > >
> > > await matrix.copy_frame_buffer( ... tile_index=0, source_fb=1, target_fb=0, duration=2.0 ... )
> > >
> > > ###### For a chain of 5 tiles, update all simultaneously:
> > >
> > > await matrix.copy_frame_buffer( ... tile_index=0, source_fb=1, target_fb=0, length=5 ... )

Source code in `src/lifx/devices/matrix.py`

```python
async def copy_frame_buffer(
    self,
    tile_index: int,
    source_fb: int = 1,
    target_fb: int = 0,
    duration: float = 0.0,
    length: int = 1,
) -> None:
    """Copy frame buffer (for tiles with >64 zones).

    This is used for tiles with more than 64 zones. After setting colors
    in the temporary buffer (fb=1), copy to the display buffer (fb=0).

    Args:
        tile_index: Index of the tile (0-based)
        source_fb: Source frame buffer index (usually 1)
        target_fb: Target frame buffer index (usually 0)
        duration: time in seconds to transition if target_fb is 0
        length: Number of tiles to update starting from tile_index (default 1)

    Example:
        >>> # For 16x8 tile (128 zones):
        >>> # 1. Set first 64 zones to buffer 1
        >>> await matrix.set64(
        ...     tile_index=0,
        ...     length=1,
        ...     x=0,
        ...     y=0,
        ...     width=16,
        ...     duration=0,
        ...     colors=colors[:64],
        ...     fb_index=1,
        ... )
        >>> # 2. Set second 64 zones to buffer 1
        >>> await matrix.set64(
        ...     tile_index=0,
        ...     length=1,
        ...     x=0,
        ...     y=4,
        ...     width=16,
        ...     duration=0,
        ...     colors=colors[64:],
        ...     fb_index=1,
        ... )
        >>> # 3. Copy buffer 1 to buffer 0 (display)
        >>> await matrix.copy_frame_buffer(
        ...     tile_index=0, source_fb=1, target_fb=0, duration=2.0
        ... )

        >>> # For a chain of 5 tiles, update all simultaneously:
        >>> await matrix.copy_frame_buffer(
        ...     tile_index=0, source_fb=1, target_fb=0, length=5
        ... )
    """
    _LOGGER.debug(
        "Copying frame buffer %d -> %d for tile %d (length=%d) on %s",
        source_fb,
        target_fb,
        tile_index,
        length,
        self.label or self.serial,
    )

    # Get tile dimensions for the copy operation
    if self._device_chain is None:
        await self.get_device_chain()

    if self._device_chain is None or tile_index >= len(self._device_chain):
        raise ValueError(f"Invalid tile_index {tile_index}")

    tile = self._device_chain[tile_index]
    duration_ms = round(duration * 1000 if duration else 0)

    await self.connection.send_packet(
        packets.Tile.CopyFrameBuffer(
            tile_index=tile_index,
            length=length,
            src_fb_index=source_fb,
            dst_fb_index=target_fb,
            src_x=0,
            src_y=0,
            dst_x=0,
            dst_y=0,
            width=tile.width,
            height=tile.height,
            duration=duration_ms,
        )
    )
```

##### set_matrix_colors

```python
set_matrix_colors(
    tile_index: int, colors: list[HSBK], duration: int = 0
) -> None
```

Convenience method to set all colors on a tile.

If all colors are the same, uses SetColor() packet which sets all zones across all tiles. Otherwise, automatically handles tiles with >64 zones using frame buffer strategy.

| PARAMETER    | DESCRIPTION                                                                     |
| ------------ | ------------------------------------------------------------------------------- |
| `tile_index` | Index of the tile (0-based) **TYPE:** `int`                                     |
| `colors`     | List of HSBK colors (length must match tile total_zones) **TYPE:** `list[HSBK]` |
| `duration`   | Transition duration in milliseconds **TYPE:** `int` **DEFAULT:** `0`            |

Example

> > > ###### Set entire tile to solid red (uses SetColor packet)
> > >
> > > colors = [HSBK.from_rgb(255, 0, 0)] * 64 await matrix.set_matrix_colors(tile_index=0, colors=colors)
> > >
> > > ###### Set 8x8 tile to gradient (uses set64 with zones)
> > >
> > > colors = [HSBK(i * 360 / 64, 1.0, 1.0, 3500) for i in range(64)] await matrix.set_matrix_colors(tile_index=0, colors=colors)

Source code in `src/lifx/devices/matrix.py`

```python
async def set_matrix_colors(
    self, tile_index: int, colors: list[HSBK], duration: int = 0
) -> None:
    """Convenience method to set all colors on a tile.

    If all colors are the same, uses SetColor() packet which sets all zones
    across all tiles. Otherwise, automatically handles tiles with >64 zones
    using frame buffer strategy.

    Args:
        tile_index: Index of the tile (0-based)
        colors: List of HSBK colors (length must match tile total_zones)
        duration: Transition duration in milliseconds

    Example:
        >>> # Set entire tile to solid red (uses SetColor packet)
        >>> colors = [HSBK.from_rgb(255, 0, 0)] * 64
        >>> await matrix.set_matrix_colors(tile_index=0, colors=colors)

        >>> # Set 8x8 tile to gradient (uses set64 with zones)
        >>> colors = [HSBK(i * 360 / 64, 1.0, 1.0, 3500) for i in range(64)]
        >>> await matrix.set_matrix_colors(tile_index=0, colors=colors)
    """
    # Get device chain to determine tile dimensions
    if self._device_chain is None:
        await self.get_device_chain()

    if not self._device_chain or tile_index >= len(self._device_chain):
        raise ValueError(f"Invalid tile_index: {tile_index}")

    tile = self._device_chain[tile_index]

    if len(colors) != tile.total_zones:
        raise ValueError(
            f"Color count mismatch: expected {tile.total_zones}, got {len(colors)}"
        )

    # Check if all colors are the same
    first_color = colors[0]
    all_same = all(
        c.hue == first_color.hue
        and c.saturation == first_color.saturation
        and c.brightness == first_color.brightness
        and c.kelvin == first_color.kelvin
        for c in colors
    )

    if all_same:
        # All zones same color - use SetColor packet (much faster!)
        _LOGGER.debug(
            "All zones same color, using SetColor packet for tile %d",
            tile_index,
        )
        await self.set_color(first_color, duration=duration / 1000.0)
        return

    if tile.requires_frame_buffer:
        # Tile has >64 zones, use frame buffer strategy
        _LOGGER.debug(
            "Using frame buffer strategy for tile %d (%dx%d = %d zones)",
            tile_index,
            tile.width,
            tile.height,
            tile.total_zones,
        )

        # Calculate rows per batch (64 zones / width)
        rows_per_batch = 64 // tile.width
        total_batches = (tile.height + rows_per_batch - 1) // rows_per_batch

        for batch in range(total_batches):
            start_row = batch * rows_per_batch
            end_row = min(start_row + rows_per_batch, tile.height)

            # Extract colors for this batch
            start_idx = start_row * tile.width
            end_idx = end_row * tile.width
            batch_colors = colors[start_idx:end_idx]

            # Set colors to frame buffer 1
            await self.set64(
                tile_index=tile_index,
                length=1,
                x=0,
                y=start_row,
                width=tile.width,
                duration=duration if batch == total_batches - 1 else 0,
                colors=batch_colors,
                fb_index=1,
            )

        # Copy frame buffer 1 to 0 (display)
        await self.copy_frame_buffer(
            tile_index=tile_index, source_fb=1, target_fb=0
        )
    else:
        # Tile has 64 zones, single set64() call
        await self.set64(
            tile_index=tile_index,
            length=1,
            x=0,
            y=0,
            width=tile.width,
            duration=duration,
            colors=colors,
        )
```

##### get_effect

```python
get_effect() -> MatrixEffect
```

Get current running matrix effect.

| RETURNS        | DESCRIPTION                                      |
| -------------- | ------------------------------------------------ |
| `MatrixEffect` | MatrixEffect describing the current effect state |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

> > > effect = await matrix.get_effect() print(f"Effect type: {effect.effect_type}")

Source code in `src/lifx/devices/matrix.py`

```python
async def get_effect(self) -> MatrixEffect:
    """Get current running matrix effect.

    Returns:
        MatrixEffect describing the current effect state

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        >>> effect = await matrix.get_effect()
        >>> print(f"Effect type: {effect.effect_type}")
    """
    _LOGGER.debug("Getting matrix effect for %s", self.label or self.serial)

    response: packets.Tile.StateEffect = await self.connection.request(
        packets.Tile.GetEffect()
    )
    self._raise_if_unhandled(response)

    # Convert protocol effect to MatrixEffect
    palette = [
        HSBK.from_protocol(proto_color)
        for proto_color in response.settings.palette[
            : response.settings.palette_count
        ]
    ]

    effect = MatrixEffect(
        effect_type=response.settings.effect_type,
        speed=response.settings.speed,
        duration=response.settings.duration,
        palette=palette if palette else None,
        sky_type=response.settings.parameter.sky_type,
        cloud_saturation_min=response.settings.parameter.cloud_saturation_min,
        cloud_saturation_max=response.settings.parameter.cloud_saturation_max,
    )

    self._tile_effect = effect

    # Update state if it exists
    if self._state is not None and hasattr(self._state, "effect"):
        self._state.effect = effect.effect_type
        self._state.last_updated = __import__("time").time()

    return effect
```

##### set_effect

```python
set_effect(
    effect_type: FirmwareEffect,
    speed: float = 3.0,
    duration: int = 0,
    palette: list[HSBK] | None = None,
    sky_type: TileEffectSkyType = SUNRISE,
    cloud_saturation_min: int = 0,
    cloud_saturation_max: int = 0,
) -> None
```

Set matrix effect with configuration.

| PARAMETER              | DESCRIPTION                                                                                    |
| ---------------------- | ---------------------------------------------------------------------------------------------- |
| `effect_type`          | Type of effect (OFF, MORPH, FLAME, SKY) **TYPE:** `FirmwareEffect`                             |
| `speed`                | Effect speed in seconds (default: 3) **TYPE:** `float` **DEFAULT:** `3.0`                      |
| `duration`             | Total effect duration in nanoseconds (0 for infinite) **TYPE:** `int` **DEFAULT:** `0`         |
| `palette`              | Color palette for the effect (max 16 colors, None for no palette) **TYPE:** \`list[HSBK]       |
| `sky_type`             | Sky effect type (SUNRISE, SUNSET, CLOUDS) **TYPE:** `TileEffectSkyType` **DEFAULT:** `SUNRISE` |
| `cloud_saturation_min` | Minimum cloud saturation (0-255, for CLOUDS) **TYPE:** `int` **DEFAULT:** `0`                  |
| `cloud_saturation_max` | Maximum cloud saturation (0-255, for CLOUDS) **TYPE:** `int` **DEFAULT:** `0`                  |

Example

> > > ###### Set MORPH effect with rainbow palette
> > >
> > > rainbow = [ ... HSBK(0, 1.0, 1.0, 3500), # Red ... HSBK(60, 1.0, 1.0, 3500), # Yellow ... HSBK(120, 1.0, 1.0, 3500), # Green ... HSBK(240, 1.0, 1.0, 3500), # Blue ... ] await matrix.set_effect( ... effect_type=FirmwareEffect.MORPH, ... speed=5.0, ... palette=rainbow, ... )
> > >
> > > ###### Set effect without a palette
> > >
> > > await matrix.set_effect( ... effect_type=FirmwareEffect.FLAME, ... speed=3.0, ... )

Source code in `src/lifx/devices/matrix.py`

```python
async def set_effect(
    self,
    effect_type: FirmwareEffect,
    speed: float = 3.0,
    duration: int = 0,
    palette: list[HSBK] | None = None,
    sky_type: TileEffectSkyType = TileEffectSkyType.SUNRISE,
    cloud_saturation_min: int = 0,
    cloud_saturation_max: int = 0,
) -> None:
    """Set matrix effect with configuration.

    Args:
        effect_type: Type of effect (OFF, MORPH, FLAME, SKY)
        speed: Effect speed in seconds (default: 3)
        duration: Total effect duration in nanoseconds (0 for infinite)
        palette: Color palette for the effect (max 16 colors, None for no palette)
        sky_type: Sky effect type (SUNRISE, SUNSET, CLOUDS)
        cloud_saturation_min: Minimum cloud saturation (0-255, for CLOUDS)
        cloud_saturation_max: Maximum cloud saturation (0-255, for CLOUDS)

    Example:
        >>> # Set MORPH effect with rainbow palette
        >>> rainbow = [
        ...     HSBK(0, 1.0, 1.0, 3500),  # Red
        ...     HSBK(60, 1.0, 1.0, 3500),  # Yellow
        ...     HSBK(120, 1.0, 1.0, 3500),  # Green
        ...     HSBK(240, 1.0, 1.0, 3500),  # Blue
        ... ]
        >>> await matrix.set_effect(
        ...     effect_type=FirmwareEffect.MORPH,
        ...     speed=5.0,
        ...     palette=rainbow,
        ... )

        >>> # Set effect without a palette
        >>> await matrix.set_effect(
        ...     effect_type=FirmwareEffect.FLAME,
        ...     speed=3.0,
        ... )
    """
    _LOGGER.debug(
        "Setting matrix effect %s (speed=%d) for %s",
        effect_type,
        speed,
        self.label or self.serial,
    )
    speed_ms = round(speed * 1000) if speed else 3000

    # Create and validate MatrixEffect
    effect = MatrixEffect(
        effect_type=effect_type,
        speed=speed_ms,
        duration=duration,
        palette=palette,
        sky_type=sky_type,
        cloud_saturation_min=cloud_saturation_min,
        cloud_saturation_max=cloud_saturation_max,
    )

    # Convert to protocol format
    proto_palette = []
    palette_count = 0

    if effect.palette is not None:
        palette_count = len(effect.palette)
        for color in effect.palette:
            proto_palette.append(
                LightHsbk(
                    hue=int(color.hue / 360 * 65535),
                    saturation=int(color.saturation * 65535),
                    brightness=int(color.brightness * 65535),
                    kelvin=color.kelvin,
                )
            )

    # Pad palette to 16 colors (protocol requirement)
    while len(proto_palette) < 16:
        proto_palette.append(LightHsbk(0, 0, 0, 3500))

    settings = TileEffectSettings(
        instanceid=0,
        effect_type=effect.effect_type,
        speed=effect.speed,
        duration=effect.duration,
        parameter=TileEffectParameter(
            sky_type=effect.sky_type,
            cloud_saturation_min=effect.cloud_saturation_min,
            cloud_saturation_max=effect.cloud_saturation_max,
        ),
        palette_count=palette_count,
        palette=proto_palette,
    )

    await self.connection.send_packet(packets.Tile.SetEffect(settings=settings))
    self._tile_effect = effect
```

##### apply_theme

```python
apply_theme(
    theme: Theme, power_on: bool = False, duration: float = 0.0
) -> None
```

Apply a theme across matrix tiles using Canvas interpolation.

Distributes theme colors across the tile matrix with smooth color blending using the Canvas API for visually pleasing transitions.

| PARAMETER  | DESCRIPTION                                                         |
| ---------- | ------------------------------------------------------------------- |
| `theme`    | Theme to apply **TYPE:** `Theme`                                    |
| `power_on` | Turn on the light **TYPE:** `bool` **DEFAULT:** `False`             |
| `duration` | Transition duration in seconds **TYPE:** `float` **DEFAULT:** `0.0` |

Example

```python
from lifx.theme import get_theme

theme = get_theme("evening")
await matrix.apply_theme(theme, power_on=True, duration=0.5)
```

Source code in `src/lifx/devices/matrix.py`

````python
async def apply_theme(
    self,
    theme: Theme,
    power_on: bool = False,
    duration: float = 0.0,
) -> None:
    """Apply a theme across matrix tiles using Canvas interpolation.

    Distributes theme colors across the tile matrix with smooth color blending
    using the Canvas API for visually pleasing transitions.

    Args:
        theme: Theme to apply
        power_on: Turn on the light
        duration: Transition duration in seconds

    Example:
        ```python
        from lifx.theme import get_theme

        theme = get_theme("evening")
        await matrix.apply_theme(theme, power_on=True, duration=0.5)
        ```
    """
    from lifx.theme.canvas import Canvas

    # Get device chain
    tiles = await self.get_device_chain()

    if not tiles:
        return

    # Create canvas and populate with theme colors
    canvas = Canvas()
    for tile in tiles:
        canvas.add_points_for_tile((int(tile.user_x), int(tile.user_y)), theme)

    # Shuffle and blur ONCE after all points are added
    # (Previously these were inside the loop, causing earlier tiles' points
    # to be shuffled/blurred multiple times, displacing them from their
    # intended positions and losing theme color variety)
    canvas.shuffle_points()
    canvas.blur_by_distance()

    # Create tile canvas and fill in gaps for smooth interpolation
    tile_canvas = Canvas()
    for tile in tiles:
        tile_canvas.fill_in_points(
            canvas,
            int(tile.user_x),
            int(tile.user_y),
            tile.width,
            tile.height,
        )

    # Final blur for smooth gradients
    tile_canvas.blur()

    # Check if light is on
    is_on = await self.get_power()

    # Apply colors to each tile
    for tile in tiles:
        # Extract tile colors from canvas as 1D list
        tile_coords = (int(tile.user_x), int(tile.user_y))
        colors = tile_canvas.points_for_tile(
            tile_coords, width=tile.width, height=tile.height
        )

        # Apply with appropriate timing
        if power_on and not is_on:
            await self.set_matrix_colors(tile.tile_index, colors, duration=0)
        else:
            await self.set_matrix_colors(
                tile.tile_index, colors, duration=int(duration * 1000)
            )

    # Turn on light if requested and currently off
    if power_on and not is_on:
        await self.set_power(True, duration=duration)
````

##### refresh_state

```python
refresh_state() -> None
```

Refresh matrix light state from hardware.

Fetches color, tiles, tile colors for all tiles, and effect.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/matrix.py`

```python
async def refresh_state(self) -> None:
    """Refresh matrix light state from hardware.

    Fetches color, tiles, tile colors for all tiles, and effect.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    await super().refresh_state()

    # Fetch all matrix light state sequentially to avoid overwhelming device
    all_tile_colors = await self.get_all_tile_colors()
    effect = await self.get_effect()

    # Flatten tile colors for state storage
    self._state.tile_colors = [c for tile in all_tile_colors for c in tile]
    self._state.effect = effect.effect_type
```

### MatrixLightState

Matrix light device state dataclass returned by `MatrixLight.state`.

#### MatrixLightState

```python
MatrixLightState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
    color: HSBK,
    chain: list[TileInfo],
    tile_orientations: dict[int, str],
    tile_colors: list[HSBK],
    tile_count: int,
    effect: FirmwareEffect,
)
```

Bases: `LightState`

Matrix light device state with tile-based control.

| ATTRIBUTE     | DESCRIPTION                                                                |
| ------------- | -------------------------------------------------------------------------- |
| `tiles`       | List of tile information for each tile in the chain                        |
| `tile_colors` | List of HSBK colors for all pixels across all tiles **TYPE:** `list[HSBK]` |
| `tile_count`  | Total number of tiles in chain **TYPE:** `int`                             |
| `effect`      | Current matrix effect configuration **TYPE:** `FirmwareEffect`             |

| METHOD             | DESCRIPTION                              |
| ------------------ | ---------------------------------------- |
| `from_light_state` | Create MatrixLightState from LightState. |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return MatrixLightState as dict.

##### Functions

###### from_light_state

```python
from_light_state(
    light_state: LightState,
    chain: list[TileInfo],
    tile_orientations: dict[int, str],
    tile_colors: list[HSBK],
    effect: FirmwareEffect,
) -> MatrixLightState
```

Create MatrixLightState from LightState.

Source code in `src/lifx/devices/matrix.py`

```python
@classmethod
def from_light_state(
    cls,
    light_state: LightState,
    chain: list[TileInfo],
    tile_orientations: dict[int, str],
    tile_colors: list[HSBK],
    effect: FirmwareEffect,
) -> MatrixLightState:
    """Create MatrixLightState from LightState."""
    return cls(
        model=light_state.model,
        label=light_state.label,
        serial=light_state.serial,
        mac_address=light_state.mac_address,
        power=light_state.power,
        capabilities=light_state.capabilities,
        host_firmware=light_state.host_firmware,
        wifi_firmware=light_state.wifi_firmware,
        location=light_state.location,
        group=light_state.group,
        color=light_state.color,
        chain=chain,
        tile_orientations=tile_orientations,
        tile_colors=tile_colors,
        tile_count=len(chain),
        effect=effect,
        last_updated=time.time(),
    )
```

### TileInfo

Information dataclass for a single tile in the device chain. Returned as part of `MatrixLightState.chain`.

#### TileInfo

```python
TileInfo(
    tile_index: int,
    accel_meas_x: int,
    accel_meas_y: int,
    accel_meas_z: int,
    user_x: float,
    user_y: float,
    width: int,
    height: int,
    supported_frame_buffers: int,
    device_version_vendor: int,
    device_version_product: int,
    device_version_version: int,
    firmware_build: int,
    firmware_version_minor: int,
    firmware_version_major: int,
)
```

Information about a single tile in the device chain.

| ATTRIBUTE                 | DESCRIPTION                                               |
| ------------------------- | --------------------------------------------------------- |
| `tile_index`              | Index of this tile in the chain (0-based) **TYPE:** `int` |
| `accel_meas_x`            | Accelerometer measurement X **TYPE:** `int`               |
| `accel_meas_y`            | Accelerometer measurement Y **TYPE:** `int`               |
| `accel_meas_z`            | Accelerometer measurement Z **TYPE:** `int`               |
| `user_x`                  | User-defined X position **TYPE:** `float`                 |
| `user_y`                  | User-defined Y position **TYPE:** `float`                 |
| `width`                   | Tile width in zones **TYPE:** `int`                       |
| `height`                  | Tile height in zones **TYPE:** `int`                      |
| `supported_frame_buffers` | frame buffer count **TYPE:** `int`                        |
| `device_version_vendor`   | Device vendor ID **TYPE:** `int`                          |
| `device_version_product`  | Device product ID **TYPE:** `int`                         |
| `device_version_version`  | Device version **TYPE:** `int`                            |
| `firmware_build`          | Firmware build timestamp **TYPE:** `int`                  |
| `firmware_version_minor`  | Firmware minor version **TYPE:** `int`                    |
| `firmware_version_major`  | Firmware major version **TYPE:** `int`                    |

| METHOD          | DESCRIPTION                                    |
| --------------- | ---------------------------------------------- |
| `from_protocol` | Create TileInfo from protocol TileStateDevice. |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return TileInfo as dictionary.

###### total_zones

```python
total_zones: int
```

Get total number of zones on this tile.

###### requires_frame_buffer

```python
requires_frame_buffer: bool
```

Check if tile has more than 64 zones (requires frame buffer strategy).

###### nearest_orientation

```python
nearest_orientation: str
```

Determine the orientation of the tile from accelerometer data.

##### Functions

###### from_protocol

```python
from_protocol(tile_index: int, protocol_tile: TileStateDevice) -> TileInfo
```

Create TileInfo from protocol TileStateDevice.

| PARAMETER       | DESCRIPTION                                                 |
| --------------- | ----------------------------------------------------------- |
| `tile_index`    | Index of this tile in the chain (0-based) **TYPE:** `int`   |
| `protocol_tile` | Protocol TileStateDevice object **TYPE:** `TileStateDevice` |

| RETURNS    | DESCRIPTION       |
| ---------- | ----------------- |
| `TileInfo` | TileInfo instance |

Source code in `src/lifx/devices/matrix.py`

```python
@classmethod
def from_protocol(
    cls, tile_index: int, protocol_tile: LifxProtocolTileDevice
) -> TileInfo:
    """Create TileInfo from protocol TileStateDevice.

    Args:
        tile_index: Index of this tile in the chain (0-based)
        protocol_tile: Protocol TileStateDevice object

    Returns:
        TileInfo instance
    """
    return cls(
        tile_index=tile_index,
        accel_meas_x=protocol_tile.accel_meas.x,
        accel_meas_y=protocol_tile.accel_meas.y,
        accel_meas_z=protocol_tile.accel_meas.z,
        user_x=protocol_tile.user_x,
        user_y=protocol_tile.user_y,
        width=protocol_tile.width,
        height=protocol_tile.height,
        supported_frame_buffers=protocol_tile.supported_frame_buffers,
        device_version_vendor=protocol_tile.device_version.vendor,
        device_version_product=protocol_tile.device_version.product,
        device_version_version=0,  # Not available in TileStateDevice
        firmware_build=protocol_tile.firmware.build,
        firmware_version_minor=protocol_tile.firmware.version_minor,
        firmware_version_major=protocol_tile.firmware.version_major,
    )
```

### MatrixEffect

Configuration dataclass for matrix effects (MORPH, FLAME, SKY). Used with `MatrixLight.set_effect()` and returned by `MatrixLight.get_effect()`.

#### MatrixEffect

```python
MatrixEffect(
    effect_type: FirmwareEffect,
    speed: int,
    duration: int = 0,
    palette: list[HSBK] | None = None,
    sky_type: TileEffectSkyType = SUNRISE,
    cloud_saturation_min: int = 0,
    cloud_saturation_max: int = 0,
)
```

Matrix effect configuration.

| ATTRIBUTE              | DESCRIPTION                                                             |
| ---------------------- | ----------------------------------------------------------------------- |
| `effect_type`          | Type of effect (OFF, MORPH, FLAME, SKY) **TYPE:** `FirmwareEffect`      |
| `speed`                | Effect speed in milliseconds **TYPE:** `int`                            |
| `duration`             | Total effect duration in nanoseconds (0 for infinite) **TYPE:** `int`   |
| `palette`              | Color palette for the effect (max 16 colors) **TYPE:** \`list[HSBK]     |
| `sky_type`             | Sky effect type (SUNRISE, SUNSET, CLOUDS) **TYPE:** `TileEffectSkyType` |
| `cloud_saturation_min` | Minimum cloud saturation (0-255, for CLOUDS sky type) **TYPE:** `int`   |
| `cloud_saturation_max` | Maximum cloud saturation (0-255, for CLOUDS sky type) **TYPE:** `int`   |

## Ceiling Light

The `CeilingLight` class extends `MatrixLight` with independent control over uplight and downlight components for LIFX Ceiling fixtures.

### CeilingLight

```python
CeilingLight(
    serial: str,
    ip: str,
    port: int = 56700,
    timeout: float = 0.5,
    max_retries: int = 3,
    state_file: str | None = None,
)
```

Bases: `MatrixLight`

LIFX Ceiling Light with independent uplight and downlight control.

CeilingLight extends MatrixLight to provide semantic control over uplight and downlight components while maintaining full backward compatibility with the MatrixLight API.

The uplight component is the last zone in the matrix, and the downlight component consists of all other zones.

Example

```python
from lifx.devices import CeilingLight
from lifx.color import HSBK

async with await CeilingLight.from_ip("192.168.1.100") as ceiling:
    # Independent component control
    await ceiling.set_downlight_colors(HSBK(hue=0, sat=0, bri=1.0, kelvin=3500))
    await ceiling.set_uplight_color(HSBK(hue=30, sat=0.2, bri=0.3, kelvin=2700))

    # Turn components on/off
    await ceiling.turn_downlight_on()
    await ceiling.turn_uplight_off()

    # Check component state
    if ceiling.uplight_is_on:
        print("Uplight is on")
```

| PARAMETER     | DESCRIPTION                                                                                         |
| ------------- | --------------------------------------------------------------------------------------------------- |
| `serial`      | Device serial number **TYPE:** `str`                                                                |
| `ip`          | Device IP address **TYPE:** `str`                                                                   |
| `port`        | Device UDP port (default: 56700) **TYPE:** `int` **DEFAULT:** `56700`                               |
| `timeout`     | Overall timeout for network requests in seconds (default: 0.5) **TYPE:** `float` **DEFAULT:** `0.5` |
| `max_retries` | Maximum number of retry attempts for network requests (default: 3) **TYPE:** `int` **DEFAULT:** `3` |
| `state_file`  | Optional path to JSON file for state persistence **TYPE:** \`str                                    |

| RAISES      | DESCRIPTION                                  |
| ----------- | -------------------------------------------- |
| `LifxError` | If device is not a supported Ceiling product |

| METHOD                 | DESCRIPTION                                                           |
| ---------------------- | --------------------------------------------------------------------- |
| `refresh_state`        | Refresh ceiling light state from hardware.                            |
| `from_ip`              | Create CeilingLight from IP address.                                  |
| `get_uplight_color`    | Get current uplight component color from device.                      |
| `get_downlight_colors` | Get current downlight component colors from device.                   |
| `set_uplight_color`    | Set uplight component color.                                          |
| `set_downlight_colors` | Set downlight component colors.                                       |
| `turn_uplight_on`      | Turn uplight component on.                                            |
| `turn_uplight_off`     | Turn uplight component off.                                           |
| `turn_downlight_on`    | Turn downlight component on.                                          |
| `set_power`            | Set light power state, capturing component colors before turning off. |
| `set_color`            | Set light color, updating component state tracking.                   |
| `turn_downlight_off`   | Turn downlight component off.                                         |

| ATTRIBUTE              | DESCRIPTION                                                         |
| ---------------------- | ------------------------------------------------------------------- |
| `state`                | Get Ceiling light state. **TYPE:** `CeilingLightState`              |
| `uplight_zone`         | Zone index of the uplight component. **TYPE:** `int`                |
| `downlight_zones`      | Slice representing the downlight component zones. **TYPE:** `slice` |
| `downlight_zone_count` | Number of downlight zones. **TYPE:** `int`                          |
| `uplight_is_on`        | True if uplight component is currently on. **TYPE:** `bool`         |
| `downlight_is_on`      | True if downlight component is currently on. **TYPE:** `bool`       |

Source code in `src/lifx/devices/ceiling.py`

```python
def __init__(
    self,
    serial: str,
    ip: str,
    port: int = 56700,  # LIFX_UDP_PORT
    timeout: float = 0.5,  # DEFAULT_REQUEST_TIMEOUT
    max_retries: int = 3,  # DEFAULT_MAX_RETRIES
    state_file: str | None = None,
):
    """Initialize CeilingLight.

    Args:
        serial: Device serial number
        ip: Device IP address
        port: Device UDP port (default: 56700)
        timeout: Overall timeout for network requests in seconds
            (default: 0.5)
        max_retries: Maximum number of retry attempts for network requests
            (default: 3)
        state_file: Optional path to JSON file for state persistence

    Raises:
        LifxError: If device is not a supported Ceiling product
    """
    super().__init__(serial, ip, port, timeout, max_retries)
    self._state_file = state_file
    self._stored_uplight_state: HSBK | None = None
    self._stored_downlight_state: list[HSBK] | None = None
    self._last_uplight_color: HSBK | None = None
    self._last_downlight_colors: list[HSBK] | None = None
```

#### Attributes

##### state

```python
state: CeilingLightState
```

Get Ceiling light state.

| RETURNS             | DESCRIPTION                                       |
| ------------------- | ------------------------------------------------- |
| `CeilingLightState` | CeilingLightState with current state information. |

| RAISES         | DESCRIPTION                              |
| -------------- | ---------------------------------------- |
| `RuntimeError` | If accessed before state initialization. |

##### uplight_zone

```python
uplight_zone: int
```

Zone index of the uplight component.

| RETURNS | DESCRIPTION                                           |
| ------- | ----------------------------------------------------- |
| `int`   | Zone index (63 for standard Ceiling, 127 for Capsule) |

| RAISES      | DESCRIPTION                                                 |
| ----------- | ----------------------------------------------------------- |
| `LifxError` | If device version is not available or not a Ceiling product |

##### downlight_zones

```python
downlight_zones: slice
```

Slice representing the downlight component zones.

| RETURNS | DESCRIPTION                                                         |
| ------- | ------------------------------------------------------------------- |
| `slice` | Slice object (slice(0, 63) for standard, slice(0, 127) for Capsule) |

| RAISES      | DESCRIPTION                                                 |
| ----------- | ----------------------------------------------------------- |
| `LifxError` | If device version is not available or not a Ceiling product |

##### downlight_zone_count

```python
downlight_zone_count: int
```

Number of downlight zones.

| RETURNS | DESCRIPTION                                            |
| ------- | ------------------------------------------------------ |
| `int`   | Zone count (63 for standard 8x8, 127 for Capsule 16x8) |

| RAISES      | DESCRIPTION                                                 |
| ----------- | ----------------------------------------------------------- |
| `LifxError` | If device version is not available or not a Ceiling product |

##### uplight_is_on

```python
uplight_is_on: bool
```

True if uplight component is currently on.

Calculated as: power_level > 0 AND uplight brightness > 0

Note

Requires recent data from device. Call get_uplight_color() or get_power() to refresh cached values before checking this property.

| RETURNS | DESCRIPTION                                      |
| ------- | ------------------------------------------------ |
| `bool`  | True if uplight component is on, False otherwise |

##### downlight_is_on

```python
downlight_is_on: bool
```

True if downlight component is currently on.

Calculated as: power_level > 0 AND NOT all downlight zones have brightness == 0

Note

Requires recent data from device. Call get_downlight_colors() or get_power() to refresh cached values before checking this property.

| RETURNS | DESCRIPTION                                        |
| ------- | -------------------------------------------------- |
| `bool`  | True if downlight component is on, False otherwise |

#### Functions

##### refresh_state

```python
refresh_state() -> None
```

Refresh ceiling light state from hardware.

Fetches color, tiles, tile colors, effect, and ceiling component state.

| RAISES                    | DESCRIPTION                       |
| ------------------------- | --------------------------------- |
| `RuntimeError`            | If state has not been initialized |
| `LifxTimeoutError`        | If device does not respond        |
| `LifxDeviceNotFoundError` | If device cannot be reached       |

Source code in `src/lifx/devices/ceiling.py`

```python
async def refresh_state(self) -> None:
    """Refresh ceiling light state from hardware.

    Fetches color, tiles, tile colors, effect, and ceiling component state.

    Raises:
        RuntimeError: If state has not been initialized
        LifxTimeoutError: If device does not respond
        LifxDeviceNotFoundError: If device cannot be reached
    """
    await super().refresh_state()

    # Extract ceiling component colors from already-fetched tile_colors
    # (parent refresh_state already called get_all_tile_colors)
    tile_colors = self._state.tile_colors
    uplight_color = tile_colors[self.uplight_zone]
    downlight_colors = list(tile_colors[self.downlight_zones])

    # Cache for is_on properties
    self._last_uplight_color = uplight_color
    self._last_downlight_colors = downlight_colors

    # Update ceiling-specific state fields
    state = cast(CeilingLightState, self._state)
    state.uplight_color = uplight_color
    state.downlight_colors = downlight_colors
    state.uplight_is_on = bool(
        self.state.power > 0 and uplight_color.brightness > 0
    )
    state.downlight_is_on = bool(
        self.state.power > 0 and any(c.brightness > 0 for c in downlight_colors)
    )
```

##### from_ip

```python
from_ip(
    ip: str,
    port: int = 56700,
    serial: str | None = None,
    timeout: float = 0.5,
    max_retries: int = 3,
    *,
    state_file: str | None = None,
) -> CeilingLight
```

Create CeilingLight from IP address.

| PARAMETER     | DESCRIPTION                                                                   |
| ------------- | ----------------------------------------------------------------------------- |
| `ip`          | Device IP address **TYPE:** `str`                                             |
| `port`        | Port number (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `56700`      |
| `serial`      | Serial number as 12-digit hex string **TYPE:** \`str                          |
| `timeout`     | Request timeout for this device instance **TYPE:** `float` **DEFAULT:** `0.5` |
| `max_retries` | Maximum number of retries for requests **TYPE:** `int` **DEFAULT:** `3`       |
| `state_file`  | Optional path to JSON file for state persistence **TYPE:** \`str              |

| RETURNS        | DESCRIPTION           |
| -------------- | --------------------- |
| `CeilingLight` | CeilingLight instance |

| RAISES                    | DESCRIPTION                               |
| ------------------------- | ----------------------------------------- |
| `LifxDeviceNotFoundError` | Device not found at IP                    |
| `LifxTimeoutError`        | Device did not respond                    |
| `LifxError`               | Device is not a supported Ceiling product |

Source code in `src/lifx/devices/ceiling.py`

```python
@classmethod
async def from_ip(
    cls,
    ip: str,
    port: int = 56700,  # LIFX_UDP_PORT
    serial: str | None = None,
    timeout: float = 0.5,  # DEFAULT_REQUEST_TIMEOUT
    max_retries: int = 3,  # DEFAULT_MAX_RETRIES
    *,
    state_file: str | None = None,
) -> CeilingLight:
    """Create CeilingLight from IP address.

    Args:
        ip: Device IP address
        port: Port number (default LIFX_UDP_PORT)
        serial: Serial number as 12-digit hex string
        timeout: Request timeout for this device instance
        max_retries: Maximum number of retries for requests
        state_file: Optional path to JSON file for state persistence

    Returns:
        CeilingLight instance

    Raises:
        LifxDeviceNotFoundError: Device not found at IP
        LifxTimeoutError: Device did not respond
        LifxError: Device is not a supported Ceiling product
    """
    # Use parent class factory method
    device = await super().from_ip(ip, port, serial, timeout, max_retries)
    # Type cast to CeilingLight and set state_file
    ceiling = CeilingLight(device.serial, device.ip)
    ceiling._state_file = state_file
    ceiling.connection = device.connection
    return ceiling
```

##### get_uplight_color

```python
get_uplight_color() -> HSBK
```

Get current uplight component color from device.

| RETURNS | DESCRIPTION                |
| ------- | -------------------------- |
| `HSBK`  | HSBK color of uplight zone |

| RAISES             | DESCRIPTION            |
| ------------------ | ---------------------- |
| `LifxTimeoutError` | Device did not respond |

Source code in `src/lifx/devices/ceiling.py`

```python
async def get_uplight_color(self) -> HSBK:
    """Get current uplight component color from device.

    Returns:
        HSBK color of uplight zone

    Raises:
        LifxTimeoutError: Device did not respond
    """
    # Get all colors from tile
    all_colors = await self.get_all_tile_colors()
    tile_colors = all_colors[0]  # First tile

    # Extract uplight zone
    uplight_color = tile_colors[self.uplight_zone]

    # Cache for is_on property
    self._last_uplight_color = uplight_color

    return uplight_color
```

##### get_downlight_colors

```python
get_downlight_colors() -> list[HSBK]
```

Get current downlight component colors from device.

| RETURNS      | DESCRIPTION                                                   |
| ------------ | ------------------------------------------------------------- |
| `list[HSBK]` | List of HSBK colors for each downlight zone (63 or 127 zones) |

| RAISES             | DESCRIPTION            |
| ------------------ | ---------------------- |
| `LifxTimeoutError` | Device did not respond |

Source code in `src/lifx/devices/ceiling.py`

```python
async def get_downlight_colors(self) -> list[HSBK]:
    """Get current downlight component colors from device.

    Returns:
        List of HSBK colors for each downlight zone (63 or 127 zones)

    Raises:
        LifxTimeoutError: Device did not respond
    """
    # Get all colors from tile
    all_colors = await self.get_all_tile_colors()
    tile_colors = all_colors[0]  # First tile

    # Extract downlight zones
    downlight_colors = tile_colors[self.downlight_zones]

    # Cache for is_on property
    self._last_downlight_colors = downlight_colors

    return downlight_colors
```

##### set_uplight_color

```python
set_uplight_color(color: HSBK, duration: float = 0.0) -> None
```

Set uplight component color.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `color`    | HSBK color to set **TYPE:** `HSBK`                                                |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES             | DESCRIPTION                                             |
| ------------------ | ------------------------------------------------------- |
| `ValueError`       | If color.brightness == 0 (use turn_uplight_off instead) |
| `LifxTimeoutError` | Device did not respond                                  |

Note

Also updates stored state for future restoration.

Source code in `src/lifx/devices/ceiling.py`

```python
async def set_uplight_color(self, color: HSBK, duration: float = 0.0) -> None:
    """Set uplight component color.

    Args:
        color: HSBK color to set
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If color.brightness == 0 (use turn_uplight_off instead)
        LifxTimeoutError: Device did not respond

    Note:
        Also updates stored state for future restoration.
    """
    if color.brightness == 0:
        raise ValueError(
            "Cannot set uplight color with brightness=0. "
            "Use turn_uplight_off() instead."
        )

    # Get current colors for all zones
    all_colors = await self.get_all_tile_colors()
    tile_colors = all_colors[0]

    # Update uplight zone
    tile_colors[self.uplight_zone] = color

    # Set all colors back (duration in milliseconds for set_matrix_colors)
    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))

    # Store state
    self._stored_uplight_state = color
    self._last_uplight_color = color

    # Persist if enabled
    if self._state_file:
        self._save_state_to_file()
```

##### set_downlight_colors

```python
set_downlight_colors(colors: HSBK | list[HSBK], duration: float = 0.0) -> None
```

Set downlight component colors.

| PARAMETER  | DESCRIPTION                                                                                                                                        |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `colors`   | Either: - Single HSBK: sets all downlight zones to same color - List\[HSBK\]: sets each zone individually (must match zone count) **TYPE:** \`HSBK |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                  |

| RAISES             | DESCRIPTION                                                   |
| ------------------ | ------------------------------------------------------------- |
| `ValueError`       | If any color.brightness == 0 (use turn_downlight_off instead) |
| `ValueError`       | If list length doesn't match downlight zone count             |
| `LifxTimeoutError` | Device did not respond                                        |

Note

Also updates stored state for future restoration.

Source code in `src/lifx/devices/ceiling.py`

```python
async def set_downlight_colors(
    self, colors: HSBK | list[HSBK], duration: float = 0.0
) -> None:
    """Set downlight component colors.

    Args:
        colors: Either:
            - Single HSBK: sets all downlight zones to same color
            - List[HSBK]: sets each zone individually (must match zone count)
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If any color.brightness == 0 (use turn_downlight_off instead)
        ValueError: If list length doesn't match downlight zone count
        LifxTimeoutError: Device did not respond

    Note:
        Also updates stored state for future restoration.
    """
    # Validate and normalize colors
    if isinstance(colors, HSBK):
        if colors.brightness == 0:
            raise ValueError(
                "Cannot set downlight color with brightness=0. "
                "Use turn_downlight_off() instead."
            )
        downlight_colors = [colors] * self.downlight_zone_count
    else:
        if all(c.brightness == 0 for c in colors):
            raise ValueError(
                "Cannot set downlight colors with brightness=0. "
                "Use turn_downlight_off() instead."
            )

        if len(colors) != self.downlight_zone_count:
            raise ValueError(
                f"Expected {self.downlight_zone_count} colors for downlight, "
                f"got {len(colors)}"
            )
        downlight_colors = colors

    # Get current colors for all zones
    all_colors = await self.get_all_tile_colors()
    tile_colors = all_colors[0]

    # Update downlight zones
    tile_colors[self.downlight_zones] = downlight_colors

    # Set all colors back
    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))

    # Store state
    self._stored_downlight_state = downlight_colors
    self._last_downlight_colors = downlight_colors

    # Persist if enabled
    if self._state_file:
        self._save_state_to_file()
```

##### turn_uplight_on

```python
turn_uplight_on(color: HSBK | None = None, duration: float = 0.0) -> None
```

Turn uplight component on.

If the entire light is off, this will set the color instantly and then turn on the light with the specified duration, so the light fades to the target color instead of flashing to its previous state.

| PARAMETER  | DESCRIPTION                                                                                                                                          |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `color`    | Optional HSBK color. If provided: - Uses this color immediately - Updates stored state If None, uses brightness determination logic **TYPE:** \`HSBK |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                    |

| RAISES             | DESCRIPTION              |
| ------------------ | ------------------------ |
| `ValueError`       | If color.brightness == 0 |
| `LifxTimeoutError` | Device did not respond   |

Source code in `src/lifx/devices/ceiling.py`

```python
async def turn_uplight_on(
    self, color: HSBK | None = None, duration: float = 0.0
) -> None:
    """Turn uplight component on.

    If the entire light is off, this will set the color instantly and then
    turn on the light with the specified duration, so the light fades to
    the target color instead of flashing to its previous state.

    Args:
        color: Optional HSBK color. If provided:
            - Uses this color immediately
            - Updates stored state
            If None, uses brightness determination logic
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If color.brightness == 0
        LifxTimeoutError: Device did not respond
    """
    # Validate provided color early
    if color is not None and color.brightness == 0:
        raise ValueError("Cannot turn on uplight with brightness=0")

    # Check if light is off first to determine which path to take
    if await self.get_power() == 0:
        # Light is off - single fetch for both determining color and modification
        all_colors = await self.get_all_tile_colors()
        tile_colors = all_colors[0]

        # Determine target color (pass pre-fetched colors to avoid extra fetch)
        if color is not None:
            target_color = color
        else:
            target_color = await self._determine_uplight_brightness(tile_colors)

        # Store current downlight colors BEFORE zeroing them out
        # This allows turn_downlight_on() to restore them later
        downlight_colors = tile_colors[self.downlight_zones]
        self._stored_downlight_state = list(downlight_colors)

        # Set uplight zone to target color
        tile_colors[self.uplight_zone] = target_color

        # Zero out downlight zones so they stay off when power turns on
        for i in range(*self.downlight_zones.indices(len(tile_colors))):
            tile_colors[i] = HSBK(
                hue=tile_colors[i].hue,
                saturation=tile_colors[i].saturation,
                brightness=0.0,
                kelvin=tile_colors[i].kelvin,
            )

        # Set all colors instantly (duration=0) while light is off
        await self.set_matrix_colors(0, tile_colors, duration=0)

        # Update stored state for uplight
        self._stored_uplight_state = target_color
        self._last_uplight_color = target_color

        # Turn on with the requested duration - light fades on to target color
        await super().set_power(True, duration)

        # Persist AFTER device operations complete
        if self._state_file:
            self._save_state_to_file()
    else:
        # Light is already on - determine target color first, then set
        if color is not None:
            target_color = color
        else:
            target_color = await self._determine_uplight_brightness()

        # set_uplight_color will fetch and modify (single fetch in that method)
        await self.set_uplight_color(target_color, duration)
```

##### turn_uplight_off

```python
turn_uplight_off(color: HSBK | None = None, duration: float = 0.0) -> None
```

Turn uplight component off.

| PARAMETER  | DESCRIPTION                                                                                                                                                                                       |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `color`    | Optional HSBK color to store for future turn_on. If provided, stores this color (with brightness=0 on the device). If None, stores current color from device before turning off. **TYPE:** \`HSBK |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                                                                 |

| RAISES             | DESCRIPTION              |
| ------------------ | ------------------------ |
| `ValueError`       | If color.brightness == 0 |
| `LifxTimeoutError` | Device did not respond   |

Note

Sets uplight zone brightness to 0 on device while preserving H, S, K.

Source code in `src/lifx/devices/ceiling.py`

```python
async def turn_uplight_off(
    self, color: HSBK | None = None, duration: float = 0.0
) -> None:
    """Turn uplight component off.

    Args:
        color: Optional HSBK color to store for future turn_on.
            If provided, stores this color (with brightness=0 on the device).
            If None, stores current color from device before turning off.
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If color.brightness == 0
        LifxTimeoutError: Device did not respond

    Note:
        Sets uplight zone brightness to 0 on device while preserving H, S, K.
    """
    if color is not None and color.brightness == 0:
        raise ValueError(
            "Provided color cannot have brightness=0. "
            "Omit the parameter to use current color."
        )

    # Fetch current state once and reuse to calculate brightness
    all_colors = await self.get_all_tile_colors()
    tile_colors = all_colors[0]

    # Determine which color to store
    if color is not None:
        stored_color = color
    else:
        stored_color = tile_colors[self.uplight_zone]
        self._last_uplight_color = stored_color

    # Store for future restoration
    self._stored_uplight_state = stored_color

    # Create color with brightness=0 for device
    off_color = HSBK(
        hue=stored_color.hue,
        saturation=stored_color.saturation,
        brightness=0.0,
        kelvin=stored_color.kelvin,
    )

    # Update uplight zone and send immediately
    tile_colors[self.uplight_zone] = off_color
    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))

    # Update cache
    self._last_uplight_color = off_color

    # Persist if enabled
    if self._state_file:
        self._save_state_to_file()
```

##### turn_downlight_on

```python
turn_downlight_on(
    colors: HSBK | list[HSBK] | None = None, duration: float = 0.0
) -> None
```

Turn downlight component on.

If the entire light is off, this will set the colors instantly and then turn on the light with the specified duration, so the light fades to the target colors instead of flashing to its previous state.

| PARAMETER  | DESCRIPTION                                                                                                                                                                                                                                        |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `colors`   | Optional colors. Can be: - None: uses brightness determination logic - Single HSBK: sets all downlight zones to same color - List\[HSBK\]: sets each zone individually (must match zone count) If provided, updates stored state. **TYPE:** \`HSBK |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                                                                                                                  |

| RAISES             | DESCRIPTION                                       |
| ------------------ | ------------------------------------------------- |
| `ValueError`       | If any color.brightness == 0                      |
| `ValueError`       | If list length doesn't match downlight zone count |
| `LifxTimeoutError` | Device did not respond                            |

Source code in `src/lifx/devices/ceiling.py`

```python
async def turn_downlight_on(
    self, colors: HSBK | list[HSBK] | None = None, duration: float = 0.0
) -> None:
    """Turn downlight component on.

    If the entire light is off, this will set the colors instantly and then
    turn on the light with the specified duration, so the light fades to
    the target colors instead of flashing to its previous state.

    Args:
        colors: Optional colors. Can be:
            - None: uses brightness determination logic
            - Single HSBK: sets all downlight zones to same color
            - List[HSBK]: sets each zone individually (must match zone count)
            If provided, updates stored state.
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If any color.brightness == 0
        ValueError: If list length doesn't match downlight zone count
        LifxTimeoutError: Device did not respond
    """
    # Validate provided colors early
    if colors is not None:
        if isinstance(colors, HSBK):
            if colors.brightness == 0:
                raise ValueError("Cannot turn on downlight with brightness=0")
        else:
            if all(c.brightness == 0 for c in colors):
                raise ValueError("Cannot turn on downlight with brightness=0")
            if len(colors) != self.downlight_zone_count:
                raise ValueError(
                    f"Expected {self.downlight_zone_count} colors for downlight, "
                    f"got {len(colors)}"
                )

    # Check if light is off first to determine which path to take
    if await self.get_power() == 0:
        # Light is off - single fetch for both determining colors and modification
        all_colors = await self.get_all_tile_colors()
        tile_colors = all_colors[0]

        # Determine target colors (pass pre-fetched colors to avoid extra fetch)
        if colors is not None:
            if isinstance(colors, HSBK):
                target_colors = [colors] * self.downlight_zone_count
            else:
                target_colors = list(colors)
        else:
            target_colors = await self._determine_downlight_brightness(tile_colors)

        # Store current uplight color BEFORE zeroing it out
        # This allows turn_uplight_on() to restore it later
        self._stored_uplight_state = tile_colors[self.uplight_zone]

        # Set downlight zones to target colors
        tile_colors[self.downlight_zones] = target_colors

        # Zero out uplight zone so it stays off when power turns on
        uplight_color = tile_colors[self.uplight_zone]
        tile_colors[self.uplight_zone] = HSBK(
            hue=uplight_color.hue,
            saturation=uplight_color.saturation,
            brightness=0.0,
            kelvin=uplight_color.kelvin,
        )

        # Set all colors instantly (duration=0) while light is off
        await self.set_matrix_colors(0, tile_colors, duration=0)

        # Update stored state for downlight
        self._stored_downlight_state = target_colors
        self._last_downlight_colors = target_colors

        # Turn on with the requested duration - light fades on to target colors
        await super().set_power(True, duration)

        # Persist AFTER device operations complete
        if self._state_file:
            self._save_state_to_file()
    else:
        # Light is already on - determine target colors first, then set
        if colors is not None:
            if isinstance(colors, HSBK):
                target_colors = [colors] * self.downlight_zone_count
            else:
                target_colors = list(colors)
        else:
            target_colors = await self._determine_downlight_brightness()

        # set_downlight_colors will fetch and modify (single fetch in that method)
        await self.set_downlight_colors(target_colors, duration)
```

##### set_power

```python
set_power(level: bool | int, duration: float = 0.0) -> None
```

Set light power state, capturing component colors before turning off.

Overrides Light.set_power() to capture the current uplight and downlight colors before turning off the entire light. This allows subsequent calls to turn_uplight_on() or turn_downlight_on() to restore the colors that were active just before the light was turned off.

The captured colors preserve hue, saturation, and kelvin values even if a component was already off (brightness=0). The brightness will be determined at turn-on time using the standard brightness inference logic.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `level`    | True/65535 to turn on, False/0 to turn off **TYPE:** \`bool                       |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `ValueError`                  | If integer value is not 0 or 65535     |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
# Turn off entire ceiling light (captures colors for later)
await ceiling.set_power(False)

# Later, turn on just the uplight with its previous color
await ceiling.turn_uplight_on()

# Or turn on just the downlight with its previous colors
await ceiling.turn_downlight_on()
```

Source code in `src/lifx/devices/ceiling.py`

````python
async def set_power(self, level: bool | int, duration: float = 0.0) -> None:
    """Set light power state, capturing component colors before turning off.

    Overrides Light.set_power() to capture the current uplight and downlight
    colors before turning off the entire light. This allows subsequent calls
    to turn_uplight_on() or turn_downlight_on() to restore the colors that
    were active just before the light was turned off.

    The captured colors preserve hue, saturation, and kelvin values even if
    a component was already off (brightness=0). The brightness will be
    determined at turn-on time using the standard brightness inference logic.

    Args:
        level: True/65535 to turn on, False/0 to turn off
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If integer value is not 0 or 65535
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        # Turn off entire ceiling light (captures colors for later)
        await ceiling.set_power(False)

        # Later, turn on just the uplight with its previous color
        await ceiling.turn_uplight_on()

        # Or turn on just the downlight with its previous colors
        await ceiling.turn_downlight_on()
        ```
    """
    # Determine if we're turning off
    if isinstance(level, bool):
        turning_off = not level
    elif isinstance(level, int):
        if level not in (0, 65535):
            raise ValueError(f"Power level must be 0 or 65535, got {level}")
        turning_off = level == 0
    else:
        raise TypeError(f"Expected bool or int, got {type(level).__name__}")

    # If turning off, capture current colors for both components with single fetch
    if turning_off:
        # Single fetch to capture both uplight and downlight colors
        all_colors = await self.get_all_tile_colors()
        tile_colors = all_colors[0]

        # Extract and store both component colors
        self._stored_uplight_state = tile_colors[self.uplight_zone]
        self._stored_downlight_state = list(tile_colors[self.downlight_zones])

        # Also update cache for is_on properties
        self._last_uplight_color = self._stored_uplight_state
        self._last_downlight_colors = self._stored_downlight_state

    # Call parent to perform actual power change
    await super().set_power(level, duration)

    # Persist AFTER device operation completes
    if turning_off and self._state_file:
        self._save_state_to_file()
````

##### set_color

```python
set_color(color: HSBK, duration: float = 0.0) -> None
```

Set light color, updating component state tracking.

Overrides Light.set_color() to track the color change in the ceiling light's component state. When set_color() is called, all zones (uplight and downlight) are set to the same color. This override ensures that the cached component colors stay in sync so that subsequent component control methods (like turn_uplight_on or turn_downlight_on) use the correct color values.

| PARAMETER  | DESCRIPTION                                                                       |
| ---------- | --------------------------------------------------------------------------------- |
| `color`    | HSBK color to set for the entire light **TYPE:** `HSBK`                           |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0` |

| RAISES                        | DESCRIPTION                            |
| ----------------------------- | -------------------------------------- |
| `LifxDeviceNotFoundError`     | If device is not connected             |
| `LifxTimeoutError`            | If device does not respond             |
| `LifxUnsupportedCommandError` | If device doesn't support this command |

Example

```python
from lifx.color import HSBK

# Set entire ceiling light to warm white
await ceiling.set_color(
    HSBK(hue=0, saturation=0, brightness=1.0, kelvin=2700)
)

# Later component control will use this color
await ceiling.turn_uplight_off()  # Uplight off
await ceiling.turn_uplight_on()  # Restores to warm white
```

Source code in `src/lifx/devices/ceiling.py`

````python
async def set_color(self, color: HSBK, duration: float = 0.0) -> None:
    """Set light color, updating component state tracking.

    Overrides Light.set_color() to track the color change in the ceiling
    light's component state. When set_color() is called, all zones (uplight
    and downlight) are set to the same color. This override ensures that
    the cached component colors stay in sync so that subsequent component
    control methods (like turn_uplight_on or turn_downlight_on) use the
    correct color values.

    Args:
        color: HSBK color to set for the entire light
        duration: Transition duration in seconds (default 0.0)

    Raises:
        LifxDeviceNotFoundError: If device is not connected
        LifxTimeoutError: If device does not respond
        LifxUnsupportedCommandError: If device doesn't support this command

    Example:
        ```python
        from lifx.color import HSBK

        # Set entire ceiling light to warm white
        await ceiling.set_color(
            HSBK(hue=0, saturation=0, brightness=1.0, kelvin=2700)
        )

        # Later component control will use this color
        await ceiling.turn_uplight_off()  # Uplight off
        await ceiling.turn_uplight_on()  # Restores to warm white
        ```
    """
    # Call parent to perform actual color change
    await super().set_color(color, duration)

    # Update cached component colors - all zones now have the same color
    self._last_uplight_color = color
    self._last_downlight_colors = [color] * self.downlight_zone_count

    # Also update stored state for restoration
    self._stored_uplight_state = color
    self._stored_downlight_state = [color] * self.downlight_zone_count

    # Persist if enabled
    if self._state_file:
        self._save_state_to_file()
````

##### turn_downlight_off

```python
turn_downlight_off(
    colors: HSBK | list[HSBK] | None = None, duration: float = 0.0
) -> None
```

Turn downlight component off.

| PARAMETER  | DESCRIPTION                                                                                                                                                                                                                                                                                     |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `colors`   | Optional colors to store for future turn_on. Can be: - None: stores current colors from device - Single HSBK: stores this color for all zones - List\[HSBK\]: stores individual colors (must match zone count) If provided, stores these colors (with brightness=0 on device). **TYPE:** \`HSBK |
| `duration` | Transition duration in seconds (default 0.0) **TYPE:** `float` **DEFAULT:** `0.0`                                                                                                                                                                                                               |

| RAISES             | DESCRIPTION                                       |
| ------------------ | ------------------------------------------------- |
| `ValueError`       | If any color.brightness == 0                      |
| `ValueError`       | If list length doesn't match downlight zone count |
| `LifxTimeoutError` | Device did not respond                            |

Note

Sets all downlight zone brightness to 0 on device while preserving H, S, K.

Source code in `src/lifx/devices/ceiling.py`

```python
async def turn_downlight_off(
    self, colors: HSBK | list[HSBK] | None = None, duration: float = 0.0
) -> None:
    """Turn downlight component off.

    Args:
        colors: Optional colors to store for future turn_on. Can be:
            - None: stores current colors from device
            - Single HSBK: stores this color for all zones
            - List[HSBK]: stores individual colors (must match zone count)
            If provided, stores these colors (with brightness=0 on device).
        duration: Transition duration in seconds (default 0.0)

    Raises:
        ValueError: If any color.brightness == 0
        ValueError: If list length doesn't match downlight zone count
        LifxTimeoutError: Device did not respond

    Note:
        Sets all downlight zone brightness to 0 on device while preserving H, S, K.
    """
    # Validate provided colors early (before fetching)
    stored_colors: list[HSBK] | None = None
    if colors is not None:
        if isinstance(colors, HSBK):
            if colors.brightness == 0:
                raise ValueError(
                    "Provided color cannot have brightness=0. "
                    "Omit the parameter to use current colors."
                )
            stored_colors = [colors] * self.downlight_zone_count
        else:
            if all(c.brightness == 0 for c in colors):
                raise ValueError(
                    "Provided colors cannot have brightness=0. "
                    "Omit the parameter to use current colors."
                )
            if len(colors) != self.downlight_zone_count:
                raise ValueError(
                    f"Expected {self.downlight_zone_count} colors for downlight, "
                    f"got {len(colors)}"
                )
            stored_colors = list(colors)

    # Fetch current state once and reuse to calculate brightness
    all_colors = await self.get_all_tile_colors()
    tile_colors = all_colors[0]

    # If colors not provided, extract from fetched data
    if stored_colors is None:
        stored_colors = list(tile_colors[self.downlight_zones])
        self._last_downlight_colors = stored_colors

    # Store for future restoration
    self._stored_downlight_state = stored_colors

    # Create colors with brightness=0 for device
    off_colors = [
        HSBK(
            hue=c.hue,
            saturation=c.saturation,
            brightness=0.0,
            kelvin=c.kelvin,
        )
        for c in stored_colors
    ]

    # Update downlight zones and send immediately
    tile_colors[self.downlight_zones] = off_colors
    await self.set_matrix_colors(0, tile_colors, duration=int(duration * 1000))

    # Update cache
    self._last_downlight_colors = off_colors

    # Persist if enabled
    if self._state_file:
        self._save_state_to_file()
```

### CeilingLightState

The `CeilingLightState` dataclass extends `MatrixLightState` with ceiling-specific component information. It is returned by `CeilingLight.state` after connecting to a device.

#### CeilingLightState

```python
CeilingLightState(
    model: str,
    label: str,
    serial: str,
    mac_address: str,
    capabilities: DeviceCapabilities,
    power: int,
    host_firmware: FirmwareInfo,
    wifi_firmware: FirmwareInfo,
    location: CollectionInfo,
    group: CollectionInfo,
    last_updated: float,
    color: HSBK,
    chain: list[TileInfo],
    tile_orientations: dict[int, str],
    tile_colors: list[HSBK],
    tile_count: int,
    effect: FirmwareEffect,
    uplight_color: HSBK,
    downlight_colors: list[HSBK],
    uplight_is_on: bool,
    downlight_is_on: bool,
    uplight_zone: int,
    downlight_zones: slice,
)
```

Bases: `MatrixLightState`

Ceiling light device state with uplight/downlight component control.

Extends MatrixLightState with ceiling-specific component information.

| ATTRIBUTE          | DESCRIPTION                                                                  |
| ------------------ | ---------------------------------------------------------------------------- |
| `uplight_color`    | Current HSBK color of the uplight component **TYPE:** `HSBK`                 |
| `downlight_colors` | List of HSBK colors for each downlight zone **TYPE:** `list[HSBK]`           |
| `uplight_is_on`    | Whether uplight component is on (brightness > 0) **TYPE:** `bool`            |
| `downlight_is_on`  | Whether downlight component is on (any zone brightness > 0) **TYPE:** `bool` |
| `uplight_zone`     | Zone index for the uplight component **TYPE:** `int`                         |
| `downlight_zones`  | Slice representing downlight component zones **TYPE:** `slice`               |

| METHOD              | DESCRIPTION                                     |
| ------------------- | ----------------------------------------------- |
| `from_matrix_state` | Create CeilingLightState from MatrixLightState. |

##### Attributes

###### as_dict

```python
as_dict: Any
```

Return CeilingLightState as dict.

##### Functions

###### from_matrix_state

```python
from_matrix_state(
    matrix_state: MatrixLightState,
    uplight_color: HSBK,
    downlight_colors: list[HSBK],
    uplight_zone: int,
    downlight_zones: slice,
) -> CeilingLightState
```

Create CeilingLightState from MatrixLightState.

| PARAMETER          | DESCRIPTION                                                    |
| ------------------ | -------------------------------------------------------------- |
| `matrix_state`     | Base MatrixLightState to extend **TYPE:** `MatrixLightState`   |
| `uplight_color`    | Current uplight zone color **TYPE:** `HSBK`                    |
| `downlight_colors` | Current downlight zone colors **TYPE:** `list[HSBK]`           |
| `uplight_zone`     | Zone index for uplight component **TYPE:** `int`               |
| `downlight_zones`  | Slice representing downlight component zones **TYPE:** `slice` |

| RETURNS             | DESCRIPTION                                                     |
| ------------------- | --------------------------------------------------------------- |
| `CeilingLightState` | CeilingLightState with all matrix state plus ceiling components |

Source code in `src/lifx/devices/ceiling.py`

```python
@classmethod
def from_matrix_state(
    cls,
    matrix_state: MatrixLightState,
    uplight_color: HSBK,
    downlight_colors: list[HSBK],
    uplight_zone: int,
    downlight_zones: slice,
) -> CeilingLightState:
    """Create CeilingLightState from MatrixLightState.

    Args:
        matrix_state: Base MatrixLightState to extend
        uplight_color: Current uplight zone color
        downlight_colors: Current downlight zone colors
        uplight_zone: Zone index for uplight component
        downlight_zones: Slice representing downlight component zones

    Returns:
        CeilingLightState with all matrix state plus ceiling components
    """
    return cls(
        model=matrix_state.model,
        label=matrix_state.label,
        serial=matrix_state.serial,
        mac_address=matrix_state.mac_address,
        power=matrix_state.power,
        capabilities=matrix_state.capabilities,
        host_firmware=matrix_state.host_firmware,
        wifi_firmware=matrix_state.wifi_firmware,
        location=matrix_state.location,
        group=matrix_state.group,
        color=matrix_state.color,
        chain=matrix_state.chain,
        tile_orientations=matrix_state.tile_orientations,
        tile_colors=matrix_state.tile_colors,
        tile_count=matrix_state.tile_count,
        effect=matrix_state.effect,
        uplight_color=uplight_color,
        downlight_colors=downlight_colors,
        uplight_is_on=uplight_color.brightness > 0,
        downlight_is_on=any(c.brightness > 0 for c in downlight_colors),
        uplight_zone=uplight_zone,
        downlight_zones=downlight_zones,
        last_updated=time.time(),
    )
```

## Device Properties

### MAC Address

The `mac_address` property provides the device's MAC address, calculated from the serial number and host firmware version. The calculation is performed automatically when the device is used as a context manager or when `get_host_firmware()` is called.

**Calculation Logic** (based on host firmware major version):

- **Version 2 or 4**: MAC address matches the serial number
- **Version 3**: MAC address is the serial number with the least significant byte incremented by 1 (with wraparound from 0xFF to 0x00)
- **Unknown versions**: Defaults to the serial number

The MAC address is returned in colon-separated lowercase hexadecimal format (e.g., `d0:73:d5:01:02:03`) to visually distinguish it from the serial number format.

```python
from lifx import Device

async def main():
    async with await Device.from_ip("192.168.1.100") as device:
        # MAC address is automatically calculated during setup
        if device.mac_address:
            print(f"Serial: {device.serial}")
            print(f"MAC:    {device.mac_address}")

        # Returns None before host_firmware is fetched
        assert device.mac_address is not None
```

## Examples

### Basic Light Control

```python
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Turn on and set color
        await light.set_power(True)
        await light.set_color(Colors.BLUE, duration=1.0)

        # Get device info
        label = await light.get_label()
        print(f"Controlling: {label}")
```

### Light Effects

```python
from lifx import Light, Colors


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Pulse effect
        await light.pulse(Colors.RED, period=1.0, cycles=5)

        # Breathe effect
        await light.breathe(Colors.BLUE, period=2.0, cycles=3)
```

### HEV Light Control (Anti-Bacterial Cleaning)

```python
from lifx import HevLight


async def main():
    async with await HevLight.from_ip("192.168.1.100") as light:
        # Start a 2-hour cleaning cycle
        await light.set_hev_cycle(enable=True, duration_seconds=7200)

        # Check cycle status
        state = await light.get_hev_cycle()
        if state.is_running:
            print(f"Cleaning: {state.remaining_s}s remaining")

        # Configure default settings
        await light.set_hev_config(indication=True, duration_seconds=7200)
```

### Infrared Light Control (Night Vision)

```python
from lifx import InfraredLight


async def main():
    async with await InfraredLight.from_ip("192.168.1.100") as light:
        # Set infrared brightness to 50%
        await light.set_infrared(0.5)

        # Get current infrared brightness
        brightness = await light.get_infrared()
        print(f"IR brightness: {brightness * 100}%")
```

### Ambient Light Sensor

Light devices with ambient light sensors can measure the current ambient light level in lux:

```python
from lifx import Light


async def main():
    async with await Light.from_ip("192.168.1.100") as light:
        # Ensure light is off for accurate reading
        await light.set_power(False)

        # Get ambient light level in lux
        lux = await light.get_ambient_light_level()
        if lux > 0:
            print(f"Ambient light: {lux} lux")
        else:
            print("No ambient light sensor or completely dark")
```

**Notes:**

- Devices without ambient light sensors return 0.0 (not an error)
- For accurate readings, the light should be turned off (otherwise the light's own illumination interferes with the sensor)
- This is a volatile property - always fetched fresh from the device
- A reading of 0.0 could mean either no sensor or complete darkness
- Returns ambient light level in lux (higher values indicate brighter ambient light)

### MultiZone Control

```python
from lifx import MultiZoneLight, Colors, FirmwareEffect, Direction


async def main():
    async with await MultiZoneLight.from_ip("192.168.1.100") as light:
        # Get all zones - automatically uses best method
        colors = await light.get_all_color_zones()
        print(f"Device has {len(colors)} zones")

        # Set a MOVE effect
        await light.set_effect(
            effect_type=FirmwareEffect.MOVE,
            speed=5.0,  # seconds per cycle
            direction=Direction.FORWARD,
        )

        # Get current effect
        effect = await light.get_effect()
        print(f"Effect: {effect.effect_type.name}")
        if effect.effect_type == FirmwareEffect.MOVE:
            print(f"Direction: {effect.direction.name}")

        # Stop the effect
        await light.set_effect(effect_type=FirmwareEffect.OFF)
```

### Tile Control

```python
from lifx import MatrixLight, HSBK, FirmwareEffect


async def main():
    async with await MatrixLight.from_ip("192.168.1.100") as light:
        # Set a gradient across the tile
        colors = [
            HSBK(hue=h, saturation=1.0, brightness=0.5, kelvin=3500)
            for h in range(0, 360, 10)
        ]
        await light.set_tile_colors(colors)

        # Set a tile effect (MORPH, FLAME, or SKY)
        await light.set_effect(
            effect_type=FirmwareEffect.FLAME,
            speed=5.0,  # seconds per cycle
        )

        # Get current effect
        effect = await light.get_effect()
        print(f"Tile effect: {effect.effect_type.name}")

        # Stop the effect
        await light.set_effect(effect_type=FirmwareEffect.OFF)
```

### Ceiling Light Control

```python
from lifx import CeilingLight, HSBK


async def main():
    async with await CeilingLight.from_ip("192.168.1.100") as ceiling:
        # Set downlight to warm white
        await ceiling.set_downlight_colors(
            HSBK(hue=0, saturation=0, brightness=0.8, kelvin=3000)
        )

        # Set uplight to a dim ambient glow
        await ceiling.set_uplight_color(
            HSBK(hue=30, saturation=0.2, brightness=0.3, kelvin=2700)
        )

        # Turn uplight off (stores color for later restoration)
        await ceiling.turn_uplight_off()

        # Turn uplight back on (restores previous color)
        await ceiling.turn_uplight_on()

        # Check component state
        if ceiling.downlight_is_on:
            print("Downlight is currently on")
```

For detailed CeilingLight usage, see the [Ceiling Lights User Guide](https://djelibeybi.github.io/lifx-async/user-guide/ceiling-lights/index.md).

# Network Layer

The network layer provides low-level operations for communicating with LIFX devices over UDP.

## Discovery

Functions for discovering LIFX devices on the local network.

### discover_devices

```python
discover_devices(
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> AsyncGenerator[DiscoveredDevice, None]
```

Discover LIFX devices on the local network.

Sends a broadcast DeviceGetService packet and yields devices as they respond. Implements DoS protection via timeout, source validation, and serial validation.

| PARAMETER                 | DESCRIPTION                                                                                          |
| ------------------------- | ---------------------------------------------------------------------------------------------------- |
| `timeout`                 | Discovery timeout in seconds **TYPE:** `float` **DEFAULT:** `DISCOVERY_TIMEOUT`                      |
| `broadcast_address`       | Broadcast address to use **TYPE:** `str` **DEFAULT:** `'255.255.255.255'`                            |
| `port`                    | UDP port to use (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                 |
| `max_response_time`       | Max time to wait for responses **TYPE:** `float` **DEFAULT:** `MAX_RESPONSE_TIME`                    |
| `idle_timeout_multiplier` | Idle timeout multiplier **TYPE:** `float` **DEFAULT:** `IDLE_TIMEOUT_MULTIPLIER`                     |
| `device_timeout`          | request timeout set on discovered devices **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT`   |
| `max_retries`             | max retries per request set on discovered devices **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES` |

| YIELDS                                   | DESCRIPTION                                       |
| ---------------------------------------- | ------------------------------------------------- |
| `AsyncGenerator[DiscoveredDevice, None]` | DiscoveredDevice instances as they are discovered |
| `AsyncGenerator[DiscoveredDevice, None]` | (deduplicated by serial number)                   |

Example

```python
# Process devices as they're discovered
async for device in discover_devices(timeout=5.0):
    print(f"Found device: {device.serial} at {device.ip}:{device.port}")

# Or collect all devices first
devices = []
async for device in discover_devices():
    devices.append(device)
```

Source code in `src/lifx/network/discovery.py`

````python
async def discover_devices(
    timeout: float = DISCOVERY_TIMEOUT,
    broadcast_address: str = "255.255.255.255",
    port: int = LIFX_UDP_PORT,
    max_response_time: float = MAX_RESPONSE_TIME,
    idle_timeout_multiplier: float = IDLE_TIMEOUT_MULTIPLIER,
    device_timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
) -> AsyncGenerator[DiscoveredDevice, None]:
    """Discover LIFX devices on the local network.

    Sends a broadcast DeviceGetService packet and yields devices as they respond.
    Implements DoS protection via timeout, source validation, and serial validation.

    Args:
        timeout: Discovery timeout in seconds
        broadcast_address: Broadcast address to use
        port: UDP port to use (default LIFX_UDP_PORT)
        max_response_time: Max time to wait for responses
        idle_timeout_multiplier: Idle timeout multiplier
        device_timeout: request timeout set on discovered devices
        max_retries: max retries per request set on discovered devices

    Yields:
        DiscoveredDevice instances as they are discovered
        (deduplicated by serial number)

    Example:
        ```python
        # Process devices as they're discovered
        async for device in discover_devices(timeout=5.0):
            print(f"Found device: {device.serial} at {device.ip}:{device.port}")

        # Or collect all devices first
        devices = []
        async for device in discover_devices():
            devices.append(device)
        ```
    """
    seen_serials: set[str] = set()
    packet_count = 0
    start_time = time.time()

    # Create transport with broadcast enabled
    async with UdpTransport(port=0, broadcast=True) as transport:
        # Allocate unique source for this discovery session
        discovery_source = secrets.randbelow(0xFFFFFFFF - 1) + 2

        # Create discovery message
        discovery_packet = DevicePackets.GetService()
        message = create_message(
            packet=discovery_packet,
            source=discovery_source,
            sequence=_DEFAULT_SEQUENCE_START,
            target=b"\x00" * 8,  # Broadcast
            res_required=True,
            ack_required=False,
        )

        # Send broadcast
        request_time = time.time()
        _LOGGER.debug(
            {
                "class": "discover_devices",
                "method": "discover",
                "action": "broadcast_sent",
                "broadcast_address": broadcast_address,
                "port": port,
                "max_timeout": timeout,
                "request_time": request_time,
            }
        )
        await transport.send(message, (broadcast_address, port))

        # Calculate idle timeout
        idle_timeout = max_response_time * idle_timeout_multiplier
        last_response_time = request_time

        # Collect responses with dynamic timeout
        while True:
            # Calculate elapsed time since last response
            elapsed_since_last = time.time() - last_response_time

            # Stop if we've been idle too long
            if elapsed_since_last >= idle_timeout:
                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "idle_timeout",
                        "idle_time": elapsed_since_last,
                        "idle_timeout": idle_timeout,
                    }
                )
                break

            # Stop if we've exceeded the overall timeout
            if time.time() - request_time >= timeout:
                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "overall_timeout",
                        "elapsed": time.time() - request_time,
                        "timeout": timeout,
                    }
                )
                break

            # Calculate remaining timeout (use the shorter of idle or overall timeout)
            remaining_idle = idle_timeout - elapsed_since_last
            remaining_overall = timeout - (time.time() - request_time)
            remaining = min(remaining_idle, remaining_overall)

            # Try to receive a packet
            try:
                data, addr = await transport.receive(timeout=remaining)
                response_timestamp = time.time()

            except LifxTimeoutError:
                # Timeout means no more responses within the idle period
                _LOGGER.debug(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "no_responses",
                    }
                )
                break

            # Increment packet counter for logging
            packet_count += 1

            try:
                # Parse message
                header, payload = parse_message(data)

                # Validate source matches expected source
                if header.source != discovery_source:
                    _LOGGER.debug(
                        {
                            "class": "discover_devices",
                            "method": "discover",
                            "action": "source_mismatch",
                            "expected_source": discovery_source,
                            "received_source": header.source,
                            "source_ip": addr[0],
                        }
                    )
                    continue

                # Check if this is a DeviceStateService response
                if header.pkt_type != DevicePackets.StateService.PKT_TYPE:
                    _LOGGER.debug(
                        {
                            "class": "discover_devices",
                            "method": "discover",
                            "action": "unexpected_packet_type",
                            "pkt_type": header.pkt_type,
                            "expected_type": DevicePackets.StateService.PKT_TYPE,
                            "source_ip": addr[0],
                        }
                    )
                    continue

                # Validate serial is not multicast/broadcast
                if header.target[0] & 0x01 or header.target == b"\xff" * 8:
                    _LOGGER.warning(
                        {
                            "warning": "Invalid serial number in discovery response",
                            "serial": header.target.hex(),
                            "source_ip": addr[0],
                        }
                    )
                    continue

                # Parse service info
                _service, device_port = _parse_device_state_service(payload)

                # Calculate accurate response time from this specific response
                response_time = response_timestamp - request_time

                # Convert 8-byte protocol serial to string
                device_serial = Serial.from_protocol(header.target).to_string()

                # Deduplicate by serial number and yield new devices immediately
                if device_serial not in seen_serials:
                    seen_serials.add(device_serial)

                    # Create device info
                    device = DiscoveredDevice(
                        serial=device_serial,
                        ip=addr[0],
                        port=device_port,
                        response_time=response_time,
                        timeout=device_timeout,
                        max_retries=max_retries,
                    )

                    _LOGGER.debug(
                        {
                            "class": "discover_devices",
                            "method": "discover",
                            "action": "device_found",
                            "serial": device.serial,
                            "ip": device.ip,
                            "port": device.port,
                            "response_time": response_time,
                        }
                    )

                    yield device

                # Update last response time for idle timeout calculation
                last_response_time = response_timestamp

            except LifxProtocolError as e:
                # Log malformed responses
                _LOGGER.warning(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "malformed_response",
                        "reason": str(e),
                        "source_ip": addr[0],
                        "packet_size": len(data),
                    },
                    exc_info=True,
                )
                continue
            except Exception as e:
                # Log unexpected errors
                _LOGGER.error(
                    {
                        "class": "discover_devices",
                        "method": "discover",
                        "action": "unexpected_error",
                        "error_details": str(e),
                        "source_ip": addr[0],
                    },
                    exc_info=True,
                )
                continue

        _LOGGER.debug(
            {
                "class": "discover_devices",
                "method": "discover",
                "action": "complete",
                "devices_found": len(seen_serials),
                "packets_processed": packet_count,
                "elapsed": time.time() - start_time,
            }
        )
````

### DiscoveredDevice

```python
DiscoveredDevice(
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
    max_retries: int = DEFAULT_MAX_RETRIES,
    first_seen: float = time(),
    response_time: float = 0.0,
)
```

Information about a discovered LIFX device.

| ATTRIBUTE       | DESCRIPTION                                                                        |
| --------------- | ---------------------------------------------------------------------------------- |
| `serial`        | Device serial number as 12-digit hex string (e.g., "d073d5123456") **TYPE:** `str` |
| `ip`            | Device IP address **TYPE:** `str`                                                  |
| `port`          | Device UDP port **TYPE:** `int`                                                    |
| `first_seen`    | Timestamp when device was first discovered **TYPE:** `float`                       |
| `response_time` | Response time in seconds **TYPE:** `float`                                         |

| METHOD          | DESCRIPTION                                                       |
| --------------- | ----------------------------------------------------------------- |
| `create_device` | Create appropriate device instance based on product capabilities. |
| `__hash__`      | Hash based on serial number for deduplication.                    |
| `__eq__`        | Equality based on serial number.                                  |

#### Functions

##### create_device

```python
create_device() -> Device | None
```

Create appropriate device instance based on product capabilities.

Queries the device for its product ID and uses the product registry to instantiate the appropriate device class (Device, Light, HevLight, InfraredLight, MultiZoneLight, MatrixLight, or CeilingLight) based on the product capabilities.

This is the single source of truth for device type detection and instantiation across the library.

| RETURNS  | DESCRIPTION |
| -------- | ----------- |
| \`Device | None\`      |

| RAISES                    | DESCRIPTION                    |
| ------------------------- | ------------------------------ |
| `LifxDeviceNotFoundError` | If device doesn't respond      |
| `LifxTimeoutError`        | If device query times out      |
| `LifxProtocolError`       | If device returns invalid data |

Example

```python
devices = await discover_devices()
for discovered in devices:
    device = await discovered.create_device()
    print(f"Created {type(device).__name__}: {await device.get_label()}")
```

Source code in `src/lifx/network/discovery.py`

````python
async def create_device(self) -> Device | None:
    """Create appropriate device instance based on product capabilities.

    Queries the device for its product ID and uses the product registry
    to instantiate the appropriate device class (Device, Light, HevLight,
    InfraredLight, MultiZoneLight, MatrixLight, or CeilingLight) based on
    the product capabilities.

    This is the single source of truth for device type detection and
    instantiation across the library.

    Returns:
        Device instance of the appropriate type

    Raises:
        LifxDeviceNotFoundError: If device doesn't respond
        LifxTimeoutError: If device query times out
        LifxProtocolError: If device returns invalid data

    Example:
        ```python
        devices = await discover_devices()
        for discovered in devices:
            device = await discovered.create_device()
            print(f"Created {type(device).__name__}: {await device.get_label()}")
        ```
    """
    from lifx.devices.base import Device
    from lifx.devices.ceiling import CeilingLight
    from lifx.devices.hev import HevLight
    from lifx.devices.infrared import InfraredLight
    from lifx.devices.light import Light
    from lifx.devices.matrix import MatrixLight
    from lifx.devices.multizone import MultiZoneLight
    from lifx.products import is_ceiling_product

    kwargs = {
        "serial": self.serial,
        "ip": self.ip,
        "port": self.port,
        "timeout": self.timeout,
        "max_retries": self.max_retries,
    }

    # Create temporary device to query version
    temp_device = Device(**kwargs)

    try:
        await temp_device._ensure_capabilities()

        if temp_device.capabilities:
            # Check for Ceiling products first (before generic MatrixLight)
            if temp_device.version and is_ceiling_product(
                temp_device.version.product
            ):
                return CeilingLight(**kwargs)

            if temp_device.capabilities.has_matrix:
                return MatrixLight(**kwargs)
            if temp_device.capabilities.has_multizone:
                return MultiZoneLight(**kwargs)
            if temp_device.capabilities.has_infrared:
                return InfraredLight(**kwargs)
            if temp_device.capabilities.has_hev:
                return HevLight(**kwargs)
            if temp_device.capabilities.has_relays or (
                temp_device.capabilities.has_buttons
                and not temp_device.capabilities.has_color
            ):
                return None

            return Light(**kwargs)

    except Exception:
        return None

    finally:
        # Always close the temporary device connection to prevent resource leaks
        await temp_device.connection.close()

    return None
````

##### __hash__

```python
__hash__() -> int
```

Hash based on serial number for deduplication.

Source code in `src/lifx/network/discovery.py`

```python
def __hash__(self) -> int:
    """Hash based on serial number for deduplication."""
    return hash(self.serial)
```

##### __eq__

```python
__eq__(other: object) -> bool
```

Equality based on serial number.

Source code in `src/lifx/network/discovery.py`

```python
def __eq__(self, other: object) -> bool:
    """Equality based on serial number."""
    if not isinstance(other, DiscoveredDevice):
        return False
    return self.serial == other.serial
```

### DiscoveryResponse

Response dataclass from custom discovery broadcasts (using packets other than GetService).

#### DiscoveryResponse

```python
DiscoveryResponse(
    serial: str,
    ip: str,
    port: int,
    response_time: float,
    response_payload: dict[str, Any],
)
```

Response from a discovery broadcast using a custom packet.

| ATTRIBUTE          | DESCRIPTION                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| `serial`           | Device serial number **TYPE:** `str`                                      |
| `ip`               | Device IP address **TYPE:** `str`                                         |
| `port`             | Device UDP port **TYPE:** `int`                                           |
| `response_time`    | Response time in seconds **TYPE:** `float`                                |
| `response_payload` | Unpacked State packet fields as key/value dict **TYPE:** `dict[str, Any]` |

## UDP Transport

Low-level UDP transport for sending and receiving LIFX protocol messages.

### UdpTransport

```python
UdpTransport(
    ip_address: str = DEFAULT_IP_ADDRESS, port: int = 0, broadcast: bool = False
)
```

UDP transport for sending and receiving LIFX packets.

This class provides a simple interface for UDP communication with LIFX devices. It uses asyncio for async I/O operations.

| PARAMETER   | DESCRIPTION                                                                         |
| ----------- | ----------------------------------------------------------------------------------- |
| `port`      | Local port to bind to (0 for automatic assignment) **TYPE:** `int` **DEFAULT:** `0` |
| `broadcast` | Enable broadcast mode for device discovery **TYPE:** `bool` **DEFAULT:** `False`    |

| METHOD         | DESCRIPTION                                     |
| -------------- | ----------------------------------------------- |
| `open`         | Open the UDP socket.                            |
| `send`         | Send data to a specific address.                |
| `receive`      | Receive data from socket with size validation.  |
| `receive_many` | Receive multiple packets within timeout period. |
| `close`        | Close the UDP socket.                           |

| ATTRIBUTE | DESCRIPTION                               |
| --------- | ----------------------------------------- |
| `is_open` | Check if socket is open. **TYPE:** `bool` |

Source code in `src/lifx/network/transport.py`

```python
def __init__(
    self,
    ip_address: str = DEFAULT_IP_ADDRESS,
    port: int = 0,
    broadcast: bool = False,
) -> None:
    """Initialize UDP transport.

    Args:
        port: Local port to bind to (0 for automatic assignment)
        broadcast: Enable broadcast mode for device discovery
    """
    self._ip_address = ip_address
    self._port = port
    self._broadcast = broadcast
    self._protocol: _UdpProtocol | None = None
    self._transport: DatagramTransport | None = None
```

#### Attributes

##### is_open

```python
is_open: bool
```

Check if socket is open.

#### Functions

##### open

```python
open() -> None
```

Open the UDP socket.

Source code in `src/lifx/network/transport.py`

```python
async def open(self) -> None:
    """Open the UDP socket."""
    if self._protocol is not None:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "already_open",
                "ip_address": self._ip_address,
                "port": self._port,
            }
        )
        return

    try:
        import socket as stdlib_socket

        loop = asyncio.get_running_loop()

        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "opening_socket",
                "ip_address": self._ip_address,
                "port": self._port,
                "broadcast": self._broadcast,
            }
        )

        # Create protocol
        protocol = _UdpProtocol()
        self._protocol = protocol

        # Create datagram endpoint
        self._transport, _ = await loop.create_datagram_endpoint(
            lambda: protocol,
            local_addr=(self._ip_address, self._port),
            reuse_port=bool(hasattr(stdlib_socket, "SO_REUSEPORT")),
            family=stdlib_socket.AF_INET,
        )

        # Get actual port assigned
        actual_port = self._transport.get_extra_info("sockname")[1]
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "socket_opened",
                "assigned_port": actual_port,
                "broadcast": self._broadcast,
            }
        )

        # Enable broadcast if requested
        if self._broadcast:
            sock = self._transport.get_extra_info("socket")
            if sock:
                sock.setsockopt(
                    stdlib_socket.SOL_SOCKET,
                    stdlib_socket.SO_BROADCAST,
                    1,
                )
                _LOGGER.debug(
                    {
                        "class": "UdpTransport",
                        "method": "open",
                        "action": "broadcast_enabled",
                    }
                )

    except OSError as e:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "open",
                "action": "failed",
                "ip_address": self._ip_address,
                "port": self._port,
                "reason": str(e),
            }
        )
        raise LifxNetworkError(f"Failed to open UDP socket: {e}") from e
```

##### send

```python
send(data: bytes, address: tuple[str, int]) -> None
```

Send data to a specific address.

| PARAMETER | DESCRIPTION                                       |
| --------- | ------------------------------------------------- |
| `data`    | Bytes to send **TYPE:** `bytes`                   |
| `address` | Tuple of (host, port) **TYPE:** `tuple[str, int]` |

| RAISES         | DESCRIPTION                         |
| -------------- | ----------------------------------- |
| `NetworkError` | If socket is not open or send fails |

Source code in `src/lifx/network/transport.py`

```python
async def send(self, data: bytes, address: tuple[str, int]) -> None:
    """Send data to a specific address.

    Args:
        data: Bytes to send
        address: Tuple of (host, port)

    Raises:
        NetworkError: If socket is not open or send fails
    """
    if self._transport is None or self._protocol is None:
        raise LifxNetworkError("Socket not open")

    try:
        self._transport.sendto(data, address)
    except OSError as e:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "send",
                "action": "failed",
                "destination": address,
                "packet_size": len(data),
                "reason": str(e),
            }
        )
        raise LifxNetworkError(f"Failed to send data: {e}") from e
```

##### receive

```python
receive(timeout: float = 2.0) -> tuple[bytes, tuple[str, int]]
```

Receive data from socket with size validation.

| PARAMETER | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `timeout` | Timeout in seconds **TYPE:** `float` **DEFAULT:** `2.0` |

| RETURNS                         | DESCRIPTION                                            |
| ------------------------------- | ------------------------------------------------------ |
| `tuple[bytes, tuple[str, int]]` | Tuple of (data, address) where address is (host, port) |

| RAISES             | DESCRIPTION                            |
| ------------------ | -------------------------------------- |
| `LifxTimeoutError` | If no data received within timeout     |
| `NetworkError`     | If socket is not open or receive fails |
| `ProtocolError`    | If packet size is invalid              |

Source code in `src/lifx/network/transport.py`

```python
async def receive(self, timeout: float = 2.0) -> tuple[bytes, tuple[str, int]]:
    """Receive data from socket with size validation.

    Args:
        timeout: Timeout in seconds

    Returns:
        Tuple of (data, address) where address is (host, port)

    Raises:
        LifxTimeoutError: If no data received within timeout
        NetworkError: If socket is not open or receive fails
        ProtocolError: If packet size is invalid
    """
    if self._protocol is None:
        raise LifxNetworkError("Socket not open")

    try:
        async with asyncio.timeout(timeout):
            data, addr = await self._protocol.queue.get()

            # Validate packet size
            if len(data) > MAX_PACKET_SIZE:
                from lifx.exceptions import LifxProtocolError

                _LOGGER.error(
                    {
                        "class": "UdpTransport",
                        "method": "receive",
                        "action": "packet_too_large",
                        "packet_size": len(data),
                        "max_size": MAX_PACKET_SIZE,
                    }
                )
                raise LifxProtocolError(
                    f"Packet too big: {len(data)} bytes > {MAX_PACKET_SIZE} bytes"
                )

            if len(data) < MIN_PACKET_SIZE:
                from lifx.exceptions import LifxProtocolError

                _LOGGER.error(
                    {
                        "class": "UdpTransport",
                        "method": "receive",
                        "action": "packet_too_small",
                        "packet_size": len(data),
                        "min_size": MIN_PACKET_SIZE,
                    }
                )
                raise LifxProtocolError(
                    f"Packet too small: {len(data)} bytes < {MIN_PACKET_SIZE} bytes"
                )

            return data, addr
    except TimeoutError as e:
        raise LifxTimeoutError(f"No data received within {timeout}s") from e
    except OSError as e:
        _LOGGER.error(
            {
                "class": "UdpTransport",
                "method": "receive",
                "action": "failed",
                "reason": str(e),
            }
        )
        raise LifxNetworkError(f"Failed to receive data: {e}") from e
```

##### receive_many

```python
receive_many(
    timeout: float = 5.0, max_packets: int | None = None
) -> list[tuple[bytes, tuple[str, int]]]
```

Receive multiple packets within timeout period.

| PARAMETER     | DESCRIPTION                                                               |
| ------------- | ------------------------------------------------------------------------- |
| `timeout`     | Total timeout in seconds **TYPE:** `float` **DEFAULT:** `5.0`             |
| `max_packets` | Maximum number of packets to receive (None for unlimited) **TYPE:** \`int |

| RETURNS                               | DESCRIPTION                    |
| ------------------------------------- | ------------------------------ |
| `list[tuple[bytes, tuple[str, int]]]` | List of (data, address) tuples |

| RAISES         | DESCRIPTION           |
| -------------- | --------------------- |
| `NetworkError` | If socket is not open |

Source code in `src/lifx/network/transport.py`

```python
async def receive_many(
    self, timeout: float = 5.0, max_packets: int | None = None
) -> list[tuple[bytes, tuple[str, int]]]:
    """Receive multiple packets within timeout period.

    Args:
        timeout: Total timeout in seconds
        max_packets: Maximum number of packets to receive (None for unlimited)

    Returns:
        List of (data, address) tuples

    Raises:
        NetworkError: If socket is not open
    """
    if self._protocol is None:
        raise LifxNetworkError("Socket not open")

    packets: list[tuple[bytes, tuple[str, int]]] = []

    try:
        async with asyncio.timeout(timeout):
            while True:
                if max_packets is not None and len(packets) >= max_packets:
                    break

                try:
                    data, addr = await self._protocol.queue.get()

                    # Validate packet size
                    if len(data) > MAX_PACKET_SIZE:
                        # Drop oversized packet to prevent memory exhaustion DoS
                        continue

                    if len(data) < MIN_PACKET_SIZE:
                        # Drop undersized packet (header is 36 bytes)
                        continue

                    packets.append((data, addr))
                except OSError:
                    # Ignore individual receive errors
                    break

    except TimeoutError:
        # Timeout is expected - return what we collected
        pass

    return packets
```

##### close

```python
close() -> None
```

Close the UDP socket.

Source code in `src/lifx/network/transport.py`

```python
async def close(self) -> None:
    """Close the UDP socket."""
    if self._transport is not None:
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "close",
                "action": "closing",
            }
        )
        self._transport.close()
        self._transport = None
        self._protocol = None
        _LOGGER.debug(
            {
                "class": "UdpTransport",
                "method": "close",
                "action": "closed",
            }
        )
```

## Examples

### Device Discovery

```python
from lifx.network.discovery import discover_devices


async def main():
    # Discover all devices on the network
    devices = await discover_devices(timeout=3.0)

    for device in devices:
        print(f"Found: {device.label} at {device.ip}")
        print(f"  Serial: {device.serial}")
```

## Concurrency

### Request Serialization on Single Connection

Each `DeviceConnection` serializes requests using a lock to prevent response mixing:

```python
import asyncio
from lifx.network.connection import DeviceConnection
from lifx.protocol.packets import Light, Device


async def main():
    conn = DeviceConnection(serial="d073d5123456", ip="192.168.1.100")

    # Sequential requests (serialized by internal lock)
    state = await conn.request(Light.GetColor())
    power = await conn.request(Light.GetPower())
    label = await conn.request(Device.GetLabel())

    # Connection automatically closes when done
    await conn.close()
```

### Concurrent Requests on Different Devices

```python
import asyncio
from lifx.network.connection import DeviceConnection


async def main():
    conn1 = DeviceConnection(serial="d073d5000001", ip="192.168.1.100")
    conn2 = DeviceConnection(serial="d073d5000002", ip="192.168.1.101")

    # Fully parallel - different UDP sockets
    result1, result2 = await asyncio.gather(
        conn1.request(Light.GetColor()),
        conn2.request(Light.GetColor())
    )

    # Clean up connections
    await conn1.close()
    await conn2.close()
```

## Connection Management

### DeviceConnection

```python
DeviceConnection(
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    max_retries: int = DEFAULT_MAX_RETRIES,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
)
```

Connection to a LIFX device.

This class manages the UDP transport and request/response lifecycle for a single device. Connections are opened lazily on first request and remain open until explicitly closed.

Features:

- Lazy connection opening (no context manager required)
- Async generator-based request/response streaming
- Retry logic with exponential backoff and jitter
- Request serialization to prevent response mixing
- Automatic sequence number management

Example

```python
conn = DeviceConnection(serial="d073d5123456", ip="192.168.1.100")

# Connection opens automatically on first request
state = await conn.request(packets.Light.GetColor())
# state.label is already decoded to string
# state.color is LightHsbk instance

# Optionally close when done
await conn.close()
```

With context manager (recommended for cleanup):

```python
async with DeviceConnection(...) as conn:
    state = await conn.request(packets.Light.GetColor())
# Connection automatically closed on exit
```

This is lightweight - doesn't actually create a connection. Connection is opened lazily on first request.

| PARAMETER     | DESCRIPTION                                                                                                     |
| ------------- | --------------------------------------------------------------------------------------------------------------- |
| `serial`      | Device serial number as 12-digit hex string (e.g., 'd073d5123456') **TYPE:** `str`                              |
| `ip`          | Device IP address **TYPE:** `str`                                                                               |
| `port`        | Device UDP port (default LIFX_UDP_PORT) **TYPE:** `int` **DEFAULT:** `LIFX_UDP_PORT`                            |
| `max_retries` | Maximum number of retry attempts (default: 8) **TYPE:** `int` **DEFAULT:** `DEFAULT_MAX_RETRIES`                |
| `timeout`     | Default timeout for requests in seconds (default: 8.0) **TYPE:** `float` **DEFAULT:** `DEFAULT_REQUEST_TIMEOUT` |

| METHOD           | DESCRIPTION                                                 |
| ---------------- | ----------------------------------------------------------- |
| `__aenter__`     | Enter async context manager.                                |
| `__aexit__`      | Exit async context manager and close connection.            |
| `open`           | Open connection to device.                                  |
| `close`          | Close connection to device.                                 |
| `send_packet`    | Send a packet to the device.                                |
| `receive_packet` | Receive a packet from the device.                           |
| `request_stream` | Send request and yield unpacked responses.                  |
| `request`        | Send request and get single response (convenience wrapper). |

| ATTRIBUTE | DESCRIPTION                                   |
| --------- | --------------------------------------------- |
| `is_open` | Check if connection is open. **TYPE:** `bool` |

Source code in `src/lifx/network/connection.py`

```python
def __init__(
    self,
    serial: str,
    ip: str,
    port: int = LIFX_UDP_PORT,
    max_retries: int = DEFAULT_MAX_RETRIES,
    timeout: float = DEFAULT_REQUEST_TIMEOUT,
) -> None:
    """Initialize device connection.

    This is lightweight - doesn't actually create a connection.
    Connection is opened lazily on first request.

    Args:
        serial: Device serial number as 12-digit hex string (e.g., 'd073d5123456')
        ip: Device IP address
        port: Device UDP port (default LIFX_UDP_PORT)
        max_retries: Maximum number of retry attempts (default: 8)
        timeout: Default timeout for requests in seconds (default: 8.0)
    """
    self.serial = serial
    self.ip = ip
    self.port = port
    self.max_retries = max_retries
    self.timeout = timeout

    self._transport: UdpTransport | None = None
    self._is_open = False
    self._is_opening = False  # Flag to prevent concurrent open() calls

    # Background receiver task infrastructure
    # Key: (source, sequence, serial)  Queue of (header, payload) tuples
    self._pending_requests: dict[
        tuple[int, int, str], asyncio.Queue[tuple[LifxHeader, bytes]]
    ] = {}
    self._receiver_task: asyncio.Task[None] | None = None
    self._receiver_shutdown: asyncio.Event | None = None
```

#### Attributes

##### is_open

```python
is_open: bool
```

Check if connection is open.

#### Functions

##### __aenter__

```python
__aenter__() -> Self
```

Enter async context manager.

Source code in `src/lifx/network/connection.py`

```python
async def __aenter__(self) -> Self:
    """Enter async context manager."""
    # Don't open connection here - it will open lazily on first request
    return self
```

##### __aexit__

```python
__aexit__(
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: object,
) -> None
```

Exit async context manager and close connection.

Source code in `src/lifx/network/connection.py`

```python
async def __aexit__(
    self,
    exc_type: type[BaseException] | None,
    exc_val: BaseException | None,
    exc_tb: object,
) -> None:
    """Exit async context manager and close connection."""
    await self.close()
```

##### open

```python
open() -> None
```

Open connection to device.

Opens the UDP transport for sending and receiving packets. Called automatically on first request if not already open.

Source code in `src/lifx/network/connection.py`

```python
async def open(self) -> None:
    """Open connection to device.

    Opens the UDP transport for sending and receiving packets.
    Called automatically on first request if not already open.
    """
    if self._is_open:
        return

    # Prevent concurrent open() calls
    if self._is_opening:
        # Another task is already opening, wait for it
        while self._is_opening:
            await asyncio.sleep(0.001)
        return

    self._is_opening = True
    try:
        # Double-check after setting flag
        if self._is_open:  # pragma: no cover
            return

        # Create shutdown event for receiver task
        self._receiver_shutdown = asyncio.Event()

        # Open transport
        self._transport = UdpTransport(port=0, broadcast=False)
        await self._transport.open()
        self._is_open = True

        # Start background receiver task
        self._receiver_task = asyncio.create_task(self._background_receiver())

        _LOGGER.debug(
            {
                "class": "DeviceConnection",
                "method": "open",
                "serial": self.serial,
                "ip": self.ip,
                "port": self.port,
            }
        )
    finally:
        self._is_opening = False
```

##### close

```python
close() -> None
```

Close connection to device.

Source code in `src/lifx/network/connection.py`

```python
async def close(self) -> None:
    """Close connection to device."""
    if not self._is_open:
        return

    self._is_open = False

    # Signal shutdown to receiver task
    if self._receiver_shutdown:
        self._receiver_shutdown.set()

    # Wait for receiver to stop (with timeout)
    if self._receiver_task:
        try:
            await asyncio.wait_for(
                self._receiver_task, timeout=_RECEIVER_SHUTDOWN_TIMEOUT
            )
        except TimeoutError:
            self._receiver_task.cancel()
            try:
                await self._receiver_task
            except asyncio.CancelledError:
                pass

    # Cancel all pending request queues
    for queue in self._pending_requests.values():
        # Drain queue
        while not queue.empty():
            try:
                queue.get_nowait()
            except asyncio.QueueEmpty:
                break
    self._pending_requests.clear()

    # Close transport
    if self._transport is not None:
        await self._transport.close()

    _LOGGER.debug(
        {
            "class": "DeviceConnection",
            "method": "close",
            "serial": self.serial,
            "ip": self.ip,
        }
    )
    self._transport = None
```

##### send_packet

```python
send_packet(
    packet: Any,
    source: int | None = None,
    sequence: int = 0,
    ack_required: bool = False,
    res_required: bool = False,
) -> None
```

Send a packet to the device.

| PARAMETER      | DESCRIPTION                                                            |
| -------------- | ---------------------------------------------------------------------- |
| `packet`       | Packet dataclass instance **TYPE:** `Any`                              |
| `source`       | Client source identifier (optional, allocated if None) **TYPE:** \`int |
| `sequence`     | Sequence number (default: 0) **TYPE:** `int` **DEFAULT:** `0`          |
| `ack_required` | Request acknowledgement **TYPE:** `bool` **DEFAULT:** `False`          |
| `res_required` | Request response **TYPE:** `bool` **DEFAULT:** `False`                 |

| RAISES            | DESCRIPTION                             |
| ----------------- | --------------------------------------- |
| `ConnectionError` | If connection is not open or send fails |

Source code in `src/lifx/network/connection.py`

```python
async def send_packet(
    self,
    packet: Any,
    source: int | None = None,
    sequence: int = 0,
    ack_required: bool = False,
    res_required: bool = False,
) -> None:
    """Send a packet to the device.

    Args:
        packet: Packet dataclass instance
        source: Client source identifier (optional, allocated if None)
        sequence: Sequence number (default: 0)
        ack_required: Request acknowledgement
        res_required: Request response

    Raises:
        ConnectionError: If connection is not open or send fails
    """
    if not self._is_open or self._transport is None:
        raise LifxConnectionError("Connection not open")

    # Allocate source if not provided
    if source is None:
        source = self._allocate_source()

    target = Serial.from_string(self.serial).to_protocol()
    message = create_message(
        packet=packet,
        source=source,
        sequence=sequence,
        target=target,
        ack_required=ack_required,
        res_required=res_required,
    )

    # Send to device
    await self._transport.send(message, (self.ip, self.port))
```

##### receive_packet

```python
receive_packet(timeout: float = 0.5) -> tuple[LifxHeader, bytes]
```

Receive a packet from the device.

Note

This method does not validate the source IP address. Validation is instead performed using the LIFX protocol's built-in target field (serial number) and sequence number matching in request_stream() and request_ack_stream(). This approach is more reliable in complex network configurations (NAT, multiple interfaces, bridges, etc.) while maintaining security through proper protocol-level validation.

| PARAMETER | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `timeout` | Timeout in seconds **TYPE:** `float` **DEFAULT:** `0.5` |

| RETURNS                    | DESCRIPTION                |
| -------------------------- | -------------------------- |
| `tuple[LifxHeader, bytes]` | Tuple of (header, payload) |

| RAISES            | DESCRIPTION                   |
| ----------------- | ----------------------------- |
| `ConnectionError` | If connection is not open     |
| `TimeoutError`    | If no response within timeout |

Source code in `src/lifx/network/connection.py`

```python
async def receive_packet(self, timeout: float = 0.5) -> tuple[LifxHeader, bytes]:
    """Receive a packet from the device.

    Note:
        This method does not validate the source IP address. Validation is instead
        performed using the LIFX protocol's built-in target field (serial number)
        and sequence number matching in request_stream() and request_ack_stream().
        This approach is more reliable in complex network configurations (NAT,
        multiple interfaces, bridges, etc.) while maintaining security through
        proper protocol-level validation.

    Args:
        timeout: Timeout in seconds

    Returns:
        Tuple of (header, payload)

    Raises:
        ConnectionError: If connection is not open
        TimeoutError: If no response within timeout
    """
    if not self._is_open or self._transport is None:
        raise LifxConnectionError("Connection not open")

    # Receive message - source address not validated here
    # Validation occurs via target field and sequence number matching
    data, _addr = await self._transport.receive(timeout=timeout)

    # Parse and return message
    return parse_message(data)
```

##### request_stream

```python
request_stream(
    packet: Any, timeout: float | None = None
) -> AsyncGenerator[Any, None]
```

Send request and yield unpacked responses.

This is an async generator that handles the complete request/response cycle including packet type detection, response unpacking, and label decoding. Connection is opened automatically if not already open.

Single response (most common): async for response in conn.request_stream(GetLabel()): process(response) break # Exit immediately

Multiple responses

async for state in conn.request_stream(GetColorZones()): process(state)

# Continues until timeout

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `packet`  | Packet instance to send **TYPE:** `Any`      |
| `timeout` | Request timeout in seconds **TYPE:** \`float |

| YIELDS                      | DESCRIPTION                                                              |
| --------------------------- | ------------------------------------------------------------------------ |
| `AsyncGenerator[Any, None]` | Unpacked response packet instances (including StateUnhandled if device   |
| `AsyncGenerator[Any, None]` | doesn't support the command)                                             |
| `AsyncGenerator[Any, None]` | For SET packets: yields True (acknowledgement) or False (StateUnhandled) |

| RAISES                | DESCRIPTION          |
| --------------------- | -------------------- |
| `LifxTimeoutError`    | If request times out |
| `LifxProtocolError`   | If response invalid  |
| `LifxConnectionError` | If connection fails  |

Example

```python
# GET request yields unpacked packets
async for state in conn.request_stream(packets.Light.GetColor()):
    color = HSBK.from_protocol(state.color)
    label = state.label  # Already decoded to string
    break

# SET request yields True (acknowledgement) or False (StateUnhandled)
async for result in conn.request_stream(
    packets.Light.SetColor(color=hsbk, duration=1000)
):
    if result:
        # Acknowledgement received
        pass
    else:
        # Device doesn't support this command
        pass
    break

# Multi-response GET - stream all responses
async for state in conn.request_stream(
    packets.MultiZone.GetExtendedColorZones()
):
    # Process each zone state
    pass
```

Source code in `src/lifx/network/connection.py`

````python
async def request_stream(
    self,
    packet: Any,
    timeout: float | None = None,
) -> AsyncGenerator[Any, None]:
    """Send request and yield unpacked responses.

    This is an async generator that handles the complete request/response
    cycle including packet type detection, response unpacking, and label
    decoding. Connection is opened automatically if not already open.

    Single response (most common):
        async for response in conn.request_stream(GetLabel()):
            process(response)
            break  # Exit immediately

    Multiple responses:
        async for state in conn.request_stream(GetColorZones()):
            process(state)
            # Continues until timeout

    Args:
        packet: Packet instance to send
        timeout: Request timeout in seconds

    Yields:
        Unpacked response packet instances (including StateUnhandled if device
        doesn't support the command)
        For SET packets: yields True (acknowledgement) or False (StateUnhandled)

    Raises:
        LifxTimeoutError: If request times out
        LifxProtocolError: If response invalid
        LifxConnectionError: If connection fails

    Example:
        ```python
        # GET request yields unpacked packets
        async for state in conn.request_stream(packets.Light.GetColor()):
            color = HSBK.from_protocol(state.color)
            label = state.label  # Already decoded to string
            break

        # SET request yields True (acknowledgement) or False (StateUnhandled)
        async for result in conn.request_stream(
            packets.Light.SetColor(color=hsbk, duration=1000)
        ):
            if result:
                # Acknowledgement received
                pass
            else:
                # Device doesn't support this command
                pass
            break

        # Multi-response GET - stream all responses
        async for state in conn.request_stream(
            packets.MultiZone.GetExtendedColorZones()
        ):
            # Process each zone state
            pass
        ```
    """
    # Ensure connection is open (lazy opening)
    await self._ensure_open()

    if timeout is None:
        timeout = self.timeout

    # Get packet metadata
    packet_kind = getattr(packet, "_packet_kind", "OTHER")

    if packet_kind == "GET":
        # Use PACKET_REGISTRY to find the appropriate packet class
        from lifx.protocol.packets import get_packet_class

        # Stream responses and unpack each
        async for header, payload in self._request_stream_impl(
            packet, timeout=timeout
        ):
            packet_class = get_packet_class(header.pkt_type)
            if packet_class is None:
                raise LifxProtocolError(
                    f"Unknown packet type {header.pkt_type} in response"
                )

            # Update unknown serial with value from response header
            serial = Serial(value=header.target_serial).to_string()
            if self.serial == "000000000000" and serial != self.serial:
                self.serial = serial

            # Unpack (labels are automatically decoded by Packet.unpack())
            response_packet = packet_class.unpack(payload)

            # Log the request/reply cycle
            request_values = packet.as_dict
            reply_values = response_packet.as_dict
            _LOGGER.debug(
                {
                    "class": "DeviceConnection",
                    "method": "request_stream",
                    "request": {
                        "packet": type(packet).__name__,
                        "values": request_values,
                    },
                    "reply": {
                        "packet": type(response_packet).__name__,
                        "values": reply_values,
                    },
                    "serial": self.serial,
                    "ip": self.ip,
                }
            )

            yield response_packet

    elif packet_kind == "SET":
        # Request acknowledgement
        async for ack_result in self._request_ack_stream_impl(
            packet, timeout=timeout
        ):
            # Log the request/ack cycle
            request_values = packet.as_dict
            reply_packet = "Acknowledgement" if ack_result else "StateUnhandled"
            _LOGGER.debug(
                {
                    "class": "DeviceConnection",
                    "method": "request_stream",
                    "request": {
                        "packet": type(packet).__name__,
                        "values": request_values,
                    },
                    "reply": {
                        "packet": reply_packet,
                        "values": {},
                    },
                    "serial": self.serial,
                    "ip": self.ip,
                }
            )

            yield ack_result
            return

    else:
        # Handle special cases
        if hasattr(packet, "PKT_TYPE"):
            pkt_type = packet.PKT_TYPE
            # EchoRequest/EchoResponse (58/59)
            if pkt_type == 58:  # EchoRequest
                from lifx.protocol.packets import Device

                async for header, payload in self._request_stream_impl(
                    packet, timeout=timeout
                ):
                    response_packet = Device.EchoResponse.unpack(payload)

                    # Log the request/reply cycle
                    request_values = packet.as_dict
                    reply_values = response_packet.as_dict
                    _LOGGER.debug(
                        {
                            "class": "DeviceConnection",
                            "method": "request_stream",
                            "request": {
                                "packet": type(packet).__name__,
                                "values": request_values,
                            },
                            "reply": {
                                "packet": type(response_packet).__name__,
                                "values": reply_values,
                            },
                            "serial": self.serial,
                            "ip": self.ip,
                        }
                    )

                    yield response_packet
                    return
            else:
                raise LifxProtocolError(
                    f"Cannot auto-handle packet kind: {packet_kind}"
                )
        else:
            raise LifxProtocolError(
                f"Packet missing PKT_TYPE: {type(packet).__name__}"
            )
````

##### request

```python
request(packet: Any, timeout: float | None = None) -> Any
```

Send request and get single response (convenience wrapper).

This is a convenience method that returns the first response from request_stream(). It's equivalent to: await anext(conn.request_stream(packet))

Most device operations use this method since they expect a single response. Connection is opened automatically if not already open.

| PARAMETER | DESCRIPTION                                  |
| --------- | -------------------------------------------- |
| `packet`  | Packet instance to send **TYPE:** `Any`      |
| `timeout` | Request timeout in seconds **TYPE:** \`float |

| RETURNS | DESCRIPTION                                                         |
| ------- | ------------------------------------------------------------------- |
| `Any`   | Single unpacked response packet (including StateUnhandled if device |
| `Any`   | doesn't support the command)                                        |
| `Any`   | For SET packets: True (acknowledgement) or False (StateUnhandled)   |

| RAISES                | DESCRIPTION                   |
| --------------------- | ----------------------------- |
| `LifxTimeoutError`    | If no response within timeout |
| `LifxProtocolError`   | If response invalid           |
| `LifxConnectionError` | If connection fails           |

Example

```python
# GET request returns unpacked packet
state = await conn.request(packets.Light.GetColor())
color = HSBK.from_protocol(state.color)
label = state.label  # Already decoded to string

# SET request returns True or False
success = await conn.request(
    packets.Light.SetColor(color=hsbk, duration=1000)
)
if not success:
    # Device doesn't support this command (returned StateUnhandled)
    pass
```

Source code in `src/lifx/network/connection.py`

````python
async def request(self, packet: Any, timeout: float | None = None) -> Any:
    """Send request and get single response (convenience wrapper).

    This is a convenience method that returns the first response from
    request_stream(). It's equivalent to:
        await anext(conn.request_stream(packet))

    Most device operations use this method since they expect a single response.
    Connection is opened automatically if not already open.

    Args:
        packet: Packet instance to send
        timeout: Request timeout in seconds

    Returns:
        Single unpacked response packet (including StateUnhandled if device
        doesn't support the command)
        For SET packets: True (acknowledgement) or False (StateUnhandled)

    Raises:
        LifxTimeoutError: If no response within timeout
        LifxProtocolError: If response invalid
        LifxConnectionError: If connection fails

    Example:
        ```python
        # GET request returns unpacked packet
        state = await conn.request(packets.Light.GetColor())
        color = HSBK.from_protocol(state.color)
        label = state.label  # Already decoded to string

        # SET request returns True or False
        success = await conn.request(
            packets.Light.SetColor(color=hsbk, duration=1000)
        )
        if not success:
            # Device doesn't support this command (returned StateUnhandled)
            pass
        ```
    """
    async for response in self.request_stream(packet, timeout):
        return response
    raise LifxTimeoutError(f"No response from {self.ip}")
````

## Performance Considerations

### Connection Lifecycle

- Connections open lazily on first request
- Each device owns its own connection (no shared pool)
- Connections close explicitly via `close()` or context manager exit
- Low memory overhead (one UDP socket per device)

### Response Handling

- Responses matched by sequence number
- Async generator-based streaming for efficient multi-response protocols
- Immediate exit for single-response requests (no wasted timeout)
- Retry logic with exponential backoff and jitter

### Rate Limiting

The library **intentionally does not implement rate limiting** to keep the core library simple. Applications should implement their own rate limiting if needed. According to the LIFX protocol specification, devices can handle approximately 20 messages per second.

# Protocol Layer

The protocol layer contains auto-generated structures from the official LIFX protocol specification. These classes handle binary serialization and deserialization of LIFX messages.

!!! warning "Auto-Generated Code" Files in the protocol layer are automatically generated from `protocol.yml`. Never edit these files directly. To update the protocol, download the latest `protocol.yml` from the [LIFX public-protocol repository](https://github.com/LIFX/public-protocol) and run `uv run python -m lifx.protocol.generator`.

## Base Packet

The base class for all protocol packets.

### Packet

```python
Packet()
```

Base class for all LIFX protocol packets.

Each packet subclass defines:

- PKT_TYPE: ClassVar[int] - The packet type number
- \_fields: ClassVar\[list[dict]\] - Field metadata from protocol.yml
- Actual field attributes as dataclass fields

| METHOD   | DESCRIPTION                                    |
| -------- | ---------------------------------------------- |
| `pack`   | Pack packet to bytes using field metadata.     |
| `unpack` | Unpack packet from bytes using field metadata. |

| ATTRIBUTE | DESCRIPTION                                             |
| --------- | ------------------------------------------------------- |
| `as_dict` | Return packet as dictionary. **TYPE:** `dict[str, Any]` |

#### Attributes

##### as_dict

```python
as_dict: dict[str, Any]
```

Return packet as dictionary.

#### Functions

##### pack

```python
pack() -> bytes
```

Pack packet to bytes using field metadata.

| RETURNS | DESCRIPTION                                          |
| ------- | ---------------------------------------------------- |
| `bytes` | Packed bytes ready to send in a LIFX message payload |

Source code in `src/lifx/protocol/base.py`

```python
def pack(self) -> bytes:
    """Pack packet to bytes using field metadata.

    Returns:
        Packed bytes ready to send in a LIFX message payload
    """
    from lifx.protocol import serializer

    result = b""

    for field_item in self._fields:
        # Handle reserved fields (no name)
        if "name" not in field_item:
            size_bytes = field_item.get("size_bytes", 0)
            result += serializer.pack_reserved(size_bytes)
            continue

        # Get field value from instance
        field_name = self._protocol_to_python_name(field_item["name"])
        value = getattr(self, field_name)

        # Pack based on type
        field_type = field_item["type"]
        size_bytes = field_item.get("size_bytes", 0)
        result += self._pack_field_value(value, field_type, size_bytes)

    return result
```

##### unpack

```python
unpack(data: bytes, offset: int = 0) -> Packet
```

Unpack packet from bytes using field metadata.

| PARAMETER | DESCRIPTION                                                         |
| --------- | ------------------------------------------------------------------- |
| `data`    | Bytes to unpack from **TYPE:** `bytes`                              |
| `offset`  | Offset in bytes to start unpacking **TYPE:** `int` **DEFAULT:** `0` |

| RETURNS  | DESCRIPTION                                          |
| -------- | ---------------------------------------------------- |
| `Packet` | Packet instance with label fields decoded to strings |

Source code in `src/lifx/protocol/base.py`

```python
@classmethod
def unpack(cls, data: bytes, offset: int = 0) -> Packet:
    """Unpack packet from bytes using field metadata.

    Args:
        data: Bytes to unpack from
        offset: Offset in bytes to start unpacking

    Returns:
        Packet instance with label fields decoded to strings
    """
    packet, _ = cls._unpack_internal(data, offset)

    # Decode label fields from bytes to string in-place
    # This ensures all State packets have human-readable labels
    cls._decode_labels_inplace(packet)

    # Log packet values after unpacking and decoding labels
    packet_values = asdict(packet)
    _LOGGER.debug(
        {
            "class": "Packet",
            "method": "unpack",
            "packet_type": type(packet).__name__,
            "values": packet_values,
        }
    )

    return packet
```

## Protocol Header

The LIFX protocol header structure (36 bytes).

### LifxHeader

```python
LifxHeader(
    size: int,
    protocol: int,
    source: int,
    target: bytes,
    tagged: bool,
    ack_required: bool,
    res_required: bool,
    sequence: int,
    pkt_type: int,
)
```

LIFX protocol header (36 bytes).

| ATTRIBUTE      | DESCRIPTION                                                                                                                                                                                      |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `size`         | Total packet size in bytes (header + payload) **TYPE:** `int`                                                                                                                                    |
| `protocol`     | Protocol number (must be 1024) **TYPE:** `int`                                                                                                                                                   |
| `source`       | Unique client identifier **TYPE:** `int`                                                                                                                                                         |
| `target`       | Device serial number (6 or 8 bytes, automatically padded to 8 bytes) Note: This is the LIFX serial number, which is often but not always the same as the device's MAC address. **TYPE:** `bytes` |
| `tagged`       | True for broadcast discovery, False for targeted messages **TYPE:** `bool`                                                                                                                       |
| `ack_required` | Request acknowledgement from device **TYPE:** `bool`                                                                                                                                             |
| `res_required` | Request response from device **TYPE:** `bool`                                                                                                                                                    |
| `sequence`     | Sequence number for matching requests/responses **TYPE:** `int`                                                                                                                                  |
| `pkt_type`     | Packet type identifier **TYPE:** `int`                                                                                                                                                           |

| METHOD          | DESCRIPTION                                                  |
| --------------- | ------------------------------------------------------------ |
| `__post_init__` | Validate header fields and auto-pad serial number if needed. |
| `create`        | Create a new LIFX header.                                    |
| `pack`          | Pack header into 36 bytes.                                   |
| `unpack`        | Unpack header from bytes.                                    |
| `__repr__`      | String representation of header.                             |

#### Attributes

##### target_serial

```python
target_serial: bytes
```

Get the 6-byte serial number without padding.

| RETURNS | DESCRIPTION          |
| ------- | -------------------- |
| `bytes` | 6-byte serial number |

#### Functions

##### __post_init__

```python
__post_init__() -> None
```

Validate header fields and auto-pad serial number if needed.

Source code in `src/lifx/protocol/header.py`

```python
def __post_init__(self) -> None:
    """Validate header fields and auto-pad serial number if needed."""
    # Auto-pad serial number if 6 bytes
    if len(self.target) == 6:
        self.target = self.target + b"\x00\x00"
    elif len(self.target) != 8:
        raise ValueError(f"Target must be 6 or 8 bytes, got {len(self.target)}")

    if self.protocol != self.PROTOCOL_NUMBER:
        raise ValueError(
            f"Protocol must be {self.PROTOCOL_NUMBER}, got {self.protocol}"
        )
    if self.sequence > 255:
        raise ValueError(f"Sequence must be 0-255, got {self.sequence}")
```

##### create

```python
create(
    pkt_type: int,
    source: int,
    target: bytes = b"\x00" * 6,
    tagged: bool = False,
    ack_required: bool = False,
    res_required: bool = True,
    sequence: int = 0,
    payload_size: int = 0,
) -> LifxHeader
```

Create a new LIFX header.

| PARAMETER      | DESCRIPTION                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------- |
| `pkt_type`     | Packet type identifier **TYPE:** `int`                                                                  |
| `source`       | Unique client identifier **TYPE:** `int`                                                                |
| `target`       | Device serial number (6 or 8 bytes, defaults to broadcast) **TYPE:** `bytes` **DEFAULT:** `b'\x00' * 6` |
| `tagged`       | True for broadcast, False for targeted **TYPE:** `bool` **DEFAULT:** `False`                            |
| `ack_required` | Request acknowledgement **TYPE:** `bool` **DEFAULT:** `False`                                           |
| `res_required` | Request response **TYPE:** `bool` **DEFAULT:** `True`                                                   |
| `sequence`     | Sequence number for matching requests/responses **TYPE:** `int` **DEFAULT:** `0`                        |
| `payload_size` | Size of packet payload in bytes **TYPE:** `int` **DEFAULT:** `0`                                        |

| RETURNS      | DESCRIPTION         |
| ------------ | ------------------- |
| `LifxHeader` | LifxHeader instance |

Source code in `src/lifx/protocol/header.py`

```python
@classmethod
def create(
    cls,
    pkt_type: int,
    source: int,
    target: bytes = b"\x00" * 6,
    tagged: bool = False,
    ack_required: bool = False,
    res_required: bool = True,
    sequence: int = 0,
    payload_size: int = 0,
) -> LifxHeader:
    """Create a new LIFX header.

    Args:
        pkt_type: Packet type identifier
        source: Unique client identifier
        target: Device serial number (6 or 8 bytes, defaults to broadcast)
        tagged: True for broadcast, False for targeted
        ack_required: Request acknowledgement
        res_required: Request response
        sequence: Sequence number for matching requests/responses
        payload_size: Size of packet payload in bytes

    Returns:
        LifxHeader instance
    """
    return cls(
        size=cls.HEADER_SIZE + payload_size,
        protocol=cls.PROTOCOL_NUMBER,
        source=source,
        target=target,  # __post_init__ will auto-pad if needed
        tagged=tagged,
        ack_required=ack_required,
        res_required=res_required,
        sequence=sequence,
        pkt_type=pkt_type,
    )
```

##### pack

```python
pack() -> bytes
```

Pack header into 36 bytes.

| RETURNS | DESCRIPTION         |
| ------- | ------------------- |
| `bytes` | Packed header bytes |

Source code in `src/lifx/protocol/header.py`

```python
def pack(self) -> bytes:
    """Pack header into 36 bytes.

    Returns:
        Packed header bytes
    """
    # Frame (8 bytes)
    # Byte 0-1: size (uint16)
    # Byte 2-3: origin + tagged + addressable + protocol bits
    # Byte 4-7: source (uint32)

    # Pack protocol field with flags
    protocol_field = (
        (self.ORIGIN & 0b11) << 14
        | (int(self.tagged) & 0b1) << 13
        | (self.ADDRESSABLE & 0b1) << 12
        | (self.protocol & 0xFFF)
    )

    frame = struct.pack("<HHI", self.size, protocol_field, self.source)

    # Frame Address (16 bytes)
    # Byte 0-7: target (uint64)
    # Byte 8-13: reserved (6 bytes)
    # Byte 14: res_required (bit 0) + ack_required (bit 1) + reserved (6 bits)
    # Byte 15: sequence (uint8)

    flags = (int(self.res_required) & 0b1) | ((int(self.ack_required) & 0b1) << 1)

    frame_addr = struct.pack(
        "<Q6sBB",
        int.from_bytes(self.target, byteorder="little"),
        b"\x00" * 6,  # reserved
        flags,
        self.sequence,
    )

    # Protocol Header (12 bytes)
    # Byte 0-7: reserved (uint64)
    # Byte 8-9: type (uint16)
    # Byte 10-11: reserved (uint16)

    protocol_header = struct.pack("<QHH", 0, self.pkt_type, 0)

    return frame + frame_addr + protocol_header
```

##### unpack

```python
unpack(data: bytes) -> LifxHeader
```

Unpack header from bytes.

| PARAMETER | DESCRIPTION                                        |
| --------- | -------------------------------------------------- |
| `data`    | Header bytes (at least 36 bytes) **TYPE:** `bytes` |

| RETURNS      | DESCRIPTION         |
| ------------ | ------------------- |
| `LifxHeader` | LifxHeader instance |

| RAISES       | DESCRIPTION                     |
| ------------ | ------------------------------- |
| `ValueError` | If data is too short or invalid |

Source code in `src/lifx/protocol/header.py`

```python
@classmethod
def unpack(cls, data: bytes) -> LifxHeader:
    """Unpack header from bytes.

    Args:
        data: Header bytes (at least 36 bytes)

    Returns:
        LifxHeader instance

    Raises:
        ValueError: If data is too short or invalid
    """
    if len(data) < cls.HEADER_SIZE:
        raise ValueError(f"Header data must be at least {cls.HEADER_SIZE} bytes")

    # Unpack Frame (8 bytes)
    size, protocol_field, source = struct.unpack("<HHI", data[0:8])

    # Extract protocol field components
    origin = (protocol_field >> 14) & 0b11
    tagged = bool((protocol_field >> 13) & 0b1)
    addressable = bool((protocol_field >> 12) & 0b1)
    protocol = protocol_field & 0xFFF

    # Validate origin and addressable
    if origin != cls.ORIGIN:
        raise ValueError(f"Invalid origin: {origin}")
    if not addressable:
        raise ValueError("Addressable bit must be set")

    # Unpack Frame Address (16 bytes)
    target_int, _reserved, flags, sequence = struct.unpack("<Q6sBB", data[8:24])
    target = target_int.to_bytes(8, byteorder="little")

    res_required = bool(flags & 0b1)
    ack_required = bool((flags >> 1) & 0b1)

    # Unpack Protocol Header (12 bytes)
    _reserved1, pkt_type, _reserved2 = struct.unpack("<QHH", data[24:36])

    return cls(
        size=size,
        protocol=protocol,
        source=source,
        target=target,
        tagged=tagged,
        ack_required=ack_required,
        res_required=res_required,
        sequence=sequence,
        pkt_type=pkt_type,
    )
```

##### __repr__

```python
__repr__() -> str
```

String representation of header.

Source code in `src/lifx/protocol/header.py`

```python
def __repr__(self) -> str:
    """String representation of header."""
    target_serial_str = Serial(value=self.target_serial).to_string()
    return (
        f"LifxHeader(type={self.pkt_type}, size={self.size}, "
        f"source={self.source:#x}, target={target_serial_str}, "
        f"seq={self.sequence}, tagged={self.tagged}, "
        f"ack={self.ack_required}, res={self.res_required})"
    )
```

## Serializer

Binary serialization and deserialization utilities.

### FieldSerializer

```python
FieldSerializer(field_definitions: dict[str, dict[str, str]])
```

Serializer for structured fields with nested types.

| PARAMETER           | DESCRIPTION                                                                             |
| ------------------- | --------------------------------------------------------------------------------------- |
| `field_definitions` | Dict mapping field names to structure definitions **TYPE:** `dict[str, dict[str, str]]` |

| METHOD           | DESCRIPTION                                 |
| ---------------- | ------------------------------------------- |
| `pack_field`     | Pack a structured field.                    |
| `unpack_field`   | Unpack a structured field.                  |
| `get_field_size` | Get the size in bytes of a field structure. |

Source code in `src/lifx/protocol/serializer.py`

```python
def __init__(self, field_definitions: dict[str, dict[str, str]]):
    """Initialize serializer with field definitions.

    Args:
        field_definitions: Dict mapping field names to structure definitions
    """
    self.field_definitions = field_definitions
```

#### Functions

##### pack_field

```python
pack_field(field_data: dict[str, Any], field_name: str) -> bytes
```

Pack a structured field.

| PARAMETER    | DESCRIPTION                                                |
| ------------ | ---------------------------------------------------------- |
| `field_data` | Dictionary of field values **TYPE:** `dict[str, Any]`      |
| `field_name` | Name of the field structure (e.g., "HSBK") **TYPE:** `str` |

| RETURNS | DESCRIPTION  |
| ------- | ------------ |
| `bytes` | Packed bytes |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `ValueError` | If field_name is unknown |

Source code in `src/lifx/protocol/serializer.py`

```python
def pack_field(self, field_data: dict[str, Any], field_name: str) -> bytes:
    """Pack a structured field.

    Args:
        field_data: Dictionary of field values
        field_name: Name of the field structure (e.g., "HSBK")

    Returns:
        Packed bytes

    Raises:
        ValueError: If field_name is unknown
    """
    if field_name not in self.field_definitions:
        raise ValueError(f"Unknown field: {field_name}")

    field_def = self.field_definitions[field_name]
    result = b""

    for attr_name, attr_type in field_def.items():
        if attr_name not in field_data:
            raise ValueError(f"Missing attribute {attr_name} in {field_name}")
        result += pack_value(field_data[attr_name], attr_type)

    return result
```

##### unpack_field

```python
unpack_field(
    data: bytes, field_name: str, offset: int = 0
) -> tuple[dict[str, Any], int]
```

Unpack a structured field.

| PARAMETER    | DESCRIPTION                                                |
| ------------ | ---------------------------------------------------------- |
| `data`       | Bytes to unpack from **TYPE:** `bytes`                     |
| `field_name` | Name of the field structure **TYPE:** `str`                |
| `offset`     | Offset to start unpacking **TYPE:** `int` **DEFAULT:** `0` |

| RETURNS                      | DESCRIPTION                       |
| ---------------------------- | --------------------------------- |
| `tuple[dict[str, Any], int]` | Tuple of (field_dict, new_offset) |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `ValueError` | If field_name is unknown |

Source code in `src/lifx/protocol/serializer.py`

```python
def unpack_field(
    self, data: bytes, field_name: str, offset: int = 0
) -> tuple[dict[str, Any], int]:
    """Unpack a structured field.

    Args:
        data: Bytes to unpack from
        field_name: Name of the field structure
        offset: Offset to start unpacking

    Returns:
        Tuple of (field_dict, new_offset)

    Raises:
        ValueError: If field_name is unknown
    """
    if field_name not in self.field_definitions:
        raise ValueError(f"Unknown field: {field_name}")

    field_def = self.field_definitions[field_name]
    field_data: dict[str, Any] = {}
    current_offset = offset

    for attr_name, attr_type in field_def.items():
        value, current_offset = unpack_value(data, attr_type, current_offset)
        field_data[attr_name] = value

    return field_data, current_offset
```

##### get_field_size

```python
get_field_size(field_name: str) -> int
```

Get the size in bytes of a field structure.

| PARAMETER    | DESCRIPTION                                 |
| ------------ | ------------------------------------------- |
| `field_name` | Name of the field structure **TYPE:** `str` |

| RETURNS | DESCRIPTION   |
| ------- | ------------- |
| `int`   | Size in bytes |

| RAISES       | DESCRIPTION              |
| ------------ | ------------------------ |
| `ValueError` | If field_name is unknown |

Source code in `src/lifx/protocol/serializer.py`

```python
def get_field_size(self, field_name: str) -> int:
    """Get the size in bytes of a field structure.

    Args:
        field_name: Name of the field structure

    Returns:
        Size in bytes

    Raises:
        ValueError: If field_name is unknown
    """
    if field_name not in self.field_definitions:
        raise ValueError(f"Unknown field: {field_name}")

    field_def = self.field_definitions[field_name]
    return sum(TYPE_SIZES[attr_type] for attr_type in field_def.values())
```

## Protocol Types

Common protocol type definitions and enums.

### HSBK Type

#### LightHsbk

```python
LightHsbk(hue: int, saturation: int, brightness: int, kelvin: int)
```

Auto-generated field structure.

| METHOD   | DESCRIPTION        |
| -------- | ------------------ |
| `pack`   | Pack to bytes.     |
| `unpack` | Unpack from bytes. |

##### Functions

###### pack

```python
pack() -> bytes
```

Pack to bytes.

Source code in `src/lifx/protocol/protocol_types.py`

```python
def pack(self) -> bytes:
    """Pack to bytes."""
    from lifx.protocol import serializer

    result = b""

    # hue: uint16
    result += serializer.pack_value(self.hue, "uint16")
    # saturation: uint16
    result += serializer.pack_value(self.saturation, "uint16")
    # brightness: uint16
    result += serializer.pack_value(self.brightness, "uint16")
    # kelvin: uint16
    result += serializer.pack_value(self.kelvin, "uint16")

    return result
```

###### unpack

```python
unpack(data: bytes, offset: int = 0) -> tuple[LightHsbk, int]
```

Unpack from bytes.

Source code in `src/lifx/protocol/protocol_types.py`

```python
@classmethod
def unpack(cls, data: bytes, offset: int = 0) -> tuple[LightHsbk, int]:
    """Unpack from bytes."""
    from lifx.protocol import serializer

    current_offset = offset
    # hue: uint16
    hue, current_offset = serializer.unpack_value(data, "uint16", current_offset)
    # saturation: uint16
    saturation, current_offset = serializer.unpack_value(
        data, "uint16", current_offset
    )
    # brightness: uint16
    brightness, current_offset = serializer.unpack_value(
        data, "uint16", current_offset
    )
    # kelvin: uint16
    kelvin, current_offset = serializer.unpack_value(data, "uint16", current_offset)

    return cls(
        hue=hue, saturation=saturation, brightness=brightness, kelvin=kelvin
    ), current_offset
```

### Light Waveform

#### LightWaveform

Bases: `IntEnum`

Auto-generated enum.

### Device Service

#### DeviceService

Bases: `IntEnum`

Auto-generated enum.

### MultiZone Application Request

#### MultiZoneApplicationRequest

Bases: `IntEnum`

Auto-generated enum.

### Firmware Effect

Unified enum for all firmware effects (multizone and matrix devices):

#### FirmwareEffect

Bases: `IntEnum`

Auto-generated enum.

### Direction

Direction enum for MOVE effects:

#### Direction

Bases: `IntEnum`

Auto-generated enum.

## Packet Definitions

The protocol layer includes packet definitions for all LIFX message types. Major categories include:

### Device Messages

- `DeviceGetService` / `DeviceStateService` - Service discovery
- `DeviceGetLabel` / `DeviceStateLabel` - Device labels
- `DeviceGetPower` / `DeviceSetPower` / `DeviceStatePower` - Power control
- `DeviceGetVersion` / `DeviceStateVersion` - Firmware version
- `DeviceGetLocation` / `DeviceStateLocation` - Location groups
- `DeviceGetGroup` / `DeviceStateGroup` - Device groups
- `DeviceGetInfo` / `DeviceStateInfo` - Runtime info (uptime, downtime)

### Light Messages

- `LightGet` / `LightState` - Get/set light state
- `LightSetColor` - Set color with transition
- `LightSetWaveform` - Waveform effects (pulse, breathe)
- `LightGetPower` / `LightSetPower` / `LightStatePower` - Light power control
- `LightGetInfrared` / `LightSetInfrared` / `LightStateInfrared` - Infrared control

### MultiZone Messages

- `MultiZoneGetColorZones` / `MultiZoneStateZone` / `MultiZoneStateMultiZone` - Zone state
- `MultiZoneSetColorZones` - Set zone colors
- `MultiZoneGetMultiZoneEffect` / `MultiZoneSetMultiZoneEffect` - Zone effects

### Tile Messages

- `TileGetDeviceChain` / `TileStateDeviceChain` - Tile chain info
- `TileGet64` / `TileState64` - Get tile state
- `TileSet64` - Set tile colors
- `TileGetTileEffect` / `TileSetTileEffect` - Tile effects

## Protocol Models

Protocol data models for working with LIFX serial numbers and HEV cycles.

### Serial

Type-safe, immutable serial number handling:

#### Serial

```python
Serial(value: bytes)
```

LIFX device serial number.

Encapsulates a device serial number with conversion methods for different formats. The LIFX serial number is often the same as the device's MAC address, but can differ (particularly the least significant byte may be off by one).

| ATTRIBUTE | DESCRIPTION                                |
| --------- | ------------------------------------------ |
| `value`   | Serial number as 6 bytes **TYPE:** `bytes` |

Example

```python
# Create from string
serial = Serial.from_string("d073d5123456")

# Convert to protocol format (8 bytes with padding)
protocol_bytes = serial.to_protocol()

# Convert to string
serial_str = serial.to_string()  # "d073d5123456"

# Create from protocol format
serial2 = Serial.from_protocol(protocol_bytes)
```

| METHOD          | DESCRIPTION                                                |
| --------------- | ---------------------------------------------------------- |
| `__post_init__` | Validate serial number after initialization.               |
| `from_string`   | Create Serial from string format.                          |
| `from_protocol` | Create Serial from protocol format (8 bytes with padding). |
| `to_string`     | Convert serial to 12-digit hex string format.              |
| `to_protocol`   | Convert serial to 8-byte protocol format with padding.     |
| `__str__`       | Return string representation.                              |
| `__repr__`      | Return detailed representation.                            |

##### Functions

###### __post_init__

```python
__post_init__() -> None
```

Validate serial number after initialization.

Source code in `src/lifx/protocol/models.py`

```python
def __post_init__(self) -> None:
    """Validate serial number after initialization."""
    self._validate_type(self.value)
    self._validate_length(self.value)
```

###### from_string

```python
from_string(serial: str) -> Serial
```

Create Serial from string format.

Accepts 12-digit hex string (with or without separators).

| PARAMETER | DESCRIPTION                                                                       |
| --------- | --------------------------------------------------------------------------------- |
| `serial`  | 12-digit hex string (e.g., "d073d5123456" or "d0:73:d5:12:34:56") **TYPE:** `str` |

| RETURNS  | DESCRIPTION     |
| -------- | --------------- |
| `Serial` | Serial instance |

| RAISES       | DESCRIPTION                 |
| ------------ | --------------------------- |
| `ValueError` | If serial number is invalid |
| `TypeError`  | If serial is not a string   |

Example

> > > Serial.from_string("d073d5123456") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56') Serial.from_string("d0:73:d5:12:34:56") # Also accepts separators Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')

Source code in `src/lifx/protocol/models.py`

```python
@classmethod
def from_string(cls, serial: str) -> Serial:
    """Create Serial from string format.

    Accepts 12-digit hex string (with or without separators).

    Args:
        serial: 12-digit hex string (e.g., "d073d5123456" or "d0:73:d5:12:34:56")

    Returns:
        Serial instance

    Raises:
        ValueError: If serial number is invalid
        TypeError: If serial is not a string

    Example:
        >>> Serial.from_string("d073d5123456")
        Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')
        >>> Serial.from_string("d0:73:d5:12:34:56")  # Also accepts separators
        Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')
    """
    cls._validate_string_type(serial)
    serial_clean = cls._remove_separators(serial)
    cls._validate_hex_length(serial_clean)
    serial_bytes = cls._parse_hex(serial_clean)

    return cls(value=serial_bytes)
```

###### from_protocol

```python
from_protocol(padded_serial: bytes) -> Serial
```

Create Serial from protocol format (8 bytes with padding).

The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.

| PARAMETER       | DESCRIPTION                                          |
| --------------- | ---------------------------------------------------- |
| `padded_serial` | 8-byte serial number from protocol **TYPE:** `bytes` |

| RETURNS  | DESCRIPTION     |
| -------- | --------------- |
| `Serial` | Serial instance |

| RAISES       | DESCRIPTION                     |
| ------------ | ------------------------------- |
| `ValueError` | If padded serial is not 8 bytes |

Example

> > > Serial.from_protocol(b"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00") Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')

Source code in `src/lifx/protocol/models.py`

```python
@classmethod
def from_protocol(cls, padded_serial: bytes) -> Serial:
    """Create Serial from protocol format (8 bytes with padding).

    The LIFX protocol uses 8 bytes for the target field, with the serial number
    in the first 6 bytes and 2 bytes of padding (zeros) at the end.

    Args:
        padded_serial: 8-byte serial number from protocol

    Returns:
        Serial instance

    Raises:
        ValueError: If padded serial is not 8 bytes

    Example:
        >>> Serial.from_protocol(b"\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00")
        Serial(value=b'\\xd0\\x73\\xd5\\x12\\x34\\x56')
    """
    if len(padded_serial) != 8:
        raise ValueError(
            f"Padded serial number must be 8 bytes, got {len(padded_serial)}"
        )

    # Extract first 6 bytes
    return cls(value=padded_serial[:6])
```

###### to_string

```python
to_string() -> str
```

Convert serial to 12-digit hex string format.

| RETURNS | DESCRIPTION                                                                  |
| ------- | ---------------------------------------------------------------------------- |
| `str`   | Serial number string in format "xxxxxxxxxxxx" (12 hex digits, no separators) |

Example

> > > serial = Serial.from_string("d073d5123456") serial.to_string() 'd073d5123456'

Source code in `src/lifx/protocol/models.py`

```python
def to_string(self) -> str:
    """Convert serial to 12-digit hex string format.

    Returns:
        Serial number string in format "xxxxxxxxxxxx" (12 hex digits, no separators)

    Example:
        >>> serial = Serial.from_string("d073d5123456")
        >>> serial.to_string()
        'd073d5123456'
    """
    return self.value.hex()
```

###### to_protocol

```python
to_protocol() -> bytes
```

Convert serial to 8-byte protocol format with padding.

The LIFX protocol uses 8 bytes for the target field, with the serial number in the first 6 bytes and 2 bytes of padding (zeros) at the end.

| RETURNS | DESCRIPTION                                               |
| ------- | --------------------------------------------------------- |
| `bytes` | 8-byte serial number with padding (suitable for protocol) |

Example

> > > serial = Serial.from_string("d073d5123456") serial.to_protocol() b'\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00'

Source code in `src/lifx/protocol/models.py`

```python
def to_protocol(self) -> bytes:
    """Convert serial to 8-byte protocol format with padding.

    The LIFX protocol uses 8 bytes for the target field, with the serial number
    in the first 6 bytes and 2 bytes of padding (zeros) at the end.

    Returns:
        8-byte serial number with padding (suitable for protocol)

    Example:
        >>> serial = Serial.from_string("d073d5123456")
        >>> serial.to_protocol()
        b'\\xd0\\x73\\xd5\\x12\\x34\\x56\\x00\\x00'
    """
    return self.value + b"\x00\x00"
```

###### __str__

```python
__str__() -> str
```

Return string representation.

Source code in `src/lifx/protocol/models.py`

```python
def __str__(self) -> str:
    """Return string representation."""
    return self.to_string()
```

###### __repr__

```python
__repr__() -> str
```

Return detailed representation.

Source code in `src/lifx/protocol/models.py`

```python
def __repr__(self) -> str:
    """Return detailed representation."""
    return f"Serial('{self.to_string()}')"
```

### HEV Cycle State

HEV (High Energy Visible) cleaning cycle state:

#### HevCycleState

```python
HevCycleState(duration_s: int, remaining_s: int, last_power: bool)
```

HEV cleaning cycle state.

Represents the current state of a HEV (High Energy Visible) cleaning cycle, which uses anti-bacterial UV-C light to sanitize the environment.

| ATTRIBUTE     | DESCRIPTION                                                            |
| ------------- | ---------------------------------------------------------------------- |
| `duration_s`  | Total duration of the cycle in seconds **TYPE:** `int`                 |
| `remaining_s` | Remaining time in the current cycle (0 if not running) **TYPE:** `int` |
| `last_power`  | Whether the light was on during the last cycle **TYPE:** `bool`        |

Example

```python
# Check if HEV cycle is running
state = await hev_light.get_hev_cycle()
if state.remaining_s > 0:
    print(f"Cleaning in progress: {state.remaining_s}s remaining")
```

##### Attributes

###### is_running

```python
is_running: bool
```

Check if a HEV cycle is currently running.

### HEV Configuration

HEV cycle configuration:

#### HevConfig

```python
HevConfig(indication: bool, duration_s: int)
```

HEV cycle configuration.

Configuration settings for HEV cleaning cycles.

| ATTRIBUTE    | DESCRIPTION                                                        |
| ------------ | ------------------------------------------------------------------ |
| `indication` | Whether to show visual indication during cleaning **TYPE:** `bool` |
| `duration_s` | Default duration for cleaning cycles in seconds **TYPE:** `int`    |

Example

```python
# Configure HEV cycle with 2-hour duration and visual indication
await hev_light.set_hev_config(indication=True, duration_seconds=7200)
```

## Code Generator

The protocol generator reads `protocol.yml` and generates Python code.

### generator

Code generator for LIFX protocol structures.

Downloads the official protocol.yml from the LIFX GitHub repository and generates Python types and packet classes. The YAML is never stored locally, only parsed and converted into protocol classes.

| CLASS          | DESCRIPTION                                    |
| -------------- | ---------------------------------------------- |
| `TypeRegistry` | Registry of all protocol types for validation. |

| FUNCTION                                    | DESCRIPTION                                                                       |
| ------------------------------------------- | --------------------------------------------------------------------------------- |
| `to_snake_case`                             | Convert PascalCase or camelCase to snake_case.                                    |
| `apply_field_name_quirks`                   | Apply quirks to field names to avoid Python built-ins and reserved words.         |
| `apply_extended_multizone_packet_quirks`    | Apply quirks to extended multizone packet names to follow LIFX naming convention. |
| `apply_tile_effect_parameter_quirk`         | Apply local quirk to fix TileEffectParameter structure.                           |
| `apply_tile_state_device_quirk`             | Apply local quirk to add supported_frame_buffers field to TileStateDevice.        |
| `apply_sensor_packet_quirks`                | Add undocumented sensor packets for ambient light level reading.                  |
| `apply_firmware_effect_enum_quirk`          | Merge MultiZoneEffectType and TileEffectType into FirmwareEffect enum.            |
| `apply_multizone_application_request_quirk` | Suppress MultiZoneExtendedApplicationRequest enum.                                |
| `format_long_import`                        | Format a long import statement across multiple lines.                             |
| `format_long_list`                          | Format a long list across multiple lines.                                         |
| `parse_field_type`                          | Parse a field type string.                                                        |
| `camel_to_snake_upper`                      | Convert CamelCase to UPPER_SNAKE_CASE.                                            |
| `generate_enum_code`                        | Generate Python Enum definitions with shortened names.                            |
| `convert_type_to_python`                    | Convert a protocol field type to Python type annotation.                          |
| `generate_pack_method`                      | Generate pack() method code for a field structure or packet.                      |
| `generate_unpack_method`                    | Generate unpack() classmethod code for a field structure or packet.               |
| `generate_field_code`                       | Generate Python dataclass definitions for field structures.                       |
| `generate_nested_packet_code`               | Generate nested Python packet class definitions.                                  |
| `generate_types_file`                       | Generate complete types.py file.                                                  |
| `generate_packets_file`                     | Generate complete packets.py file.                                                |
| `download_protocol`                         | Download and parse protocol.yml from LIFX GitHub repository.                      |
| `validate_protocol_spec`                    | Validate protocol specification for missing type references.                      |
| `should_skip_button_relay`                  | Check if a name should be skipped (Button or Relay related).                      |
| `filter_button_relay_items`                 | Filter out Button and Relay items from a dictionary.                              |
| `filter_button_relay_packets`               | Filter out button and relay category packets.                                     |
| `extract_packets_as_fields`                 | Extract packets that are used as field types in other structures.                 |
| `main`                                      | Main generator entry point.                                                       |

#### Classes

##### TypeRegistry

```python
TypeRegistry()
```

Registry of all protocol types for validation.

Tracks all defined types (enums, fields, packets, unions) to validate that all type references in the protocol specification are valid.

| METHOD            | DESCRIPTION                      |
| ----------------- | -------------------------------- |
| `register_enum`   | Register an enum type.           |
| `register_field`  | Register a field structure type. |
| `register_packet` | Register a packet type.          |
| `register_union`  | Register a union type.           |
| `is_enum`         | Check if a type is an enum.      |
| `has_type`        | Check if a type is defined.      |
| `get_all_types`   | Get all registered types.        |

Source code in `src/lifx/protocol/generator.py`

```python
def __init__(self) -> None:
    """Initialize empty type registry."""
    self._enums: set[str] = set()
    self._fields: set[str] = set()
    self._packets: set[str] = set()
    self._unions: set[str] = set()
    self._basic_types: set[str] = {
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "int8",
        "int16",
        "int32",
        "int64",
        "float32",
        "bool",
        "byte",
        "reserved",  # Special type for reserved fields
    }
```

###### Functions

###### register_enum

```python
register_enum(name: str) -> None
```

Register an enum type.

| PARAMETER | DESCRIPTION                    |
| --------- | ------------------------------ |
| `name`    | Enum type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_enum(self, name: str) -> None:
    """Register an enum type.

    Args:
        name: Enum type name
    """
    self._enums.add(name)
```

###### register_field

```python
register_field(name: str) -> None
```

Register a field structure type.

| PARAMETER | DESCRIPTION                               |
| --------- | ----------------------------------------- |
| `name`    | Field structure type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_field(self, name: str) -> None:
    """Register a field structure type.

    Args:
        name: Field structure type name
    """
    self._fields.add(name)
```

###### register_packet

```python
register_packet(name: str) -> None
```

Register a packet type.

| PARAMETER | DESCRIPTION                      |
| --------- | -------------------------------- |
| `name`    | Packet type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_packet(self, name: str) -> None:
    """Register a packet type.

    Args:
        name: Packet type name
    """
    self._packets.add(name)
```

###### register_union

```python
register_union(name: str) -> None
```

Register a union type.

| PARAMETER | DESCRIPTION                     |
| --------- | ------------------------------- |
| `name`    | Union type name **TYPE:** `str` |

Source code in `src/lifx/protocol/generator.py`

```python
def register_union(self, name: str) -> None:
    """Register a union type.

    Args:
        name: Union type name
    """
    self._unions.add(name)
```

###### is_enum

```python
is_enum(name: str) -> bool
```

Check if a type is an enum.

| PARAMETER | DESCRIPTION                        |
| --------- | ---------------------------------- |
| `name`    | Type name to check **TYPE:** `str` |

| RETURNS | DESCRIPTION                 |
| ------- | --------------------------- |
| `bool`  | True if the type is an enum |

Source code in `src/lifx/protocol/generator.py`

```python
def is_enum(self, name: str) -> bool:
    """Check if a type is an enum.

    Args:
        name: Type name to check

    Returns:
        True if the type is an enum
    """
    return name in self._enums
```

###### has_type

```python
has_type(name: str) -> bool
```

Check if a type is defined.

| PARAMETER | DESCRIPTION                        |
| --------- | ---------------------------------- |
| `name`    | Type name to check **TYPE:** `str` |

| RETURNS | DESCRIPTION                 |
| ------- | --------------------------- |
| `bool`  | True if the type is defined |

Source code in `src/lifx/protocol/generator.py`

```python
def has_type(self, name: str) -> bool:
    """Check if a type is defined.

    Args:
        name: Type name to check

    Returns:
        True if the type is defined
    """
    return (
        name in self._enums
        or name in self._fields
        or name in self._packets
        or name in self._unions
        or name in self._basic_types
    )
```

###### get_all_types

```python
get_all_types() -> set[str]
```

Get all registered types.

| RETURNS    | DESCRIPTION           |
| ---------- | --------------------- |
| `set[str]` | Set of all type names |

Source code in `src/lifx/protocol/generator.py`

```python
def get_all_types(self) -> set[str]:
    """Get all registered types.

    Returns:
        Set of all type names
    """
    return (
        self._enums
        | self._fields
        | self._packets
        | self._unions
        | self._basic_types
    )
```

#### Functions

##### to_snake_case

```python
to_snake_case(name: str) -> str
```

Convert PascalCase or camelCase to snake_case.

| PARAMETER | DESCRIPTION                                    |
| --------- | ---------------------------------------------- |
| `name`    | PascalCase or camelCase string **TYPE:** `str` |

| RETURNS | DESCRIPTION       |
| ------- | ----------------- |
| `str`   | snake_case string |

Source code in `src/lifx/protocol/generator.py`

```python
def to_snake_case(name: str) -> str:
    """Convert PascalCase or camelCase to snake_case.

    Args:
        name: PascalCase or camelCase string

    Returns:
        snake_case string
    """
    # Insert underscore before uppercase letters (except at start)
    snake = re.sub(r"(?<!^)(?=[A-Z])", "_", name)
    return snake.lower()
```

##### apply_field_name_quirks

```python
apply_field_name_quirks(python_name: str) -> str
```

Apply quirks to field names to avoid Python built-ins and reserved words.

| PARAMETER     | DESCRIPTION                                                        |
| ------------- | ------------------------------------------------------------------ |
| `python_name` | The Python field name (usually from to_snake_case) **TYPE:** `str` |

| RETURNS | DESCRIPTION               |
| ------- | ------------------------- |
| `str`   | Quirk-adjusted field name |

Quirks applied

- "type" -> "effect_type" (avoids Python built-in)

Source code in `src/lifx/protocol/generator.py`

```python
def apply_field_name_quirks(python_name: str) -> str:
    """Apply quirks to field names to avoid Python built-ins and reserved words.

    Args:
        python_name: The Python field name (usually from to_snake_case)

    Returns:
        Quirk-adjusted field name

    Quirks applied:
        - "type" -> "effect_type" (avoids Python built-in)
    """
    if python_name == "type":
        return "effect_type"
    return python_name
```

##### apply_extended_multizone_packet_quirks

```python
apply_extended_multizone_packet_quirks(
    packet_name: str, category_class: str
) -> str
```

Apply quirks to extended multizone packet names to follow LIFX naming convention.

In the LIFX protocol, extended multizone packets should follow the standard naming pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).

| PARAMETER        | DESCRIPTION                                                 |
| ---------------- | ----------------------------------------------------------- |
| `packet_name`    | Packet name (after category prefix removal) **TYPE:** `str` |
| `category_class` | Category class name (e.g., "MultiZone") **TYPE:** `str`     |

| RETURNS | DESCRIPTION                |
| ------- | -------------------------- |
| `str`   | Quirk-adjusted packet name |

Quirks applied

- "ExtendedGetColorZones" -> "GetExtendedColorZones"
- "ExtendedSetColorZones" -> "SetExtendedColorZones"
- "ExtendedStateMultiZone" -> "StateExtendedColorZones"

Source code in `src/lifx/protocol/generator.py`

```python
def apply_extended_multizone_packet_quirks(
    packet_name: str, category_class: str
) -> str:
    """Apply quirks to extended multizone packet names to follow LIFX naming convention.

    In the LIFX protocol, extended multizone packets should follow the standard naming
    pattern of {Action}{Object} (e.g., GetExtendedColorZones, SetExtendedColorZones).

    Args:
        packet_name: Packet name (after category prefix removal)
        category_class: Category class name (e.g., "MultiZone")

    Returns:
        Quirk-adjusted packet name

    Quirks applied:
        - "ExtendedGetColorZones" -> "GetExtendedColorZones"
        - "ExtendedSetColorZones" -> "SetExtendedColorZones"
        - "ExtendedStateMultiZone" -> "StateExtendedColorZones"
    """
    if category_class == "MultiZone":
        if packet_name == "ExtendedGetColorZones":
            return "GetExtendedColorZones"
        elif packet_name == "ExtendedSetColorZones":
            return "SetExtendedColorZones"
        elif packet_name == "ExtendedStateMultiZone":
            return "StateExtendedColorZones"
    return packet_name
```

##### apply_tile_effect_parameter_quirk

```python
apply_tile_effect_parameter_quirk(fields: dict[str, Any]) -> dict[str, Any]
```

Apply local quirk to fix TileEffectParameter structure.

The upstream protocol.yml doesn't provide enough detail for TileEffectParameter. This quirk replaces it with the correct structure:

- TileEffectSkyType (enum, uint8)
- 3 reserved bytes
- cloudSaturationMin (uint8)
- 3 reserved bytes
- cloudSaturationMax (uint8)
- 23 reserved bytes Total: 32 bytes

| PARAMETER | DESCRIPTION                                                |
| --------- | ---------------------------------------------------------- |
| `fields`  | Dictionary of field definitions **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                       |
| ---------------- | ------------------------------------------------- |
| `dict[str, Any]` | Dictionary with TileEffectParameter quirk applied |

Source code in `src/lifx/protocol/generator.py`

```python
def apply_tile_effect_parameter_quirk(
    fields: dict[str, Any],
) -> dict[str, Any]:
    """Apply local quirk to fix TileEffectParameter structure.

    The upstream protocol.yml doesn't provide enough detail for TileEffectParameter.
    This quirk replaces it with the correct structure:
    - TileEffectSkyType (enum, uint8)
    - 3 reserved bytes
    - cloudSaturationMin (uint8)
    - 3 reserved bytes
    - cloudSaturationMax (uint8)
    - 23 reserved bytes
    Total: 32 bytes

    Args:
        fields: Dictionary of field definitions

    Returns:
        Dictionary with TileEffectParameter quirk applied
    """
    if "TileEffectParameter" in fields:
        fields["TileEffectParameter"] = {
            "size_bytes": 32,
            "fields": [
                {"name": "SkyType", "type": "<TileEffectSkyType>"},
                {"size_bytes": 3},
                {"name": "CloudSaturationMin", "type": "uint8"},
                {"size_bytes": 3},
                {"name": "CloudSaturationMax", "type": "uint8"},
                {"size_bytes": 23},
            ],
        }
    return fields
```

##### apply_tile_state_device_quirk

```python
apply_tile_state_device_quirk(fields: dict[str, Any]) -> dict[str, Any]
```

Apply local quirk to add supported_frame_buffers field to TileStateDevice.

The upstream protocol.yml has a reserved field between height and device_version. This quirk replaces that reserved field with supported_frame_buffers (uint8).

| PARAMETER | DESCRIPTION                                                |
| --------- | ---------------------------------------------------------- |
| `fields`  | Dictionary of field definitions **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                   |
| ---------------- | --------------------------------------------- |
| `dict[str, Any]` | Dictionary with TileStateDevice quirk applied |

Source code in `src/lifx/protocol/generator.py`

```python
def apply_tile_state_device_quirk(
    fields: dict[str, Any],
) -> dict[str, Any]:
    """Apply local quirk to add supported_frame_buffers field to TileStateDevice.

    The upstream protocol.yml has a reserved field between height and device_version.
    This quirk replaces that reserved field with supported_frame_buffers (uint8).

    Args:
        fields: Dictionary of field definitions

    Returns:
        Dictionary with TileStateDevice quirk applied
    """
    if "TileStateDevice" in fields:
        tile_def = fields["TileStateDevice"]
        if "fields" in tile_def:
            # Find and replace the reserved field between height and device_version
            fields_list = tile_def["fields"]
            for i, field in enumerate(fields_list):
                # Look for height field
                if field.get("name") == "Height":
                    # Check if next field is reserved (1 byte) and followed by DeviceVersion
                    if (
                        i + 1 < len(fields_list)
                        and i + 2 < len(fields_list)
                        and fields_list[i + 1].get("type") == "reserved"
                        and fields_list[i + 1].get("size_bytes") == 1
                        and fields_list[i + 2].get("name") == "DeviceVersion"
                    ):
                        # Replace the reserved field with supported_frame_buffers
                        fields_list[i + 1] = {
                            "name": "SupportedFrameBuffers",
                            "type": "uint8",
                        }
                        break

    return fields
```

##### apply_sensor_packet_quirks

```python
apply_sensor_packet_quirks(packets: dict[str, Any]) -> dict[str, Any]
```

Add undocumented sensor packets for ambient light level reading.

These packets are not documented in the official protocol.yml but are supported by LIFX devices with ambient light sensors.

Quirks applied

- SensorGetAmbientLight (401): Request packet with no parameters
- SensorStateAmbientLight (402): Response packet with lux field (float)

| PARAMETER | DESCRIPTION                                                 |
| --------- | ----------------------------------------------------------- |
| `packets` | Dictionary of packet definitions **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                  |
| ---------------- | -------------------------------------------- |
| `dict[str, Any]` | Dictionary with sensor packet quirks applied |

Source code in `src/lifx/protocol/generator.py`

```python
def apply_sensor_packet_quirks(packets: dict[str, Any]) -> dict[str, Any]:
    """Add undocumented sensor packets for ambient light level reading.

    These packets are not documented in the official protocol.yml but are supported
    by LIFX devices with ambient light sensors.

    Quirks applied:
        - SensorGetAmbientLight (401): Request packet with no parameters
        - SensorStateAmbientLight (402): Response packet with lux field (float)

    Args:
        packets: Dictionary of packet definitions

    Returns:
        Dictionary with sensor packet quirks applied
    """
    # Ensure sensor category exists
    if "sensor" not in packets:
        packets["sensor"] = {}

    # Add SensorGetAmbientLight (401) - request with no parameters
    packets["sensor"]["SensorGetAmbientLight"] = {
        "pkt_type": 401,
        "fields": [],
    }

    # Add SensorStateAmbientLight (402) - response with lux field
    packets["sensor"]["SensorStateAmbientLight"] = {
        "pkt_type": 402,
        "fields": [
            {"name": "Lux", "type": "float32"},
        ],
    }

    return packets
```

##### apply_firmware_effect_enum_quirk

```python
apply_firmware_effect_enum_quirk(
    enums: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any],
) -> tuple[dict[str, Any], dict[str, Any], dict[str, Any]]
```

Merge MultiZoneEffectType and TileEffectType into FirmwareEffect enum.

Both MultiZone and Tile effects use the same firmware effect protocol values, so they should share a single enum. This quirk:

- Creates FirmwareEffect enum combining values from both
- Removes MultiZoneEffectType and TileEffectType
- Updates MultiZoneEffectSettings and TileEffectSettings to use FirmwareEffect
- Uses clean enum value names (OFF, MOVE, MORPH, FLAME, SKY, RESERVED\_\*)
- Also adds DIRECTION enum for move effect parameter

| PARAMETER         | DESCRIPTION                                                         |
| ----------------- | ------------------------------------------------------------------- |
| `enums`           | Dictionary of enum definitions **TYPE:** `dict[str, Any]`           |
| `fields`          | Dictionary of field definitions **TYPE:** `dict[str, Any]`          |
| `compound_fields` | Dictionary of compound field definitions **TYPE:** `dict[str, Any]` |

| RETURNS                                                 | DESCRIPTION                                                                      |
| ------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `tuple[dict[str, Any], dict[str, Any], dict[str, Any]]` | Tuple of (enums, fields, compound_fields) with FirmwareEffect enum quirk applied |

Source code in `src/lifx/protocol/generator.py`

```python
def apply_firmware_effect_enum_quirk(
    enums: dict[str, Any], fields: dict[str, Any], compound_fields: dict[str, Any]
) -> tuple[dict[str, Any], dict[str, Any], dict[str, Any]]:
    """Merge MultiZoneEffectType and TileEffectType into FirmwareEffect enum.

    Both MultiZone and Tile effects use the same firmware effect protocol values,
    so they should share a single enum. This quirk:
    - Creates FirmwareEffect enum combining values from both
    - Removes MultiZoneEffectType and TileEffectType
    - Updates MultiZoneEffectSettings and TileEffectSettings to use FirmwareEffect
    - Uses clean enum value names (OFF, MOVE, MORPH, FLAME, SKY, RESERVED_*)
    - Also adds DIRECTION enum for move effect parameter

    Args:
        enums: Dictionary of enum definitions
        fields: Dictionary of field definitions
        compound_fields: Dictionary of compound field definitions

    Returns:
        Tuple of (enums, fields, compound_fields) with FirmwareEffect enum quirk applied
    """
    # Create FirmwareEffect enum with clean names manually
    # Based on protocol spec:
    # MultiZone: OFF=0, MOVE=1, reserved=2, reserved=3
    # Tile: OFF=0, reserved=1, MORPH=2, FLAME=3, reserved=4, SKY=5
    # Note: Reserved values are intentionally omitted
    firmware_effect_values = {
        "OFF": 0,
        "MOVE": 1,
        "MORPH": 2,
        "FLAME": 3,
        "SKY": 5,
    }

    # Create FirmwareEffect enum
    enums["FirmwareEffect"] = firmware_effect_values

    # Remove the old separate enums
    enums.pop("MultiZoneEffectType", None)
    enums.pop("TileEffectType", None)

    # Update fields to use FirmwareEffect (check both fields and compound_fields)
    for field_dict in [fields, compound_fields]:
        if "MultiZoneEffectSettings" in field_dict:
            for field in field_dict["MultiZoneEffectSettings"].get("fields", []):
                if field.get("name") == "Type":
                    field["type"] = "<FirmwareEffect>"

        if "TileEffectSettings" in field_dict:
            for field in field_dict["TileEffectSettings"].get("fields", []):
                if field.get("name") == "Type":
                    field["type"] = "<FirmwareEffect>"

    # Add DIRECTION enum for move effect
    enums["Direction"] = {
        "REVERSED": 0,
        "FORWARD": 1,
    }

    return enums, fields, compound_fields
```

##### apply_multizone_application_request_quirk

```python
apply_multizone_application_request_quirk(
    enums: dict[str, Any], packets: dict[str, Any]
) -> tuple[dict[str, Any], dict[str, Any]]
```

Suppress MultiZoneExtendedApplicationRequest enum.

Both MultiZoneApplicationRequest and MultiZoneExtendedApplicationRequest have identical values (NO_APPLY=0, APPLY=1, APPLY_ONLY=2), so we suppress the extended version and use the standard one for both SetColorZones and SetExtendedColorZones packets.

| PARAMETER | DESCRIPTION                                                 |
| --------- | ----------------------------------------------------------- |
| `enums`   | Dictionary of enum definitions **TYPE:** `dict[str, Any]`   |
| `packets` | Dictionary of packet definitions **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                                                |
| ---------------- | -------------------------------------------------------------------------- |
| `dict[str, Any]` | Tuple of (enums, packets) with MultiZoneExtendedApplicationRequest removed |
| `dict[str, Any]` | and packets updated to use MultiZoneApplicationRequest                     |

Source code in `src/lifx/protocol/generator.py`

```python
def apply_multizone_application_request_quirk(
    enums: dict[str, Any], packets: dict[str, Any]
) -> tuple[dict[str, Any], dict[str, Any]]:
    """Suppress MultiZoneExtendedApplicationRequest enum.

    Both MultiZoneApplicationRequest and MultiZoneExtendedApplicationRequest have
    identical values (NO_APPLY=0, APPLY=1, APPLY_ONLY=2), so we suppress the
    extended version and use the standard one for both SetColorZones and
    SetExtendedColorZones packets.

    Args:
        enums: Dictionary of enum definitions
        packets: Dictionary of packet definitions

    Returns:
        Tuple of (enums, packets) with MultiZoneExtendedApplicationRequest removed
        and packets updated to use MultiZoneApplicationRequest
    """
    # Remove the duplicate enum
    enums.pop("MultiZoneExtendedApplicationRequest", None)

    # Update packets in multi_zone category to use MultiZoneApplicationRequest
    if "multi_zone" in packets:
        for packet_name, packet_def in packets["multi_zone"].items():
            if "fields" in packet_def:
                for field in packet_def["fields"]:
                    if (
                        isinstance(field, dict)
                        and field.get("type") == "<MultiZoneExtendedApplicationRequest>"
                    ):
                        field["type"] = "<MultiZoneApplicationRequest>"

    return enums, packets
```

##### format_long_import

```python
format_long_import(
    items: list[str], prefix: str = "from lifx.protocol.protocol_types import "
) -> str
```

Format a long import statement across multiple lines.

| PARAMETER | DESCRIPTION                                                                              |
| --------- | ---------------------------------------------------------------------------------------- |
| `items`   | List of import items (e.g., ["Foo", "Bar as BazAlias"]) **TYPE:** `list[str]`            |
| `prefix`  | Import prefix **TYPE:** `str` **DEFAULT:** `'from lifx.protocol.protocol_types import '` |

| RETURNS | DESCRIPTION                                        |
| ------- | -------------------------------------------------- |
| `str`   | Formatted import string with line breaks if needed |

Source code in `src/lifx/protocol/generator.py`

```python
def format_long_import(
    items: list[str], prefix: str = "from lifx.protocol.protocol_types import "
) -> str:
    """Format a long import statement across multiple lines.

    Args:
        items: List of import items (e.g., ["Foo", "Bar as BazAlias"])
        prefix: Import prefix

    Returns:
        Formatted import string with line breaks if needed
    """
    if not items:
        return ""

    # Try single line first
    single_line = prefix + ", ".join(items)
    if len(single_line) <= 120:
        return single_line + "\n"

    # Multi-line format
    lines = [prefix + "("]
    for i, item in enumerate(items):
        if i < len(items) - 1:
            lines.append(f"    {item},")
        else:
            lines.append(f"    {item},")
    lines.append(")")
    return "\n".join(lines) + "\n"
```

##### format_long_list

```python
format_long_list(
    items: list[dict[str, Any]], max_line_length: int = 120
) -> str
```

Format a long list across multiple lines.

| PARAMETER         | DESCRIPTION                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| `items`           | List of dict items to format **TYPE:** `list[dict[str, Any]]`          |
| `max_line_length` | Maximum line length before wrapping **TYPE:** `int` **DEFAULT:** `120` |

| RETURNS | DESCRIPTION           |
| ------- | --------------------- |
| `str`   | Formatted list string |

Source code in `src/lifx/protocol/generator.py`

```python
def format_long_list(items: list[dict[str, Any]], max_line_length: int = 120) -> str:
    """Format a long list across multiple lines.

    Args:
        items: List of dict items to format
        max_line_length: Maximum line length before wrapping

    Returns:
        Formatted list string
    """
    if not items:
        return "[]"

    # Try single line first
    single_line = repr(items)
    if len(single_line) <= max_line_length:
        return single_line

    # Multi-line format with one item per line
    lines = ["["]
    for i, item in enumerate(items):
        item_str = repr(item)
        if i < len(items) - 1:
            lines.append(f"    {item_str},")
        else:
            lines.append(f"    {item_str},")
    lines.append("]")
    return "\n".join(lines)
```

##### parse_field_type

```python
parse_field_type(field_type: str) -> tuple[str, int | None, bool]
```

Parse a field type string.

| PARAMETER    | DESCRIPTION                                                  |
| ------------ | ------------------------------------------------------------ |
| `field_type` | Field type (e.g., 'uint16', '[32]uint8', '') **TYPE:** `str` |

| RETURNS           | DESCRIPTION                                              |
| ----------------- | -------------------------------------------------------- |
| `str`             | Tuple of (base_type, array_count, is_nested)             |
| \`int             | None\`                                                   |
| `bool`            | array_count: Number of elements if array, None otherwise |
| \`tuple\[str, int | None, bool\]\`                                           |

Source code in `src/lifx/protocol/generator.py`

```python
def parse_field_type(field_type: str) -> tuple[str, int | None, bool]:
    """Parse a field type string.

    Args:
        field_type: Field type (e.g., 'uint16', '[32]uint8', '<HSBK>')

    Returns:
        Tuple of (base_type, array_count, is_nested)
        - base_type: The base type name
        - array_count: Number of elements if array, None otherwise
        - is_nested: True if it's a nested structure (<Type>)
    """
    # Check for array: [N]type
    array_match = re.match(r"\[(\d+)\](.+)", field_type)
    if array_match:
        count = int(array_match.group(1))
        inner_type = array_match.group(2)
        # Check if inner type is nested
        if inner_type.startswith("<") and inner_type.endswith(">"):
            return inner_type[1:-1], count, True
        return inner_type, count, False

    # Check for nested structure: <Type>
    if field_type.startswith("<") and field_type.endswith(">"):
        return field_type[1:-1], None, True

    # Simple type
    return field_type, None, False
```

##### camel_to_snake_upper

```python
camel_to_snake_upper(name: str) -> str
```

Convert CamelCase to UPPER_SNAKE_CASE.

| PARAMETER | DESCRIPTION                      |
| --------- | -------------------------------- |
| `name`    | CamelCase string **TYPE:** `str` |

| RETURNS | DESCRIPTION             |
| ------- | ----------------------- |
| `str`   | UPPER_SNAKE_CASE string |

Source code in `src/lifx/protocol/generator.py`

```python
def camel_to_snake_upper(name: str) -> str:
    """Convert CamelCase to UPPER_SNAKE_CASE.

    Args:
        name: CamelCase string

    Returns:
        UPPER_SNAKE_CASE string
    """
    # Insert underscore before uppercase letters (except at start)
    snake = re.sub(r"(?<!^)(?=[A-Z])", "_", name)
    return snake.upper()
```

##### generate_enum_code

```python
generate_enum_code(enums: dict[str, Any]) -> str
```

Generate Python Enum definitions with shortened names.

| PARAMETER | DESCRIPTION                                               |
| --------- | --------------------------------------------------------- |
| `enums`   | Dictionary of enum definitions **TYPE:** `dict[str, Any]` |

| RETURNS | DESCRIPTION        |
| ------- | ------------------ |
| `str`   | Python code string |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_enum_code(enums: dict[str, Any]) -> str:
    """Generate Python Enum definitions with shortened names.

    Args:
        enums: Dictionary of enum definitions

    Returns:
        Python code string
    """
    code: list[str] = []

    for enum_name, enum_def in sorted(enums.items()):
        code.append(f"class {enum_name}(IntEnum):")
        code.append('    """Auto-generated enum."""')
        code.append("")

        # Handle both old format (dict) and new format (list of dicts)
        if isinstance(enum_def, dict) and "values" in enum_def:
            # New format: {type: "uint16", values: [{name: "X", value: 1}, ...]}
            values = enum_def["values"]

            # Check if all values share a common prefix (enum name)
            expected_prefix = camel_to_snake_upper(enum_name) + "_"
            non_reserved = [
                item["name"] for item in values if item["name"].lower() != "reserved"
            ]
            has_common_prefix = non_reserved and all(
                name.startswith(expected_prefix) for name in non_reserved
            )

            for item in sorted(values, key=lambda x: x["value"]):
                protocol_name = item["name"]
                member_value = item["value"]

                # Skip reserved fields entirely
                if protocol_name.lower() == "reserved":
                    continue

                # Remove redundant prefix for cleaner Python names
                if has_common_prefix and protocol_name.startswith(expected_prefix):
                    member_name = protocol_name[len(expected_prefix) :]
                else:
                    member_name = protocol_name

                code.append(f"    {member_name} = {member_value}")
        else:
            # Old format: {MEMBER: value, ...}
            for member_name, member_value in sorted(
                enum_def.items(), key=lambda x: x[1]
            ):
                code.append(f"    {member_name} = {member_value}")

        code.append("")
        code.append("")

    return "\n".join(code)
```

##### convert_type_to_python

```python
convert_type_to_python(
    field_type: str, type_aliases: dict[str, str] | None = None
) -> str
```

Convert a protocol field type to Python type annotation.

| PARAMETER      | DESCRIPTION                                                    |
| -------------- | -------------------------------------------------------------- |
| `field_type`   | Protocol field type string **TYPE:** `str`                     |
| `type_aliases` | Optional dict for type name aliases **TYPE:** \`dict[str, str] |

| RETURNS | DESCRIPTION                   |
| ------- | ----------------------------- |
| `str`   | Python type annotation string |

Source code in `src/lifx/protocol/generator.py`

```python
def convert_type_to_python(
    field_type: str, type_aliases: dict[str, str] | None = None
) -> str:
    """Convert a protocol field type to Python type annotation.

    Args:
        field_type: Protocol field type string
        type_aliases: Optional dict for type name aliases

    Returns:
        Python type annotation string
    """
    if type_aliases is None:
        type_aliases = {}

    base_type, array_count, is_nested = parse_field_type(field_type)

    if array_count:
        if is_nested:
            # Use alias if one exists
            type_name = type_aliases.get(base_type, base_type)
            return f"list[{type_name}]"
        elif base_type in ("uint8", "byte"):
            # Special case: byte arrays
            return "bytes"
        else:
            return "list[int]"
    elif is_nested:
        # Use alias if one exists
        return type_aliases.get(base_type, base_type)
    elif base_type in ("uint8", "uint16", "uint32", "uint64"):
        return "int"
    elif base_type in ("int8", "int16", "int32", "int64"):
        return "int"
    elif base_type == "float32":
        return "float"
    elif base_type == "bool":
        return "bool"
    else:
        return "Any"
```

##### generate_pack_method

```python
generate_pack_method(
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str
```

Generate pack() method code for a field structure or packet.

| PARAMETER     | DESCRIPTION                                                       |
| ------------- | ----------------------------------------------------------------- |
| `fields_data` | List of field definitions **TYPE:** `list[dict[str, Any]]`        |
| `class_type`  | Either "field" or "packet" **TYPE:** `str` **DEFAULT:** `'field'` |
| `enum_types`  | Set of enum type names for detection **TYPE:** \`set[str]         |

| RETURNS | DESCRIPTION               |
| ------- | ------------------------- |
| `str`   | Python method code string |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_pack_method(
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str:
    """Generate pack() method code for a field structure or packet.

    Args:
        fields_data: List of field definitions
        class_type: Either "field" or "packet"
        enum_types: Set of enum type names for detection

    Returns:
        Python method code string
    """
    if enum_types is None:
        enum_types = set()

    code = []
    code.append("    def pack(self) -> bytes:")
    code.append('        """Pack to bytes."""')
    code.append("        from lifx.protocol import serializer")
    code.append('        result = b""')
    code.append("")

    for field_item in fields_data:
        # Handle reserved fields (no name)
        if "name" not in field_item:
            size_bytes = field_item.get("size_bytes", 0)
            code.append(f"        # Reserved {size_bytes} bytes")
            code.append(f"        result += serializer.pack_reserved({size_bytes})")
            continue

        protocol_name = field_item["name"]
        field_type = field_item["type"]
        size_bytes = field_item.get("size_bytes", 0)
        python_name = apply_field_name_quirks(to_snake_case(protocol_name))

        base_type, array_count, is_nested = parse_field_type(field_type)

        # Check if this is an enum (nested but in enum_types)
        is_enum = is_nested and base_type in enum_types

        # Handle different field types
        if array_count:
            if is_enum:
                # Array of enums - pack as array of ints
                code.append(f"        # {python_name}: list[{base_type}] (enum array)")
                code.append(f"        for item in self.{python_name}:")
                code.append(
                    "            result += serializer.pack_value(int(item), 'uint8')"
                )
            elif is_nested:
                # Array of nested structures
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(f"        for item in self.{python_name}:")
                code.append("            result += item.pack()")
            elif base_type in ("uint8", "byte"):
                # Byte array
                code.append(f"        # {python_name}: bytes ({size_bytes} bytes)")
                code.append(
                    f"        result += "
                    f"serializer.pack_bytes(self.{python_name}, {size_bytes})"
                )
            else:
                # Array of primitives
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(
                    f"        result += "
                    f"serializer.pack_array(self.{python_name}, '{base_type}', {array_count})"
                )
        elif is_enum:
            # Enum - pack as int
            code.append(f"        # {python_name}: {base_type} (enum)")
            code.append(
                f"        result += "
                f"serializer.pack_value(int(self.{python_name}), 'uint8')"
            )
        elif is_nested:
            # Nested structure
            code.append(f"        # {python_name}: {base_type}")
            code.append(f"        result += self.{python_name}.pack()")
        else:
            # Primitive type
            code.append(f"        # {python_name}: {base_type}")
            code.append(
                f"        result += "
                f"serializer.pack_value(self.{python_name}, '{base_type}')"
            )

    code.append("")
    code.append("        return result")

    return "\n".join(code)
```

##### generate_unpack_method

```python
generate_unpack_method(
    class_name: str,
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str
```

Generate unpack() classmethod code for a field structure or packet.

| PARAMETER     | DESCRIPTION                                                       |
| ------------- | ----------------------------------------------------------------- |
| `class_name`  | Name of the class **TYPE:** `str`                                 |
| `fields_data` | List of field definitions **TYPE:** `list[dict[str, Any]]`        |
| `class_type`  | Either "field" or "packet" **TYPE:** `str` **DEFAULT:** `'field'` |
| `enum_types`  | Set of enum type names for detection **TYPE:** \`set[str]         |

| RETURNS | DESCRIPTION               |
| ------- | ------------------------- |
| `str`   | Python method code string |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_unpack_method(
    class_name: str,
    fields_data: list[dict[str, Any]],
    class_type: str = "field",
    enum_types: set[str] | None = None,
) -> str:
    """Generate unpack() classmethod code for a field structure or packet.

    Args:
        class_name: Name of the class
        fields_data: List of field definitions
        class_type: Either "field" or "packet"
        enum_types: Set of enum type names for detection

    Returns:
        Python method code string
    """
    if enum_types is None:
        enum_types = set()

    code = []
    code.append("    @classmethod")
    code.append(
        f"    def unpack(cls, data: bytes, offset: int = 0) -> tuple[{class_name}, int]:"
    )
    code.append('        """Unpack from bytes."""')
    code.append("        from lifx.protocol import serializer")
    code.append("        current_offset = offset")

    # Store field values
    field_vars = []

    for field_item in fields_data:
        # Handle reserved fields (no name)
        if "name" not in field_item:
            size_bytes = field_item.get("size_bytes", 0)
            code.append(f"        # Skip reserved {size_bytes} bytes")
            code.append(f"        current_offset += {size_bytes}")
            continue

        protocol_name = field_item["name"]
        field_type = field_item["type"]
        size_bytes = field_item.get("size_bytes", 0)
        python_name = apply_field_name_quirks(to_snake_case(protocol_name))
        field_vars.append(python_name)

        base_type, array_count, is_nested = parse_field_type(field_type)

        # Check if this is an enum (nested but in enum_types)
        is_enum = is_nested and base_type in enum_types

        # Handle different field types
        if array_count:
            if is_enum:
                # Array of enums
                code.append(f"        # {python_name}: list[{base_type}] (enum array)")
                code.append(f"        {python_name} = []")
                code.append(f"        for _ in range({array_count}):")
                code.append(
                    "            item_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)"
                )
                code.append(f"            {python_name}.append({base_type}(item_raw))")
            elif is_nested:
                # Array of nested structures
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(f"        {python_name} = []")
                code.append(f"        for _ in range({array_count}):")
                code.append(
                    f"            item, current_offset = {base_type}.unpack(data, current_offset)"
                )
                code.append(f"            {python_name}.append(item)")
            elif base_type in ("uint8", "byte"):
                # Byte array
                code.append(f"        # {python_name}: bytes ({size_bytes} bytes)")
                code.append(
                    f"        {python_name}, current_offset = serializer.unpack_bytes("
                )
                code.append(f"            data, {size_bytes}, current_offset")
                code.append("        )")
            else:
                # Array of primitives
                code.append(f"        # {python_name}: list[{base_type}]")
                code.append(
                    f"        {python_name}, current_offset = serializer.unpack_array("
                )
                code.append(
                    f"            data, '{base_type}', {array_count}, current_offset"
                )
                code.append("        )")
        elif is_enum:
            # Enum - unpack as int then convert
            code.append(f"        # {python_name}: {base_type} (enum)")
            code.append(
                f"        {python_name}_raw, current_offset = serializer.unpack_value(data, 'uint8', current_offset)"
            )
            code.append(f"        {python_name} = {base_type}({python_name}_raw)")
        elif is_nested:
            # Nested structure
            code.append(f"        # {python_name}: {base_type}")
            code.append(
                f"        {python_name}, current_offset = {base_type}.unpack(data, current_offset)"
            )
        else:
            # Primitive type
            code.append(f"        # {python_name}: {base_type}")
            code.append(
                f"        {python_name}, current_offset = serializer.unpack_value(data, '{base_type}', current_offset)"
            )

    code.append("")
    # Create instance - format long return statements
    field_args = ", ".join([f"{name}={name}" for name in field_vars])
    return_stmt = f"        return cls({field_args}), current_offset"

    # If too long, break across multiple lines
    if len(return_stmt) > 120:
        code.append("        return (")
        code.append("            cls(")
        for i, name in enumerate(field_vars):
            if i < len(field_vars) - 1:
                code.append(f"                {name}={name},")
            else:
                code.append(f"                {name}={name},")
        code.append("            ),")
        code.append("            current_offset,")
        code.append("        )")
    else:
        code.append(return_stmt)

    return "\n".join(code)
```

##### generate_field_code

```python
generate_field_code(
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enum_types: set[str] | None = None,
) -> tuple[str, dict[str, dict[str, str]]]
```

Generate Python dataclass definitions for field structures.

| PARAMETER           | DESCRIPTION                                                                        |
| ------------------- | ---------------------------------------------------------------------------------- |
| `fields`            | Dictionary of field definitions **TYPE:** `dict[str, Any]`                         |
| `compound_fields`   | Dictionary of compound field definitions **TYPE:** \`dict[str, Any]                |
| `unions`            | Dictionary of union definitions (treated as fields) **TYPE:** \`dict[str, Any]     |
| `packets_as_fields` | Dictionary of packets that are also used as field types **TYPE:** \`dict[str, Any] |
| `enum_types`        | Set of enum type names **TYPE:** \`set[str]                                        |

| RETURNS                     | DESCRIPTION                                               |
| --------------------------- | --------------------------------------------------------- |
| `str`                       | Tuple of (code string, field mappings dict)               |
| `dict[str, dict[str, str]]` | Field mappings: {ClassName: {python_name: protocol_name}} |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_field_code(
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enum_types: set[str] | None = None,
) -> tuple[str, dict[str, dict[str, str]]]:
    """Generate Python dataclass definitions for field structures.

    Args:
        fields: Dictionary of field definitions
        compound_fields: Dictionary of compound field definitions
        unions: Dictionary of union definitions (treated as fields)
        packets_as_fields: Dictionary of packets that are also used as field types
        enum_types: Set of enum type names

    Returns:
        Tuple of (code string, field mappings dict)
        Field mappings: {ClassName: {python_name: protocol_name}}
    """
    if enum_types is None:
        enum_types = set()

    code = []
    field_mappings: dict[str, dict[str, str]] = {}
    all_fields = {**fields}
    if compound_fields:
        all_fields.update(compound_fields)
    if unions:
        all_fields.update(unions)
    if packets_as_fields:
        all_fields.update(packets_as_fields)

    for field_name, field_def in sorted(all_fields.items()):
        code.append("@dataclass")
        code.append(f"class {field_name}:")

        # Check if this is a union (has comment indicating it's a union)
        is_union = isinstance(field_def, dict) and "comment" in field_def
        if is_union:
            code.append(
                f'    """Auto-generated union structure. {field_def.get("comment", "")}"""'
            )
        else:
            code.append('    """Auto-generated field structure."""')
        code.append("")

        field_map: dict[str, str] = {}
        fields_data = []

        # Handle both old format (dict) and new format (list of dicts)
        if isinstance(field_def, dict) and "fields" in field_def:
            # New format: {size_bytes: N, fields: [{name: "X", type: "uint16"}, ...]}
            field_list = field_def["fields"]

            # For unions, treat as a raw bytes field (they overlay, so just store raw data)
            if is_union:
                size_bytes = field_def.get("size_bytes", 16)
                code.append(f"    data: bytes  # Union of {size_bytes} bytes")
                field_map["data"] = "data"
                # For pack/unpack, use bytes field
                fields_data = [
                    {
                        "name": "data",
                        "type": f"[{size_bytes}]byte",
                        "size_bytes": size_bytes,
                    }
                ]
            else:
                # Normal field structure - process all fields
                fields_data = field_list  # Save for pack/unpack generation
                for field_item in field_list:
                    # Skip reserved fields without names (they won't be in dataclass)
                    if "name" not in field_item:
                        continue
                    protocol_name = field_item["name"]
                    attr_type = field_item["type"]
                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))
                    python_type = convert_type_to_python(attr_type)

                    code.append(f"    {python_name}: {python_type}")
                    field_map[python_name] = protocol_name
        else:
            # Old format: {attr_name: type, ...}
            # Convert to new format for pack/unpack generation
            for protocol_name, attr_type in field_def.items():
                python_name = apply_field_name_quirks(to_snake_case(protocol_name))
                python_type = convert_type_to_python(attr_type)
                code.append(f"    {python_name}: {python_type}")
                field_map[python_name] = protocol_name
                # Build fields_data for old format
                fields_data.append({"name": protocol_name, "type": attr_type})

        field_mappings[field_name] = field_map

        # Add pack/unpack methods
        if fields_data:
            code.append("")
            code.append(generate_pack_method(fields_data, "field", enum_types))
            code.append("")
            code.append(
                generate_unpack_method(field_name, fields_data, "field", enum_types)
            )

        code.append("")
        code.append("")

    return "\n".join(code), field_mappings
```

##### generate_nested_packet_code

```python
generate_nested_packet_code(
    packets: dict[str, Any], type_aliases: dict[str, str] | None = None
) -> str
```

Generate nested Python packet class definitions.

| PARAMETER      | DESCRIPTION                                                                                             |
| -------------- | ------------------------------------------------------------------------------------------------------- |
| `packets`      | Dictionary of packet definitions (grouped by category) **TYPE:** `dict[str, Any]`                       |
| `type_aliases` | Optional dict mapping type names to their aliases (for collision resolution) **TYPE:** \`dict[str, str] |

| RETURNS | DESCRIPTION                                   |
| ------- | --------------------------------------------- |
| `str`   | Python code string with nested packet classes |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_nested_packet_code(
    packets: dict[str, Any], type_aliases: dict[str, str] | None = None
) -> str:
    """Generate nested Python packet class definitions.

    Args:
        packets: Dictionary of packet definitions (grouped by category)
        type_aliases: Optional dict mapping type names to their aliases (for collision resolution)

    Returns:
        Python code string with nested packet classes
    """
    if type_aliases is None:
        type_aliases = {}

    code = []

    # Flatten packets if they're grouped by category
    flat_packets: list[tuple[str, str, dict[str, Any]]] = []

    # Check if packets are grouped by category (new format)
    sample_key = next(iter(packets.keys())) if packets else None
    if sample_key and isinstance(packets[sample_key], dict):
        sample_value = packets[sample_key]
        # Check if this is a category grouping (contains nested packet dicts)
        if any(isinstance(v, dict) and "pkt_type" in v for v in sample_value.values()):
            # New format: grouped by category
            for category, category_packets in packets.items():
                for packet_name, packet_def in category_packets.items():
                    flat_packets.append((category, packet_name, packet_def))
        else:
            # Old format: flat packets with category field
            for packet_name, packet_def in packets.items():
                category = packet_def.get("category", "misc")
                flat_packets.append((category, packet_name, packet_def))

    # Group by category
    categories: dict[str, list[tuple[str, dict[str, Any]]]] = {}
    for category, packet_name, packet_def in flat_packets:
        if category not in categories:
            categories[category] = []
        categories[category].append((packet_name, packet_def))

    # Build lookup table for request-to-response mapping
    # Maps (category, short_name) -> pkt_type
    packet_lookup: dict[tuple[str, str], int] = {}
    for category, packets_list in categories.items():
        parts = category.split("_")
        category_class = "".join(part.capitalize() for part in parts)
        for packet_name, packet_def in packets_list:
            short_name = packet_name
            if packet_name.lower().startswith(category_class.lower()):
                short_name = packet_name[len(category_class) :]
            if category_class == "Light":
                if short_name == "Get":
                    short_name = "GetColor"
                elif short_name == "State":
                    short_name = "StateColor"
            short_name = apply_extended_multizone_packet_quirks(
                short_name, category_class
            )
            packet_lookup[(category, short_name)] = packet_def["pkt_type"]

    # Generate category classes with nested packet classes
    for category in sorted(categories.keys()):
        # Generate category class
        # Quirk: Convert category names to proper camel case (multi_zone -> MultiZone)
        # Split on underscores, capitalize each part, then join
        parts = category.split("_")
        category_class = "".join(part.capitalize() for part in parts)
        code.append("")
        code.append(f"class {category_class}(Packet):")
        code.append(f'    """{category_class} category packets."""')
        code.append("")

        # Generate nested packet classes
        for packet_name, packet_def in sorted(categories[category]):
            pkt_type = packet_def["pkt_type"]
            fields_data = packet_def.get("fields", [])

            # Remove category prefix from packet name (e.g., DeviceGetLabel -> GetLabel)
            # The packet name format is: CategoryActionTarget (e.g., DeviceGetLabel, LightSetColor)
            # Use case-insensitive matching to handle multi_zone -> Multizone -> MultiZone
            short_name = packet_name
            if packet_name.lower().startswith(category_class.lower()):
                short_name = packet_name[len(category_class) :]

            # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor
            # for better clarity (Set and SetColor are different packets)
            if category_class == "Light":
                if short_name == "Get":
                    short_name = "GetColor"
                elif short_name == "State":
                    short_name = "StateColor"

            # Quirk: Rename extended multizone packets to follow standard naming convention
            short_name = apply_extended_multizone_packet_quirks(
                short_name, category_class
            )

            code.append("    @dataclass")
            code.append(f"    class {short_name}(Packet):")
            code.append(f'        """Packet type {pkt_type}."""')
            code.append("")
            code.append(f"        PKT_TYPE: ClassVar[int] = {pkt_type}")

            # Add STATE_TYPE for Get*/Request packets (expected response packet type)
            state_pkt_type = None
            if short_name.startswith("Get"):
                # Special case: GetColorZones  StateMultiZone (not StateColorZones)
                if category_class == "MultiZone" and short_name == "GetColorZones":
                    state_pkt_type = packet_lookup.get((category, "StateMultiZone"))
                else:
                    # Standard naming: GetXxx  StateXxx
                    state_name = short_name.replace("Get", "State", 1)
                    state_pkt_type = packet_lookup.get((category, state_name))
            elif short_name.endswith("Request"):
                # XxxRequest  XxxResponse
                response_name = short_name.replace("Request", "Response")
                state_pkt_type = packet_lookup.get((category, response_name))

            if state_pkt_type is not None:
                code.append(f"        STATE_TYPE: ClassVar[int] = {state_pkt_type}")

            # Format fields_data - split long lists across multiple lines
            # Account for the prefix "        _fields: ClassVar[list[dict[str, Any]]] = " which is ~50 chars
            fields_repr = format_long_list(fields_data, max_line_length=70)
            if "\n" in fields_repr:
                # Multi-line format - indent properly
                code.append("        _fields: ClassVar[list[dict[str, Any]]] = (")
                for line in fields_repr.split("\n"):
                    if line.strip():
                        code.append(f"        {line}")
                code.append("        )")
            else:
                code.append(
                    f"        _fields: ClassVar[list[dict[str, Any]]] = {fields_repr}"
                )

            # Add packet metadata for smart request handling
            # Classify packet by name pattern: Get*, Set*, State*, or OTHER
            packet_kind = "OTHER"
            if short_name.startswith("Get"):
                packet_kind = "GET"
            elif short_name.startswith("Set"):
                packet_kind = "SET"
            elif short_name.startswith("State"):
                packet_kind = "STATE"

            # Quirk: CopyFrameBuffer is semantically a SET operation
            # It modifies device state without returning data
            if category_class == "Tile" and short_name == "CopyFrameBuffer":
                packet_kind = "SET"

            code.append("")
            code.append("        # Packet metadata for automatic handling")
            code.append(f"        _packet_kind: ClassVar[str] = {repr(packet_kind)}")

            # Requires acknowledgement/response based on packet kind
            # GET requests: ack_required=False, res_required=False (device responds anyway)
            # SET requests: ack_required=True, res_required=False (need acknowledgement)
            requires_ack = packet_kind == "SET"
            requires_response = False
            code.append(f"        _requires_ack: ClassVar[bool] = {requires_ack}")
            code.append(
                f"        _requires_response: ClassVar[bool] = {requires_response}"
            )
            code.append("")

            # Generate dataclass fields (only non-reserved)
            has_fields = False
            if isinstance(fields_data, list):
                for field_item in fields_data:
                    # Skip reserved fields
                    if "name" not in field_item:
                        continue
                    protocol_name = field_item["name"]
                    field_type = field_item["type"]
                    python_name = apply_field_name_quirks(to_snake_case(protocol_name))
                    python_type = convert_type_to_python(field_type, type_aliases)
                    code.append(f"        {python_name}: {python_type}")
                    has_fields = True

            if not has_fields:
                code.append("        pass")

            code.append("")

        code.append("")

    return "\n".join(code)
```

##### generate_types_file

```python
generate_types_file(
    enums: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
) -> str
```

Generate complete types.py file.

| PARAMETER           | DESCRIPTION                                                          |
| ------------------- | -------------------------------------------------------------------- |
| `enums`             | Enum definitions **TYPE:** `dict[str, Any]`                          |
| `fields`            | Field structure definitions **TYPE:** `dict[str, Any]`               |
| `compound_fields`   | Compound field definitions **TYPE:** \`dict[str, Any]                |
| `unions`            | Union definitions **TYPE:** \`dict[str, Any]                         |
| `packets_as_fields` | Packets that are also used as field types **TYPE:** \`dict[str, Any] |

| RETURNS | DESCRIPTION                  |
| ------- | ---------------------------- |
| `str`   | Complete Python file content |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_types_file(
    enums: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
) -> str:
    """Generate complete types.py file.

    Args:
        enums: Enum definitions
        fields: Field structure definitions
        compound_fields: Compound field definitions
        unions: Union definitions
        packets_as_fields: Packets that are also used as field types

    Returns:
        Complete Python file content
    """
    header = '''"""Auto-generated LIFX protocol types.

DO NOT EDIT THIS FILE MANUALLY.
Generated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml
by protocol/generator.py

Uses Pythonic naming conventions (snake_case fields, shortened enums) while
maintaining compatibility with the official LIFX protocol through mappings.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import IntEnum


'''

    code = header
    code += generate_enum_code(enums)
    code += "\n"

    # Extract enum names for pack/unpack generation
    enum_names = set(enums.keys())

    field_code, field_mappings = generate_field_code(
        fields, compound_fields, unions, packets_as_fields, enum_names
    )
    code += field_code
    code += "\n"

    # Add type aliases for common names
    code += "# Type aliases for convenience\n"
    all_field_names = {
        **fields,
        **(compound_fields or {}),
        **(unions or {}),
        **(packets_as_fields or {}),
    }
    if "TileStateDevice" in all_field_names:
        code += "TileDevice = TileStateDevice  # Pythonic alias\n"
    code += "\n"

    # Add field name mappings as module-level constant (formatted for readability)
    code += "# Field name mappings: Python name -> Protocol name\n"
    code += "# Used by serializer to translate between conventions\n"
    code += "FIELD_MAPPINGS: dict[str, dict[str, str]] = {\n"
    for class_name in sorted(field_mappings.keys()):
        mappings = field_mappings[class_name]
        # Format each class mapping - if too long, break it into multiple lines
        mappings_str = repr(mappings)
        line = f"    {repr(class_name)}: {mappings_str},"
        if len(line) > 120:
            # Multi-line format
            code += f"    {repr(class_name)}: {{\n"
            for py_name, proto_name in sorted(mappings.items()):
                code += f"        {repr(py_name)}: {repr(proto_name)},\n"
            code += "    },\n"
        else:
            code += line + "\n"
    code += "}\n"
    code += "\n"

    return code
```

##### generate_packets_file

```python
generate_packets_file(
    packets: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enums: dict[str, Any] | None = None,
) -> str
```

Generate complete packets.py file.

| PARAMETER           | DESCRIPTION                                                                        |
| ------------------- | ---------------------------------------------------------------------------------- |
| `packets`           | Packet definitions **TYPE:** `dict[str, Any]`                                      |
| `fields`            | Field definitions (for imports) **TYPE:** `dict[str, Any]`                         |
| `compound_fields`   | Compound field definitions (for imports) **TYPE:** \`dict[str, Any]                |
| `unions`            | Union definitions (for imports) **TYPE:** \`dict[str, Any]                         |
| `packets_as_fields` | Packets that are also used as field types (for imports) **TYPE:** \`dict[str, Any] |
| `enums`             | Enum definitions for detecting enum types **TYPE:** \`dict[str, Any]               |

| RETURNS | DESCRIPTION                  |
| ------- | ---------------------------- |
| `str`   | Complete Python file content |

Source code in `src/lifx/protocol/generator.py`

```python
def generate_packets_file(
    packets: dict[str, Any],
    fields: dict[str, Any],
    compound_fields: dict[str, Any] | None = None,
    unions: dict[str, Any] | None = None,
    packets_as_fields: dict[str, Any] | None = None,
    enums: dict[str, Any] | None = None,
) -> str:
    """Generate complete packets.py file.

    Args:
        packets: Packet definitions
        fields: Field definitions (for imports)
        compound_fields: Compound field definitions (for imports)
        unions: Union definitions (for imports)
        packets_as_fields: Packets that are also used as field types (for imports)
        enums: Enum definitions for detecting enum types

    Returns:
        Complete Python file content
    """
    # Extract enum names for pack/unpack generation
    enum_names = set(enums.keys()) if enums else set()

    # Collect all field types and enum types used in packets
    used_fields = set()
    used_enums = set()
    all_fields = {**fields}
    if compound_fields:
        all_fields.update(compound_fields)
    if unions:
        all_fields.update(unions)
    if packets_as_fields:
        all_fields.update(packets_as_fields)

    # Flatten packets to scan for used field types
    flat_packets: list[dict[str, Any]] = []
    for value in packets.values():
        if isinstance(value, dict):
            # Check if this is a category grouping
            if any(isinstance(v, dict) and "pkt_type" in v for v in value.values()):
                # New format: grouped by category
                for packet_def in value.values():
                    flat_packets.append(packet_def)
            elif "pkt_type" in value:
                # Old format: direct packet
                flat_packets.append(value)

    for packet_def in flat_packets:
        fields_data = packet_def.get("fields", [])
        # Handle both list and dict formats
        if isinstance(fields_data, list):
            for field_item in fields_data:
                if "type" in field_item:
                    field_type = field_item["type"]
                    base_type, _, is_nested = parse_field_type(field_type)
                    if is_nested:
                        if base_type in all_fields:
                            used_fields.add(base_type)
                        elif base_type in enum_names:
                            used_enums.add(base_type)
        elif isinstance(fields_data, dict):
            for field_type in fields_data.values():
                base_type, _, is_nested = parse_field_type(field_type)
                if is_nested:
                    if base_type in all_fields:
                        used_fields.add(base_type)
                    elif base_type in enum_names:
                        used_enums.add(base_type)

    # Generate imports with collision detection
    imports = ""
    all_imports = sorted(used_fields | used_enums)
    if all_imports:
        # Detect name collisions with packet category names
        category_names = set()
        for category in packets.keys():
            if isinstance(packets[category], dict):
                # Convert category name to class name (same as in generate_nested_packet_code)
                parts = category.split("_")
                category_class = "".join(part.capitalize() for part in parts)
                category_names.add(category_class)

        # Generate import list with aliases for collisions
        import_items = []
        type_aliases = {}  # Map original name to aliased name
        for name in all_imports:
            if name in category_names:
                # Use alias to avoid collision
                aliased_name = f"{name}Field"
                import_items.append(f"{name} as {aliased_name}")
                type_aliases[name] = aliased_name
            else:
                import_items.append(name)

        imports = format_long_import(import_items) + "\n"
    else:
        type_aliases = {}
        imports = ""

    header = f'''"""Auto-generated LIFX protocol packets.

DO NOT EDIT THIS FILE MANUALLY.
Generated from https://github.com/LIFX/public-protocol/blob/main/protocol.yml
by protocol/generator.py

Uses nested packet classes organized by category (Device, Light, etc.).
Each packet inherits from base Packet class which provides generic pack/unpack.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar

from lifx.protocol.base import Packet
{imports}
'''

    code = header
    packet_code = generate_nested_packet_code(packets, type_aliases)
    code += packet_code

    # Generate packet registry for nested classes
    code += "\n\n"
    code += "# Packet Registry - maps packet type to nested packet class\n"
    code += "PACKET_REGISTRY: dict[int, type[Packet]] = {\n"

    # Build registry with nested class paths
    registry_items = []
    for category, value in packets.items():
        if isinstance(value, dict):
            # Check if this is a category grouping
            if any(isinstance(v, dict) and "pkt_type" in v for v in value.values()):
                # New format: grouped by category
                # Quirk: Convert category names to proper camel case (multi_zone -> MultiZone)
                parts = category.split("_")
                category_class = "".join(part.capitalize() for part in parts)
                for packet_name, packet_def in value.items():
                    pkt_type = packet_def.get("pkt_type")
                    if pkt_type is not None:
                        # Remove category prefix to get short name
                        # Use case-insensitive matching to handle multi_zone -> Multizone -> MultiZone
                        short_name = packet_name
                        if packet_name.lower().startswith(category_class.lower()):
                            short_name = packet_name[len(category_class) :]

                        # Quirk: Rename Light.Get/Set/State to Light.GetColor/SetColor/StateColor
                        if category_class == "Light":
                            if short_name == "Get":
                                short_name = "GetColor"
                            elif short_name == "State":
                                short_name = "StateColor"

                        # Quirk: Rename extended multizone packets to follow standard naming convention
                        short_name = apply_extended_multizone_packet_quirks(
                            short_name, category_class
                        )

                        # Full path: Category.ShortName
                        full_path = f"{category_class}.{short_name}"
                        registry_items.append((pkt_type, full_path))

    # Sort by packet type for readability
    for pkt_type, full_path in sorted(registry_items):
        code += f"    {pkt_type}: {full_path},\n"

    code += "}\n"
    code += "\n\n"
    code += "def get_packet_class(pkt_type: int) -> type[Packet] | None:\n"
    code += '    """Get packet class for a given packet type.\n'
    code += "\n"
    code += "    Args:\n"
    code += "        pkt_type: Packet type number\n"
    code += "\n"
    code += "    Returns:\n"
    code += "        Nested packet class, or None if unknown\n"
    code += '    """\n'
    code += "    return PACKET_REGISTRY.get(pkt_type)\n"

    return code
```

##### download_protocol

```python
download_protocol() -> dict[str, Any]
```

Download and parse protocol.yml from LIFX GitHub repository.

| RETURNS          | DESCRIPTION                |
| ---------------- | -------------------------- |
| `dict[str, Any]` | Parsed protocol dictionary |

| RAISES      | DESCRIPTION       |
| ----------- | ----------------- |
| `URLError`  | If download fails |
| `YAMLError` | If parsing fails  |

Source code in `src/lifx/protocol/generator.py`

```python
def download_protocol() -> dict[str, Any]:
    """Download and parse protocol.yml from LIFX GitHub repository.

    Returns:
        Parsed protocol dictionary

    Raises:
        URLError: If download fails
        yaml.YAMLError: If parsing fails
    """
    parsed_url = urlparse(PROTOCOL_URL)
    if parsed_url.scheme == "https" and parsed_url.netloc.startswith(
        "raw.githubusercontent.com"
    ):
        print(f"Downloading protocol.yml from {PROTOCOL_URL}...")
        with urlopen(PROTOCOL_URL) as response:  # nosec B310
            protocol_data = response.read()

        print("Parsing protocol specification...")
        protocol = yaml.safe_load(protocol_data)
        return protocol
```

##### validate_protocol_spec

```python
validate_protocol_spec(protocol: dict[str, Any]) -> list[str]
```

Validate protocol specification for missing type references.

| PARAMETER  | DESCRIPTION                                           |
| ---------- | ----------------------------------------------------- |
| `protocol` | Parsed protocol dictionary **TYPE:** `dict[str, Any]` |

| RETURNS     | DESCRIPTION                                         |
| ----------- | --------------------------------------------------- |
| `list[str]` | List of error messages (empty if validation passes) |

Source code in `src/lifx/protocol/generator.py`

```python
def validate_protocol_spec(protocol: dict[str, Any]) -> list[str]:
    """Validate protocol specification for missing type references.

    Args:
        protocol: Parsed protocol dictionary

    Returns:
        List of error messages (empty if validation passes)
    """
    errors: list[str] = []
    registry = TypeRegistry()

    # Register all types
    enums = protocol.get("enums", {})
    fields = protocol.get("fields", {})
    compound_fields = protocol.get("compound_fields", {})
    unions = protocol.get("unions", {})
    packets = protocol.get("packets", {})

    # Register enums
    for enum_name in enums.keys():
        registry.register_enum(enum_name)

    # Register field structures
    for field_name in fields.keys():
        registry.register_field(field_name)

    # Register compound fields
    for field_name in compound_fields.keys():
        registry.register_field(field_name)

    # Register unions
    for union_name in unions.keys():
        registry.register_union(union_name)

    # Register packets (flatten by category)
    for category_packets in packets.values():
        if isinstance(category_packets, dict):
            for packet_name in category_packets.keys():
                registry.register_packet(packet_name)

    # Validate field type references
    def validate_field_types(struct_name: str, struct_def: dict[str, Any]) -> None:
        """Validate all field types in a structure."""
        if isinstance(struct_def, dict) and "fields" in struct_def:
            for field_item in struct_def["fields"]:
                if "type" in field_item:
                    field_type = field_item["type"]
                    field_name = field_item.get("name", "reserved")
                    base_type, _, _ = parse_field_type(field_type)

                    # Check if type is defined
                    if not registry.has_type(base_type):
                        errors.append(
                            f"{struct_name}.{field_name}: Unknown type '{base_type}' in field type '{field_type}'"
                        )

    # Validate fields
    for field_name, field_def in fields.items():
        validate_field_types(f"fields.{field_name}", field_def)

    # Validate compound fields
    for field_name, field_def in compound_fields.items():
        validate_field_types(f"compound_fields.{field_name}", field_def)

    # Validate unions
    for union_name, union_def in unions.items():
        validate_field_types(f"unions.{union_name}", union_def)

    # Validate packets
    for category, category_packets in packets.items():
        if isinstance(category_packets, dict):
            for packet_name, packet_def in category_packets.items():
                if isinstance(packet_def, dict):
                    validate_field_types(
                        f"packets.{category}.{packet_name}", packet_def
                    )

    return errors
```

##### should_skip_button_relay

```python
should_skip_button_relay(name: str) -> bool
```

Check if a name should be skipped (Button or Relay related).

| PARAMETER | DESCRIPTION                                                                  |
| --------- | ---------------------------------------------------------------------------- |
| `name`    | Type name to check (enum, field, union, packet, or category) **TYPE:** `str` |

| RETURNS | DESCRIPTION                                                   |
| ------- | ------------------------------------------------------------- |
| `bool`  | True if the name starts with Button or Relay, False otherwise |

Source code in `src/lifx/protocol/generator.py`

```python
def should_skip_button_relay(name: str) -> bool:
    """Check if a name should be skipped (Button or Relay related).

    Args:
        name: Type name to check (enum, field, union, packet, or category)

    Returns:
        True if the name starts with Button or Relay, False otherwise
    """
    return name.startswith("Button") or name.startswith("Relay")
```

##### filter_button_relay_items

```python
filter_button_relay_items(items: dict[str, Any]) -> dict[str, Any]
```

Filter out Button and Relay items from a dictionary.

| PARAMETER | DESCRIPTION                                              |
| --------- | -------------------------------------------------------- |
| `items`   | Dictionary of items to filter **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                    |
| ---------------- | ---------------------------------------------- |
| `dict[str, Any]` | Filtered dictionary without Button/Relay items |

Source code in `src/lifx/protocol/generator.py`

```python
def filter_button_relay_items(items: dict[str, Any]) -> dict[str, Any]:
    """Filter out Button and Relay items from a dictionary.

    Args:
        items: Dictionary of items to filter

    Returns:
        Filtered dictionary without Button/Relay items
    """
    return {
        name: value
        for name, value in items.items()
        if not should_skip_button_relay(name)
    }
```

##### filter_button_relay_packets

```python
filter_button_relay_packets(packets: dict[str, Any]) -> dict[str, Any]
```

Filter out button and relay category packets.

| PARAMETER | DESCRIPTION                                                                       |
| --------- | --------------------------------------------------------------------------------- |
| `packets` | Dictionary of packet definitions (grouped by category) **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                         |
| ---------------- | --------------------------------------------------- |
| `dict[str, Any]` | Filtered dictionary without button/relay categories |

Source code in `src/lifx/protocol/generator.py`

```python
def filter_button_relay_packets(packets: dict[str, Any]) -> dict[str, Any]:
    """Filter out button and relay category packets.

    Args:
        packets: Dictionary of packet definitions (grouped by category)

    Returns:
        Filtered dictionary without button/relay categories
    """
    return {
        category: category_packets
        for category, category_packets in packets.items()
        if category not in ("button", "relay")
    }
```

##### extract_packets_as_fields

```python
extract_packets_as_fields(
    packets: dict[str, Any], fields: dict[str, Any]
) -> dict[str, Any]
```

Extract packets that are used as field types in other structures.

| PARAMETER | DESCRIPTION                                                        |
| --------- | ------------------------------------------------------------------ |
| `packets` | Dictionary of packet definitions **TYPE:** `dict[str, Any]`        |
| `fields`  | Dictionary of field definitions to scan **TYPE:** `dict[str, Any]` |

| RETURNS          | DESCRIPTION                                                         |
| ---------------- | ------------------------------------------------------------------- |
| `dict[str, Any]` | Dictionary of packet definitions that are referenced as field types |

Source code in `src/lifx/protocol/generator.py`

```python
def extract_packets_as_fields(
    packets: dict[str, Any], fields: dict[str, Any]
) -> dict[str, Any]:
    """Extract packets that are used as field types in other structures.

    Args:
        packets: Dictionary of packet definitions
        fields: Dictionary of field definitions to scan

    Returns:
        Dictionary of packet definitions that are referenced as field types
    """
    packets_as_fields = {}

    # Flatten packets first
    flat_packets = {}
    for category, category_packets in packets.items():
        if isinstance(category_packets, dict):
            for packet_name, packet_def in category_packets.items():
                if isinstance(packet_def, dict) and "pkt_type" in packet_def:
                    flat_packets[packet_name] = packet_def

    # Scan all fields for references to packet types
    all_structures = {**fields}

    for struct_def in all_structures.values():
        if isinstance(struct_def, dict) and "fields" in struct_def:
            for field_item in struct_def["fields"]:
                if "type" in field_item:
                    field_type = field_item["type"]
                    base_type, _, is_nested = parse_field_type(field_type)

                    # Check if this references a packet
                    if is_nested and base_type in flat_packets:
                        packets_as_fields[base_type] = flat_packets[base_type]

    return packets_as_fields
```

##### main

```python
main() -> None
```

Main generator entry point.

Source code in `src/lifx/protocol/generator.py`

```python
def main() -> None:
    """Main generator entry point."""
    try:
        # Download and parse protocol from GitHub
        protocol = download_protocol()
    except Exception as e:
        print(f"Error: Failed to download protocol.yml: {e}", file=sys.stderr)
        sys.exit(1)

    # Extract sections
    enums = protocol.get("enums", {})
    fields = protocol.get("fields", {})
    compound_fields = protocol.get("compound_fields", {})
    unions = protocol.get("unions", {})
    packets = protocol.get("packets", {})

    # Filter out Button and Relay items (not relevant for light control)
    print("Filtering out Button and Relay items...")
    enums = filter_button_relay_items(enums)
    fields = filter_button_relay_items(fields)
    compound_fields = filter_button_relay_items(compound_fields)
    unions = filter_button_relay_items(unions)
    packets = filter_button_relay_packets(packets)

    # Apply local quirks to fix protocol issues
    print("Applying local protocol quirks...")
    enums, fields, compound_fields = apply_firmware_effect_enum_quirk(
        enums, fields, compound_fields
    )
    enums, packets = apply_multizone_application_request_quirk(enums, packets)
    fields = apply_tile_effect_parameter_quirk(fields)
    fields = apply_tile_state_device_quirk(fields)
    packets = apply_sensor_packet_quirks(packets)

    # Rebuild protocol dict with filtered items for validation
    filtered_protocol = {
        **protocol,
        "enums": enums,
        "fields": fields,
        "compound_fields": compound_fields,
        "unions": unions,
        "packets": packets,
    }

    # Validate filtered protocol specification
    print("Validating protocol specification...")
    validation_errors = validate_protocol_spec(filtered_protocol)
    if validation_errors:
        print("Validation failed with the following errors:", file=sys.stderr)
        for error in validation_errors:
            print(f"  - {error}", file=sys.stderr)
        sys.exit(1)
    print("Validation passed!")

    # Extract packets that are used as field types (e.g., DeviceStateVersion)
    packets_as_fields = extract_packets_as_fields(packets, fields)

    print(f"Found {len(unions)} unions")
    print(
        f"Found {len(packets_as_fields)} packets used as field types: {list(packets_as_fields.keys())}"
    )

    # Determine output directory
    project_root = Path(__file__).parent.parent.parent.parent
    protocol_dir = project_root / "src" / "lifx" / "protocol"

    # Generate protocol_types.py (avoid conflict with Python's types module)
    types_code = generate_types_file(
        enums, fields, compound_fields, unions, packets_as_fields
    )
    types_file = protocol_dir / "protocol_types.py"
    with open(types_file, "w") as f:
        f.write(types_code)
    print(f"Generated {types_file}")

    # Generate packets.py
    packets_code = generate_packets_file(
        packets, fields, compound_fields, unions, packets_as_fields, enums
    )
    packets_file = protocol_dir / "packets.py"
    with open(packets_file, "w") as f:
        f.write(packets_code)
    print(f"Generated {packets_file}")
```

## Examples

### Working with Serial Numbers

The `Serial` dataclass provides type-safe, immutable serial number handling:

```python
from lifx.protocol.models import Serial

# Create from string (accepts hex with or without separators)
serial = Serial.from_string("d073d5123456")
serial = Serial.from_string("d0:73:d5:12:34:56")  # Also works

# Convert between formats
protocol_bytes = serial.to_protocol()  # 8 bytes with padding
serial_string = serial.to_string()     # "d073d5123456"
serial_bytes = serial.value            # 6 bytes (immutable/frozen)

# Create from protocol format (8 bytes)
serial = Serial.from_protocol(b"\xd0\x73\xd5\x12\x34\x56\x00\x00")
print(serial)  # "d073d5123456"

# String representations
print(str(serial))   # "d073d5123456"
print(repr(serial))  # "Serial('d073d5123456')"
```

### Using Protocol Packets Directly

```python
from lifx.network.connection import DeviceConnection
from lifx.protocol.packets import LightSetColor, LightGet, LightState
from lifx.protocol.protocol_types import LightHsbk
from lifx.protocol.models import Serial


async def main():
    serial = Serial.from_string("d073d5123456")

    async with DeviceConnection(serial.to_string(), "192.168.1.100") as conn:
        # Create a packet
        packet = LightSetColor(
            reserved=0,
            color=LightHsbk(
                hue=240 * 182, saturation=65535, brightness=32768, kelvin=3500
            ),
            duration=1000,  # milliseconds
        )

        # Send without waiting for response
        await conn.send_packet(packet)

        # Request with response
        response = await conn.request_response(LightGet(), LightState)
        print(f"Hue: {response.color.hue / 182}")
```

### Binary Serialization

```python
from lifx.protocol.packets import DeviceSetLabel
from lifx.protocol.serializer import Serializer

# Create packet
packet = DeviceSetLabel(label=b"Kitchen Light\0" + b"\0" * 19)

# Serialize to bytes
data = packet.pack()
print(f"Packet size: {len(data)} bytes")

# Deserialize from bytes
unpacked = DeviceSetLabel.unpack(data)
print(f"Label: {unpacked.label.decode('utf-8').rstrip('\0')}")
```

### Protocol Header

```python
from lifx.protocol.header import LifxHeader
from lifx.protocol.models import Serial

# Create header with Serial
serial = Serial.from_string("d073d5123456")
header = LifxHeader(
    size=36,
    protocol=1024,
    addressable=True,
    tagged=False,
    origin=0,
    source=0x12345678,
    target=serial.to_protocol(),  # 8 bytes with padding
    reserved1=b"\x00" * 6,
    ack_required=False,
    res_required=True,
    sequence=42,
    reserved2=0,
    pkt_type=101,  # LightGet
    reserved3=0,
)

# Serialize
data = header.pack()
print(f"Header: {data.hex()}")

# Deserialize
unpacked_header = LifxHeader.unpack(data)
print(f"Packet type: {unpacked_header.pkt_type}")
print(f"Target serial: {Serial.from_protocol(unpacked_header.target)}")
```

## Protocol Constants

### Message Types

Each packet class has a `PKT_TYPE` constant defining its protocol message type:

```python
from lifx.protocol.packets import LightSetColor, LightGet, DeviceGetLabel

print(f"LightSetColor type: {LightSetColor.PKT_TYPE}")  # 102
print(f"LightGet type: {LightGet.PKT_TYPE}")  # 101
print(f"DeviceGetLabel type: {DeviceGetLabel.PKT_TYPE}")  # 23
```

### Waveform Types

```python
from lifx.protocol.protocol_types import LightWaveform

# Available waveforms
LightWaveform.SAW
LightWaveform.SINE
LightWaveform.HALF_SINE
LightWaveform.TRIANGLE
LightWaveform.PULSE
```

### Firmware Effects

```python
from lifx.protocol.protocol_types import FirmwareEffect, Direction

# Available firmware effects (for multizone and matrix devices)
FirmwareEffect.OFF
FirmwareEffect.MOVE       # MultiZone only
FirmwareEffect.MORPH      # Tile/Matrix only
FirmwareEffect.FLAME      # Tile/Matrix only
FirmwareEffect.SKY        # Tile/Matrix only

# Direction for MOVE effects
Direction.FORWARD   # Move forward through zones
Direction.REVERSED  # Move backward through zones
```

## Product Registry

The product registry provides automatic device type detection and capability information:

### ProductInfo

```python
ProductInfo(
    pid: int,
    name: str,
    vendor: int,
    capabilities: int,
    temperature_range: TemperatureRange | None,
    min_ext_mz_firmware: int | None,
)
```

Information about a LIFX product.

| ATTRIBUTE             | DESCRIPTION                                                      |
| --------------------- | ---------------------------------------------------------------- |
| `pid`                 | Product ID **TYPE:** `int`                                       |
| `name`                | Product name **TYPE:** `str`                                     |
| `vendor`              | Vendor ID (always 1 for LIFX) **TYPE:** `int`                    |
| `capabilities`        | Bitfield of ProductCapability flags **TYPE:** `int`              |
| `temperature_range`   | Min/max color temperature in Kelvin **TYPE:** \`TemperatureRange |
| `min_ext_mz_firmware` | Minimum firmware version for extended multizone **TYPE:** \`int  |

| METHOD                        | DESCRIPTION                                                          |
| ----------------------------- | -------------------------------------------------------------------- |
| `has_capability`              | Check if product has a specific capability.                          |
| `supports_extended_multizone` | Check if extended multizone is supported for given firmware version. |

#### Attributes

##### has_color

```python
has_color: bool
```

Check if product supports color.

##### has_infrared

```python
has_infrared: bool
```

Check if product supports infrared.

##### has_multizone

```python
has_multizone: bool
```

Check if product supports multizone.

##### has_chain

```python
has_chain: bool
```

Check if product supports chaining.

##### has_matrix

```python
has_matrix: bool
```

Check if product supports matrix (2D grid).

##### has_relays

```python
has_relays: bool
```

Check if product has relays.

##### has_buttons

```python
has_buttons: bool
```

Check if product has buttons.

##### has_hev

```python
has_hev: bool
```

Check if product supports HEV.

##### has_extended_multizone

```python
has_extended_multizone: bool
```

Check if product supports extended multizone.

#### Functions

##### has_capability

```python
has_capability(capability: ProductCapability) -> bool
```

Check if product has a specific capability.

| PARAMETER    | DESCRIPTION                                       |
| ------------ | ------------------------------------------------- |
| `capability` | Capability to check **TYPE:** `ProductCapability` |

| RETURNS | DESCRIPTION                        |
| ------- | ---------------------------------- |
| `bool`  | True if product has the capability |

Source code in `src/lifx/products/registry.py`

```python
def has_capability(self, capability: ProductCapability) -> bool:
    """Check if product has a specific capability.

    Args:
        capability: Capability to check

    Returns:
        True if product has the capability
    """
    return bool(self.capabilities & capability)
```

##### supports_extended_multizone

```python
supports_extended_multizone(firmware_version: int | None = None) -> bool
```

Check if extended multizone is supported for given firmware version.

| PARAMETER          | DESCRIPTION                                          |
| ------------------ | ---------------------------------------------------- |
| `firmware_version` | Firmware version to check (optional) **TYPE:** \`int |

| RETURNS | DESCRIPTION                             |
| ------- | --------------------------------------- |
| `bool`  | True if extended multizone is supported |

Source code in `src/lifx/products/registry.py`

```python
def supports_extended_multizone(self, firmware_version: int | None = None) -> bool:
    """Check if extended multizone is supported for given firmware version.

    Args:
        firmware_version: Firmware version to check (optional)

    Returns:
        True if extended multizone is supported
    """
    if not self.has_extended_multizone:
        return False
    if self.min_ext_mz_firmware is None:
        return True
    if firmware_version is None:
        return True
    return firmware_version >= self.min_ext_mz_firmware
```

### ProductCapability

Bases: `IntEnum`

Product capability flags.

### Using the Product Registry

```python
from lifx.products import get_product, get_device_class_name

# Get product info by product ID
product_info = get_product(product_id=27)

# Get appropriate device class name
class_name = get_device_class_name(product_id=27)  # Returns "Light", "MultiZoneLight", etc.
```

## Protocol Updates

To update to the latest LIFX protocol:

1. Download the latest `protocol.yml` from the [LIFX public-protocol repository](https://github.com/LIFX/public-protocol/blob/main/protocol.yml)
1. Save it to the project root
1. Run the generator: `uv run python -m lifx.protocol.generator`
1. Review the generated code changes
1. Run tests: `uv run pytest`

The generator will automatically:

- Parse the YAML specification
- Generate Python dataclasses for all packet types
- Create enums for protocol constants
- Add serialization/deserialization methods
- Filter out Button/Relay messages (out of scope)

# Exceptions

lifx-async defines a hierarchy of exceptions for different error conditions. All exceptions inherit from `LifxError`.

## Exception Hierarchy

```text
LifxError (base exception)
 LifxConnectionError
 LifxTimeoutError
 LifxDeviceNotFoundError
 LifxProtocolError
 LifxNetworkError
 LifxUnsupportedCommandError
```

## Base Exception

### LifxError

Bases: `Exception`

Base exception for all lifx-async errors.

## Connection Exceptions

### LifxConnectionError

Bases: `LifxError`

Raised when there's a connection error.

### LifxTimeoutError

Bases: `LifxError`

Raised when an operation times out.

### LifxDeviceNotFoundError

Bases: `LifxError`

Raised when a device cannot be found or reached.

## Protocol Exceptions

### LifxProtocolError

Bases: `LifxError`

Raised when there's an error with protocol parsing or validation.

## Network Exceptions

### LifxNetworkError

Bases: `LifxError`

Raised when there's a network-level error.

## Command Exceptions

### LifxUnsupportedCommandError

Bases: `LifxError`

Raised when a device doesn't support the requested command.

## Examples

### Basic Exception Handling

```python
from lifx import discover, LifxError, LifxTimeoutError


async def main():
    try:
        async with discover(timeout=5.0) as group:
            await group.set_color(Colors.BLUE)
    except LifxTimeoutError:
        print("Discovery timed out - no devices found")
    except LifxError as e:
        print(f"LIFX error: {e}")
```

### Specific Exception Handling

```python
from lifx import Light, LifxConnectionError, LifxUnsupportedCommandError


async def main():
    try:
        async with await Light.from_ip("192.168.1.100") as light:
            await light.set_color(Colors.BLUE)
    except LifxConnectionError:
        print("Failed to connect to device")
    except LifxUnsupportedCommandError as e:
        print(f"Device doesn't support this operation: {e}")
```

### Catching All LIFX Exceptions

```python
from lifx import find_lights, LifxError


async def safe_control():
    try:
        async with find_lights() as lights:
            for light in lights:
                await light.set_brightness(0.8)
    except LifxError as e:
        # Catches all LIFX-specific exceptions
        print(f"LIFX operation failed: {e}")
        # Log, retry, or handle gracefully
```

### Timeout Handling

```python
from lifx import DeviceConnection, LifxTimeoutError
from lifx.protocol.packets import LightGet, LightState


async def main():
    try:
        async with DeviceConnection(serial, ip, timeout=2.0) as conn:
            response = await conn.request_response(LightGet(), LightState)
    except LifxTimeoutError:
        print("Device did not respond in time")
        # Device may be offline or unreachable
```

### Protocol Error Handling

```python
from lifx import Light, LifxProtocolError


async def main():
    try:
        async with await Light.from_ip("192.168.1.100") as light:
            await light.set_color(Colors.BLUE)
    except LifxProtocolError:
        print("Protocol-level error occurred")
```

### Unsupported Command Handling

```python
from lifx import find_lights, LifxUnsupportedCommandError


async def main():
    async with find_lights() as lights:
        for light in lights:
            try:
                # Some devices may not support all features
                await light.set_infrared(0.5)
            except LifxUnsupportedCommandError:
                print(f"{light.label} doesn't support this command")
                continue
```

### Device Not Found Handling

```python
from lifx import find_by_serial, LifxDeviceNotFoundError


async def main():
    try:
        device = await find_by_serial("d073d5123456", timeout=3.0)
        if device:
            async with device:
                await device.set_power(True)
    except LifxDeviceNotFoundError:
        print("Device not found on the network")
```

## Best Practices

### Always Catch Specific Exceptions First

```python
#  Good - specific to general
try:
    await light.set_color(Colors.BLUE)
except LifxTimeoutError:
    print("Timeout")
except LifxConnectionError:
    print("Connection failed")
except LifxError:
    print("Other LIFX error")

#  Bad - general exception catches everything
try:
    await light.set_color(Colors.BLUE)
except LifxError:
    print("Error")  # Can't distinguish timeout from other errors
```

### Use Context Managers for Cleanup

```python
#  Good - resources cleaned up even on exception
try:
    async with await Light.from_ip(ip) as light:
        await light.set_color(Colors.BLUE)
except LifxError:
    print("Error occurred but connection was closed properly")

#  Bad - connection may leak on exception
light = Light(serial, ip)
await light.connect()
try:
    await light.set_color(Colors.BLUE)
except LifxError:
    pass  # Connection not closed!
finally:
    await light.disconnect()
```

### Log Exceptions for Debugging

```python
import logging
from lifx import discover, DeviceGroup, LifxError

logger = logging.getLogger(__name__)


async def main():
    try:
        devices = []
        async for device in discover():
            devices.append(device)
        group = DeviceGroup(devices)
        await group.set_color(Colors.BLUE)
    except LifxError as e:
        logger.exception("Failed to control lights")
        # Logs full traceback for debugging
```

### Graceful Degradation

```python
from lifx import find_lights, LifxError


async def main():
    async with find_lights() as lights:
        for light in lights:
            try:
                await light.set_color(Colors.BLUE)
            except LifxError as e:
                # Continue with other lights even if one fails
                print(f"Failed to control {light.label}: {e}")
                continue
```

## Common Error Scenarios

### Device Not Responding

```python
# Usually raises: LifxTimeoutError
async with await Light.from_ip("192.168.1.100", timeout=5.0) as light:
    await light.set_color(Colors.BLUE)
```

Causes:

- Device is offline or unpowered
- Wrong IP address
- Network connectivity issues
- Firewall blocking UDP port 56700

### Device Not Found During Discovery

```python
# May raise: LifxTimeoutError or LifxDeviceNotFoundError
async with discover(timeout=3.0) as group:
    if not group.devices:
        print("No devices found")
```

Causes:

- No LIFX devices on the network
- Devices on different subnet
- Discovery timeout too short
- Network doesn't allow broadcast packets

### Connection Failed

```python
# Raises: LifxConnectionError
async with DeviceConnection(serial, ip) as conn:
    await conn.send_packet(packet)
```

Causes:

- Network unreachable
- Device offline
- Port blocked by firewall
- Invalid IP address

### Unsupported Command

```python
# Raises: LifxUnsupportedCommandError
async with await Light.from_ip(ip) as light:
    await light.set_color_zones(0, 5, Colors.RED)  # Not a multizone device
```

Causes:

- Attempting zone control on non-multizone device
- Using tile operations on non-tile device
- Feature not supported by firmware version
- Sending Light commands to non-light devices (e.g., switches)

### Protocol Error

```python
# Raises: LifxProtocolError
```

Causes:

- Invalid packet format received
- Protocol parsing failure
- Corrupted message data
- Unexpected packet type
# Migration

# Effect API Changes (v4.3.0)

This document describes changes to the effect handling API introduced in version 4.3.0.

## Overview

The effect handling API has been simplified and unified to provide a cleaner, more consistent interface:

1. **Unified Effect Enum**: `MultiZoneEffectType` and `TileEffectType` merged into `FirmwareEffect`
1. **Direction Enum**: New `Direction` enum for MOVE effect direction control
1. **Simplified Methods**: Effect methods renamed for clarity (`set_effect`, `get_effect`)
1. **Unified Application Request**: `MultiZoneExtendedApplicationRequest` removed in favor of single `MultiZoneApplicationRequest`

## Changes

### 1. Effect Type Enums Consolidated

**Before:**

```python
from lifx import MultiZoneEffectType, TileEffectType

# MultiZone effects
effect = MultiZoneEffectType.MOVE

# Tile effects
effect = TileEffectType.MORPH
```

**After:**

```python
from lifx import FirmwareEffect

# All firmware effects (multizone and matrix)
effect = FirmwareEffect.MOVE   # MultiZone
effect = FirmwareEffect.MORPH  # Matrix/Tile
effect = FirmwareEffect.FLAME  # Matrix/Tile
effect = FirmwareEffect.SKY    # Matrix/Tile
```

### 2. Direction Control for MOVE Effects

**Before:**

```python
# Direction was embedded in specialized methods
await light.set_move_effect(speed=5.0, direction=1)  # 0=reversed, 1=forward
```

**After:**

```python
from lifx import FirmwareEffect, Direction

# Direction is a proper enum with named values
await light.set_effect(
    effect_type=FirmwareEffect.MOVE,
    speed=5.0,
    direction=Direction.FORWARD,  # or Direction.REVERSED
)

# Direction can also be accessed as a property on MultiZoneEffect
effect = await light.get_effect()
if effect.effect_type == FirmwareEffect.MOVE:
    print(f"Direction: {effect.direction.name}")  # FORWARD or REVERSED
```

### 3. Method Naming Simplified

**Before:**

```python
# MultiZone devices
await multizone_light.set_multizone_effect(...)
effect = await multizone_light.get_multizone_effect()

# Tile/Matrix devices
await matrix_light.set_tile_effect(...)
effect = await matrix_light.get_tile_effect()

# Specialized MOVE method
await multizone_light.set_move_effect(speed=5.0, direction=1)
```

**After:**

```python
# Unified naming across all device types
await multizone_light.set_effect(effect_type=FirmwareEffect.MOVE, ...)
effect = await multizone_light.get_effect()

await matrix_light.set_effect(effect_type=FirmwareEffect.FLAME, ...)
effect = await matrix_light.get_effect()

# No more specialized methods - use set_effect with Direction enum
```

### 4. Application Request Enum Unified

**Before:**

```python
from lifx import MultiZoneApplicationRequest, MultiZoneExtendedApplicationRequest

# Different enums for different packet types
await light.set_color_zones(..., apply=MultiZoneApplicationRequest.APPLY)
await light.set_extended_color_zones(..., apply=MultiZoneExtendedApplicationRequest.APPLY)
```

**After:**

```python
from lifx import MultiZoneApplicationRequest

# Single enum for all multizone application control
await light.set_color_zones(..., apply=MultiZoneApplicationRequest.APPLY)
await light.set_extended_color_zones(..., apply=MultiZoneApplicationRequest.APPLY)
```

## Migration Guide

### Updating MultiZone Effect Code

**Old Code:**

```python
from lifx import MultiZoneLight, MultiZoneEffectType

async with await MultiZoneLight.from_ip("192.168.1.100") as light:
    # Old API
    await light.set_multizone_effect(
        effect_type=MultiZoneEffectType.MOVE,
        speed=5.0,
    )

    # Or using specialized method
    await light.set_move_effect(speed=5.0, direction=1)

    effect = await light.get_multizone_effect()
```

**New Code:**

```python
from lifx import MultiZoneLight, FirmwareEffect, Direction

async with await MultiZoneLight.from_ip("192.168.1.100") as light:
    # New unified API
    await light.set_effect(
        effect_type=FirmwareEffect.MOVE,
        speed=5.0,
        direction=Direction.FORWARD,
    )

    effect = await light.get_effect()
    if effect.effect_type == FirmwareEffect.MOVE:
        print(f"Direction: {effect.direction.name}")
```

### Updating Matrix/Tile Effect Code

**Old Code:**

```python
from lifx import MatrixLight, TileEffectType

async with await MatrixLight.from_ip("192.168.1.100") as light:
    # Old API
    await light.set_tile_effect(
        effect_type=TileEffectType.FLAME,
        speed=5.0,
    )

    effect = await light.get_tile_effect()
```

**New Code:**

```python
from lifx import MatrixLight, FirmwareEffect

async with await MatrixLight.from_ip("192.168.1.100") as light:
    # New unified API
    await light.set_effect(
        effect_type=FirmwareEffect.FLAME,
        speed=5.0,
    )

    effect = await light.get_effect()
```

### Updating Application Request Code

**Old Code:**

```python
from lifx import MultiZoneApplicationRequest, MultiZoneExtendedApplicationRequest

# Standard zones
await light.set_color_zones(
    start=0,
    end=9,
    color=color,
    apply=MultiZoneApplicationRequest.APPLY,
)

# Extended zones
await light.set_extended_color_zones(
    zone_index=0,
    colors=colors,
    apply=MultiZoneExtendedApplicationRequest.APPLY,
)
```

**New Code:**

```python
from lifx import MultiZoneApplicationRequest

# Standard zones
await light.set_color_zones(
    start=0,
    end=9,
    color=color,
    apply=MultiZoneApplicationRequest.APPLY,
)

# Extended zones
await light.set_extended_color_zones(
    zone_index=0,
    colors=colors,
    apply=MultiZoneApplicationRequest.APPLY,  # Same enum
)
```

## Summary of Removals

The following have been **removed** in v4.3.0:

- `lifx.protocol.protocol_types.MultiZoneEffectType`  use `FirmwareEffect`
- `lifx.protocol.protocol_types.TileEffectType`  use `FirmwareEffect`
- `lifx.protocol.protocol_types.MultiZoneExtendedApplicationRequest`  use `MultiZoneApplicationRequest`
- `MultiZoneLight.set_multizone_effect()`  use `set_effect()`
- `MultiZoneLight.get_multizone_effect()`  use `get_effect()`
- `MultiZoneLight.set_move_effect()`  use `set_effect(effect_type=FirmwareEffect.MOVE, direction=Direction.FORWARD)`
- `MultiZoneLight.get_move_effect()`  use `get_effect()` and access `effect.direction`
- `MatrixLight.set_tile_effect()`  use `set_effect()`
- `MatrixLight.get_tile_effect()`  use `get_effect()`

## Benefits

These changes provide several improvements:

1. **Consistency**: All firmware effects use the same enum and method names
1. **Type Safety**: Direction is now a proper enum instead of integer values (0/1)
1. **Discoverability**: Cleaner API with fewer specialized methods
1. **Simplicity**: One enum for application requests instead of two identical ones
1. **Maintainability**: Easier to extend with new effect types in the future
# Additional Resources

# Frequently Asked Questions

## General

### What is lifx-async?

lifx-async is a modern, async Python library for controlling LIFX smart lighting devices over your local network. It provides a type-safe, high-performance interface for device discovery, color control, effects, and more.

### Which devices are supported?

lifx-async supports all LIFX lighting products, including:

- **Light**: A19, BR30, Downlight, etc.
- **HEV**: Clean
- **Infrared**: Nightvision
- **Multizone**: LIFX Z, Beam, Neon, String
- **Matrix**: LIFX Tile, Candle, Ceiling, Path, Spot

LIFX Switches are out of scope for this lighting-focused library and are therefore not supported.

### Do I need cloud access?

No! lifx-async communicates directly with devices over your local network. No cloud connection or LIFX account required.

### What Python versions are supported?

Python 3.11 or higher is required.

## Installation & Setup

### How do I install lifx-async?

```bash
# Using uv (recommended)
uv pip install lifx-async

# Or using pip
pip install lifx-async
```

See the [Installation Guide](https://djelibeybi.github.io/lifx-async/getting-started/installation/index.md) for more options.

### Why can't discovery find my devices?

Common issues:

1. **Same Network**: Ensure your computer and LIFX devices are on the same network
1. **Firewall**: Check firewall settings allow UDP broadcasts
1. **Timeout**: Try increasing timeout: `discover(timeout=10.0)`
1. **Router**: Some routers block broadcast packets - try direct connection

**Workaround** - Connect directly using IP and serial:

```python
async with await Light(serial="d073d5000000",  ip="192.168.1.100") as light:
    await light.set_color(Colors.BLUE)
```

### Do I need to know my device's IP address?

No! Discovery finds devices automatically:

```python
from lifx import discover

async for device in discover():
    print(f"Found {device.serial} at {device.ip}")
```

If you do know the IP, you can connect directly for faster connection.

## Usage

### How do I control multiple lights at once?

Use `DeviceGroup` for batch operations:

```python
from lifx import discover, DeviceGroup, Colors

devices = []
async for device in discover():
    devices.append(device)
group = DeviceGroup(devices)

# All lights at once
await group.set_power(True)
await group.set_color(Colors.BLUE)
await group.set_brightness(0.5)
```

### How do I set a specific RGB color?

Use `HSBK.from_rgb()`:

```python
from lifx import HSBK

# Create color from RGB (0-255)
purple = HSBK.from_rgb(128, 0, 128)
await light.set_color(purple)

# Or use hex
color = HSBK.from_rgb(0xFF, 0x00, 0xFF)
```

### Can I control lights concurrently?

Yes! Use `asyncio.gather()`:

```python
import asyncio

# Control multiple lights in parallel
await asyncio.gather(
    light1.set_color(Colors.RED),
    light2.set_color(Colors.GREEN),
    light3.set_color(Colors.BLUE),
)
```

### How do I find a specific device?

By label:

```python
lights = await find_lights(label_contains="Bedroom")
```

By serial number:

```python
device = await find_by_serial("d073d5123456")
```

### What are the available color presets?

See [`Colors`](https://djelibeybi.github.io/lifx-async/api/colors/#lifx.color.Colors) for the complete list:

```python
from lifx import Colors

# Primary colors
Colors.RED, Colors.GREEN, Colors.BLUE

# White variants
Colors.WARM_WHITE, Colors.COOL_WHITE, Colors.DAYLIGHT

# Pastels
Colors.PASTEL_BLUE, Colors.PASTEL_PINK
```

### How do I create smooth transitions?

Use the `duration` parameter (in seconds):

```python
# Fade to blue over 2 seconds
await light.set_color(Colors.BLUE, duration=2.0)

# Fade brightness over 3 seconds
await light.set_brightness(0.5, duration=3.0)
```

### Can I create pulsing effects?

Yes! Use the `pulse()` or `breathe()` methods:

```python
# Pulse red 5 times
await light.pulse(Colors.RED, period=1.0, cycles=5)

# Breathe blue infinitely
await light.breathe(Colors.BLUE, period=2.0, cycles=0)
```

## Performance

### Is lifx-async fast?

Yes! Key performance features:

- **Async I/O**: Non-blocking operations
- **Lazy Connections**: Auto-open on first request, reuse for all operations
- **Non-volatile State Caching**: Reduces redundant network requests
- **Concurrent Devices**: Operations on different devices run in parallel
- **Request Serialization**: Prevents response mixing on same connection

### How is state stored?

Selected device properties that are considered non-volatile, including product ID and firmware version are cached after they are fetched for the first time. Properties return `None` if no value has been fetched yet:

```python
# Check cached semi-static state (label, version, firmware, etc.)
label = light.label
if label:
    # Use cached label value
    print(f"Cached label: {label}")
else:
    # No cached value, fetch from device
    label = await light.get_label()
```

**Note**: Volatile state (power, color, hev_cycle, zones, tile_colors) is **not** cached and must always be fetched using `get_*()` methods.

To always get fresh data:

```python
# Use get_* methods to always fetch from device
# get_color() returns all three values in one call
color, power, label = await light.get_color()  # Returns (color, power, label)

# Or fetch specific info separately
version = await light.get_version()  # Get firmware and hardware version
```

If you use a light as an async context manager, it will automatically populate all of the non-volatile properties:

```python
async with Light(serial="d073d5000000",  ip="192.168.1.100") as light:
    print(f"{light.label} is a {light.model} and is in the {light.group} group.")
```

### Can I control devices from multiple computers?

Yes! lifx-async doesn't require exclusive access. Multiple instances (even on different computers) can control the same devices.

## Troubleshooting

### I get `LifxTimeoutError`

Common causes:

1. **Device offline**: Check device is powered and connected
1. **Network issues**: Verify network connectivity
1. **Firewall**: Ensure UDP port 56700 is open
1. **Timeout too short**: Increase timeout value

### Connection fails with `LifxConnectionError`

Try:

1. **Restart device**: Power cycle the LIFX device
1. **Check IP**: Verify IP address is correct
1. **Firewall**: Check firewall allows UDP 56700
1. **Network**: Ensure same subnet

### Effects don't work as expected

Make sure you're using the correct duration/period values:

```python
# Period is in seconds
await light.pulse(Colors.RED, period=1.0, cycles=5)

# Duration is in seconds (milliseconds * 1000)
await light.set_color(Colors.BLUE, duration=2.0)
```

### Type checker errors

lifx-async is fully type-hinted. If you get type errors:

1. Ensure you're using Python 3.11+
1. Update your type checker (Pyright, mypy)
1. Check you're using correct types

## Development

### How do I contribute?

Quick start:

1. Fork the repository
1. Create a feature branch
1. Make your changes with tests
1. Submit a pull request

### How do I run tests?

```bash
uv run --frozen pytest
```

### How do I generate protocol code?

```bash
uv run python -m lifx.protocol.generator
```

This downloads the latest `protocol.yml` from LIFX and regenerates Python code.

### Where is the protocol specification?

The official LIFX protocol specification is at: https://github.com/LIFX/public-protocol/blob/main/protocol.yml

lifx-async automatically downloads and generates Python code from this specification.

## Advanced

### Can I use lifx-async without async?

No.

### How do I access low-level protocol?

```python
from lifx.protocol.packets import Light
from lifx.protocol.protocol_types import HSBK

# Create a packet directly
packet = Light.SetColor(
    color=HSBK(hue=180, saturation=1.0, brightness=0.8, kelvin=3500), duration=1.0
)

# Send via connection
async with DeviceConnection(serial, ip) as conn:
    reply = await conn.request(packet)
```

### How does connection management work?

Each device owns its own connection that opens lazily on first request. The connection is reused for all subsequent operations on that device. Connections are automatically closed when you exit the device's context manager, or you can manually call `await device.connection.close()`.

## Still have questions?

- **Documentation**: Browse the [API Reference](https://djelibeybi.github.io/lifx-async/api/index.md)
- **Issues**: Report bugs on [GitHub Issues](https://github.com/Djelibeybi/lifx-async/issues)
- **Discussions**: Ask questions in [GitHub Discussions](https://github.com/Djelibeybi/lifx-async/discussions)

# CHANGELOG

## v4.7.5 (2025-12-16)

### Bug Fixes

- **devices**: Override set_color in CeilingLight to track component state ([`0d20563`](https://github.com/Djelibeybi/lifx-async/commit/0d20563c170363229ab17620398283bd85ee7829))

## v4.7.4 (2025-12-16)

### Performance Improvements

- **devices**: Reduce get_all_tile_colors calls in CeilingLight ([`3936158`](https://github.com/Djelibeybi/lifx-async/commit/39361582856fcde57f30f052b8286f0bbb695f67))

## v4.7.3 (2025-12-16)

### Bug Fixes

- **devices**: Capture component colors before set_power turns off light ([`a99abee`](https://github.com/Djelibeybi/lifx-async/commit/a99abeeeb4f6cad1e49410204b8e7a567765b3ed))

## v4.7.2 (2025-12-16)

### Bug Fixes

- **api**: Close device connections in DeviceGroup context manager ([`054bfee`](https://github.com/Djelibeybi/lifx-async/commit/054bfee88e548d38c1e7c49277d3bb334b55adcc))

### Documentation

- **api**: Add dataclass documentation and improve navigation ([`c859c87`](https://github.com/Djelibeybi/lifx-async/commit/c859c8711335bdf5357412ccf4364075ce0df535))

## v4.7.1 (2025-12-13)

### Bug Fixes

- **devices**: Add length parameter to copy_frame_buffer() ([`6a74690`](https://github.com/Djelibeybi/lifx-async/commit/6a746904665d38545e534829c2c690a61e48da54))

## v4.7.0 (2025-12-13)

### Features

- **devices**: Add fast parameter to set_extended_color_zones() ([`0276fca`](https://github.com/Djelibeybi/lifx-async/commit/0276fca9b18e9f78441c843880ef52b4c79dac7b))

## v4.6.1 (2025-12-12)

### Bug Fixes

- **devices**: Check for power and brightness for Ceiling components ([`bd1b92f`](https://github.com/Djelibeybi/lifx-async/commit/bd1b92fb76c0e239c36dda09cca66035b527965a))

## v4.6.0 (2025-12-11)

### Features

- **devices**: Add CeilingLightState dataclass for ceiling component state ([`607f15c`](https://github.com/Djelibeybi/lifx-async/commit/607f15c3ed3508a883523ecee940959806d49400))

## v4.5.1 (2025-12-11)

### Bug Fixes

- **devices**: Export CeilingLight add add user guide and API documentation ([`10e0089`](https://github.com/Djelibeybi/lifx-async/commit/10e008983ffd8b233dd2427a4a4f64661c8f14bd))

## v4.5.0 (2025-12-08)

### Features

- **devices**: Add CeilingLight with independent uplight/downlight component control ([`95fc5a6`](https://github.com/Djelibeybi/lifx-async/commit/95fc5a68c598232f5c710ad5d67f3647ba89d720))

## v4.4.1 (2025-12-03)

### Bug Fixes

- **theme**: Prevent color displacement in multi-tile matrix theme application ([`ca936ec`](https://github.com/Djelibeybi/lifx-async/commit/ca936ec8df84fc42803182ae9898d243e017c5a3))

## v4.4.0 (2025-11-29)

### Features

- **devices**: Add factory pattern with automatic type detection and state management ([`4374248`](https://github.com/Djelibeybi/lifx-async/commit/4374248bb46cb5af1cf303866ad82b6692bb8932))

## v4.3.9 (2025-11-27)

### Bug Fixes

- **network**: Propagate timeout from request() to internal methods ([`b35ebea`](https://github.com/Djelibeybi/lifx-async/commit/b35ebea46120bfd4ad9ce149f5e25125d3694b30))

## v4.3.8 (2025-11-25)

### Bug Fixes

- **network**: Raise exception on StateUnhandled instead of returning False ([`5ca3e8a`](https://github.com/Djelibeybi/lifx-async/commit/5ca3e8abcde0ec0eefe77645aeb0a2e63b18418c))

## v4.3.7 (2025-11-25)

### Bug Fixes

- **devices**: Raise LifxUnsupportedCommandError on StateUnhandled responses ([`ec142cf`](https://github.com/Djelibeybi/lifx-async/commit/ec142cf0130847d65d4b9cd825575658936ef823))

## v4.3.6 (2025-11-25)

### Bug Fixes

- **network**: Return StateUnhandled packets instead of raising exception ([`f27e848`](https://github.com/Djelibeybi/lifx-async/commit/f27e84849656a84e7e120d66d1dba7bbabe18ed5))

## v4.3.5 (2025-11-22)

### Bug Fixes

- **devices**: Allow MatrixEffect without palette ([`fb31df5`](https://github.com/Djelibeybi/lifx-async/commit/fb31df51b1af9d8c7c2f573ec9619566b4f7393b))

## v4.3.4 (2025-11-22)

### Bug Fixes

- **network**: Exclude retry sleep time from timeout budget ([`312d7a7`](https://github.com/Djelibeybi/lifx-async/commit/312d7a7e2561de7d2bbf142c8a521daca31651bb))

## v4.3.3 (2025-11-22)

### Bug Fixes

- Give MatrixLight.get64() some default parameters ([`a69a49c`](https://github.com/Djelibeybi/lifx-async/commit/a69a49c93488c79c8c3be58a9304fd01b4b12231))
- **themes**: Apply theme colors to all zones via proper canvas interpolation ([`f1628c4`](https://github.com/Djelibeybi/lifx-async/commit/f1628c4a071d257d7db79a7945d1516c783d8d52))

## v4.3.2 (2025-11-22)

### Bug Fixes

- **effects**: Add name property to LIFXEffect and subclasses ([`deb8a54`](https://github.com/Djelibeybi/lifx-async/commit/deb8a54f674d2d4cd9b8dce519dc6ca8678e048a))

## v4.3.1 (2025-11-22)

### Bug Fixes

- Actually rename the matrix methods ([`061aaa7`](https://github.com/Djelibeybi/lifx-async/commit/061aaa7c1931b2fc606363d5acc14ec7fa1b039b))

## v4.3.0 (2025-11-22)

### Features

- **effects**: Unify effect enums and simplify API ([`df1c3c8`](https://github.com/Djelibeybi/lifx-async/commit/df1c3c8ba63dbf6cbfa5b973cdfe648c100a1371))

## v4.2.1 (2025-11-21)

### Bug Fixes

- Get_wifi_info now returns signal and rssi correctly ([`6db03b3`](https://github.com/Djelibeybi/lifx-async/commit/6db03b334a36de6faa1b9749f545f3775a01d7dd))

## v4.2.0 (2025-11-21)

### Documentation

- **api**: Remove obsolete reference to MessageBuilder ([`9847948`](https://github.com/Djelibeybi/lifx-async/commit/98479483d00c875e324d5a7dcd88bf08f11f73cb))

### Features

- **devices**: Add ambient light sensor support ([`75f0673`](https://github.com/Djelibeybi/lifx-async/commit/75f0673dc9b6e8bce30a5b5958215a600925357e))

## v4.1.0 (2025-11-20)

### Features

- **network**: Replace polling architecture with event-driven background receiver ([`9862eac`](https://github.com/Djelibeybi/lifx-async/commit/9862eac1eea162fa66bf19d277a3772de7c70db1))

## v4.0.2 (2025-11-19)

### Bug Fixes

- Product registry generation ([`2742a18`](https://github.com/Djelibeybi/lifx-async/commit/2742a184f805ba3863c376670c323f9d078766f3))

## v4.0.1 (2025-11-18)

### Bug Fixes

- **devices**: Prevent connection leaks in temporary device queries ([`0ee8d0c`](https://github.com/Djelibeybi/lifx-async/commit/0ee8d0cc211aa73eac32ebbe6516aa70e7158f29))

## v4.0.0 (2025-11-18)

### Features

- **devices**: Replace TileDevice with MatrixLight implementation ([`1b8bc39`](https://github.com/Djelibeybi/lifx-async/commit/1b8bc397495443ad857c96052de2694a4b350011))

### Breaking Changes

- **devices**: TileDevice class has been removed and replaced with MatrixLight

## v3.1.0 (2025-11-17)

### Features

- Remove connection pool in favor of lazy device-owned connections ([`11b3cb2`](https://github.com/Djelibeybi/lifx-async/commit/11b3cb24f51f3066cacc94d5ec2b2adb1bdf5ce1))

## v3.0.1 (2025-11-17)

### Bug Fixes

- Get_power() now returns an integer value not a boolean ([`3644bb9`](https://github.com/Djelibeybi/lifx-async/commit/3644bb9baf56593a8f4dceaac19689b3a0152384))

## v3.0.0 (2025-11-16)

### Features

- Convert discovery methods to async generators ([`0d41880`](https://github.com/Djelibeybi/lifx-async/commit/0d418800729b45869057b1f4dd86b4ceb7ef2fbe))
- Replace event-based request/response with async generators ([`fa50734`](https://github.com/Djelibeybi/lifx-async/commit/fa50734057d40ac968f2edb4ff7d6634fe5be798))

### Breaking Changes

- Internal connection architecture completely refactored

## v2.2.2 (2025-11-14)

### Bug Fixes

- **devices**: Replace hardcoded timeout and retry values with constants ([`989afe2`](https://github.com/Djelibeybi/lifx-async/commit/989afe20f116d287215ec7bf5e78baa766a5ac63))

## v2.2.1 (2025-11-14)

### Bug Fixes

- **network**: Resolve race condition in concurrent request handling ([`8bb7bc6`](https://github.com/Djelibeybi/lifx-async/commit/8bb7bc68bf1c8baad0c9d96ba3034e40176f50e3))

## v2.2.0 (2025-11-14)

### Features

- **network**: Add jitter to backoff and consolidate retry logic ([`0dfb1a2`](https://github.com/Djelibeybi/lifx-async/commit/0dfb1a2847330270c635f91c9b63577c7aad2598))

## v2.1.0 (2025-11-14)

### Features

- Add mac_address property to Device class ([`bd101a0`](https://github.com/Djelibeybi/lifx-async/commit/bd101a0af3eec021304d39de699e8ea0e59934c1))

## v2.0.0 (2025-11-14)

### Refactoring

- Simplify state caching and remove TTL system ([`fd15587`](https://github.com/Djelibeybi/lifx-async/commit/fd155873e9d9b56cdfa38cae3ec9bbdc9bfe283b))

## v1.3.1 (2025-11-12)

### Bug Fixes

- Add Theme, ThemeLibrary, get_theme to main lifx package exports ([`6b41bb8`](https://github.com/Djelibeybi/lifx-async/commit/6b41bb8b052a0447d5a667681eb3bedcfd1e7218))

### Documentation

- Add mkdocs-llmstxt to create llms.txt and llms-full.txt ([`4dd378c`](https://github.com/Djelibeybi/lifx-async/commit/4dd378cacf4e9904dc64e2e59936f4a9e325fc47))
- Remove effects release notes ([`2fdabc0`](https://github.com/Djelibeybi/lifx-async/commit/2fdabc04a3abba507bbee3f93721a8814296e269))

## v1.3.0 (2025-11-10)

### Features

- Add software effects ([`be768fb`](https://github.com/Djelibeybi/lifx-async/commit/be768fbb4c2984646da4a0ee954b36930ca6261d))

## v1.2.1 (2025-11-08)

### Bug Fixes

- Implement tile effect parameters as local quirk ([`f4ada9b`](https://github.com/Djelibeybi/lifx-async/commit/f4ada9b13f63060459ed80b4961eb9339559a8ea))

## v1.2.0 (2025-11-07)

### Features

- Add theme support ([`82477cd`](https://github.com/Djelibeybi/lifx-async/commit/82477cd078004c37ad5b538ed8a261ac5fbece78))

## v1.1.3 (2025-11-06)

### Performance Improvements

- Reduce network traffic when updating individual color values ([`679b717`](https://github.com/Djelibeybi/lifx-async/commit/679b7176abd7634644e9395281ffa28dde26ebec))

## v1.1.2 (2025-11-05)

### Bug Fixes

- Dummy fix to trigger semantic release ([`86ad8b4`](https://github.com/Djelibeybi/lifx-async/commit/86ad8b442138216974bb65dac130d6ff54bd65a5))

## v1.1.1 (2025-11-05)

### Bug Fixes

- Dummy fix to trigger semantic release ([`12786b5`](https://github.com/Djelibeybi/lifx-async/commit/12786b54e76cd51c023d64f7a23fc963252421f8))

## v1.1.0 (2025-11-05)

### Features

- Replace cache TTL system with timestamped state attributes ([`5ae147a`](https://github.com/Djelibeybi/lifx-async/commit/5ae147a8c1cbbdc0244c9316708bd381269375db))

## v1.0.0 (2025-11-04)

- Initial Release
